@isTest
private class HealthCheckDefinitionModel_TEST {
    /**************************************************************************************************************************
    * @description Test method to verify that the constructor is working as expected.
    ***************************************************************************************************************************/
    @isTest
    private static void getInstanceExisting() {
        Test.startTest();
            HealthCheckDefinitionModel healthCheckDefinitionModel = new HealthCheckDefinitionModel('All Success', 'SRVC_HealthCheckGroupAPI', 'hed');
        Test.stopTest();

        System.assertEquals('All Success', healthCheckDefinitionModel.name);
        System.assertEquals('SRVC_HealthCheckGroupAPI', healthCheckDefinitionModel.className);
        System.assertEquals('hed', healthCheckDefinitionModel.namespace);
    }
}
public virtual with sharing class HealthCheckDefinitionService {

    /*********************************************
    * @description Instance for Singleton Pattern
    **********************************************/
    @TestVisible
    private static HealthCheckDefinitionService instance;

    /*********************************************************************
    * @description Empty constructor is not public for Singleton Pattern
    **********************************************************************/
    protected HealthCheckDefinitionService() {}

    /******************************************************************************
    * @description Static method to get the current instance for Singleton pattern
    * @return The instance of HealthCheckDefinitionService.
    ******************************************************************************/
    public static HealthCheckDefinitionService getInstance() {
        if (instance == null) {
            instance = new HealthCheckDefinitionService();
        }

        return instance;
    }

    /******************************************************************************
    * @description Get a list of Health Check Definition models
    * @return A list of HealthCheckDefinitionModel.
    ******************************************************************************/
    public virtual List<HealthCheckDefinitionModel> getHealthCheckDefinitionModels() {
        return this.locateHealthCheckDefinitionMapper().getHealthCheckDefinitionModels();
    }

    /******************************************************************************
    * @description Retrieves an instance of the HealthCheckDefinitionMapper class.
    * @return An instance of HealthCheckDefinitionMapper.
    ******************************************************************************/
    @TestVisible
    private HealthCheckDefinitionMapper locateHealthCheckDefinitionMapper() {
        return HealthCheckDefinitionMapper.getInstance();
    }
}
@isTest
private class HealthCheckDefinitionService_TEST {
    
    /**************************************************************************************************************************
    * @description Test method to verify that the getInstance method returns a new instance of the 
    * HealthCheckDefinitionService class when one does not already exist.
    ***************************************************************************************************************************/
    @isTest
    private static void getInstanceNew() {
        Test.startTest();
            HealthCheckDefinitionService healthCheckDefinitionServiceInstance = HealthCheckDefinitionService.getInstance();
        Test.stopTest();

        System.assertEquals(HealthCheckDefinitionService.instance, healthCheckDefinitionServiceInstance, 'Instance of service class returned should match static instance variable.');
        System.assertEquals(true, healthCheckDefinitionServiceInstance != null, 'Instance of service class should not be null.');
    }

    /**************************************************************************************************************************
    * @description Test method to verify that the getInstance method returns the existing instance of the 
    * HealthCheckDefinitionService class when one already exists.
    ***************************************************************************************************************************/
    @isTest
    private static void getInstanceExisting() {
        Test.startTest();
            HealthCheckDefinitionService healthCheckDefinitionServiceInstance1 = HealthCheckDefinitionService.getInstance();
            HealthCheckDefinitionService healthCheckDefinitionServiceInstance2 = HealthCheckDefinitionService.getInstance();
        Test.stopTest();

        System.assertEquals(HealthCheckDefinitionService.instance, healthCheckDefinitionServiceInstance1, 'Instance of service class returned should match static instance variable.');
        System.assertEquals(healthCheckDefinitionServiceInstance1, healthCheckDefinitionServiceInstance2, 'Subsequent retrievals of service class instance should return existing instance.');
        System.assertEquals(true, healthCheckDefinitionServiceInstance1 != null, 'Instance of service class should not be null.');
    }

    /**************************************************************************************************************************
    * @description Test method to verify that the getHealthCheckDefinitionModels method in Health Check Service class
    * returns a list of Health Check Definition models
    ***************************************************************************************************************************/
    @isTest
    private static void getHealthCheckDefinitionModelsExistingFromService() {
        HealthCheckDefinitionMapper.instance = new STUB_HealthCheckDefinitionMapper();
        Test.startTest();
            List<HealthCheckDefinitionModel> healthCheckDefinitionModels = HealthCheckDefinitionService.getInstance().getHealthCheckDefinitionModels();
        Test.stopTest();

        System.assertEquals(3, healthCheckDefinitionModels.size());
    }

    /**************************************************************************************************************************
    * @description Test method to verify that the locateHealthCheckDefinitionMapper method 
    * returns an instance of HealthCheckDefinitionMapper
    ***************************************************************************************************************************/
    @isTest
    private static void locateHealthCheckDefinitionMapperTest() {
        Test.startTest();
            HealthCheckDefinitionMapper healthCheckDefinitionMapperInstance = HealthCheckDefinitionMapper.getInstance();
        Test.stopTest();

        System.assertEquals(HealthCheckDefinitionMapper.instance, healthCheckDefinitionMapperInstance);
    }

    /**************************************************************************************************************************
    ****************************************************** STUB CLASS *********************************************************
    **************************************************************************************************************************/

    /*************************************************************************************************************
    * @description Stub class to simulate the response from HealthCheckDefinitionMapper to return a list of HealthCheckDefinitionModel
    */
    private class STUB_HealthCheckDefinitionMapper extends HealthCheckDefinitionMapper {
        public override List<HealthCheckDefinitionModel> getHealthCheckDefinitionModels() {
            List<HealthCheckDefinitionModel> stubHealthCheckDefinitionModelList = new List<HealthCheckDefinitionModel>();
            stubHealthCheckDefinitionModelList.add(new HealthCheckDefinitionModel('All Success',
                                                                        'EDAHealthCheckGroupAPIService',
                                                                        'hed'));
            stubHealthCheckDefinitionModelList.add(new HealthCheckDefinitionModel('All Failure',
                                                                        'EDAHealthCheckGroupAPIService',
                                                                        'hed'));
            stubHealthCheckDefinitionModelList.add(new HealthCheckDefinitionModel('Mixed',
                                                                        'EDAHealthCheckGroupAPIService',
                                                                        'hed'));
            return stubHealthCheckDefinitionModelList;         
        }
    }
}
public with sharing class HealthCheckDefinitionVModel implements Comparable {

    @AuraEnabled public String name;
    @AuraEnabled public String className;
    @AuraEnabled public String namespace;

    public HealthCheckDefinitionVModel(String name, String className, String namespace) {
        this.name = name;
        this.className = className;
        this.namespace = namespace;
    }

    /****************************************************************************************************************************
    * @description Implementation of compareTo() to sort HealthCheckDefinitionVModels by name.
    * @param  objectToCompareTo A HealthCheckDefinitionVModel to be used for comparison
    * @return 0 if names are equal, 1 if the current name is greater, -1 otherwise
    ****************************************************************************************************************************/ 
    public Integer compareTo(Object objectToCompareTo){
        HealthCheckDefinitionVModel healthCheckDefinitionVModelToCompareTo = (HealthCheckDefinitionVModel)objectToCompareTo;
        return this.name.toLowerCase().compareTo(healthCheckDefinitionVModelToCompareTo.name.toLowerCase());
    } 
}
@isTest 
public with sharing class HealthCheckDefinitionVModel_TEST {

    /****************************************************************************************************************************
    * @description Test to verify constructor with 3 parameters initializes object with properties set as expected.
    ****************************************************************************************************************************/
    @isTest 
    private static void threeParamConstructorValid(){
        Test.startTest();
        HealthCheckDefinitionVModel hlthChkDefVModl = new HealthCheckDefinitionVModel('TestName', 'TestClass', 'TEST');
        Test.stopTest();

        System.assertEquals('TestName', hlthChkDefVModl.name, 'Name property should be \'TestName\'.');
        System.assertEquals('TestClass', hlthChkDefVModl.className, 'Classname property should be \'TestClass\'.');
        System.assertEquals('TEST', hlthChkDefVModl.namespace, 'Namespace property should be \'TEST\'.');
    }

    /****************************************************************************************************************************
    * @description Test to verify compareTo() properly sorts Health Check View models by name
    * in ascending order when no duplicates are not present.
    ****************************************************************************************************************************/
    @isTest 
    private static void sortNamesWithoutDuplicates(){
        List<HealthCheckDefinitionVModel> healthCheckDefinitionVModelsList = new List<HealthCheckDefinitionVModel>();
        HealthCheckDefinitionVModel healthCheckDefinitionVModel1 = new HealthCheckDefinitionVModel('test1', 'TestClass', 'TEST');
        HealthCheckDefinitionVModel healthCheckDefinitionVModel2 = new HealthCheckDefinitionVModel('pineapple', 'TestClass', 'TEST');
        HealthCheckDefinitionVModel healthCheckDefinitionVModel3 = new HealthCheckDefinitionVModel('Banana', 'TestClass', 'TEST');
        HealthCheckDefinitionVModel healthCheckDefinitionVModel4 = new HealthCheckDefinitionVModel('Test4', 'TestClass', 'TEST');
        HealthCheckDefinitionVModel healthCheckDefinitionVModel5 = new HealthCheckDefinitionVModel('Papaya', 'TestClass', 'TEST');
        HealthCheckDefinitionVModel healthCheckDefinitionVModel6 = new HealthCheckDefinitionVModel('Apple', 'TestClass', 'TEST');
        
        healthCheckDefinitionVModelsList.add(healthCheckDefinitionVModel1);
        healthCheckDefinitionVModelsList.add(healthCheckDefinitionVModel2);
        healthCheckDefinitionVModelsList.add(healthCheckDefinitionVModel3);
        healthCheckDefinitionVModelsList.add(healthCheckDefinitionVModel4);
        healthCheckDefinitionVModelsList.add(healthCheckDefinitionVModel5);
        healthCheckDefinitionVModelsList.add(healthCheckDefinitionVModel6);
    
        Test.startTest();
        healthCheckDefinitionVModelsList.sort();
        Test.stopTest();

        System.assertEquals('Apple', healthCheckDefinitionVModelsList[0].name, 'First name in sorted list should be \'Apple\'');
        System.assertEquals('Banana', healthCheckDefinitionVModelsList[1].name, 'Second name in sorted list should be \'Banana\'');
        System.assertEquals('Papaya', healthCheckDefinitionVModelsList[2].name, 'Third name in sorted list should be \'Papaya\'');
        System.assertEquals('pineapple', healthCheckDefinitionVModelsList[3].name, 'Fourth name in sorted list should be \'pineapple\'');
        System.assertEquals('test1', healthCheckDefinitionVModelsList[4].name, 'Fifth name in sorted list should be \'test1\'');
        System.assertEquals('Test4', healthCheckDefinitionVModelsList[5].name, 'Sixth name in sorted list should be \'Test4\'');
    }

    /****************************************************************************************************************************
    * @description Test to verify compareTo() properly sorts Health Check View models by name
    * in ascending order when no duplicates are present.
    ****************************************************************************************************************************/
    @isTest 
    private static void sortNamesWithDuplicates(){
        List<HealthCheckDefinitionVModel> healthCheckDefinitionVModelsList = new List<HealthCheckDefinitionVModel>();
        HealthCheckDefinitionVModel healthCheckDefinitionVModel1 = new HealthCheckDefinitionVModel('Pineapple', 'TestClass', 'TEST');
        HealthCheckDefinitionVModel healthCheckDefinitionVModel2 = new HealthCheckDefinitionVModel('Pineapple', 'TestClass', 'TEST');
        HealthCheckDefinitionVModel healthCheckDefinitionVModel3 = new HealthCheckDefinitionVModel('Pineapple', 'TestClass', 'TEST');
        HealthCheckDefinitionVModel healthCheckDefinitionVModel4 = new HealthCheckDefinitionVModel('test4', 'TestClass', 'TEST');
        HealthCheckDefinitionVModel healthCheckDefinitionVModel5 = new HealthCheckDefinitionVModel('123Papaya', 'TestClass', 'TEST');
        HealthCheckDefinitionVModel healthCheckDefinitionVModel6 = new HealthCheckDefinitionVModel('Apple Pie', 'TestClass', 'TEST');
        
        healthCheckDefinitionVModelsList.add(healthCheckDefinitionVModel1);
        healthCheckDefinitionVModelsList.add(healthCheckDefinitionVModel2);
        healthCheckDefinitionVModelsList.add(healthCheckDefinitionVModel3);
        healthCheckDefinitionVModelsList.add(healthCheckDefinitionVModel4);
        healthCheckDefinitionVModelsList.add(healthCheckDefinitionVModel5);
        healthCheckDefinitionVModelsList.add(healthCheckDefinitionVModel6);
    
        Test.startTest();
        healthCheckDefinitionVModelsList.sort();
        Test.stopTest();

        System.assertEquals('123Papaya', healthCheckDefinitionVModelsList[0].name, 'First name in sorted list should be \'123Papaya\'');
        System.assertEquals('Apple Pie', healthCheckDefinitionVModelsList[1].name, 'Second name in sorted list should be \'Apple Pie\'');
        System.assertEquals('Pineapple', healthCheckDefinitionVModelsList[2].name, 'Third name in sorted list should be \'Pineapple\'');
        System.assertEquals('Pineapple', healthCheckDefinitionVModelsList[3].name, 'Fourth name in sorted list should be \'Pineapple\'');
        System.assertEquals('Pineapple', healthCheckDefinitionVModelsList[4].name, 'Fifth name in sorted list should be \'Pineapple\'');
        System.assertEquals('test4', healthCheckDefinitionVModelsList[5].name, 'Sixth name in sorted list should be \'test4\'');
    }
}
public virtual interface HealthCheckGroupAPIServiceInterface {
    HealthCheckGroupAPIServiceInterface getInstance();
    HealthCheckGroupVModel getHealthCheckGroup(String name);
}
public with sharing class HealthCheckGroupController {

    /**********************************************************************************
    * @description Locates and returns an instance of HealthCheckVMapper. 
    **********************************************************************************/
    @TestVisible
    private static HealthCheckGroupService locateHealthCheckGroupService() {
        return HealthCheckGroupService.getInstance();
    }

    /**********************************************************************************
    * getHealthCheckGroupViewModel description
    * @param  name      name description
    * @param  className className description
    * @param  namespace namespace description
    * @return           return description
    **********************************************************************************/
    @AuraEnabled(cacheable=true)
    public static HealthCheckGroupVModel getHealthCheckGroupViewModel(String name, String className, String namespace){
        try {
            return HealthCheckGroupController.locateHealthCheckGroupService().getHealthCheckGroup(name, className, namespace);
        } catch (Exception e) {
            throw new AuraHandledException(e.getMessage());
        }
    }
}
@isTest 
public with sharing class HealthCheckGroupController_TEST {
    /****************************************************************************************************************************
    * @description Test method to verify that the locateHealthCheckGroupService method returns instance of HealthCheckGroupService.
    ****************************************************************************************************************************/
    @isTest
    private static void locateHealthCheckGroupServiceValid() {
        Test.startTest();
            HealthCheckGroupService healthCheckGroupServiceInstance = HealthCheckGroupController.locateHealthCheckGroupService();
        Test.stopTest();

        System.assertEquals(HealthCheckGroupService.getInstance(), healthCheckGroupServiceInstance, 'Should return the instance of HealthCheckGroupService.');
    } 

    /****************************************************************************************************************************
    * @description Test method to verify that the getHealthCheckGroupViewModel method returns a valid HealthCheckGroupVModel.
    ****************************************************************************************************************************/
    @isTest 
    private static void getHealthCheckGroupViewModelValid(){
        HealthCheckGroupService.instance = new STUB_HealthCheckGroupServiceMixedBag();

        Test.startTest();
        HealthCheckGroupVModel healthCheckGroupVModel = HealthCheckGroupController.getHealthCheckGroupViewModel('Mixed Bag', 'TestClassName', 'abc');
        Test.stopTest();

        System.assertEquals('Mixed Bag', healthCheckGroupVModel.label, 'Label should \'Mixed Bag\'.');
        System.assertEquals('Fail', healthCheckGroupVModel.status, 'Status should be \'Fail\'.');
        System.assertEquals(5, healthCheckGroupVModel.passedChecks, 'Should be 5 health check definitions.');
        System.assertEquals(10, healthCheckGroupVModel.totalChecks, 'Should be 5 health check definitions.');
        System.assertEquals(true, healthCheckGroupVModel.expandedRowsList.isEmpty(), 'expandedRowsList should be empty.');
        System.assertEquals(true, healthCheckGroupVModel.healthCheckItemList.isEmpty(), 'healthCheckItemList should be empty.');
    }

    /****************************************************************************************************************************
    * @description Test method to verify that the getHealthCheckGroupViewModel method throws an exception when expected.
    ****************************************************************************************************************************/
    @isTest 
    private static void getHealthCheckGroupViewModelException(){
        HealthCheckGroupService.instance = new STUB_ExceptionHealthCheckGroupService();

        try{
            Test.startTest();
            HealthCheckGroupVModel healthCheckGroupVModel = HealthCheckGroupController.getHealthCheckGroupViewModel('Exception Bag', 'TestClassName', 'abc');
            Test.stopTest();
        } catch (System.AuraHandledException ex){
            System.assertEquals('System.AuraHandledException', ex.getTypeName(), 'AuraHandledException should be thrown when exception occurs.');
            System.assertEquals('Script-thrown exception', ex.getMessage(), 'AuraHandledException text should be associated with message when exception occurs.');
        }
    }

    /**************************************************************************************************************************
    ****************************************************** STUBS **************************************************************
    **************************************************************************************************************************/
    
    /**************************************************************************************************************************************
    * @description Stub class to simulate the response from HealthCheckGroupService to return a HealthCheckGroupVModel
    **************************************************************************************************************************************/ 
    private class STUB_HealthCheckGroupServiceMixedBag extends HealthCheckGroupService {
        @TestVisible 
        public override HealthCheckGroupVModel getHealthCheckGroup(String name, String className, String namespace){   
            return new HealthCheckGroupVModel('Mixed Bag', 'Fail', 5, 10, new List<String>(), new List<HealthCheckItemVModel>());
        }
    }

    /**************************************************************************************************************************************
    * @description Stub class to simulate the response from HealthCheckGroupService to throw an exception
    **************************************************************************************************************************************/ 
    private class STUB_ExceptionHealthCheckGroupService extends HealthCheckGroupService {
        @TestVisible 
        public override HealthCheckGroupVModel getHealthCheckGroup(String name, String className, String namespace){   
            throw new TestException('Test exception thrown!');
        }
    }

    /**************************************************************************************
    * @description Custom exception class for testing.
    **************************************************************************************/
    public class TestException extends Exception {}
}
public virtual with sharing class HealthCheckGroupService {
    /*********************************************
    * @description Instance for Singleton Pattern
    **********************************************/
    @TestVisible
    private static HealthCheckGroupService instance;

    /*********************************************************************
    * @description Empty constructor is not public for Singleton Pattern
    **********************************************************************/
    protected HealthCheckGroupService() {}

    /******************************************************************************
    * @description Static method to get the current instance for Singleton pattern
    * @return The instance of HealthCheckGroupService.
    ******************************************************************************/
    public static HealthCheckGroupService getInstance() {
        if (instance == null) {
            instance = new HealthCheckGroupService();
        }

        return instance;
    }

    /********************************************************************************************
    * @description Retrieves the HealthCheckGroup view model for a specified 
    * HealthCheckDefinitionModel.
    * @param  name The name corresponding to a specified HealthCheckDefinitionModel
    * @param  className The className corresponding to a specified HealthCheckDefinitionModel
    * @param  namespace The namespace corresponding to a specified HealthCheckDefinitionModel
    * @return A HealthCheckGroupVModel representing the specified HealthCheckDefinitionModel.
    ********************************************************************************************/
    public virtual HealthCheckGroupVModel getHealthCheckGroup(String name, String className, String namespace){
        HealthCheckGroupAPIServiceInterface healthCheckGroupServiceInterface = 
            this.locateHealthCheckGroupAPIService(className, namespace);

        return healthCheckGroupServiceInterface.getHealthCheckGroup(name);
    }

    /********************************************************************************************
    * @description Dynamically instantiates a HealthCheckGroupAPIServiceInterface based on a 
    * specified classname and namespace.
    * @param  className The classname of a HealthCheckDefinitionModel
    * @param  namespace The namespace of a HealthCheckDefinitionModel
    * @return A HealthCheckGroupAPIServiceInterface corresponding to the specified classname and namespace.
    ********************************************************************************************/
    @TestVisible
    private virtual HealthCheckGroupAPIServiceInterface locateHealthCheckGroupAPIService(String className, String namespace){
        HealthCheckGroupAPIServiceInterface healthCheckGroupServiceInterface;
        String nonEDANamespace = namespace;
        
        if (namespace.equalsIgnoreCase('hed')){
            nonEDANamespace = '';
        }

        try{
            Type healthCheckGroupType = Type.forName(nonEDANamespace, className);
            healthCheckGroupServiceInterface = (HealthCheckGroupAPIServiceInterface)healthCheckGroupType.newInstance();
        } catch (System.NullPointerException e){
            throw new HealthCheckNotFoundException(e.getMessage());
        } catch (System.TypeException e){
            throw new HealthCheckNotFoundException(e.getMessage());
        }

        return healthCheckGroupServiceInterface.getInstance();
    }

    /********************************************************************************************
    * @description A custom exception class to represent Health Check Not Found errors.
    ********************************************************************************************/
    public class HealthCheckNotFoundException extends Exception{}
}
@isTest 
public with sharing class HealthCheckGroupService_TEST {

    /**************************************************************************************************************************
    * @description Test method to verify that the getInstance method returns a new instance of the 
    * HealthCheckGroupService class when one does not already exist.
    ***************************************************************************************************************************/
    @isTest
    private static void getInstanceNew() {
        Test.startTest();
            HealthCheckGroupService HealthCheckGroupServiceInstance = HealthCheckGroupService.getInstance();
        Test.stopTest();

        System.assertEquals(HealthCheckGroupService.instance, HealthCheckGroupServiceInstance, 'Instance of service class returned should match static instance variable.');
        System.assertEquals(true, HealthCheckGroupServiceInstance != null, 'Instance of service class should not be null.');
    }

    /**************************************************************************************************************************
    * @description Test method to verify that the getInstance method returns the existing instance of the 
    * HealthCheckGroupService class when one already exists.
    ***************************************************************************************************************************/
    @isTest
    private static void getInstanceExisting() {
        Test.startTest();
            HealthCheckGroupService HealthCheckGroupServiceInstance1 = HealthCheckGroupService.getInstance();
            HealthCheckGroupService HealthCheckGroupServiceInstance2 = HealthCheckGroupService.getInstance();
        Test.stopTest();

        System.assertEquals(HealthCheckGroupService.instance, HealthCheckGroupServiceInstance1, 'Instance of service class returned should match static instance variable.');
        System.assertEquals(HealthCheckGroupServiceInstance1, HealthCheckGroupServiceInstance2, 'Subsequent retrievals of service class instance should return existing instance.');
        System.assertEquals(true, HealthCheckGroupServiceInstance1 != null, 'Instance of service class should not be null.');
    }

    /**************************************************************************************************************************
    * @description Test method to verify that the getHealthCheckGroup method returns a HealthCheckGroup view model when provided
    * with valid HealthCheckDefinitionModel data.
    ***************************************************************************************************************************/
    @isTest 
    private static void getHealthCheckGroupValidReciprocal(){
        ReciprocalRelHealthCheckVMapper.instance = new STUB_ReciprocalRelHealthCheckVMapper();
        HealthCheckGroupService.instance = new STUB_HealthCheckGroupServiceEDAHealthCheckAPI();
        HealthCheckGroupService healthCheckGroupService =
            HealthCheckGroupService.getInstance();

        Test.startTest();
            HealthCheckGroupVModel healthCheckGroupVModel =
                healthCheckGroupService.getHealthCheckGroup(
                    'reciprocalrelationship',
                    'EDAHealthCheckGroupAPIService',
                    'hed'
                );
        Test.stopTest();

        System.assertEquals('Mocked', healthCheckGroupVModel.label, 'Label for returned HC Group view model should match valud in EDAHealthCheckGroupAPIService.');
        System.assertEquals('Pass', healthCheckGroupVModel.status, 'Status for returned HC Group view model should match valud in EDAHealthCheckGroupAPIService.');
        System.assertEquals(2, healthCheckGroupVModel.passedChecks, 'Passed Checks for returned HC Group view model should match valud in EDAHealthCheckGroupAPIService.');
        System.assertEquals(2, healthCheckGroupVModel.totalChecks, 'Total Checks for returned HC Group view model should match valud in EDAHealthCheckGroupAPIService.');
        System.assertEquals(true, healthCheckGroupVModel.expandedRowsList.isEmpty(), 'Expanded rows list for returned HC Group view model should match valud in EDAHealthCheckGroupAPIService.');
        System.assertEquals(2, healthCheckGroupVModel.healthCheckItemList.size(), 'Health Check items list for returned HC Group view model should match valud in EDAHealthCheckGroupAPIService.');
    }

    /**************************************************************************************************************************
    * @description Test method to verify that the getHealthCheckGroup method returns a HealthCheckGroup view model when provided
    * with valid HealthCheckDefinitionModel data.
    ***************************************************************************************************************************/
    @isTest 
    private static void getHealthCheckGroupValidCourseConn(){

        CourseConSettingHealthCheckVMapper.instance = new STUB_CourseConSettingHealthCheckVMapper();
        HealthCheckGroupService.instance = new STUB_HealthCheckGroupServiceEDAHealthCheckAPI();

        Test.startTest();
            HealthCheckGroupVModel hlthChkGroupVMod = 
                HealthCheckGroupService.getInstance(
                ).getHealthCheckGroup(
                    'courseconnectionsettings', 
                    'EDAHealthCheckGroupAPIService',
                    'hed'
                );
        Test.stopTest();
            System.assertEquals('Mocked', hlthChkGroupVMod.label, 'Label for returned HC Group view model should match valud in EDAHealthCheckGroupAPIService.');
            System.assertEquals('Pass', hlthChkGroupVMod.status, 'Status for returned HC Group view model should match valud in EDAHealthCheckGroupAPIService.');
            System.assertEquals(2, hlthChkGroupVMod.passedChecks, 'Passed Checks for returned HC Group view model should match valud in EDAHealthCheckGroupAPIService.');
            System.assertEquals(2, hlthChkGroupVMod.totalChecks, 'Total Checks for returned HC Group view model should match valud in EDAHealthCheckGroupAPIService.');
            System.assertEquals(true, hlthChkGroupVMod.expandedRowsList.isEmpty(), 'Expanded rows list for returned HC Group view model should match valud in EDAHealthCheckGroupAPIService.');
            System.assertEquals(2, hlthChkGroupVMod.healthCheckItemList.size(), 'Health Check items list for returned HC Group view model should match valud in EDAHealthCheckGroupAPIService.');
    }

    /**************************************************************************************************************************
    * @description Test method to verify that the getHealthCheckGroup method returns a HealthCheckGroup view model when provided
    * with valid HealthCheckDefinitionModel data.
    ***************************************************************************************************************************/
    @isTest 
    private static void getHealthCheckGroupValidAccountModel(){

        AccountModelHealthCheckVMapper.instance = new STUB_AccountModelHealthCheckVMapper();
        HealthCheckGroupService.instance = new STUB_HealthCheckGroupServiceEDAHealthCheckAPI();

        Test.startTest();
            HealthCheckGroupVModel hlthChkGroupVMod = 
                HealthCheckGroupService.getInstance(
                ).getHealthCheckGroup(
                    'accountmodel', 
                    'EDAHealthCheckGroupAPIService',
                    'hed'
                );
        Test.stopTest();
            System.assertEquals('Mocked', hlthChkGroupVMod.label, 'Label for returned HC Group view model should match valud in EDAHealthCheckGroupAPIService.');
            System.assertEquals('Pass', hlthChkGroupVMod.status, 'Status for returned HC Group view model should match valud in EDAHealthCheckGroupAPIService.');
            System.assertEquals(2, hlthChkGroupVMod.passedChecks, 'Passed Checks for returned HC Group view model should match valud in EDAHealthCheckGroupAPIService.');
            System.assertEquals(2, hlthChkGroupVMod.totalChecks, 'Total Checks for returned HC Group view model should match valud in EDAHealthCheckGroupAPIService.');
            System.assertEquals(true, hlthChkGroupVMod.expandedRowsList.isEmpty(), 'Expanded rows list for returned HC Group view model should match valud in EDAHealthCheckGroupAPIService.');
            System.assertEquals(2, hlthChkGroupVMod.healthCheckItemList.size(), 'Health Check items list for returned HC Group view model should match valud in EDAHealthCheckGroupAPIService.');
    }

    /**************************************************************************************************************************
    * @description Test method to verify that the getHealthCheckGroup method returns a HealthCheckGroup view model when provided
    * with valid HealthCheckDefinitionModel data.
    ***************************************************************************************************************************/
    @isTest 
    private static void getHealthCheckGroupValidAffiliationMappings(){

        AffiliationMappingsHealthCheckVMapper.instance = new STUB_AffiliationMappingsHealthCheckVMapper();
        HealthCheckGroupService.instance = new STUB_HealthCheckGroupServiceEDAHealthCheckAPI();

        Test.startTest();
            HealthCheckGroupVModel hlthChkGroupVMod = 
                HealthCheckGroupService.getInstance(
                ).getHealthCheckGroup(
                    'affiliationmappings', 
                    'EDAHealthCheckGroupAPIService',
                    'hed'
                );
        Test.stopTest();
            System.assertEquals('Mocked', hlthChkGroupVMod.label, 'Label for returned HC Group view model should match valud in EDAHealthCheckGroupAPIService.');
            System.assertEquals('Pass', hlthChkGroupVMod.status, 'Status for returned HC Group view model should match valud in EDAHealthCheckGroupAPIService.');
            System.assertEquals(2, hlthChkGroupVMod.passedChecks, 'Passed Checks for returned HC Group view model should match valud in EDAHealthCheckGroupAPIService.');
            System.assertEquals(2, hlthChkGroupVMod.totalChecks, 'Total Checks for returned HC Group view model should match valud in EDAHealthCheckGroupAPIService.');
            System.assertEquals(true, hlthChkGroupVMod.expandedRowsList.isEmpty(), 'Expanded rows list for returned HC Group view model should match valud in EDAHealthCheckGroupAPIService.');
            System.assertEquals(2, hlthChkGroupVMod.healthCheckItemList.size(), 'Health Check items list for returned HC Group view model should match valud in EDAHealthCheckGroupAPIService.');
    }

    /**************************************************************************************************************************
    * @description Test method to verify that the getHealthCheckGroup method returns a null HealthCheckGroup view model when 
    * provided with invalid HealthCheckDefinitionModel data.
    ***************************************************************************************************************************/
    @isTest 
    private static void getHealthCheckGroupInValid(){
        Test.startTest();
        HealthCheckGroupVModel healthCheckGroupVModel =
            HealthCheckGroupService.getInstance(
            ).getHealthCheckGroup(
                'Non-existent Health Check Group',
                'EDAHealthCheckGroupAPIService',
                'hed'
            );
        Test.stopTest();

        System.assertEquals(true, healthCheckGroupVModel == null, 'Health Check Group view model should be null.');
    }

    /**************************************************************************************************************************
    * @description Test method to verify that the locateHealthCheckGroupAPIService method returns a valid instance of 
    * HealthCheckGroupAPIServiceInterface when a valid classname and namespace corresponding to a Serivce that implements the 
    * interface is provided.
    ***************************************************************************************************************************/
    @isTest 
    private static void locateHealthCheckGroupAPIServiceValid(){
        Test.startTest();
        HealthCheckGroupAPIServiceInterface healthCheckGroupAPIServiceInterface = 
            HealthCheckGroupService.getInstance().locateHealthCheckGroupAPIService('EDAHealthCheckGroupAPIService', 'hed');
        Test.stopTest();

        System.assertEquals(EDAHealthCheckGroupAPIService.getInstance(), healthCheckGroupAPIServiceInterface.getInstance(), 
                'HealthCheckGroupAPIServiceInterface should be instance of EDAHealthCheckGroupAPIService.');
    }

    /**************************************************************************************************************************
    * @description Test method to verify that the locateHealthCheckGroupAPIService method throws a NullPointerException  
    * when an invalid classname an an invalid namespace is provided.
    ***************************************************************************************************************************/
    @isTest 
    private static void locateHealthCheckGroupAPIServiceInValidClassName(){
        try{
            Test.startTest();
            HealthCheckGroupAPIServiceInterface healthCheckGroupAPIServiceInterface = 
            HealthCheckGroupService.getInstance().locateHealthCheckGroupAPIService('Not a Valid Service Name', 'abc');
            Test.stopTest();
        } catch (System.NullPointerException e){
            System.assertEquals(true, String.isNotBlank(e.getMessage()), 'Invalid className should throw NullPointerException.');
        } catch (HealthCheckGroupService.HealthCheckNotFoundException hcNotFoundEx){
            System.assertEquals(true, String.isNotBlank(hcNotFoundEx.getMessage()), 'NullPointerException should throw HealthCheckNotFoundException.');
        }
    }

    /**************************************************************************************************************************
    * @description Test method to verify that the locateHealthCheckGroupAPIService method throws a TypeException  
    * when a valid classname to a class that does not extend the HealthCheckGroupAPIServiceInterface and blank namespace is provided.
    ***************************************************************************************************************************/
    @isTest 
    private static void locateHealthCheckGroupAPIServiceValidClassNameNotImplementingInterface(){
        try{
            Test.startTest();
            HealthCheckGroupAPIServiceInterface healthCheckGroupAPIServiceInterface = 
            HealthCheckGroupService.getInstance().locateHealthCheckGroupAPIService('HealthCheckVMapper', '');
            Test.stopTest();
        } catch (System.TypeException e){
            System.assertEquals(true, String.isNotBlank(e.getMessage()), 'Invalid className should throw TypeException.');
        } catch (HealthCheckGroupService.HealthCheckNotFoundException hcNotFoundEx){
            System.assertEquals(true, String.isNotBlank(hcNotFoundEx.getMessage()), 'TypeException should throw HealthCheckNotFoundException.');
        }
    }

    /**************************************************************************************************************************
    ****************************************************** STUBS **************************************************************
    **************************************************************************************************************************/
    
    /**************************************************************************************************************************************
    * @description Stub class to simulate the response from HealthCheckGroupService to return instance of EDAHealthCheckGroupAPIService.
    **************************************************************************************************************************************/ 
    private class STUB_HealthCheckGroupServiceEDAHealthCheckAPI extends HealthCheckGroupService {
        @TestVisible 
        private override HealthCheckGroupAPIServiceInterface locateHealthCheckGroupAPIService(
            String className,
            String namespace
        ){ 
            return EDAHealthCheckGroupAPIService.getInstance(); 
        }
    }

    /***************************************************************************
    * @description Stub class to simulate the response from
    * EDAHealthCheckGroupAPIService to control for a static response
    ***************************************************************************/
    private class STUB_ReciprocalRelHealthCheckVMapper extends ReciprocalRelHealthCheckVMapper {

        public override HealthCheckGroupVModel getHealthCheckGroup(){
            List<HealthCheckItemVModel> healthCheckItemsList = new List<HealthCheckItemVModel>();
            List<String> rowKeysList = new List<String>();
    
            HealthCheckItemVModel healthCheckItemModel1 = 
                new HealthCheckItemVModel(
                    '01', 
                    'Passed Setting 1', 
                    'Pass', 
                    Label.stgHealthCheckStatusPassed, 
                    'Mocked description 1', 
                    'Mocked recommended fix 1',
                    new List<HealthCheckItemVModel>()
                );
                                                                                
            HealthCheckItemVModel healthCheckItemModel2 = 
                new HealthCheckItemVModel(
                    '02',
                    'Passed Setting 2',
                    'Pass',
                    Label.stgHealthCheckStatusPassed,
                    'Mocked description 2',
                    'Mocked recommended fix 2',
                    new List<HealthCheckItemVModel>()
                );
            
            healthCheckItemsList.add(healthCheckItemModel1);
            healthCheckItemsList.add(healthCheckItemModel2);

            return new HealthCheckGroupVModel(
                'Mocked',
                'Pass',
                2,
                2,
                rowKeysList,
                healthCheckItemsList
            );
        }
    }

    /***************************************************************************
    * @description Stub class to simulate the response from
    * EDAHealthCheckGroupAPIService to control for a static response
    ***************************************************************************/
    private class STUB_CourseConSettingHealthCheckVMapper extends CourseConSettingHealthCheckVMapper {

        public override HealthCheckGroupVModel getHealthCheckGroup(){
            List<HealthCheckItemVModel> hlthChkItemsList = new List<HealthCheckItemVModel>();
            List<String> rowKeysList = new List<String>();

            HealthCheckItemVModel hlthChkItemMod1 = 
                new HealthCheckItemVModel(
                    '01', 
                    'Passed Setting 1', 
                    'Pass', 
                    Label.stgHealthCheckStatusPassed, 
                    'Mocked description 1', 
                    'Mocked recommended fix 1',
                    new List<HealthCheckItemVModel>()
                );

            HealthCheckItemVModel hlthChkItemMod2 = 
                new HealthCheckItemVModel(
                    '02',
                    'Passed Setting 2',
                    'Pass',
                    Label.stgHealthCheckStatusPassed,
                    'Mocked description 2',
                    'Mocked recommended fix 2',
                    new List<HealthCheckItemVModel>()
                );

            hlthChkItemsList.add(hlthChkItemMod1);
            hlthChkItemsList.add(hlthChkItemMod2);

            return new HealthCheckGroupVModel(
                'Mocked',
                'Pass',
                2,
                2,
                rowKeysList,
                hlthChkItemsList
            );
        }
    }
    
    /***************************************************************************
    * @description Stub class to simulate the response from
    * EDAHealthCheckGroupAPIService to control for a static response
    ***************************************************************************/
    private class STUB_AccountModelHealthCheckVMapper extends AccountModelHealthCheckVMapper {

        public override HealthCheckGroupVModel getHealthCheckGroup(){
            List<HealthCheckItemVModel> hlthChkItemsList = new List<HealthCheckItemVModel>();
            List<String> rowKeysList = new List<String>();

            HealthCheckItemVModel hlthChkItemMod1 = 
                new HealthCheckItemVModel(
                    '01', 
                    'Passed Setting 1', 
                    'Pass', 
                    Label.stgHealthCheckStatusPassed, 
                    'Mocked description 1', 
                    'Mocked recommended fix 1',
                    new List<HealthCheckItemVModel>()
                );

            HealthCheckItemVModel hlthChkItemMod2 = 
                new HealthCheckItemVModel(
                    '02',
                    'Passed Setting 2',
                    'Pass',
                    Label.stgHealthCheckStatusPassed,
                    'Mocked description 2',
                    'Mocked recommended fix 2',
                    new List<HealthCheckItemVModel>()
                );

            hlthChkItemsList.add(hlthChkItemMod1);
            hlthChkItemsList.add(hlthChkItemMod2);

            return new HealthCheckGroupVModel(
                'Mocked',
                'Pass',
                2,
                2,
                rowKeysList,
                hlthChkItemsList
            );
        }
    }

    /***************************************************************************
    * @description Stub class to simulate the response from
    * EDAHealthCheckGroupAPIService to control for a static response
    ***************************************************************************/
    private class STUB_AffiliationMappingsHealthCheckVMapper extends AffiliationMappingsHealthCheckVMapper {

        public override HealthCheckGroupVModel getHealthCheckGroup(){
            List<HealthCheckItemVModel> hlthChkItemsList = new List<HealthCheckItemVModel>();
            List<String> rowKeysList = new List<String>();

            HealthCheckItemVModel hlthChkItemMod1 = 
                new HealthCheckItemVModel(
                    '01', 
                    'Passed Setting 1', 
                    'Pass', 
                    Label.stgHealthCheckStatusPassed, 
                    'Mocked description 1', 
                    'Mocked recommended fix 1',
                    new List<HealthCheckItemVModel>()
                );

            HealthCheckItemVModel hlthChkItemMod2 = 
                new HealthCheckItemVModel(
                    '02',
                    'Passed Setting 2',
                    'Pass',
                    Label.stgHealthCheckStatusPassed,
                    'Mocked description 2',
                    'Mocked recommended fix 2',
                    new List<HealthCheckItemVModel>()
                );

            hlthChkItemsList.add(hlthChkItemMod1);
            hlthChkItemsList.add(hlthChkItemMod2);

            return new HealthCheckGroupVModel(
                'Mocked',
                'Pass',
                2,
                2,
                rowKeysList,
                hlthChkItemsList
            );
        }
    }
}
public virtual with sharing class HealthCheckGroupVModel implements Comparable {
    
    @AuraEnabled public String label;
    @AuraEnabled public String status;
    @AuraEnabled public Integer passedChecks;
    @AuraEnabled public Integer totalChecks;
    @AuraEnabled public List<String> expandedRowsList { get; private set; }
    @AuraEnabled public List<HealthCheckItemVModel> healthCheckItemList { get; private set; }

    public HealthCheckGroupVModel() {
        this.label = '';
        this.passedChecks = 0;
        this.totalChecks = 0;
        this.expandedRowsList = new List<String>();
        this.healthCheckItemList = new List<HealthCheckItemVModel>();

        this.updateHealthCheckStatus();
    }
    
    public HealthCheckGroupVModel(String label, 
                                 String status, 
                                 Integer passedChecks, 
                                 Integer totalChecks, 
                                 List<String> expandedRowsList, 
                                 List<HealthCheckItemVModel> healthCheckItemList) {
        this.label = label;
        this.status = status;
        this.passedChecks = passedChecks;
        this.totalChecks = totalChecks;
        this.expandedRowsList = expandedRowsList;
        this.healthCheckItemList = healthCheckItemList;
    }

    /*********************************************************************************************************************
    * @description Update the status of a HealthCheckGroupVModel based on the number of passing health checks to total checks. 
    *********************************************************************************************************************/
    public void updateHealthCheckStatus() {      
        this.status = (this.passedChecks == this.totalChecks) ? 
            System.Label.stgHealthCheckStatusPassed : System.Label.stgHealthCheckStatusFailed;
    }
    
    /*****************************************************************************************
    * @description Implementation of CompareTo() that sorts by status (Fail above Pass), then in
    * ascending alphabetical order on label.
    * @param compareTo A HealthCheckGroupVModel object to compare to another
    * @return 0 if the current object is greater than the object to compare, -1 if it is less, 0 if
    * they are equal, or if the objec to compare is an incompatible type.
    *****************************************************************************************/ 
    public virtual Integer compareTo(Object compareTo){

        if (!(compareTo instanceof HealthCheckGroupVModel)){
            return 0;
        }

        HealthCheckGroupVModel healthCheckGroupVModelToCompareTo = (HealthCheckGroupVModel)compareTo;
        Integer statusResult = this.status.toLowerCase().compareTo(healthCheckGroupVModelToCompareTo.status.toLowerCase());
        
        if (statusResult != 0){
            return statusResult;
        }
        
        return this.label.toLowerCase().compareTo(healthCheckGroupVModelToCompareTo.label.toLowerCase());
    }
}
@isTest 
public with sharing class HealthCheckGroupVModel_TEST {
    /*****************************************************************************************
    * @description Test to verify empty constructor generates model as expected.
    *****************************************************************************************/
    @isTest 
    private static void constructorWithNoParametersValid(){
        Test.startTest();
        HealthCheckGroupVModel healthCheckGroupVModel = new HealthCheckGroupVModel();
        Test.stopTest();

        System.assertEquals('', healthCheckGroupVModel.label, 'HealthCheckGroupVModel label should be blank.');
        System.assertEquals(Label.stgHealthCheckStatusPassed, healthCheckGroupVModel.status, 'HealthCheckGroupVModel status should be set to \'' + Label.stgHealthCheckStatusPassed + ' \'.');
        System.assertEquals(0, healthCheckGroupVModel.passedChecks, 'HealthCheckGroupVModel passedChecks should be 0.');
        System.assertEquals(0, healthCheckGroupVModel.totalChecks, 'HealthCheckGroupVModel totalChecks should be 0.');
        System.assertEquals(true, healthCheckGroupVModel.expandedRowsList.isEmpty(), 'HealthCheckGroupVModel expandedRowsList should be empty.');
        System.assertEquals(true, healthCheckGroupVModel.healthCheckItemList.isEmpty(), 'HealthCheckGroupVModel healthCheckItemList should be empty.');
    }

    /*****************************************************************************************
    * @description Test to verify constructor with 7 parameters generates model as expected.
    *****************************************************************************************/
    @isTest 
    private static void constructorWithSevenParametersValid(){
        List<String> expandedRowsList = new List<String>{'aString', 'bString', 'cString'};
        List<HealthCheckItemVModel> healthCheckItemList = new List<HealthCheckItemVModel>();
        for (Integer i = 0; i<5; i++){
            HealthCheckItemVModel healthCheckItemVModel = new HealthCheckItemVModel('TestKey' + i, 
                                                                          'TestSetting' + i, 
                                                                          'TestStatus' + i, 
                                                                          'TestStatusLabel' + i,
                                                                          'TestDescription' + i, 
                                                                          'TextRecommendedFix' + i,
                                                                          new List<HealthCheckItemVModel>());
            healthCheckItemList.add(healthCheckItemVModel);
        }

        Test.startTest();
        HealthCheckGroupVModel healthCheckGroupVModel = new HealthCheckGroupVModel('TestLabel',
                                                                          'TestStatus', 
                                                                          5, 
                                                                          8,
                                                                          expandedRowsList, 
                                                                          healthCheckItemList);
        Test.stopTest();

        System.assertEquals('TestLabel', healthCheckGroupVModel.label, 'HealthCheckGroupVModel label should be set to \'TestLabel\'..');
        System.assertEquals('TestStatus', healthCheckGroupVModel.status, 'HealthCheckGroupVModel status should be set to \'TestStatus\'.');
        System.assertEquals(5, healthCheckGroupVModel.passedChecks, 'HealthCheckGroupVModel passedChecks should be 5.');
        System.assertEquals(8, healthCheckGroupVModel.totalChecks, 'HealthCheckGroupVModel totalChecks should be 8.');
        System.assertEquals(3, healthCheckGroupVModel.expandedRowsList.size(), 'HealthCheckGroupVModel expandedRowsList should contain 3 strings.');
        System.assertEquals(5, healthCheckGroupVModel.healthCheckItemList.size(), 'HealthCheckGroupVModel healthCheckItemList should contain 5 healthCheckItem view models.');
    }

    /*****************************************************************************************
    * @description Test to verify compareTo() implementation separates HealthCheckGroupVModels 
    * with 'Fail' status from those with 'Pass' status (Fail above Pass) and in ascending 
    * alphabetical order by label within each group when duplicates do not exist.
    *****************************************************************************************/
    @isTest
    private static void sortByStatusThenLabelWithoutDuplicates(){
        List<HealthCheckGroupVModel> healthCheckGroupVModelsList = new List<HealthCheckGroupVModel>();


        HealthCheckGroupVModel healthCheckGroupVModel1 = new HealthCheckGroupVModel('Zebra',
                                                                           'Fail', 
                                                                           5, 
                                                                           8,
                                                                           new List<String>(), 
                                                                           new List<HealthCheckItemVModel>());

        HealthCheckGroupVModel healthCheckGroupVModel2 = new HealthCheckGroupVModel('zebra',
                                                                           'pass', 
                                                                           5, 
                                                                           8,
                                                                           new List<String>(), 
                                                                           new List<HealthCheckItemVModel>());
        
        HealthCheckGroupVModel healthCheckGroupVModel3 = new HealthCheckGroupVModel('Baboon',
                                                                           'Pass', 
                                                                           5, 
                                                                           8,
                                                                           new List<String>(), 
                                                                           new List<HealthCheckItemVModel>());
       
        HealthCheckGroupVModel healthCheckGroupVModel4 = new HealthCheckGroupVModel('Giraffe',
                                                                           'Fail', 
                                                                           5, 
                                                                           8,
                                                                           new List<String>(), 
                                                                           new List<HealthCheckItemVModel>());
        
        HealthCheckGroupVModel healthCheckGroupVModel5 = new HealthCheckGroupVModel('Lion',
                                                                           'Pass', 
                                                                           5, 
                                                                           8,
                                                                           new List<String>(), 
                                                                           new List<HealthCheckItemVModel>());
        
        HealthCheckGroupVModel healthCheckGroupVModel6 = new HealthCheckGroupVModel('Antelope',
                                                                           'Fail', 
                                                                           5, 
                                                                           8,
                                                                           new List<String>(), 
                                                                           new List<HealthCheckItemVModel>());

        healthCheckGroupVModelsList.add(healthCheckGroupVModel1);
        healthCheckGroupVModelsList.add(healthCheckGroupVModel2);
        healthCheckGroupVModelsList.add(healthCheckGroupVModel3);        
        healthCheckGroupVModelsList.add(healthCheckGroupVModel4);
        healthCheckGroupVModelsList.add(healthCheckGroupVModel5);
        healthCheckGroupVModelsList.add(healthCheckGroupVModel6);

        Test.startTest();
        healthCheckGroupVModelsList.sort();
        Test.stopTest();

        System.assertEquals(true, healthCheckGroupVModelsList[0].label.equalsIgnoreCase('Antelope'));
        System.assertEquals(true, healthCheckGroupVModelsList[0].status.equalsIgnoreCase('Fail'));
        System.assertEquals(true, healthCheckGroupVModelsList[1].label.equalsIgnoreCase('Giraffe'));
        System.assertEquals(true, healthCheckGroupVModelsList[1].status.equalsIgnoreCase('Fail'));
        System.assertEquals(true, healthCheckGroupVModelsList[2].label.equalsIgnoreCase('Zebra'));
        System.assertEquals(true, healthCheckGroupVModelsList[2].status.equalsIgnoreCase('Fail'));
        System.assertEquals(true, healthCheckGroupVModelsList[3].label.equalsIgnoreCase('Baboon'));
        System.assertEquals(true, healthCheckGroupVModelsList[3].status.equalsIgnoreCase('Pass'));
        System.assertEquals(true, healthCheckGroupVModelsList[4].label.equalsIgnoreCase('Lion'));
        System.assertEquals(true, healthCheckGroupVModelsList[4].status.equalsIgnoreCase('Pass'));
        System.assertEquals(true, healthCheckGroupVModelsList[5].label.equalsIgnoreCase('Zebra'));
        System.assertEquals(true, healthCheckGroupVModelsList[5].status.equalsIgnoreCase('Pass'));
    }

    /*****************************************************************************************
    * @description Test to verify compareTo() implementation separates HealthCheckGroupVModels 
    * with 'Fail' status from those with 'Pass' status (Fail above Pass) and in ascending 
    * alphabetical order by label within each group when duplicates exist.
    *****************************************************************************************/
    @isTest
    private static void sortByStatusThenLabelWithDuplicates(){
        List<HealthCheckGroupVModel> healthCheckGroupVModelsList = new List<HealthCheckGroupVModel>();


        HealthCheckGroupVModel healthCheckGroupVModel1 = new HealthCheckGroupVModel('Zebra',
                                                                           'Pass', 
                                                                           5, 
                                                                           8,
                                                                           new List<String>(), 
                                                                           new List<HealthCheckItemVModel>());

        HealthCheckGroupVModel healthCheckGroupVModel2 = new HealthCheckGroupVModel('zebra',
                                                                           'pass', 
                                                                           5, 
                                                                           8,
                                                                           new List<String>(), 
                                                                           new List<HealthCheckItemVModel>());
        
        HealthCheckGroupVModel healthCheckGroupVModel3 = new HealthCheckGroupVModel('Meerkat',
                                                                           'Fail', 
                                                                           5, 
                                                                           8,
                                                                           new List<String>(), 
                                                                           new List<HealthCheckItemVModel>());
       
        HealthCheckGroupVModel healthCheckGroupVModel4 = new HealthCheckGroupVModel('lion',
                                                                           'fail', 
                                                                           5, 
                                                                           8,
                                                                           new List<String>(), 
                                                                           new List<HealthCheckItemVModel>());
        
        HealthCheckGroupVModel healthCheckGroupVModel5 = new HealthCheckGroupVModel('Lion',
                                                                           'fail', 
                                                                           5, 
                                                                           8,
                                                                           new List<String>(), 
                                                                           new List<HealthCheckItemVModel>());
        
        HealthCheckGroupVModel healthCheckGroupVModel6 = new HealthCheckGroupVModel('Antelope',
                                                                           'Pass', 
                                                                           5, 
                                                                           8,
                                                                           new List<String>(), 
                                                                           new List<HealthCheckItemVModel>());

        healthCheckGroupVModelsList.add(healthCheckGroupVModel1);
        healthCheckGroupVModelsList.add(healthCheckGroupVModel2);
        healthCheckGroupVModelsList.add(healthCheckGroupVModel3);        
        healthCheckGroupVModelsList.add(healthCheckGroupVModel4);
        healthCheckGroupVModelsList.add(healthCheckGroupVModel5);
        healthCheckGroupVModelsList.add(healthCheckGroupVModel6);

        Test.startTest();
        healthCheckGroupVModelsList.sort();
        Test.stopTest();

        System.assertEquals(true, healthCheckGroupVModelsList[0].label.equalsIgnoreCase('Lion'));
        System.assertEquals(true, healthCheckGroupVModelsList[0].status.equalsIgnoreCase('Fail'));
        System.assertEquals(true, healthCheckGroupVModelsList[1].label.equalsIgnoreCase('Lion'));
        System.assertEquals(true, healthCheckGroupVModelsList[1].status.equalsIgnoreCase('Fail'));
        System.assertEquals(true, healthCheckGroupVModelsList[2].label.equalsIgnoreCase('Meerkat'));
        System.assertEquals(true, healthCheckGroupVModelsList[2].status.equalsIgnoreCase('Fail'));
        System.assertEquals(true, healthCheckGroupVModelsList[3].label.equalsIgnoreCase('Antelope'));
        System.assertEquals(true, healthCheckGroupVModelsList[3].status.equalsIgnoreCase('Pass'));
        System.assertEquals(true, healthCheckGroupVModelsList[4].label.equalsIgnoreCase('Zebra'));
        System.assertEquals(true, healthCheckGroupVModelsList[4].status.equalsIgnoreCase('Pass'));
        System.assertEquals(true, healthCheckGroupVModelsList[5].label.equalsIgnoreCase('Zebra'));
        System.assertEquals(true, healthCheckGroupVModelsList[5].status.equalsIgnoreCase('Pass'));
    }

    /*****************************************************************************************
    * @description Test to verify compareTo() implementation does not sort lists that 
    * contain Object of type other than HealthCheckGroupVModel, when the HealthCheckGroupVModel
    * is first in the list. 
    *****************************************************************************************/
    private static void sortWithIncomparableObjectTypesRightFirstInList(){
        List<Object> objectsToSort = new List<Object>();
        HealthCheckGroupVModel healthCheckGroupVModel = new HealthCheckGroupVModel('Antelope',
                                                                           'Pass', 
                                                                           5, 
                                                                           8,
                                                                           new List<String>(), 
                                                                           new List<HealthCheckItemVModel>());

        Account testAccount = new Account(Name = 'TestAccount');
        Contact testContact = new Contact(LastName = 'Testerson');

        objectsToSort.add(healthCheckGroupVModel);
        objectsToSort.add(testContact);
        objectsToSort.add(testAccount);

        Test.startTest();
        objectsToSort.sort();
        Test.stopTest();

        System.assertEquals(true, objectsToSort[0] instanceof HealthCheckGroupVModel, 'List should not be sorted when object types are not equal.');
        System.assertEquals(true, objectsToSort[1] instanceof Contact, 'List should not be sorted when object types are not equal.');
        System.assertEquals(true, objectsToSort[2] instanceof Account, 'List should not be sorted when object types are not equal.');
    }

    /*****************************************************************************************
    * @description Test to verify compareTo() implementation does not sort lists that 
    * contain Object of type other than HealthCheckGroupVModel, when the HealthCheckGroupVModel
    * is not first in the list. 
    *****************************************************************************************/
    private static void sortWithIncomparableObjectTypesWrongFirstInList(){
        List<Object> objectsToSort = new List<Object>();
        HealthCheckGroupVModel healthCheckGroupVModel = new HealthCheckGroupVModel('Antelope',
                                                                           'Pass', 
                                                                           5, 
                                                                           8,
                                                                           new List<String>(), 
                                                                           new List<HealthCheckItemVModel>());


        HealthCheckItemVModel healthCheckItemVModel1 = new HealthCheckItemVModel('TestKey1', 
                                                                          'TestSetting', 
                                                                          'Fail', 
                                                                          'TestStatusLabel',
                                                                          'TestDescription', 
                                                                          'TextRecommendedFix',
                                                                          new List<HealthCheckItemVModel>());

        HealthCheckItemVModel healthCheckItemVModel2 = new HealthCheckItemVModel('TestKey2', 
                                                                          'TestSetting', 
                                                                          'Fail', 
                                                                          'TestStatusLabel',
                                                                          'TestDescription', 
                                                                          'TextRecommendedFix',
                                                                          new List<HealthCheckItemVModel>());
        Account testAccount = new Account(Name = 'TestAccount');
        Contact testContact = new Contact(LastName = 'Testerson');

        objectsToSort.add(healthCheckItemVModel1);
        objectsToSort.add(healthCheckGroupVModel);
        objectsToSort.add(healthCheckItemVModel1);
        objectsToSort.add(testAccount);
        objectsToSort.add(testContact);

        Test.startTest();
        objectsToSort.sort();
        Test.stopTest();

        System.assertEquals(true, objectsToSort[0] instanceof HealthCheckItemVModel, 'List should not be sorted when object types are not equal.');
        System.assertEquals(true, objectsToSort[1] instanceof HealthCheckGroupVModel, 'List should not be sorted when object types are not equal.');
        System.assertEquals(true, objectsToSort[2] instanceof HealthCheckItemVModel, 'List should not be sorted when object types are not equal.');
        System.assertEquals(true, objectsToSort[3] instanceof Account, 'List should not be sorted when object types are not equal.');
        System.assertEquals(true, objectsToSort[4] instanceof Contact, 'List should not be sorted when object types are not equal.');
    }

    /*****************************************************************************************
    * @description Test to verify compareTo() method returns 0 when an object that is not of 
    * type HealthCheckGroupVModel is provided for comparison.
    *****************************************************************************************/
    @isTest 
    private static void compareToIncompatibleObjectType(){
        Account acct = new Account(Name = 'Test Account');

        HealthCheckGroupVModel healthCheckGroupVModel = new HealthCheckGroupVModel('TestLabel',
                                                                          'TestStatus', 
                                                                          5, 
                                                                          8,
                                                                          new List<String>{'TestString'}, 
                                                                          new List<HealthCheckItemVModel>());

        Test.startTest();
        Integer compareToResult = healthCheckGroupVModel.compareTo(acct);
        Test.stopTest();

        System.assertEquals(0, compareToResult, 'Result comparing incompatible object types should be 0.');
    }

    /**************************************************************************************************************************
    * @description Test to verify updateHealthCheckStatus() returns Pass when all health checks executed pass.
    **************************************************************************************************************************/ 
    @isTest
    private static void updateHealthCheckStatusPass(){
        HealthCheckGroupVModel healthCheckGroupVModel = new HealthCheckGroupVModel('TestLabel',
                                                                          'TestStatus', 
                                                                          5, 
                                                                          5,
                                                                          new List<String>{'TestString'}, 
                                                                          new List<HealthCheckItemVModel>());
        Test.startTest();
        healthCheckGroupVModel.updateHealthCheckStatus();
        Test.stopTest();

        System.assertEquals(Label.stgHealthCheckStatusPassed, healthCheckGroupVModel.status, 'Should return \'' + Label.stgHealthCheckStatusPassed + '\'.');
    }

    /**************************************************************************************************************************
    * @description Test to verify updateHealthCheckStatus() returns Fail when any health checks executed fail.
    **************************************************************************************************************************/ 
    @isTest
    private static void updateHealthCheckStatusFail(){
        HealthCheckGroupVModel healthCheckGroupVModel = new HealthCheckGroupVModel('TestLabel',
                                                                          'TestStatus', 
                                                                          5, 
                                                                          10,
                                                                          new List<String>{'TestString'}, 
                                                                          new List<HealthCheckItemVModel>());
        Test.startTest();
        healthCheckGroupVModel.updateHealthCheckStatus();
        Test.stopTest();

        System.assertEquals(Label.stgHealthCheckStatusFailed, healthCheckGroupVModel.status, 'Should return \'' + Label.stgHealthCheckStatusFailed + '\'.');
    }
}
public virtual with sharing class HealthCheckItemVModel implements Comparable {
    @AuraEnabled public String key { get; private set; }
    @AuraEnabled public String setting { get; private set; }
    @AuraEnabled public String status;
    @AuraEnabled public String statusLabel;
    @AuraEnabled public String description;
    @AuraEnabled public String recommendedFix;
    @AuraEnabled public List<HealthCheckItemVModel> healthCheckItemList { get; private set; }
    
    public HealthCheckItemVModel(String key, 
                                 String setting, 
                                 String status, 
                                 String statusLabel,
                                 String description, 
                                 String recommendedFix,
                                 List<HealthCheckItemVModel> healthCheckItemList) {
        this.key = key;
        this.setting = setting;
        this.status = status;
        this.statusLabel = statusLabel;
        this.description = description;
        this.recommendedFix = recommendedFix;
        this.healthCheckItemList = healthCheckItemList;
    }

    /*****************************************************************************************
    * @description Implementation of CompareTo() that sorts by status (Fail above Pass), then in
    * ascending alphabetical order on setting.
    * @param compareTo A HealthCheckItemVModel object to compare to another
    * @return 0 if the current object is greater than the object to compare, -1 if it is less, 0 if
    * they are equal, or if the objec to compare is an incompatible type.
    *****************************************************************************************/ 
    public virtual Integer compareTo(Object compareTo){

        if (!(compareTo instanceof HealthCheckItemVModel)){
            return 0;
        }

        HealthCheckItemVModel healthCheckItemVModelToCompareTo = (HealthCheckItemVModel)compareTo;
        Integer statusResult = this.status.toLowerCase().compareTo(healthCheckItemVModelToCompareTo.status.toLowerCase());
        
        if (statusResult != 0){
            return statusResult;
        }
        
        return this.setting.toLowerCase().compareTo(healthCheckItemVModelToCompareTo.setting.toLowerCase());
    }
}
@isTest 
public with sharing class HealthCheckItemVModel_TEST {

    /*****************************************************************************************
    * @description Test to verify constructor with 5 parameters generates model as expected.
    *****************************************************************************************/
    @isTest 
    private static void constructorWithFiveParamsValid(){

        List<HealthCheckItemVModel> sampleHCItemVModelList = new List<HealthCheckItemVModel>();

        Test.startTest();
        HealthCheckItemVModel healthCheckItemVModel = new HealthCheckItemVModel('TestKey', 
                                                                          'TestSetting', 
                                                                          'TestStatus', 
                                                                          'TestStatusLabel',
                                                                          'TestDescription', 
                                                                          'TextRecommendedFix',
                                                                          sampleHCItemVModelList);
        Test.stopTest();

        System.assertEquals('TestKey', healthCheckItemVModel.key, 'HealthCheckItemVModel key should be set to \'TestKey\'');
        System.assertEquals('TestSetting', healthCheckItemVModel.setting, 'HealthCheckItemVModel setting should be set to \'TestSetting\'');
        System.assertEquals('TestStatus', healthCheckItemVModel.status, 'HealthCheckItemVModel status should be set to \'TestStatus\'');
        System.assertEquals('TestStatusLabel', healthCheckItemVModel.statusLabel, 'HealthCheckItemVModel statuslabel should be set to \'TestStatusLabel\'');
        System.assertEquals('TestDescription', healthCheckItemVModel.description, 'HealthCheckItemVModel description should be set to \'TestDescription\'');
        System.assertEquals('TextRecommendedFix', healthCheckItemVModel.recommendedFix, 'HealthCheckItemVModel recommendedFix should be set to \'TextRecommendedFix\'');
        System.assertEquals(sampleHCItemVModelList, healthCheckItemVModel.healthCheckItemList, 'List of HealthCheckItemVModel should not change.');
    }

    /*****************************************************************************************
    * @description Test to verify compareTo() implementation separates HealthCheckGroupVModels 
    * with 'Fail' status from those with 'Pass' status (Fail above Pass) and in ascending 
    * alphabetical order by label within each group when duplicates do not exist.
    *****************************************************************************************/
    @isTest
    private static void sortByStatusThenLabelWithoutDuplicates(){
        List<HealthCheckItemVModel> healthCheckItemVModelsList = new List<HealthCheckItemVModel>();


        HealthCheckItemVModel healthCheckItemVModel1 = new HealthCheckItemVModel('key-1',
                                                                           'Zebra',
                                                                           'Fail', 
                                                                           'Fail-Label', 
                                                                           'Test Description',
                                                                           'Test Recommended fix', 
                                                                           new List<HealthCheckItemVModel>());

        HealthCheckItemVModel healthCheckItemVModel2 = new HealthCheckItemVModel('key-2',
                                                                            'Zebra',
                                                                            'pass', 
                                                                            'pass-Label', 
                                                                            'Test Description',
                                                                            'Test Recommended fix', 
                                                                            new List<HealthCheckItemVModel>());
        
        HealthCheckItemVModel healthCheckItemVModel3 = new HealthCheckItemVModel('key-3',
                                                                            'Baboon',
                                                                            'Pass', 
                                                                            'Pass-Label', 
                                                                            'Test Description',
                                                                            'Test Recommended fix', 
                                                                            new List<HealthCheckItemVModel>());
       
        HealthCheckItemVModel healthCheckItemVModel4 = new HealthCheckItemVModel('key-4',
                                                                            'Giraffe',
                                                                            'Fail', 
                                                                            'Fail-Label', 
                                                                            'Test Description',
                                                                            'Test Recommended fix', 
                                                                            new List<HealthCheckItemVModel>());
        
        HealthCheckItemVModel healthCheckItemVModel5 = new HealthCheckItemVModel('key-5',
                                                                            'Lion',
                                                                            'Pass', 
                                                                            'Pass-Label', 
                                                                            'Test Description',
                                                                            'Test Recommended fix', 
                                                                            new List<HealthCheckItemVModel>());
        
        HealthCheckItemVModel healthCheckItemVModel6 = new HealthCheckItemVModel('key-1',
                                                                            'Antelope',
                                                                            'Fail', 
                                                                            'Fail-Label', 
                                                                            'Test Description',
                                                                            'Test Recommended fix', 
                                                                            new List<HealthCheckItemVModel>());

        healthCheckItemVModelsList.add(healthCheckItemVModel1);
        healthCheckItemVModelsList.add(healthCheckItemVModel2);
        healthCheckItemVModelsList.add(healthCheckItemVModel3);        
        healthCheckItemVModelsList.add(healthCheckItemVModel4);
        healthCheckItemVModelsList.add(healthCheckItemVModel5);
        healthCheckItemVModelsList.add(healthCheckItemVModel6);

        Test.startTest();
        healthCheckItemVModelsList.sort();
        Test.stopTest();

        System.assertEquals(true, healthCheckItemVModelsList[0].setting.equalsIgnoreCase('Antelope'));
        System.assertEquals(true, healthCheckItemVModelsList[0].status.equalsIgnoreCase('Fail'));
        System.assertEquals(true, healthCheckItemVModelsList[1].setting.equalsIgnoreCase('Giraffe'));
        System.assertEquals(true, healthCheckItemVModelsList[1].status.equalsIgnoreCase('Fail'));
        System.assertEquals(true, healthCheckItemVModelsList[2].setting.equalsIgnoreCase('Zebra'));
        System.assertEquals(true, healthCheckItemVModelsList[2].status.equalsIgnoreCase('Fail'));
        System.assertEquals(true, healthCheckItemVModelsList[3].setting.equalsIgnoreCase('Baboon'));
        System.assertEquals(true, healthCheckItemVModelsList[3].status.equalsIgnoreCase('Pass'));
        System.assertEquals(true, healthCheckItemVModelsList[4].setting.equalsIgnoreCase('Lion'));
        System.assertEquals(true, healthCheckItemVModelsList[4].status.equalsIgnoreCase('Pass'));
        System.assertEquals(true, healthCheckItemVModelsList[5].setting.equalsIgnoreCase('Zebra'));
        System.assertEquals(true, healthCheckItemVModelsList[5].status.equalsIgnoreCase('Pass'));
    }

    /*****************************************************************************************
    * @description Test to verify compareTo() implementation separates HealthCheckGroupVModels 
    * with 'Fail' status from those with 'Pass' status (Fail above Pass) and in ascending 
    * alphabetical order by label within each group when duplicates exist.
    *****************************************************************************************/
    @isTest
    private static void sortByStatusThenLabelWithDuplicates(){
        List<HealthCheckItemVModel> healthCheckItemVModelsList = new List<HealthCheckItemVModel>();


        HealthCheckItemVModel healthCheckItemVModel1 = new HealthCheckItemVModel('key-1',
                                                                          'Zebra',
                                                                          'Pass', 
                                                                          'Pass-label', 
                                                                          'Test Description',
                                                                          'Test Recommended Fix', 
                                                                          new List<HealthCheckItemVModel>());

                                                                          

        HealthCheckItemVModel healthCheckItemVModel2 = new HealthCheckItemVModel('key-2',
                                                                          'zebra',
                                                                          'pass', 
                                                                          'pass-label', 
                                                                          'Test Description',
                                                                          'Test Recommended Fix', 
                                                                          new List<HealthCheckItemVModel>());


        HealthCheckItemVModel healthCheckItemVModel3 = new HealthCheckItemVModel('key-3',
                                                                          'Meerkat',
                                                                          'Fail', 
                                                                          'Fail-label', 
                                                                          'Test Description',
                                                                          'Test Recommended Fix', 
                                                                          new List<HealthCheckItemVModel>());


        HealthCheckItemVModel healthCheckItemVModel4 = new HealthCheckItemVModel('key-4',
                                                                          'lion',
                                                                          'fail', 
                                                                          'fail-label', 
                                                                          'Test Description',
                                                                          'Test Recommended Fix', 
                                                                          new List<HealthCheckItemVModel>());


        HealthCheckItemVModel healthCheckItemVModel5 = new HealthCheckItemVModel('key-5',
                                                                          'Lion',
                                                                          'fail', 
                                                                          'fail-label', 
                                                                          'Test Description',
                                                                          'Test Recommended Fix', 
                                                                          new List<HealthCheckItemVModel>());


        HealthCheckItemVModel healthCheckItemVModel6 = new HealthCheckItemVModel('key-6',
                                                                          'Antelope',
                                                                          'Pass', 
                                                                          'Pass-label', 
                                                                          'Test Description',
                                                                          'Test Recommended Fix', 
                                                                          new List<HealthCheckItemVModel>());


        healthCheckItemVModelsList.add(healthCheckItemVModel1);
        healthCheckItemVModelsList.add(healthCheckItemVModel2);
        healthCheckItemVModelsList.add(healthCheckItemVModel3);        
        healthCheckItemVModelsList.add(healthCheckItemVModel4);
        healthCheckItemVModelsList.add(healthCheckItemVModel5);
        healthCheckItemVModelsList.add(healthCheckItemVModel6);

        Test.startTest();
        healthCheckItemVModelsList.sort();
        Test.stopTest();

        System.assertEquals(true, healthCheckItemVModelsList[0].setting.equalsIgnoreCase('Lion'));
        System.assertEquals(true, healthCheckItemVModelsList[0].status.equalsIgnoreCase('Fail'));
        System.assertEquals(true, healthCheckItemVModelsList[1].setting.equalsIgnoreCase('Lion'));
        System.assertEquals(true, healthCheckItemVModelsList[1].status.equalsIgnoreCase('Fail'));
        System.assertEquals(true, healthCheckItemVModelsList[2].setting.equalsIgnoreCase('Meerkat'));
        System.assertEquals(true, healthCheckItemVModelsList[2].status.equalsIgnoreCase('Fail'));
        System.assertEquals(true, healthCheckItemVModelsList[3].setting.equalsIgnoreCase('Antelope'));
        System.assertEquals(true, healthCheckItemVModelsList[3].status.equalsIgnoreCase('Pass'));
        System.assertEquals(true, healthCheckItemVModelsList[4].setting.equalsIgnoreCase('Zebra'));
        System.assertEquals(true, healthCheckItemVModelsList[4].status.equalsIgnoreCase('Pass'));
        System.assertEquals(true, healthCheckItemVModelsList[5].setting.equalsIgnoreCase('Zebra'));
        System.assertEquals(true, healthCheckItemVModelsList[5].status.equalsIgnoreCase('Pass'));
    }

    /*****************************************************************************************
    * @description Test to verify compareTo() implementation does not sort lists that 
    * contain Object of type other than HealthCheckItemVModel, when the HealthCheckItemVModel
    * is first in the list. 
    *****************************************************************************************/
    private static void sortWithIncomparableObjectTypesRightFirstInList(){
        List<Object> objectsToSort = new List<Object>();
        HealthCheckItemVModel healthCheckItemVModel = new HealthCheckItemVModel('key-1',
                                                                         'Antelope',
                                                                         'Pass', 
                                                                         'Pass-label', 
                                                                         'Test Description',
                                                                         'Test Recommended Fix', 
                                                                         new List<HealthCheckItemVModel>());

        Account testAccount = new Account(Name = 'TestAccount');
        Contact testContact = new Contact(LastName = 'Testerson');

        objectsToSort.add(healthCheckItemVModel);
        objectsToSort.add(testContact);
        objectsToSort.add(testAccount);

        Test.startTest();
        objectsToSort.sort();
        Test.stopTest();

        System.assertEquals(true, objectsToSort[0] instanceof HealthCheckItemVModel, 'List should not be sorted when object types are not equal.');
        System.assertEquals(true, objectsToSort[1] instanceof Contact, 'List should not be sorted when object types are not equal.');
        System.assertEquals(true, objectsToSort[2] instanceof Account, 'List should not be sorted when object types are not equal.');
    }

    /*****************************************************************************************
    * @description Test to verify compareTo() implementation does not sort lists that 
    * contain Object of type other than HealthCheckItemVModel, when the HealthCheckItemVModel
    * is not first in the list. 
    *****************************************************************************************/
    private static void sortWithIncomparableObjectTypesWrongFirstInList(){
        List<Object> objectsToSort = new List<Object>();

        HealthCheckGroupVModel healthCheckGroupVModel = new HealthCheckGroupVModel('Zebra',
                                                                             'Fail', 
                                                                             5, 
                                                                             8,
                                                                             new List<String>(), 
                                                                             new List<HealthCheckItemVModel>());

        HealthCheckItemVModel healthCheckItemVModel1 = new HealthCheckItemVModel('TestKey1', 
                                                                           'TestSetting', 
                                                                           'Fail', 
                                                                           'TestStatusLabel',
                                                                           'TestDescription', 
                                                                           'TextRecommendedFix',
                                                                           new List<HealthCheckItemVModel>());

        HealthCheckItemVModel healthCheckItemVModel2 = new HealthCheckItemVModel('TestKey2', 
                                                                           'TestSetting', 
                                                                           'Fail', 
                                                                           'TestStatusLabel',
                                                                           'TestDescription', 
                                                                           'TextRecommendedFix',
                                                                           new List<HealthCheckItemVModel>());
        Account testAccount = new Account(Name = 'TestAccount');
        Contact testContact = new Contact(LastName = 'Testerson');

        objectsToSort.add(healthCheckGroupVModel);
        objectsToSort.add(healthCheckItemVModel1);
        objectsToSort.add(healthCheckItemVModel2);
        objectsToSort.add(testAccount);
        objectsToSort.add(testContact);

        Test.startTest();
        objectsToSort.sort();
        Test.stopTest();

        System.assertEquals(true, objectsToSort[0] instanceof HealthCheckGroupVModel, 'List should not be sorted when object types are not equal.');
        System.assertEquals(true, objectsToSort[1] instanceof HealthCheckItemVModel, 'List should not be sorted when object types are not equal.');
        System.assertEquals(true, objectsToSort[2] instanceof HealthCheckItemVModel, 'List should not be sorted when object types are not equal.');
        System.assertEquals(true, objectsToSort[3] instanceof Account, 'List should not be sorted when object types are not equal.');
        System.assertEquals(true, objectsToSort[4] instanceof Contact, 'List should not be sorted when object types are not equal.');
    }

    /*****************************************************************************************
    * @description Test to verify compareTo() method returns 0 when an object that is not of 
    * type HealthCheckItemVModel is provided for comparison.
    *****************************************************************************************/
    @isTest 
    private static void compareToIncompatibleObjectType(){
        Account acct = new Account(Name = 'Test Account');

        HealthCheckItemVModel healthCheckItemVModel = new HealthCheckItemVModel('TestKey1', 
                                                                           'TestSetting', 
                                                                           'Fail', 
                                                                           'TestStatusLabel',
                                                                           'TestDescription', 
                                                                           'TextRecommendedFix',
                                                                           new List<HealthCheckItemVModel>());

        Test.startTest();
        Integer compareToResult = healthCheckItemVModel.compareTo(acct);
        Test.stopTest();

        System.assertEquals(0, compareToResult, 'Result comparing incompatible object types should be 0.');
    }
}
public virtual with sharing class HealthCheckVMapper {

    /**********************************************************************************
    * @description Instance for Singleton Pattern
    **********************************************************************************/
    @TestVisible
    private static HealthCheckVMapper instance;

    /**********************************************************************************
    * @description Empty constructor is not public for Singleton Pattern
    **********************************************************************************/
    protected HealthCheckVMapper() {}

    /**********************************************************************************
    * @description Static method to get the current instance for Singleton pattern
    * @return The instance of HealthCheckVMapper.
    **********************************************************************************/
    public static HealthCheckVMapper getInstance() {
        if (instance == null) {
            instance = new HealthCheckVMapper();
        }

        return instance;
    }

    /**********************************************************************************
    * @description Locates and returns an instance of FeatureParameterService 
    **********************************************************************************/
    @TestVisible
    private FeatureParameterService locateFeatureParameterService() {
        return FeatureParameterService.getInstance();
    }

    /**********************************************************************************
    * @description Locates and returns an instance of HealthCheckDefinitionService 
    **********************************************************************************/
    @TestVisible
    private HealthCheckDefinitionService locateHealthCheckDefinitionService() {
        return HealthCheckDefinitionService.getInstance();
    }

    /**********************************************************************************
    * @description Retrieve a view model representing a health check to run.
    * @return A HealthCheckVModel representing details of a health check to be run.
    **********************************************************************************/
    public virtual HealthCheckVModel getHealthCheckViewModel() {
        try {
            String lastRunDate = '';

            FeatureParameterDateModel featureParamDateModel = 
               (FeatureParameterDateModel)this.locateFeatureParameterService().getFeatureParameterModel('SettingsHealthCheckLastRunDate');

            if (featureParamDateModel.value != date.newinstance(2015, 12, 31)) {
                lastRunDate = featureParamDateModel.convertToString();
            }

            List<HealthCheckDefinitionVModel> healthCheckDefViewModelsList = new List<HealthCheckDefinitionVModel>(); // list to store VIEW MODELS
            List<HealthCheckDefinitionModel> healthCheckDefinitionList = this.locateHealthCheckDefinitionService().getHealthCheckDefinitionModels(); // retrieve models
            
            for (HealthCheckDefinitionModel healthCheckDefinitionModel : healthCheckDefinitionList) {
                //Generate view model for current health check definition model
                HealthCheckDefinitionVModel healthCheckDefinitionVModel = new HealthCheckDefinitionVModel(healthCheckDefinitionModel.name,
                                                                                                    healthCheckDefinitionModel.className,
                                                                                                    healthCheckDefinitionModel.namespace);

                healthCheckDefViewModelsList.add(healthCheckDefinitionVModel);
            }

            Integer numberOfRuns = healthCheckDefinitionList.size();

            return new HealthCheckVModel(lastRunDate, numberOfRuns, healthCheckDefViewModelsList);
        }
        catch (FeatureParameterMapper.FeatureParameterMapperException e) {
            throw new AuraHandledException(Label.stgHealthCheckErrorLastRunDate);
        }
    }
}
@isTest 
public class HealthCheckVMapper_TEST {

    /**************************************************************************************************************************
    ***************************************************** UNIT TESTS **********************************************************
    **************************************************************************************************************************/
    
    /**************************************************************************************************************************
    * @description Test method to verify that the getInstance method returns a new instance of the 
    * HealthCheckVMapper class when one does not already exist.
    ***************************************************************************************************************************/
    @isTest
    private static void getInstanceNew() {

        Test.startTest();
            HealthCheckVMapper healthCheckVMapperInstance = HealthCheckVMapper.getInstance();
        Test.stopTest();

        System.assertEquals(HealthCheckVMapper.instance, healthCheckVMapperInstance, 'Instance of mapper class returned should match static instance variable.');
        System.assertEquals(true, healthCheckVMapperInstance != null, 'Instance of mapper class should not be null.');
    }

    /**************************************************************************************************************************
    * @description Test method to verify that the getInstance method returns the existing instance of the 
    * HealthCheckVMapper class when one already exists.
    ***************************************************************************************************************************/
    @isTest
    private static void getInstanceExisting() {

        Test.startTest();
            HealthCheckVMapper HealthCheckVMapperInstance1 = HealthCheckVMapper.getInstance();
            HealthCheckVMapper HealthCheckVMapperInstance2 = HealthCheckVMapper.getInstance();
        Test.stopTest();

        System.assertEquals(HealthCheckVMapper.instance, HealthCheckVMapperInstance1, 'Instance of mapper class returned should match static instance variable.');
        System.assertEquals(HealthCheckVMapperInstance1, HealthCheckVMapperInstance2, 'Subsequent retrievals of mapper class instance should return existing instance.');
        System.assertEquals(true, HealthCheckVMapperInstance1 != null, 'Instance of mapper class should not be null.');
    }

    /****************************************************************************************************************************
    * @description Test method to verify that the locateFeatureParameterService method returns instance of FeatureParameterService.
    ****************************************************************************************************************************/
    @isTest
    private static void locateFeatureParameterServiceValid() {
        Test.startTest();
            FeatureParameterService featureParamService = HealthCheckVMapper.getInstance().locateFeatureParameterService();
        Test.stopTest();

        System.assertEquals(FeatureParameterService.getInstance(), featureParamService, 'Should return the instance of FeatureParameterService.');
    }    

    /****************************************************************************************************************************
    * @description Test method to verify that the locateHealthCheckDefinitionService method returns instance of HealthCheckDefinitionService.
    ****************************************************************************************************************************/
    @isTest
    private static void locateHealthCheckDefinitionServiceValid() {
        Test.startTest();
        HealthCheckDefinitionService healthCheckDefService = HealthCheckVMapper.getInstance().locateHealthCheckDefinitionService();
        Test.stopTest();

        System.assertEquals(HealthCheckDefinitionService.getInstance(), healthCheckDefService, 'Should return the instance of HealthCheckDefinitionService.');
    }

    /****************************************************************************************************************************
    * @description Test to verify that getHealthCheckViewModel method returns a Health Check View Model.
    ****************************************************************************************************************************/
    @isTest 
    private static void getHealthCheckViewModelValid(){

        FeatureParameterMapper.instance = new STUB_FeatureParameterDateModel();
        HealthCheckDefinitionService.instance = new STUB_HealthCheckDefinitionService();

        Test.startTest();
        HealthCheckVModel healthCheckVModel = HealthCheckVMapper.getInstance().getHealthCheckViewModel();
        Test.stopTest();

        System.assertEquals(Date.today().addDays(-3).format(), healthCheckVModel.lastRunDate, 'Last run date should be 3 days before current date.');
        System.assertEquals(10, healthCheckVModel.numberOfHealthChecks, 'Number of healt checks to run should equal 10.');
        System.assertEquals(10, healthCheckVModel.healthCheckDefinitionList.size(), 'There should be 10 health check definition view models.');
     
        for (Integer i = 0; i < healthCheckVModel.healthCheckDefinitionList.size(); i++){
            System.assertEquals('Test Health Check ' + i, healthCheckVModel.healthCheckDefinitionList[i].name, 'Name of health check view model should be \'Test Health Check ' + i + '\'');
            System.assertEquals('Test Classname', healthCheckVModel.healthCheckDefinitionList[i].className, 'Classname of health check should be \'Test Classname\'');
            System.assertEquals('TEST', healthCheckVModel.healthCheckDefinitionList[i].namespace, 'Classname of health check should be \'TEST\'');
        }  
    }

    /****************************************************************************************************************************
    * @description Test to verify that getHealthCheckViewModel throws AuraHandledException
    ****************************************************************************************************************************/
    @isTest 
    private static void getHealthCheckViewModelException(){

        FeatureParameterMapper.instance = new STUB_FeatureParameterMapperError();
        HealthCheckDefinitionService.instance = new STUB_HealthCheckDefinitionService();

        try {
            Test.startTest();
                HealthCheckVModel healthCheckVModel = HealthCheckVMapper.getInstance().getHealthCheckViewModel();
            Test.stopTest();
            System.assert(false, 'Should throw an exception');
        } catch (AuraHandledException ex) {
            System.assertEquals('System.AuraHandledException', ex.getTypeName(), 'AuraHandledException should be thrown when exception occurs.');
        } 
    }


    /**************************************************************************************************************************
    ****************************************************** STUBS **************************************************************
    **************************************************************************************************************************/
    
    /**************************************************************************************************************************************
    * @description Stub class to simulate the response from FeatureParameterMapper to return a new instance of a FeatureParameterDateModel
    **************************************************************************************************************************************/ 
    private class STUB_FeatureParameterDateModel extends FeatureParameterMapper {
        @TestVisible 
        public override FeatureParameterModel getFeatureParameterModel(String featureParameter){            
            FeatureParameterDateModel featureParamDateMdl = new FeatureParameterDateModel('Test Feature Param', Date.today().addDays(-3));
            return featureParamDateMdl;
        }
    }

    /**************************************************************************************************************************************
    * @description Stub class to simulate the response from HealthCheckDefinitionService to return a list of HealthCheckDefinitionVModels
    **************************************************************************************************************************************/ 
    private class STUB_HealthCheckDefinitionService extends HealthCheckDefinitionService {
        @TestVisible
        public override List<HealthCheckDefinitionModel> getHealthCheckDefinitionModels(){
            List<HealthCheckDefinitionModel> healthCheckDefModelsList = new List<HealthCheckDefinitionModel>();

            for (Integer i = 0; i < 10; i++){
                HealthCheckDefinitionModel healthCheckDefModel = new HealthCheckDefinitionModel('Test Health Check ' + i, 'Test Classname', 'TEST');
                healthCheckDefModelsList.add(healthCheckDefModel);
            }

            return healthCheckDefModelsList;
        }
    }
    
    /**************************************************************************************************************************************
    * @description Stub class to simulate the exception for FeatureParameterMapper
    **************************************************************************************************************************************/ 
    private class STUB_FeatureParameterMapperError extends FeatureParameterMapper {
        
        @TestVisible
        public override FeatureParameterModel getFeatureParameterModel(String featureParameter){
            TelemetryParameterName telemetryParameterName = FeatureParameterMapper.TelemetryParameterByString.get(featureParameter);
            throw new FeatureParameterMapperException('Feature Parameter ' + String.valueOf(telemetryParameterName) + ' is not defined.');
        }
    }
}
public with sharing class HealthCheckVModel {
    @AuraEnabled public String lastRunDate { get; private set; }
    @AuraEnabled public Integer numberOfHealthChecks { get; private set; }
    @AuraEnabled public List<HealthCheckDefinitionVModel> healthCheckDefinitionList { get; private set; }

    public HealthCheckVModel(String lastRunDate, 
                            Integer numberOfHealthChecks, 
                            List<HealthCheckDefinitionVModel> healthCheckDefinitionList) {
                                
        this.lastRunDate = lastRunDate;
        this.numberOfHealthChecks = numberOfHealthChecks;
        this.healthCheckDefinitionList = healthCheckDefinitionList;
    }
}
@isTest 
public with sharing class HealthCheckVModel_TEST {
    /****************************************************************************************************************************
    * @description Test to verify constructor with 3 parameters initializes object with properties set as expected.
    ****************************************************************************************************************************/
    @isTest 
    private static void threeParamConstructorValid(){
        List<HealthCheckDefinitionVModel> healthCheckDefinitionList = new List<HealthCheckDefinitionVModel>();

        for (Integer i=0; i<5; i++){
            HealthCheckDefinitionVModel healthCheckDefinitionVModel = new HealthCheckDefinitionVModel('Test ' + i, 'TestClass', 'TEST');
            healthCheckDefinitionList.add(healthCheckDefinitionVModel);
        }

        Test.startTest();
        HealthCheckVModel healthCheckVModel = new HealthCheckVModel(Date.today().format(), healthCheckDefinitionList.size(), healthCheckDefinitionList);
        Test.stopTest();

        System.assertEquals(Date.today().format(), healthCheckVModel.lastRunDate, 'Last run date should be today.');
        System.assertEquals(5, healthCheckVModel.numberOfHealthChecks, 'Number of health checks to run should be 5.');

        for (Integer i = 0; i < healthCheckVModel.healthCheckDefinitionList.size(); i++){
            System.assertEquals('Test ' + i, healthCheckVModel.healthCheckDefinitionList[i].name, 'View model name should be \'Test ' + i + '\'.');
        }
    }

}
public with sharing class HierarchySettingsChangesController {
    /**********************************************************************************
     * @description Update the HierarchySettingsChangesVModel with specified changes.
     * @return True if update was successful, false otherwise.
     **********************************************************************************/
    @AuraEnabled
    public static Boolean updateHierarchySettings(HierarchySettingsChangesVModel hierarchySettingsChangesVModel) {
        return HierarchySettingsChangesController.locateHierarchySettingsUpdaterService()
            .updateHierarchySettings(hierarchySettingsChangesVModel);
    }

    /************************************************************************************
     * @description Retrieve an instance of the HierarchySettingsService class.
     * @return An instance of the HierarchySettingsService class.
     ************************************************************************************/
    @TestVisible
    private static HierarchySettingsService locateHierarchySettingsUpdaterService() {
        return HierarchySettingsService.getInstance();
    }
}
@isTest
public with sharing class HierarchySettingsChangesController_TEST {
    /**************************************************************************************************************************
    * @description Test method to verify that the locateHierarchySettingsUpdaterService method returns an instance of the
    * HierarchySettingsService class.
    ***************************************************************************************************************************/
    @isTest 
    private static void locateHierarchySettingsUpdaterServiceValid() {
        Test.startTest();
        HierarchySettingsService hierarchySettingsServiceInstance = 
            HierarchySettingsChangesController.locateHierarchySettingsUpdaterService();
        Test.stopTest();

        System.assertEquals(
            HierarchySettingsService.instance, 
            hierarchySettingsServiceInstance,
            'Should return instance of HierarchySettingsService class.');
    }

    /**************************************************************************************************************************
    * @description Test method to verify that the updateHierarchySettings method returns true when an update to Hierarchy
    * Settings is successfully processed.
    ***************************************************************************************************************************/
    @isTest 
    private static void updateHierarchySettingsValid() {
        HierarchySettingsService.instance = new STUB_HierarchySettingsService();

        Map<String, String> settingsSingleValueBySettingsName = new Map<String, String> {
            'Value1' => 'Changed Value 1'
        };

        Map<String, List<String>> settingsListSettingsName = new Map<String, List<String>> {
            'CollectionValue1' => new List<String>{'Change1', 'Change2', 'Change3'}
        };

        HierarchySettingsChangesVModel hierarchySettingsChangesVModel = 
            new HierarchySettingsChangesVModel(settingsSingleValueBySettingsName, settingsListSettingsName);

        Test.startTest();
        Boolean updateHierarchySettingsResult = 
            HierarchySettingsChangesController.updateHierarchySettings(hierarchySettingsChangesVModel);
        Test.stopTest();

        System.assertEquals(
            true, 
            updateHierarchySettingsResult,
            'Should return true indicating a successful update.'
        );
    }

    /**************************************************************************************************************************
    * @description Test method to verify that the updateHierarchySettings method returns false when an update to Hierarchy
    * Settings is fails due to a DML exception.
    ***************************************************************************************************************************/
    @isTest 
    private static void updateHierarchySettingsInValid() {
        HierarchySettingsService.instance = new STUB_HierarchySettingsServiceDMLFailure();

        Map<String, String> settingsSingleValueBySettingsName = new Map<String, String> {
            'Value1' => 'Changed Value 1'
        };

        Map<String, List<String>> settingsListSettingsName = new Map<String, List<String>> {
            'CollectionValue1' => new List<String>{'Change1', 'Change2', 'Change3'}
        };

        HierarchySettingsChangesVModel hierarchySettingsChangesVModel = 
            new HierarchySettingsChangesVModel(settingsSingleValueBySettingsName, settingsListSettingsName);

        Test.startTest();
        Boolean updateHierarchySettingsResult = 
            HierarchySettingsChangesController.updateHierarchySettings(hierarchySettingsChangesVModel);
        Test.stopTest();

        System.assertEquals(
            false, 
            updateHierarchySettingsResult,
            'Should return true indicating a failure due to a DML Exception.'
        );
    }

    /**************************************************************************************************************************
    * @description Test method to verify that the updateHierarchySettings method throws an exception when the update fails due
    * to inadequate permissions or casting errors.
    ***************************************************************************************************************************/
    @isTest 
    private static void updateHierarchySettingsException() {
        HierarchySettingsService.instance = new STUB_HierarchySettingsExceptionResponse();

        Map<String, String> settingsSingleValueBySettingsName = new Map<String, String> {
            UTIL_Namespace.StrTokenNSPrefix('Value1') => 'Changed Value 1'
        };

        Map<String, List<String>> settingsListSettingsName = new Map<String, List<String>> {
            UTIL_Namespace.StrTokenNSPrefix('CollectionValue1') => new List<String>{'Change1', 'Change2', 'Change3'}
        };

        HierarchySettingsChangesVModel hierarchySettingsChangesVModel = 
            new HierarchySettingsChangesVModel(settingsSingleValueBySettingsName, settingsListSettingsName);

        try {
            Test.startTest();
            Boolean updateHierarchySettingsResult = 
                HierarchySettingsChangesController.updateHierarchySettings(hierarchySettingsChangesVModel);
            Test.stopTest();
        } catch (TestException e) {
            System.assertEquals(
                'Test Exception Encountered', 
                e.getMessage(),
                'Should throw a TestException.'
            );
        }        
    }
    /**************************************************************************************************************************
    ****************************************************** STUBS **************************************************************
    **************************************************************************************************************************/
    
    /**************************************************************************************************************************************
    * @description Stub class to simulate the response from HierarchySettingsService to indicate a successful update
    **************************************************************************************************************************************/ 
    private class STUB_HierarchySettingsService extends HierarchySettingsService {
        public override Boolean updateHierarchySettings(HierarchySettingsChangesVModel hierarchySettingsChangesVModel) {
            return true;
        }
    }
    
    /**************************************************************************************************************************************
    * @description Stub class to simulate the response from HierarchySettingsService to indicate a failure due to a DML exception.
    **************************************************************************************************************************************/ 
    private class STUB_HierarchySettingsServiceDMLFailure extends HierarchySettingsService {
        public override Boolean updateHierarchySettings(HierarchySettingsChangesVModel hierarchySettingsChangesVModel) {
            return false;
        }
    }

    /**************************************************************************************************************************************
    * @description Stub class to simulate the response from HierarchySettingsService to indicate a failure due to a DML exception.
    **************************************************************************************************************************************/ 
    private class STUB_HierarchySettingsExceptionResponse extends HierarchySettingsService {
        public override Boolean updateHierarchySettings(HierarchySettingsChangesVModel hierarchySettingsChangesVModel) {
            throw new TestException('Test Exception Encountered');
        }
    }

    /********************************************************************************************************
    * @description A custom exception class to for testing.
    ********************************************************************************************************/
    public class TestException extends Exception {}
}
public with sharing class HierarchySettingsChangesVModel {
    @AuraEnabled public Map<String, String> settingsSingleValueBySettingsName { get; set; }
    @AuraEnabled public Map<String, List<String>> settingsListSettingsName { get; set; }

    /**********************************************************************************************************************
    * @description No argument constructor
    * @return A HierarchySettingsChangesVModel with empty maps
    **********************************************************************************************************************/
    public HierarchySettingsChangesVModel() {
        this.settingsSingleValueBySettingsName = new Map<String, String>();
        this.settingsListSettingsName = new Map<String, List<String>>();
    }

    /**********************************************************************************************************************
    * @description Two parameter constructor
    * @param  settingsSingleValueBySettingsName A map of changed hierarchy settings with single values mapped by name 
    * @param  settingsListSettingsName A map of changed hierarchy settings with collections mapped by name 
    * @return A HierarchySettingsChangesVModel with all properties populated
    **********************************************************************************************************************/ 
    public HierarchySettingsChangesVModel(
        Map<String, String> settingsSingleValueBySettingsName, 
        Map<String, List<String>> settingsListSettingsName
    ) {
        this.settingsSingleValueBySettingsName = settingsSingleValueBySettingsName;
        this.settingsListSettingsName = settingsListSettingsName;
    }
}
@isTest 
public with sharing class HierarchySettingsChangesVModel_TEST {
    /******************************************************************************
    * @description Test method to verify the no argument constructor returns a
    * HierarchySettingsChangesVModel with empty properties initialized.
    ******************************************************************************/
    @isTest 
    private static void noParameterConstructor() {
        Test.startTest();
        HierarchySettingsChangesVModel hierarchySettingsChangesVModel = new HierarchySettingsChangesVModel();
        Test.stopTest();

        System.assertEquals(
            true, 
            hierarchySettingsChangesVModel.settingsSingleValueBySettingsName.isEmpty(), 
            'settingsSingleValueBySettingsName should be an empty map.'
        );

        System.assertEquals(
            true, 
            hierarchySettingsChangesVModel.settingsListSettingsName.isEmpty(), 
            'settingsListSettingsName should be an empty map.'
        );
    }

    /******************************************************************************
    * @description Test method to verify two argument constructor returns a
    * HierarchySettingsChangesVModel with all properties populated.
    ******************************************************************************/
    @isTest 
    private static void twoParameterConstructor() {
        Map<String, String> settingsSingleValueBySettingsName = new Map<String, String> {
            'Value1' => 'Changed Value 1'
        };

        Map<String, List<String>> settingsListSettingsName = new Map<String, List<String>> {
            'CollectionValue1' => new List<String>{'Change1', 'Change2', 'Change3'}
        };

        Test.startTest();
        HierarchySettingsChangesVModel hierarchySettingsChangesVModel = 
            new HierarchySettingsChangesVModel(settingsSingleValueBySettingsName, settingsListSettingsName);
        Test.stopTest();

        System.assertEquals(
            'Changed Value 1', 
            hierarchySettingsChangesVModel.settingsSingleValueBySettingsName.get('Value1'), 
            'Mapped value should match parameter value.'
        );

        System.assertEquals(
            3, 
            hierarchySettingsChangesVModel.settingsListSettingsName.get('CollectionValue1').size(), 
            'Mapped value should be list of 3 elements.'
        );

        System.assertEquals(
            true, 
            hierarchySettingsChangesVModel.settingsListSettingsName.get('CollectionValue1').contains('Change1'),
            'List of changes to setting should include \'Change1\''
        );

        System.assertEquals(
            true, 
            hierarchySettingsChangesVModel.settingsListSettingsName.get('CollectionValue1').contains('Change2'),
            'List of changes to setting should include \'Change2\''
        );

        System.assertEquals(
            true, 
            hierarchySettingsChangesVModel.settingsListSettingsName.get('CollectionValue1').contains('Change3'),
            'List of changes to setting should include \'Change3\''
        );
    }
}
public virtual with sharing class HierarchySettingsMapper {
    /**********************************************************************************
     * @description Instance for Singleton Pattern
     **********************************************************************************/
    @TestVisible
    private static HierarchySettingsMapper instance;

    /**********************************************************************************
     * @description Empty constructor is not public for Singleton Pattern
     **********************************************************************************/
    protected HierarchySettingsMapper() {
    }

    /**********************************************************************************
     * @description Static method to get the current instance for Singleton pattern
     * @return The instance of HierarchySettingsMapper.
     **********************************************************************************/
    public static HierarchySettingsMapper getInstance() {
        if (instance == null) {
            instance = new HierarchySettingsMapper();
        }

        return instance;
    }

    /**********************************************************************************
     * @description Retrieve a model representing the values set in Hierarchy Settings.
     * @return A HierarchySettingsModel.
     **********************************************************************************/
    public HierarchySettingsModel getHierarchySettings() {
        Hierarchy_Settings__c hierarchySettings = UTIL_CustomSettingsFacade.getSettings();
        return new HierarchySettingsModel(hierarchySettings);
    }

    /**********************************************************************************
     * @description Retrieve the describe result for a specified Hierarchy Settings field.
     * @return A Schema.DescribeFieldResult for the specified Hierarchy Settings field.
     **********************************************************************************/
    public Schema.DescribeFieldResult getHierarchySettingsField(String apiName) {
        return UTIL_Describe.getFieldDescribe(UTIL_Namespace.StrTokenNSPrefix('Hierarchy_Settings__c'), apiName);
    }

    /****************************************************************************************************
     * @description Update a HierarchySettingsModel to reflect changes made to setting values.
     * @param hierarchySettingsModel A HierarchySettingsModel with changes to updated Hierarchy Settings fields set.
     * @return A true if the update to Hierarchy Settings is successful, false otherwise.
     ****************************************************************************************************/
    public virtual boolean updateHierarchySettings(HierarchySettingsModel hierarchySettingsModel) {
        try {
            /* sfca-disable-next-line ApexFlsViolationRule */
            update hierarchySettingsModel.hierarchySettings;
        } catch (System.DmlException e) {
            return false;
        }

        return true;
    }
}
@isTest
public inherited sharing class HierarchySettingsMapper_TEST {
    /**************************************************************************************************************************
     * @description Test method to verify that the getInstance method returns a new instance of the
     * HierarchySettingsMapper class when one does not already exist.
     ***************************************************************************************************************************/
    @isTest
    private static void getInstanceNew() {
        Test.startTest();
        HierarchySettingsMapper hierarchySettingsMapperInstance = HierarchySettingsMapper.getInstance();
        Test.stopTest();

        System.assertEquals(
            HierarchySettingsMapper.instance,
            hierarchySettingsMapperInstance,
            'Instance of mapper class returned should match static instance variable.'
        );

        System.assertEquals(
            true,
            hierarchySettingsMapperInstance != null,
            'Instance of mapper class should not be null.'
        );
    }

    /**************************************************************************************************************************
     * @description Test method to verify that the getInstance method returns the existing instance of the
     * HierarchySettingsMapper class when one already exists.
     ***************************************************************************************************************************/
    @isTest
    private static void getInstanceExisting() {
        Test.startTest();
        HierarchySettingsMapper hierarchySettingsMapperInstance1 = HierarchySettingsMapper.getInstance();
        HierarchySettingsMapper hierarchySettingsMapperInstance2 = HierarchySettingsMapper.getInstance();
        Test.stopTest();

        System.assertEquals(
            HierarchySettingsMapper.instance,
            hierarchySettingsMapperInstance1,
            'Instance of mapper class returned should match static instance variable.'
        );

        System.assertEquals(
            hierarchySettingsMapperInstance1,
            hierarchySettingsMapperInstance2,
            'Subsequent retrievals of mapper class instance should return existing instance.'
        );

        System.assertEquals(
            true,
            hierarchySettingsMapperInstance1 != null,
            'Instance of mapper class should not be null.'
        );
    }

    /**************************************************************************************************************************
     * @description Test method to verify that the getHierarchySettings method returns the values specified in Hierarchy Settings.
     ***************************************************************************************************************************/
    @isTest
    private static void getHierarchySettingsValid() {
        Hierarchy_Settings__c hierarchySettings = UTIL_CustomSettings_API.getSettingsForTests(
            new Hierarchy_Settings__c(Account_Processor__c = 'Test Account')
        );

        HierarchySettingsMapper hierarchySettingsMapperInstance = HierarchySettingsMapper.getInstance();

        Test.startTest();
        HierarchySettingsModel hierarchySettingsModel = hierarchySettingsMapperInstance.getHierarchySettings();
        Test.stopTest();

        System.assertEquals(
            'Test Account',
            hierarchySettingsModel.hierarchySettings.Account_Processor__c,
            'Account_Processor__c hierarchy setting should match specified value.'
        );
    }

    /**************************************************************************************************************************
     * @description Test method to verify that the getHierarchySettingsField method returns the DescribeFieldResult for a
     * specified Hierarchy Settings field.
     ***************************************************************************************************************************/
    @isTest
    private static void getHierarchySettingsFieldValid() {
        HierarchySettingsMapper hierarchySettingsMapperInstance = HierarchySettingsMapper.getInstance();

        Test.startTest();
        Schema.DescribeFieldResult describeFieldResult = hierarchySettingsMapperInstance.getHierarchySettingsField(
            UTIL_Namespace.StrTokenNSPrefix('Account_Processor__c')
        );
        Test.stopTest();

        System.assertEquals(
            'Account Processor',
            describeFieldResult.getLabel(),
            'Should match field label value specified for Account Processor.'
        );
        System.assertEquals(
            UTIL_Namespace.StrTokenNSPrefix('Account_Processor__c'),
            describeFieldResult.getName(),
            'Should match api name value specified for Account Processor.'
        );
    }

    /**************************************************************************************************************************
     * @description Test method to verify that the getHierarchySettingsField method throws an exception for a field
     * that is not specified in Hierarchy Settings.
     ***************************************************************************************************************************/
    @isTest
    private static void getHierarchySettingsFieldInValid() {
        HierarchySettingsMapper hierarchySettingsMapperInstance = HierarchySettingsMapper.getInstance();

        try {
            Test.startTest();
            Schema.DescribeFieldResult describeFieldResult = hierarchySettingsMapperInstance.getHierarchySettingsField(
                UTIL_Namespace.StrTokenNSPrefix('Invalid_Field_Name__c')
            );
            Test.stopTest();
        } catch (UTIL_Describe.SchemaDescribeException e) {
            System.assertEquals(
                'Invalid field name \'' +
                UTIL_Namespace.StrTokenNSPrefix('Invalid_Field_Name__c') +
                '\'',
                e.getMessage(),
                'Invalid field name should cause exception'
            );
        }
    }

    /**************************************************************************************************************************
     * @description Test method to verify that the updateHierarchySettings method updates Hierarchy Setting values of both
     * primitive and collection data types.
     ***************************************************************************************************************************/
    @isTest
    private static void updateHierarchySettingsValid() {
        Hierarchy_Settings__c hierarchySettings = UTIL_CustomSettings_API.getSettingsForTests(
            new Hierarchy_Settings__c(
                Account_Processor__c = 'Original Account',
                Accounts_to_Delete__c = 'Original Value1;Original Value2'
            )
        );
        insert hierarchySettings;

        Hierarchy_Settings__c updatedHierarchySettings = UTIL_CustomSettings_API.getSettingsForTests(
            new Hierarchy_Settings__c(
                Account_Processor__c = 'Updated Account',
                Accounts_to_Delete__c = 'Updated Value 1;Updated Value 2'
            )
        );

        HierarchySettingsModel hierarchySettingsModel = new HierarchySettingsModel(updatedHierarchySettings);
        HierarchySettingsMapper hierarchySettingsMapperInstance = HierarchySettingsMapper.getInstance();

        Test.startTest();
        Boolean updateResult = hierarchySettingsMapperInstance.updateHierarchySettings(hierarchySettingsModel);
        Test.stopTest();

        System.assertEquals(true, updateResult, 'Update should complete successfully.');

        Hierarchy_Settings__c updatedHierarchySettingsResult = UTIL_CustomSettings_API.getSettings();

        System.assertEquals(
            'Updated Account',
            updatedHierarchySettingsResult.Account_Processor__c,
            'Account_Processor__c value should be updated.'
        );

        System.assertEquals(
            'Updated Value 1;Updated Value 2',
            updatedHierarchySettings.Accounts_to_Delete__c,
            'Accounts_to_Delete__c value should be updated.'
        );
    }
}
public with sharing class HierarchySettingsModel {
    public Hierarchy_Settings__c hierarchySettings { get; private set; }
    
    /**************************************************************************
    * @description Single parameter constructor 
    * @param  hierarchySettings A Hierarchy_Settings__c object
    * @return A HierarchySettingsModel with all parameters populated.
    **************************************************************************/
    public HierarchySettingsModel(Hierarchy_Settings__c hierarchySettings) {
        this.hierarchySettings = hierarchySettings;
    }

    /****************************************************************************
    * @description Helper method to set the value for a Hierarchy Settings field
    * with a valud of type String.
    * @param  fieldName A Hierarchy Settings field name
    * @param  fieldValue A String value for the specified Hierarchy Settings field
    ****************************************************************************/
    public void setSettingsField(String fieldName, String fieldValue) {
        this.hierarchySettings.put(fieldName, fieldValue);
    }

    /****************************************************************************
    * @description Helper method to set the value for a Hierarchy Settings field
    * with a valud of type Boolean.
    * @param  fieldName A Hierarchy Settings field name
    * @param  fieldValue A Boolean value for the specified Hierarchy Settings field
    ****************************************************************************/
    public void setSettingsField(String fieldName, Boolean fieldValue) {
        this.hierarchySettings.put(fieldName, fieldValue);
    }

    /****************************************************************************
    * @description Helper method to set the value for a Hierarchy Settings field
    * with a valud of type DateTime.
    * @param  fieldName A Hierarchy Settings field name
    * @param  fieldValue A DateTime value for the specified Hierarchy Settings field
    ****************************************************************************/
    public void setSettingsField(String fieldName, Datetime fieldValue) {
        this.hierarchySettings.put(fieldName, fieldValue);
    }
}
@isTest
public with sharing class HierarchySettingsModel_TEST {
    /******************************************************************************
    * @description Test method to verify single parameter constructor returns a
    * HierarchySettingsChangesVModel with all parameters populated.
    ******************************************************************************/
    @isTest 
    private static void singleParameterConstructor() {
        Hierarchy_Settings__c hierarchySettings = UTIL_CustomSettings_API.getSettingsForTests(
            new Hierarchy_Settings__c(
                Account_Processor__c = 'Test Account',
                Household_Addresses_RecType__c = 'Test HH Account',
                Administrative_Account_Record_Type__c = 'Test Admin Account'
            )
        );

        Test.startTest();
        HierarchySettingsModel hierarchySettingsModel = new HierarchySettingsModel(hierarchySettings);
        Test.stopTest();

        System.assertEquals(
            'Test Account', 
            hierarchySettingsModel.hierarchySettings.Account_Processor__c,
            'Account_Processor__c hierarchy setting should match specified value.'    
        );
        System.assertEquals(
            'Test HH Account', 
            hierarchySettingsModel.hierarchySettings.Household_Addresses_RecType__c,
            'Household_Addresses_RecType__c hierarchy setting should match specified value.'
        );
        System.assertEquals(
            'Test Admin Account', 
            hierarchySettingsModel.hierarchySettings.Administrative_Account_Record_Type__c,
            'Administrative_Account_Record_Type__c hierarchy setting should match specified value.'
        );
    }
}
public virtual with sharing class HierarchySettingsService {
    /**********************************************************************************
     * @description Instance for Singleton Pattern
     **********************************************************************************/
    @TestVisible
    private static HierarchySettingsService instance;

    /**********************************************************************************
     * @description Empty constructor is not public for Singleton Pattern
     **********************************************************************************/
    protected HierarchySettingsService() {
    }

    /**********************************************************************************
     * @description Static method to get the current instance for Singleton pattern
     * @return The instance of HierarchySettingsService.
     **********************************************************************************/
    public static HierarchySettingsService getInstance() {
        if (instance == null) {
            instance = new HierarchySettingsService();
        }

        return instance;
    }

    /************************************************************************************************************
     * @description Update Hierarchy Settings fields with specified changes.
     * @param  hierarchySettingsChangesVModel A HierarchySettingsChangesVModel representing updates to Hierarchy Settings.
     * @return True if the updates were completed successfully, false otherwise.
     ************************************************************************************************************/
    public virtual Boolean updateHierarchySettings(HierarchySettingsChangesVModel hierarchySettingsChangesVModel) {
        if (this.locateUserPermissionService().checkCustomizeApplicationForCurrentUser() == false) {
            return false;
        }

        HierarchySettingsModel hierarchySettingsModelToUpdate = this.locateHierarchySettingsMapper()
            .getHierarchySettings();

        try {
            // Update Hierarchy Settings fields with single values
            for (
                String changedSettingName : hierarchySettingsChangesVModel.settingsSingleValueBySettingsName.keySet()
            ) {
                String settingsField = UTIL_Namespace.StrTokenNSPrefix(changedSettingName);

                Schema.DescribeFieldResult fieldDescribeResult = this.locateHierarchySettingsMapper()
                    .getHierarchySettingsField(settingsField);
                Schema.DisplayType displayType = fieldDescribeResult.getType();

                if (displayType == Schema.DisplayType.TEXTAREA || displayType == Schema.DisplayType.STRING) {
                    String hierarchySettingValue = (String) hierarchySettingsChangesVModel.settingsSingleValueBySettingsName.get(
                        changedSettingName
                    );
                    hierarchySettingsModelToUpdate.setSettingsField(changedSettingName, hierarchySettingValue);
                }

                if (displayType == Schema.DisplayType.BOOLEAN) {
                    Boolean hierarchySettingValue = Boolean.valueOf(
                        hierarchySettingsChangesVModel.settingsSingleValueBySettingsName.get(changedSettingName)
                    );
                    hierarchySettingsModelToUpdate.setSettingsField(changedSettingName, hierarchySettingValue);
                }

                if (displayType == Schema.DisplayType.DATETIME) {
                    Datetime hierarchySettingValue = Datetime.valueOf(
                        hierarchySettingsChangesVModel.settingsSingleValueBySettingsName.get(changedSettingName)
                    );
                    hierarchySettingsModelToUpdate.setSettingsField(changedSettingName, hierarchySettingValue);
                }
            }

            // Update Hierarchy Settings fields with collections as values
            for (String changedSettingName : hierarchySettingsChangesVModel.settingsListSettingsName.keySet()) {
                String settingsField = UTIL_Namespace.StrTokenNSPrefix(changedSettingName);

                Schema.DescribeFieldResult fieldDescribeResult = this.locateHierarchySettingsMapper()
                    .getHierarchySettingsField(settingsField);

                String hierarchySettingValue = this.denormalizeListSettingChange(
                    hierarchySettingsChangesVModel.settingsListSettingsName.get(changedSettingName)
                );

                hierarchySettingsModelToUpdate.hierarchySettings.put(changedSettingName, hierarchySettingValue);
            }
        } catch (UTIL_Describe.SchemaDescribeException e) {
            UTIL_Debug.debug('****SchemaDescribeException encountered: ' + e.getMessage());
            throw new InvalidSettingsException(Label.stgErrorInvalidSettings);
        } catch (System.TypeException e) {
            UTIL_Debug.debug('****TypeException encountered: ' + e.getMessage());
            throw new InvalidSettingsException(Label.stgErrorInvalidSettings);
        } catch (Exception e) {
            UTIL_Debug.debug('****Unexpected Exception encountered: ' + e.getMessage());
            throw new InvalidSettingsException(Label.stgErrorInvalidSettings);
        }

        return this.locateHierarchySettingsMapper().updateHierarchySettings(hierarchySettingsModelToUpdate);
    }

    /******************************************************************************************************
     * @description Converts a List of Strings to a semicolon-delimited string.
     * @param  collectionTypeHierarchySettingsUpdateList List<String> to convert
     * @return A semicolon-delimited String representing each String in the specified list.
     ******************************************************************************************************/
    @TestVisible
    private String denormalizeListSettingChange(List<String> collectionTypeHierarchySettingsUpdateList) {
        return String.join(collectionTypeHierarchySettingsUpdateList, ';');
    }

    /************************************************************************************************************
     * @description Retrieve an instance of HierarchySettingsMapper
     * @return An instance of the HierarchySettingsMapper class
     ************************************************************************************************************/
    @TestVisible
    private HierarchySettingsMapper locateHierarchySettingsMapper() {
        return HierarchySettingsMapper.getInstance();
    }

    /************************************************************************************************************
     * @description Retrieve an instance of UserPermissionService
     * @return An instance of the UserPermissionService class
     ************************************************************************************************************/
    @TestVisible
    private UserPermissionService locateUserPermissionService() {
        return UserPermissionService.getInstance();
    }

    /********************************************************************************************************
     * @description A custom exception class to represent errors associated with updates to Hierarchy Settings.
     ********************************************************************************************************/
    public class InvalidSettingsException extends Exception {
    }
}
@isTest
public with sharing class HierarchySettingsService_TEST {
    /**************************************************************************************************************************
     * @description Test method to verify that the getInstance method returns a new instance of the
     * HierarchySettingsService class when one does not already exist.
     ***************************************************************************************************************************/
    @isTest
    private static void getInstanceNew() {
        Test.startTest();
        HierarchySettingsService hierarchySettingsServiceInstance = HierarchySettingsService.getInstance();
        Test.stopTest();

        System.assertEquals(
            HierarchySettingsService.instance,
            hierarchySettingsServiceInstance,
            'Instance of mapper class returned should match static instance variable.'
        );

        System.assertEquals(
            true,
            hierarchySettingsServiceInstance != null,
            'Instance of mapper class should not be null.'
        );
    }

    /**************************************************************************************************************************
     * @description Test method to verify that the getInstance method returns the existing instance of the
     * HierarchySettingsService class when one already exists.
     ***************************************************************************************************************************/
    @isTest
    private static void getInstanceExisting() {
        Test.startTest();
        HierarchySettingsService hierarchySettingsServiceInstance1 = HierarchySettingsService.getInstance();
        HierarchySettingsService hierarchySettingsServiceInstance2 = HierarchySettingsService.getInstance();
        Test.stopTest();

        System.assertEquals(
            HierarchySettingsService.instance,
            hierarchySettingsServiceInstance1,
            'Instance of mapper class returned should match static instance variable.'
        );

        System.assertEquals(
            hierarchySettingsServiceInstance1,
            hierarchySettingsServiceInstance2,
            'Subsequent retrievals of mapper class instance should return existing instance.'
        );

        System.assertEquals(
            true,
            hierarchySettingsServiceInstance1 != null,
            'Instance of mapper class should not be null.'
        );
    }

    /**************************************************************************************************************************
     * @description Test method to verify that the locateHierarchySettingsMapper method returns a valid instance of
     * HierarchySettingsMapper.
     ***************************************************************************************************************************/
    @isTest
    private static void locateHierarchySettingsMapperValid() {
        HierarchySettingsService hierarchySettingsServiceInstance = HierarchySettingsService.getInstance();

        Test.startTest();
        HierarchySettingsMapper hierarchySettingsMapperInstance = hierarchySettingsServiceInstance.locateHierarchySettingsMapper();
        Test.stopTest();

        System.assertEquals(
            HierarchySettingsMapper.getInstance(),
            hierarchySettingsMapperInstance,
            'Should return instance of HierarchySettingsMapper.'
        );
    }

    /**************************************************************************************************************************
     * @description Test method to verify that the locateUserPermissionService method returns a valid instance of
     * UserPermissionService.
     ***************************************************************************************************************************/
    @isTest
    private static void locateUserPermissionServiceValid() {
        HierarchySettingsService hierarchySettingsServiceInstance = HierarchySettingsService.getInstance();

        Test.startTest();
        UserPermissionService userPermissionServiceInstance = hierarchySettingsServiceInstance.locateUserPermissionService();
        Test.stopTest();

        System.assertEquals(
            UserPermissionService.getInstance(),
            userPermissionServiceInstance,
            'Should return instance of UserPermissionService.'
        );
    }

    /**************************************************************************************************************************
     * @description Test method to verify that the updateHierarchySettings method returns true when an update to Hierarchy
     * Settings is successfully processed.
     ***************************************************************************************************************************/
    @isTest
    private static void updateHierarchySettingsValid() {
        PermissionSetMapper.instance = new STUB_PermissionSetMapperHasAccess();
        HierarchySettingsMapper.instance = new STUB_HierarchySettingsMapper();

        HierarchySettingsChangesVModel hierarchySettingsChangesVModel = new HierarchySettingsChangesVModel();
        HierarchySettingsService hierarchySettingsServiceInstance = HierarchySettingsService.getInstance();

        Test.startTest();
        Boolean updateHierarchySettingsResult = hierarchySettingsServiceInstance.updateHierarchySettings(
            hierarchySettingsChangesVModel
        );
        Test.stopTest();

        System.assertEquals(true, updateHierarchySettingsResult, 'Should return true indicating a successful update.');
    }

    /**************************************************************************************************************************
     * @description Test method to verify that the updateHierarchySettings method throws an exception when an exception is
     * encountered from the UserPermissionService class
     ***************************************************************************************************************************/
    @isTest
    private static void updateHierarchySettingsPermissionException() {
        PermissionSetMapper.instance = new STUB_PermissionSetMapperNoAccess();

        HierarchySettingsChangesVModel hierarchySettingsChangesVModel = new HierarchySettingsChangesVModel();
        HierarchySettingsService hierarchySettingsServiceInstance = HierarchySettingsService.getInstance();

        try {
            Test.startTest();
            Boolean updateHierarchySettingsResult = hierarchySettingsServiceInstance.updateHierarchySettings(
                hierarchySettingsChangesVModel
            );
            Test.stopTest();
        } catch (System.NoAccessException e) {
            System.assertEquals(
                'Script-thrown exception',
                e.getMessage(),
                'Should throw an error when permissions are missing.'
            );
        }
    }

    /**************************************************************************************************************************
     * @description Test method to verify that the updateHierarchySettings method throws an error and does not update any
     * Hierarchy Settings fields when an error is encountered.
     ***************************************************************************************************************************/
    @isTest
    private static void updateHierarchySettingsSchemaDescribeException() {
        PermissionSetMapper.instance = new STUB_PermissionSetMapperHasAccess();

        Hierarchy_Settings__c hierarchySettings = UTIL_CustomSettings_API.getSettingsForTests(
            new Hierarchy_Settings__c(
                Account_Processor__c = 'Original Account',
                Accounts_to_Delete__c = 'Original Value1;Original Value2'
            )
        );

        Map<String, String> singleValueSettingUpdatesByNameInvalid = new Map<String, String>{
            'Account_Processor_Invalid__c' => 'Updated Value'
        };

        Map<String, List<String>> listValueSettingUpdatesByName = new Map<String, List<String>>{
            'Accounts_to_Delete__c' => new List<String>{ 'Updated Value 1', 'Updated Value 2' }
        };

        HierarchySettingsChangesVModel hierarchySettingsChangesVModel = new HierarchySettingsChangesVModel(
            singleValueSettingUpdatesByNameInvalid,
            listValueSettingUpdatesByName
        );

        HierarchySettingsService hierarchySettingsServiceInstance = HierarchySettingsService.getInstance();

        try {
            Test.startTest();
            Boolean updateResult = hierarchySettingsServiceInstance.updateHierarchySettings(
                hierarchySettingsChangesVModel
            );
            Test.stopTest();
        } catch (UTIL_Describe.SchemaDescribeException e) {
            System.assertEquals(
                'Invalid field name \'' +
                'Account_Processor_Invalid__c' +
                '\'',
                e.getMessage(),
                'Invalid field name should cause exception'
            );
        } catch (HierarchySettingsService.InvalidSettingsException e) {
            System.assertEquals(
                Label.stgErrorInvalidSettings,
                e.getMessage(),
                'Invalid mapping should throw exception.'
            );
        }

        Hierarchy_Settings__c updatedHierarchySettings = UTIL_CustomSettings_API.getSettings();

        System.assertEquals(
            'Original Account',
            updatedHierarchySettings.Account_Processor__c,
            'Account_Processor__c value should remain unchanged.'
        );

        System.assertEquals(
            'Original Value1;Original Value2',
            updatedHierarchySettings.Accounts_to_Delete__c,
            'Accounts_to_Delete__c value should remain unchanged.'
        );
    }

    /**************************************************************************************************************************
     * @description Test method to verify that the updateHierarchySettingsWithListValues method throws an error when an invalid
     * Hierarchy Setting field is specified for update.
     ***************************************************************************************************************************/
    @isTest
    private static void updateHierarchySettingsWithListValuesInValidFieldName() {
        PermissionSetMapper.instance = new STUB_PermissionSetMapperHasAccess();

        Hierarchy_Settings__c hierarchySettings = UTIL_CustomSettings_API.getSettingsForTests(
            new Hierarchy_Settings__c(Accounts_to_Delete__c = 'Original Value1;Original Value2')
        );

        Map<String, List<String>> listValueSettingUpdatesByName = new Map<String, List<String>>{
            'Accounts_to_Delete__c' => new List<String>{ 'Updated Value 1', 'Updated Value 2' },
            'Not_A_Valid_Field__c' => new List<String>{ 'Invalid value' }
        };

        HierarchySettingsChangesVModel hierarchySettingsChangesVModelListValuesError = new HierarchySettingsChangesVModel(
            new Map<String, String>(),
            listValueSettingUpdatesByName
        );

        HierarchySettingsService hierarchySettingsServiceInstance = HierarchySettingsService.getInstance();

        try {
            Test.startTest();
            Boolean updateResult = hierarchySettingsServiceInstance.updateHierarchySettings(
                hierarchySettingsChangesVModelListValuesError
            );
            Test.stopTest();
        } catch (UTIL_Describe.SchemaDescribeException e) {
            System.assertEquals(
                'Invalid field name \'' +
                'Not_A_Valid_Field__c' +
                '\'',
                e.getMessage(),
                'Invalid field mapping should throw error.'
            );
        } catch (HierarchySettingsService.InvalidSettingsException e) {
            System.assertEquals(
                Label.stgErrorInvalidSettings,
                e.getMessage(),
                'Invalid mapping should throw exception.'
            );
        }
    }

    /**************************************************************************************************************************
     * @description Test method to verify that the updateHierarchySettings method does not update the specified Hierarchy
     * Settings fields of type collection when no updates are specified.
     ***************************************************************************************************************************/
    @isTest
    private static void updateHierarchySettingsWithListValuesEmpty() {
        PermissionSetMapper.instance = new STUB_PermissionSetMapperHasAccess();
        HierarchySettingsMapper.instance = new STUB_HierarchySettingsMapper();

        Hierarchy_Settings__c hierarchySettings = UTIL_CustomSettings_API.getSettingsForTests(
            new Hierarchy_Settings__c(Accounts_to_Delete__c = 'Original Value1;Original Value2')
        );

        Map<String, List<String>> listValueSettingUpdatesByName = new Map<String, List<String>>();

        HierarchySettingsChangesVModel hierarchySettingsChangesVModelListValuesEmpty = new HierarchySettingsChangesVModel(
            new Map<String, String>(),
            listValueSettingUpdatesByName
        );

        HierarchySettingsService hierarchySettingsServiceInstance = HierarchySettingsService.getInstance();

        Test.startTest();
        Boolean updateResult = hierarchySettingsServiceInstance.updateHierarchySettings(
            hierarchySettingsChangesVModelListValuesEmpty
        );
        Test.stopTest();

        System.assertEquals(true, updateResult, 'Update to string value should complete successfully.');

        Hierarchy_Settings__c updatedHierarchySettings = UTIL_CustomSettings_API.getSettings();

        System.assertEquals(
            'Original Value1;Original Value2',
            updatedHierarchySettings.Accounts_to_Delete__c,
            'Accounts_to_Delete__c value should remain unchanged.'
        );
    }

    /**************************************************************************************************************************
     * @description Test method to verify that the updateHierarchySettings method does not update Hierarchy Settings fields
     * when updates for a primitive data type are not specified.
     ***************************************************************************************************************************/
    @isTest
    private static void updateHierarchySettingsWithSingleValuesEmpty() {
        PermissionSetMapper.instance = new STUB_PermissionSetMapperHasAccess();
        HierarchySettingsMapper.instance = new STUB_HierarchySettingsMapper();

        Hierarchy_Settings__c hierarchySettings = UTIL_CustomSettings_API.getSettingsForTests(
            new Hierarchy_Settings__c(Account_Processor__c = 'Original Value')
        );

        Map<String, String> singleValueSettingUpdatesByName = new Map<String, String>();

        HierarchySettingsChangesVModel hierarchySettingsChangesVModelEmptySingleValues = new HierarchySettingsChangesVModel(
            singleValueSettingUpdatesByName,
            new Map<String, List<String>>()
        );

        HierarchySettingsService hierarchySettingsServiceInstance = HierarchySettingsService.getInstance();

        Test.startTest();
        Boolean updateResult = hierarchySettingsServiceInstance.updateHierarchySettings(
            hierarchySettingsChangesVModelEmptySingleValues
        );
        Test.stopTest();

        System.assertEquals(true, updateResult, 'Update to string value should complete successfully.');

        Hierarchy_Settings__c updatedHierarchySettings = UTIL_CustomSettings_API.getSettings();

        System.assertEquals(
            'Original Value',
            updatedHierarchySettings.Account_Processor__c,
            'Account Processor value should remain unchanged.'
        );
    }

    /**************************************************************************************************************************
     * @description Test method to verify that the updateHierarchySettings method throws an error when a field is mapped to a
     * Hierarchy Settings field with the wrong data type is updated.
     ***************************************************************************************************************************/
    @isTest
    private static void updateHierarchySettingsWithSingleValuesInValidDateTime() {
        PermissionSetMapper.instance = new STUB_PermissionSetMapperHasAccess();

        Hierarchy_Settings__c hierarchySettings = UTIL_CustomSettings_API.getSettingsForTests(
            new Hierarchy_Settings__c(Async_Error_Check_Last_Run__c = Datetime.now().addDays(-1))
        );

        Map<String, String> singleValueSettingUpdatesByName = new Map<String, String>{
            'Async_Error_Check_Last_Run__c' => 'Updated Value'
        };

        HierarchySettingsChangesVModel hierarchySettingsChangesVModelInvalidType = new HierarchySettingsChangesVModel(
            singleValueSettingUpdatesByName,
            new Map<String, List<String>>()
        );

        HierarchySettingsService hierarchySettingsServiceInstance = HierarchySettingsService.getInstance();

        try {
            Test.startTest();
            Boolean updateResult = hierarchySettingsServiceInstance.updateHierarchySettings(
                hierarchySettingsChangesVModelInvalidType
            );
            Test.stopTest();
        } catch (System.TypeException e) {
            System.assertEquals(
                'Invalid date/time: Updated Value',
                e.getMessage(),
                'Invalid mapping should throw exception.'
            );
        } catch (HierarchySettingsService.InvalidSettingsException e) {
            System.assertEquals(
                Label.stgErrorInvalidSettings,
                e.getMessage(),
                'Invalid mapping should throw exception.'
            );
        }
    }

    /**************************************************************************************************************************
     * @description Test method to verify that the updateHierarchySettings method updates the specified Hierarchy Settings fields
     * of a collection type.
     ***************************************************************************************************************************/
    @isTest
    private static void updateHierarchySettingsWithListValuesValid() {
        PermissionSetMapper.instance = new STUB_PermissionSetMapperHasAccess();
        HierarchySettingsMapper.instance = new STUB_HierarchySettingsMapper();

        Hierarchy_Settings__c hierarchySettings = UTIL_CustomSettings_API.getSettingsForTests(
            new Hierarchy_Settings__c(Accounts_to_Delete__c = 'Original Value1;Original Value2')
        );

        Map<String, List<String>> listValueSettingUpdatesByName = new Map<String, List<String>>{
            'Accounts_to_Delete__c' => new List<String>{ 'Updated Value 1', 'Updated Value 2' }
        };

        HierarchySettingsChangesVModel hierarchySettingsChangesVModelListValues = new HierarchySettingsChangesVModel(
            new Map<String, String>(),
            listValueSettingUpdatesByName
        );

        HierarchySettingsService hierarchySettingsServiceInstance = HierarchySettingsService.getInstance();

        Test.startTest();
        Boolean updateResult = hierarchySettingsServiceInstance.updateHierarchySettings(
            hierarchySettingsChangesVModelListValues
        );
        Test.stopTest();

        System.assertEquals(true, updateResult, 'Update to string value should complete successfully.');

        Hierarchy_Settings__c updatedHierarchySettings = UTIL_CustomSettings_API.getSettings();

        System.assertEquals(
            'Updated Value 1;Updated Value 2',
            updatedHierarchySettings.Accounts_to_Delete__c,
            'Accounts_to_Delete__c value should be updated.'
        );
    }

    /**************************************************************************************************************************
     * @description Test method to verify that the updateHierarchySettings method throws an error when an
     * update is made for a field that is not in Hierarchy Settings.
     ***************************************************************************************************************************/
    @isTest
    private static void updateHierarchySettingsWithSingleValuesInValidFieldName() {
        PermissionSetMapper.instance = new STUB_PermissionSetMapperHasAccess();

        Hierarchy_Settings__c hierarchySettings = UTIL_CustomSettings_API.getSettingsForTests(
            new Hierarchy_Settings__c(Account_Processor__c = 'Original Value')
        );

        Map<String, String> singleValueSettingUpdatesByName = new Map<String, String>{
            'Account_Processor__c' => 'Updated Value',
            'Invalid_Field_Name__c' => 'Updated Invalid Value'
        };

        HierarchySettingsChangesVModel hierarchySettingsChangesVModelError = new HierarchySettingsChangesVModel(
            singleValueSettingUpdatesByName,
            new Map<String, List<String>>()
        );

        HierarchySettingsService hierarchySettingsServiceInstance = HierarchySettingsService.getInstance();

        try {
            Test.startTest();
            Boolean updateResult = hierarchySettingsServiceInstance.updateHierarchySettings(
                hierarchySettingsChangesVModelError
            );
            Test.stopTest();
        } catch (UTIL_Describe.SchemaDescribeException e) {
            System.assertEquals(
                'Invalid field name \'' +
                'Invalid_Field_Name__c' +
                '\'',
                e.getMessage(),
                'Invalid mapping should throw exception.'
            );
        } catch (HierarchySettingsService.InvalidSettingsException e) {
            System.assertEquals(
                Label.stgErrorInvalidSettings,
                e.getMessage(),
                'Invalid mapping should throw exception.'
            );
        }
    }

    /**************************************************************************************************************************
     * @description Test method to verify that the updateHierarchySettings method updates the Hierarchy Settings fields
     * for updates to fields with Datetime type.
     ***************************************************************************************************************************/
    @isTest
    private static void updateHierarchySettingsWithSingleValuesValidDateTime() {
        PermissionSetMapper.instance = new STUB_PermissionSetMapperHasAccess();
        HierarchySettingsMapper.instance = new STUB_HierarchySettingsMapper();

        Hierarchy_Settings__c hierarchySettings = UTIL_CustomSettings_API.getSettingsForTests(
            new Hierarchy_Settings__c(Async_Error_Check_Last_Run__c = Datetime.now().addDays(-3))
        );

        Map<String, String> singleValueSettingUpdatesByName = new Map<String, String>{
            'Async_Error_Check_Last_Run__c' => String.valueOf(DateTime.newInstance(2021, 3, 17, 5, 0, 0))
        };

        HierarchySettingsChangesVModel hierarchySettingsChangesVModelDateTimeValues = new HierarchySettingsChangesVModel(
            singleValueSettingUpdatesByName,
            new Map<String, List<String>>()
        );

        HierarchySettingsService hierarchySettingsServiceInstance = HierarchySettingsService.getInstance();

        Test.startTest();
        Boolean updateResult = hierarchySettingsServiceInstance.updateHierarchySettings(
            hierarchySettingsChangesVModelDateTimeValues
        );
        Test.stopTest();

        System.assertEquals(true, updateResult, 'Update to DateTime value should complete successfully.');

        Hierarchy_Settings__c updatedHierarchySettings = UTIL_CustomSettings_API.getSettings();

        System.assertEquals(
            DateTime.newInstance(2021, 3, 17, 5, 0, 0),
            updatedHierarchySettings.Async_Error_Check_Last_Run__c,
            'Async_Error_Check_Last_Run__c value should be updated.'
        );
    }

    /**************************************************************************************************************************
     * @description Test method to verify that the updateHierarchySettings method updates the Hierarchy Settings fields
     * for updates to fields with Boolean type.
     ***************************************************************************************************************************/
    @isTest
    private static void updateHierarchySettingsWithSingleValuesValidBoolean() {
        PermissionSetMapper.instance = new STUB_PermissionSetMapperHasAccess();
        HierarchySettingsMapper.instance = new STUB_HierarchySettingsMapper();

        Hierarchy_Settings__c hierarchySettings = UTIL_CustomSettings_API.getSettingsForTests(
            new Hierarchy_Settings__c(Allow_AutoCreated_Duplicates__c = false)
        );

        Map<String, String> singleValueSettingUpdatesByName = new Map<String, String>{
            'Allow_AutoCreated_Duplicates__c' => 'true'
        };

        HierarchySettingsChangesVModel hierarchySettingsChangesVModelBooleanValues = new HierarchySettingsChangesVModel(
            singleValueSettingUpdatesByName,
            new Map<String, List<String>>()
        );

        HierarchySettingsService hierarchySettingsServiceInstance = HierarchySettingsService.getInstance();

        Test.startTest();
        Boolean updateResult = hierarchySettingsServiceInstance.updateHierarchySettings(
            hierarchySettingsChangesVModelBooleanValues
        );
        Test.stopTest();

        System.assertEquals(true, updateResult, 'Update to Boolean value should complete successfully.');

        Hierarchy_Settings__c updatedHierarchySettings = UTIL_CustomSettings_API.getSettings();

        System.assertEquals(
            true,
            updatedHierarchySettings.Allow_AutoCreated_Duplicates__c,
            'Allow_AutoCreated_Duplicates__c value should be updated.'
        );
    }

    /**************************************************************************************************************************
     * @description Test method to verify that the updateHierarchySetting method updates the Hierarchy Settings fields for
     * updates to fields with String type.
     ***************************************************************************************************************************/
    @isTest
    private static void updateHierarchySettingsWithSingleValuesValidString() {
        PermissionSetMapper.instance = new STUB_PermissionSetMapperHasAccess();
        HierarchySettingsMapper.instance = new STUB_HierarchySettingsMapper();

        Hierarchy_Settings__c hierarchySettings = UTIL_CustomSettings_API.getSettingsForTests(
            new Hierarchy_Settings__c(Account_Processor__c = 'Original Value')
        );

        Map<String, String> singleValueSettingUpdatesByName = new Map<String, String>{
            'Account_Processor__c' => 'Updated Value'
        };

        HierarchySettingsChangesVModel hierarchySettingsChangesVModelStringValues = new HierarchySettingsChangesVModel(
            singleValueSettingUpdatesByName,
            new Map<String, List<String>>()
        );

        HierarchySettingsService hierarchySettingsServiceInstance = HierarchySettingsService.getInstance();

        Boolean updateResult;
        Test.startTest();
        updateResult = hierarchySettingsServiceInstance.updateHierarchySettings(
            hierarchySettingsChangesVModelStringValues
        );
        Test.stopTest();

        System.assertEquals(true, updateResult, 'Update to string value should complete successfully.');

        Hierarchy_Settings__c updatedHierarchySettings = UTIL_CustomSettings_API.getSettings();

        System.assertEquals(
            'Updated Value',
            updatedHierarchySettings.Account_Processor__c,
            'Account Processor value should be updated.'
        );
    }

    /**************************************************************************************************************************
     * @description Test method to verify that the updateHierarchySetting method updates the Hierarchy Settings fields for
     * updates to fields with TextArea type.
     ***************************************************************************************************************************/
    @isTest
    private static void updateHierarchySettingsWithSingleValuesValidTextArea() {
        PermissionSetMapper.instance = new STUB_PermissionSetMapperHasAccess();
        HierarchySettingsMapper.instance = new STUB_HierarchySettingsMapper();

        Hierarchy_Settings__c hierarchySettings = UTIL_CustomSettings_API.getSettingsForTests(
            new Hierarchy_Settings__c(Error_Notifications_To__c = 'Original Value')
        );

        Map<String, String> singleValueSettingUpdatesByName = new Map<String, String>{
            'Error_Notifications_To__c' => 'Updated Value'
        };

        HierarchySettingsChangesVModel hierarchySettingsChangesVModelStringValues = new HierarchySettingsChangesVModel(
            singleValueSettingUpdatesByName,
            new Map<String, List<String>>()
        );

        HierarchySettingsService hierarchySettingsServiceInstance = HierarchySettingsService.getInstance();

        Boolean updateResult;
        Test.startTest();
        updateResult = hierarchySettingsServiceInstance.updateHierarchySettings(
            hierarchySettingsChangesVModelStringValues
        );
        Test.stopTest();

        System.assertEquals(true, updateResult, 'Update to text area value should complete successfully.');

        Hierarchy_Settings__c updatedHierarchySettings = UTIL_CustomSettings_API.getSettings();

        System.assertEquals(
            'Updated Value',
            updatedHierarchySettings.Error_Notifications_To__c,
            'Error Notifications To value should be updated.'
        );
    }

    /**************************************************************************************************************************
     * @description Test method to verify that the denormalizeListSettingChange returns a semicolon-delimited string containing
     * all values in a specified list of strings.
     ***************************************************************************************************************************/
    @isTest
    private static void denormalizeListSettingChangeValid() {
        List<String> stringsToConvertList = new List<String>{ 'value1', 'value2', 'value3' };
        HierarchySettingsService hierarchySettingsServiceInstance = HierarchySettingsService.getInstance();

        Test.startTest();
        String denormalizedString = hierarchySettingsServiceInstance.denormalizeListSettingChange(stringsToConvertList);
        Test.stopTest();

        System.assertEquals(
            'value1;value2;value3',
            denormalizedString,
            'Should return semicolon-delimited string containing values in list.'
        );
    }

    /**************************************************************************************************************************
     * @description Test method to verify that the denormalizeListSettingChange returns an empty string when an empty list of
     * Strings is provided.
     ***************************************************************************************************************************/
    @isTest
    private static void denormalizeListSettingChangeEmptyList() {
        List<String> stringsToConvertList = new List<String>();
        HierarchySettingsService hierarchySettingsServiceInstance = HierarchySettingsService.getInstance();

        Test.startTest();
        String denormalizedString = hierarchySettingsServiceInstance.denormalizeListSettingChange(stringsToConvertList);
        Test.stopTest();

        System.assertEquals('', denormalizedString, 'Should return empty string.');
    }

    /**************************************************************************************************************************
     ****************************************************** STUBS **************************************************************
     **************************************************************************************************************************/

    /**************************************************************************************************************************************
     * @description Stub class to simulate a successful response from HierarchySettingsMapper
     **************************************************************************************************************************************/
    private class STUB_HierarchySettingsMapper extends HierarchySettingsMapper {
        public override Boolean updateHierarchySettings(HierarchySettingsModel hierarchySettingsModel) {
            return true;
        }
    }

    /*************************************************************************************************************
     * @description Stub class to simulate the response from PermissionSetMapper to return true
     */
    private class STUB_PermissionSetMapperHasAccess extends PermissionSetMapper {
        public override Boolean checkPermissionSetsWithCustomizeApplicationFromIds(Set<Id> permissionSetIdsSet) {
            return true;
        }
    }

    /*************************************************************************************************************
     * @description Stub class to simulate the response from PermissionSetMapper to return false
     */
    private class STUB_PermissionSetMapperNoAccess extends PermissionSetMapper {
        public override Boolean checkPermissionSetsWithCustomizeApplicationFromIds(Set<Id> permissionSetIdsSet) {
            return false;
        }
    }
}
public virtual with sharing class LeadConversionAccountNamingMapper {
    /*********************************************
    * @description Instance for Singleton Pattern
    **********************************************/
    @TestVisible
    private static LeadConversionAccountNamingMapper instance;

    /*********************************************************************
    * @description Empty constructor is not public for Singleton Pattern
    **********************************************************************/
    protected LeadConversionAccountNamingMapper() {}

    /*****************************************************************************
    * @description Static method to get the current instance for Singleton pattern
    * @return The instance of LeadConversionAccountNamingMapper.
    ******************************************************************************/
    public static LeadConversionAccountNamingMapper getInstance() {
        if (instance == null) {
            instance = new LeadConversionAccountNamingMapper();
        }

        return instance;
    }

    /*****************************************************************************
    * @description Retrieves an LeadConversionAccountNamingModel populated with
    * a list of Account Record Type Ids specified in Hierarchy Settings 
    * selected for renaming Accounts during Lead Conversion.
    * @return A LeadConversionAccountNamingModel
    *****************************************************************************/
    public virtual LeadConversionAccountNamingModel getLeadConversionAccountNamingModel() {
        Hierarchy_Settings__c hierarchySettings = UTIL_CustomSettingsFacade.getSettings();

        if (String.isEmpty(hierarchySettings.Lead_Converted_Account_RTypes__c) == true) {
            return new LeadConversionAccountNamingModel(new List<String>());
        }  

        // split on semi-colon and optional space
        List<String> recordTypesToNameList = hierarchySettings.Lead_Converted_Account_RTypes__c.split(';\\s?');
        return new LeadConversionAccountNamingModel(recordTypesToNameList);
    }
}
@isTest
private with sharing class LeadConversionAccountNamingMapper_TEST {
    /**************************************************************************************************************************
    * @description Test method to verify that the getInstance method returns a new instance of the 
    * LeadConversionAccountNamingMapper class when one does not already exist.
    ***************************************************************************************************************************/
    @isTest
    private static void getInstanceNew() {

        Test.startTest();
            LeadConversionAccountNamingMapper LeadConversionAccountNamingMapperInstance = 
                LeadConversionAccountNamingMapper.getInstance();
        Test.stopTest();

        System.assertEquals(
            LeadConversionAccountNamingMapper.instance, 
            LeadConversionAccountNamingMapperInstance, 
            'Instance of service class returned should match static instance variable.'
        );

        System.assertEquals(
            true, 
            LeadConversionAccountNamingMapperInstance != null, 
            'Instance of service class should not be null.'
        );
    }

    /**************************************************************************************************************************
    * @description Test method to verify that the getInstance method returns the existing instance of the 
    * LeadConversionAccountNamingMapper class when one already exists.
    ***************************************************************************************************************************/
    @isTest
    private static void getInstanceExisting() {

        Test.startTest();
            LeadConversionAccountNamingMapper LeadConversionAccountNamingMapperInstance1 = 
                LeadConversionAccountNamingMapper.getInstance();

            LeadConversionAccountNamingMapper LeadConversionAccountNamingMapperInstance2 = 
                LeadConversionAccountNamingMapper.getInstance();
        Test.stopTest();

        System.assertEquals(
            LeadConversionAccountNamingMapper.instance, 
            LeadConversionAccountNamingMapperInstance1, 
            'Instance of service class returned should match static instance variable.'
        );

        System.assertEquals(
            LeadConversionAccountNamingMapperInstance1, 
            LeadConversionAccountNamingMapperInstance2, 
            'Subsequent retrievals of service class instance should return existing instance.'
        );

        System.assertEquals(
            true, 
            LeadConversionAccountNamingMapperInstance1 != null, 
            'Instance of service class should not be null.'
        );
    }

    /**************************************************************************************************************************
    * @description Test method to verify that the getLeadConversionAccountNamingModel method correctly returns a list of
    * Ids corresponding to those specified by the semi-colon delimited list in Hierarchy Settings.
    ***************************************************************************************************************************/
    @isTest
    private static void getLeadConversionAccountNamingModelValid() {
        UTIL_CustomSettings_API.getSettingsForTests(
            new Hierarchy_Settings__c(
                Lead_Converted_Account_RTypes__c = 'Id1;Id2;Id3; Id4; Id5'
            )
        );

        LeadConversionAccountNamingMapper LeadConversionAccountNamingMapperInstance = 
                LeadConversionAccountNamingMapper.getInstance();

        Test.startTest();
        LeadConversionAccountNamingModel LeadConversionAccountNamingModel = 
            LeadConversionAccountNamingMapperInstance.getLeadConversionAccountNamingModel();
        Test.stopTest();


        for (Integer i = 0; i<5; i++) {
            System.assertEquals(
                'Id' + (i+1), 
                LeadConversionAccountNamingModel.accountRecordTypeIdsForLeadConversionWhenOrphanedList[i],
                'Id in list should match value at location ' + (i+1) + ' in semi-colon delimited list in hierarchy settings.'
            );
        }        
    }

    /**************************************************************************************************************************
    * @description Test method to verify that the getLeadConversionAccountNamingModel method correctly returns an empty list
    * Ids when there are no Account Record Types marked account renaming in the Hierarchy Settings.
    ***************************************************************************************************************************/
    @isTest
    private static void getLeadConversionAccountNamingModelEmpty() {
        UTIL_CustomSettings_API.getSettingsForTests(
            new Hierarchy_Settings__c(
                Lead_Converted_Account_RTypes__c = null
            )
        );

        LeadConversionAccountNamingMapper LeadConversionAccountNamingMapperInstance = 
                LeadConversionAccountNamingMapper.getInstance();

        Test.startTest();
        LeadConversionAccountNamingModel LeadConversionAccountNamingModel = 
            LeadConversionAccountNamingMapperInstance.getLeadConversionAccountNamingModel();
        Test.stopTest();

        System.assertEquals(
            0,
            LeadConversionAccountNamingModel.accountRecordTypeIdsForLeadConversionWhenOrphanedList.size(),
            'LeadConversionAccountNamingModel should contain an empty list of Strings.'
        );     
    }
}
public with sharing class LeadConversionAccountNamingModel {
    public List<String> accountRecordTypeIdsForLeadConversionWhenOrphanedList { get; private set; }

    /*******************************************************************************************************************
    * @description One parameter constructor.
    * @param  accountRecordTypeIdsForLeadConversionWhenOrphanedList A list representing the Account Record Type Ids 
    * selected for account naming during lead conversion.
    * @return An LeadConversionAccountNamingModel with all properties populated
    *******************************************************************************************************************/
    public LeadConversionAccountNamingModel(List<String> accountRecordTypeIdsForLeadConversionWhenOrphanedList) {
        this.accountRecordTypeIdsForLeadConversionWhenOrphanedList = accountRecordTypeIdsForLeadConversionWhenOrphanedList;
    }
}
@isTest
private inherited sharing class LeadConversionAccountNamingModel_TEST {

    /**********************************************************************
    * @description Test method to verify one parameter constructor returns
    * a populated model.
    **********************************************************************/
    @isTest 
    private static void oneParameterConstructor() {
        List<String> sampleIdsList = new List<String>{
            'testId1',
            'testId2'
        };

        Test.startTest();
        LeadConversionAccountNamingModel LeadConversionAccountNamingModel = 
            new LeadConversionAccountNamingModel(sampleIdsList);
        Test.stopTest();

        System.assertEquals(
            'testId1', 
            LeadConversionAccountNamingModel.accountRecordTypeIdsForLeadConversionWhenOrphanedList[0],
            'String should match value specified in parameter.'
        );

        System.assertEquals(
            'testId2', 
            LeadConversionAccountNamingModel.accountRecordTypeIdsForLeadConversionWhenOrphanedList[1],
            'String should match value specified in parameter.'
        );
    }
}
public virtual with sharing class LeadConversionAccountNamingService {
    /*********************************************
    * @description Instance for Singleton Pattern
    **********************************************/
    @TestVisible
    private static LeadConversionAccountNamingService instance;

    /*********************************************************************
    * @description Empty constructor is not public for Singleton Pattern
    **********************************************************************/
    protected LeadConversionAccountNamingService() {}

    /*****************************************************************************
    * @description Static method to get the current instance for Singleton pattern
    * @return The instance of LeadConversionAccountNamingService.
    ******************************************************************************/
    public static LeadConversionAccountNamingService getInstance() {
        if (instance == null) {
            instance = new LeadConversionAccountNamingService();
        }

        return instance;
    }

    /*****************************************************************************
    * @description Retrieve a LeadConversionAccountNamingModel populated with a
    * list of Account Record Type Ids from Hierarchy Settings that have been 
    * selected for Account Naming.
    * @return An LeadConversionAccountNamingModel
    *****************************************************************************/
    public LeadConversionAccountNamingModel getLeadConversionAccountNamingModel() {
        return this.locateLeadConversionAccountNamingMapper().getLeadConversionAccountNamingModel();
    }

    /*****************************************************************************
    * @description Retrieve an instance of LeadConversionAccountNamingMapper.
    * @return An instance of the LeadConversionAccountNamingMapper class
    *****************************************************************************/
    @TestVisible 
    private LeadConversionAccountNamingMapper locateLeadConversionAccountNamingMapper() {
        return LeadConversionAccountNamingMapper.getInstance();
    }
}
@isTest
private with sharing class LeadConversionAccountNamingService_TEST {
    /**************************************************************************************************************************
    * @description Test method to verify that the getInstance method returns a new instance of the 
    * LeadConversionAccountNamingService class when one does not already exist.
    ***************************************************************************************************************************/
    @isTest
    private static void getInstanceNew() {

        Test.startTest();
            LeadConversionAccountNamingService LeadConversionAccountNamingServiceInstance = 
                LeadConversionAccountNamingService.getInstance();
        Test.stopTest();

        System.assertEquals(
            LeadConversionAccountNamingService.instance, 
            LeadConversionAccountNamingServiceInstance, 
            'Instance of service class returned should match static instance variable.'
        );

        System.assertEquals(
            true, 
            LeadConversionAccountNamingServiceInstance != null, 
            'Instance of service class should not be null.'
        );
    }

    /**************************************************************************************************************************
    * @description Test method to verify that the getInstance method returns the existing instance of the 
    * LeadConversionAccountNamingService class when one already exists.
    ***************************************************************************************************************************/
    @isTest
    private static void getInstanceExisting() {

        Test.startTest();
            LeadConversionAccountNamingService LeadConversionAccountNamingServiceInstance1 = 
                LeadConversionAccountNamingService.getInstance();

            LeadConversionAccountNamingService LeadConversionAccountNamingServiceInstance2 = 
                LeadConversionAccountNamingService.getInstance();
        Test.stopTest();

        System.assertEquals(
            LeadConversionAccountNamingService.instance, 
            LeadConversionAccountNamingServiceInstance1, 
            'Instance of service class returned should match static instance variable.'
        );

        System.assertEquals(
            LeadConversionAccountNamingServiceInstance1, 
            LeadConversionAccountNamingServiceInstance2, 
            'Subsequent retrievals of service class instance should return existing instance.'
        );

        System.assertEquals(
            true, 
            LeadConversionAccountNamingServiceInstance1 != null, 
            'Instance of service class should not be null.'
        );
    }

    /**************************************************************************************************************************
    * @description Test method to verify that the getLeadConversionAccountNamingModel method returns an LeadConversionAccountNamingModel
    * populated with a list of strings matching the semi-colon delimited list specifed in Hierarchy Settings.
    ***************************************************************************************************************************/
    @isTest 
    private static void getLeadConversionAccountNamingModelValid() {
        LeadConversionAccountNamingMapper.instance = new STUB_LeadConversionAccountNamingMapper();

        LeadConversionAccountNamingService LeadConversionAccountNamingServiceInstance = 
                LeadConversionAccountNamingService.getInstance();

        Test.startTest();
        LeadConversionAccountNamingModel LeadConversionAccountNamingModel = 
            LeadConversionAccountNamingServiceInstance.getLeadConversionAccountNamingModel();
        Test.stopTest();

        System.assertEquals(
            'Id1', 
            LeadConversionAccountNamingModel.accountRecordTypeIdsForLeadConversionWhenOrphanedList[0],
            'Should match value set in stubbed model.'
        );

        System.assertEquals(
            'Id2', 
            LeadConversionAccountNamingModel.accountRecordTypeIdsForLeadConversionWhenOrphanedList[1],
            'Should match value set in stubbed model.'
        );
    }

    /**************************************************************************************************************************
    * @description Test method to verify that the locateLeadConversionAccountNamingMapper method returns an instance of 
    * the LeadConversionAccountNamingMapper class.
    ***************************************************************************************************************************/
    @isTest 
    private static void locateLeadConversionAccountNamingMapperValid() {
        LeadConversionAccountNamingService LeadConversionAccountNamingServiceInstance = 
                LeadConversionAccountNamingService.getInstance();

        Test.startTest();
        LeadConversionAccountNamingMapper LeadConversionAccountNamingMapperInstance = 
            LeadConversionAccountNamingServiceInstance.locateLeadConversionAccountNamingMapper();
        Test.stopTest();

        System.assertEquals(
            LeadConversionAccountNamingMapper.getInstance(), 
            LeadConversionAccountNamingMapperInstance,
            'Should return an instance of LeadConversionAccountNamingMapper.');
    }


    /**************************************************************************************************************************
    ****************************************************** STUB CLASS *********************************************************
    **************************************************************************************************************************/

    /*************************************************************************************************************
    * @description Stub class to simulate the response from LeadConversionAccountNamingMapper to return an 
    * LeadConversionAccountNamingModel for testing.
    *************************************************************************************************************/
    private class STUB_LeadConversionAccountNamingMapper extends LeadConversionAccountNamingMapper {
        public override LeadConversionAccountNamingModel getLeadConversionAccountNamingModel() {
            List<String> recordTypeIdsList = new List<String>{
                'Id1',
                'Id2'
            };

            return new LeadConversionAccountNamingModel(recordTypeIdsList);
        }
    }    
}
public virtual with sharing class LeadConversionAccountNamingVMapper {
    /**********************************************************************************
     * @description Instance for Singleton Pattern
     **********************************************************************************/
    @TestVisible
    private static LeadConversionAccountNamingVMapper instance;

    /**********************************************************************************
     * @description Empty constructor is not public for Singleton Pattern
     **********************************************************************************/
    protected LeadConversionAccountNamingVMapper() {
    }

    /**********************************************************************************
     * @description Static method to get the current instance for Singleton pattern
     * @return The instance of LeadConversionAccountNamingVMapper.
     **********************************************************************************/
    public static LeadConversionAccountNamingVMapper getInstance() {
        if (instance == null) {
            instance = new LeadConversionAccountNamingVMapper();
        }

        return instance;
    }

    /*******************************************************************************************************
     * @description Retrieve a DualListboxVModel representing the Account Record Types currently selected
     * for renaming accounts during Lead Conversion that available for selection.
     * @return  A DualListboxVModel
     *******************************************************************************************************/
    public virtual DualListboxVModel getLeadConversionAccountNamingViewModel() {
        // get current values set for deletion from hierarchy settings
        LeadConversionAccountNamingModel currentAccountNamingSettings = this.locateLeadConversionAccountNamingService()
            .getLeadConversionAccountNamingModel();

        // get all active account record types in org
        Map<Id, RecordTypeModel> activeAccountRecordTypeModelsById = this.locateRecordTypeService()
            .getActiveRecordTypeModelsById(
                this.locateRecordTypeService().getModelByIdMapForSObjectType(Account.SObjectType).values()
            );

        // create DualListboxValueVModels for each of the selected and available options
        List<DualListboxValueVModel> optionsDualListboxValuesList = new List<DualListboxValueVModel>();

        // populate available listbox - should contain all values regardless of if they are selected
        for (Id recordTypeId : activeAccountRecordTypeModelsById.keySet()) {
            optionsDualListboxValuesList.add(
                new DualListboxValueVModel(
                    activeAccountRecordTypeModelsById.get(recordTypeId).name,
                    activeAccountRecordTypeModelsById.get(recordTypeId).id
                )
            );
        }

        // populate selected listbox - only requires the String representing the value of the selected option
        List<String> selectedOptionsDualListboxValuesList = (List<String>) this.locateRecordTypeService()
            .filterListForValidIds(
                currentAccountNamingSettings.accountRecordTypeIdsForLeadConversionWhenOrphanedList,
                activeAccountRecordTypeModelsById.keySet()
            );

        return new DualListboxVModel(selectedOptionsDualListboxValuesList, optionsDualListboxValuesList);
    }

    /*****************************************************************************
     * @description Retrieve an instance of the LeadConversionAccountNamingService class.
     * @return An instance of LeadConversionAccountNamingService.
     *****************************************************************************/
    @TestVisible
    private LeadConversionAccountNamingService locateLeadConversionAccountNamingService() {
        return LeadConversionAccountNamingService.getInstance();
    }

    /*****************************************************************************
     * @description Retrieve an instance of the RecordTypeService class.
     * @return An instance of RecordTypeService.
     *****************************************************************************/
    @TestVisible
    private RecordTypeService locateRecordTypeService() {
        return RecordTypeService.getInstance();
    }
}
@isTest
private with sharing class LeadConversionAccountNamingVMapper_TEST {
    /**************************************************************************************************************************
     * @description Test method to verify that the getInstance method returns a new instance of the
     * LeadConversionAccountNamingMapper class when one does not already exist.
     ***************************************************************************************************************************/
    @isTest
    private static void getInstanceNew() {
        Test.startTest();
        LeadConversionAccountNamingMapper LeadConversionAccountNamingMapperInstance = LeadConversionAccountNamingMapper.getInstance();
        Test.stopTest();

        System.assertEquals(
            LeadConversionAccountNamingMapper.instance,
            LeadConversionAccountNamingMapperInstance,
            'Instance of mapper class returned should match static instance variable.'
        );
        System.assertEquals(
            true,
            LeadConversionAccountNamingMapperInstance != null,
            'Instance of mapper class should not be null.'
        );
    }

    /**************************************************************************************************************************
     * @description Test method to verify that the getInstance method returns the existing instance of the
     * LeadConversionAccountNamingMapper class when one already exists.
     ***************************************************************************************************************************/
    @isTest
    private static void getInstanceExisting() {
        Test.startTest();
        LeadConversionAccountNamingMapper LeadConversionAccountNamingMapperInstance1 = LeadConversionAccountNamingMapper.getInstance();
        LeadConversionAccountNamingMapper LeadConversionAccountNamingMapperInstance2 = LeadConversionAccountNamingMapper.getInstance();
        Test.stopTest();

        System.assertEquals(
            LeadConversionAccountNamingMapper.instance,
            LeadConversionAccountNamingMapperInstance1,
            'Instance of mapper class returned should match static instance variable.'
        );
        System.assertEquals(
            LeadConversionAccountNamingMapperInstance1,
            LeadConversionAccountNamingMapperInstance2,
            'Subsequent retrievals of mapper class instance should return existing instance.'
        );
        System.assertEquals(
            true,
            LeadConversionAccountNamingMapperInstance1 != null,
            'Instance of mapper class should not be null.'
        );
    }

    /**************************************************************************************************************************
     * @description Test to verify locateRecordTypeService() returns an instance of the RecordTypeService class.
     **************************************************************************************************************************/
    @isTest
    private static void locateRecordTypeServiceValid() {
        LeadConversionAccountNamingVMapper leadConversionAccountNamingMapperInstance = LeadConversionAccountNamingVMapper.getInstance();
        Test.startTest();
        RecordTypeService recordTypeServiceInstance = leadConversionAccountNamingMapperInstance.locateRecordTypeService();
        Test.stopTest();

        System.assertEquals(
            RecordTypeService.getInstance(),
            recordTypeServiceInstance,
            'Should return instance of RecordTypeService class.'
        );
        System.assertEquals(
            true,
            recordTypeServiceInstance != null,
            'Instance of RecordTypeService class should not be null.'
        );
    }

    /**************************************************************************************************************************
     * @description Test to verify locateLeadConversionAccountNamingService() returns an instance of the LeadConversionAccountNamingService class.
     **************************************************************************************************************************/
    @isTest
    private static void locateLeadConversionAccountNamingServiceValid() {
        LeadConversionAccountNamingVMapper LeadConversionAccountNamingMapperInstance = LeadConversionAccountNamingVMapper.getInstance();

        Test.startTest();
        LeadConversionAccountNamingService LeadConversionAccountNamingServiceInstance = LeadConversionAccountNamingMapperInstance.locateLeadConversionAccountNamingService();
        Test.stopTest();

        System.assertEquals(
            LeadConversionAccountNamingService.getInstance(),
            LeadConversionAccountNamingServiceInstance,
            'Should return instance of LeadConversionAccountNamingService class.'
        );
        System.assertEquals(
            true,
            LeadConversionAccountNamingServiceInstance != null,
            'Instance of LeadConversionAccountNamingService class should not be null.'
        );
    }

    /*************************************************************************************************************
     * @description Test method to verify getLeadConversionAccountNamingViewModel() returns a DualListboxVModel
     * representing only the active Account Record Types as selected and available options.  It also ensures that
     * all active Record Types are represented as available options regardless of whether they are also in the
     * selected list.
     *************************************************************************************************************/
    @isTest
    private static void getLeadConversionAccountNamingViewModelValid() {
        RecordTypeMapper.instance = new STUB_RecordTypeMapper();

        Hierarchy_Settings__c hierarchySettings = UTIL_CustomSettings_API.getSettingsForTests(
            new Hierarchy_Settings__c(Lead_Converted_Account_RTypes__c = '000000000000000001;000000000000000002')
        );

        LeadConversionAccountNamingVMapper leadConversionAccountNamingMapperInstance = LeadConversionAccountNamingVMapper.getInstance();

        Test.startTest();
        DualListboxVModel dualListboxVModel = leadConversionAccountNamingMapperInstance.getLeadConversionAccountNamingViewModel();
        Test.stopTest();

        System.assertEquals(
            1,
            dualListboxVModel.value.size(),
            'Should only display active account record type as selected value.'
        );
        System.assertEquals(
            '000000000000000001',
            dualListboxVModel.value[0],
            'Should only display active account record type as selected value.'
        );
        System.assertEquals(
            2,
            dualListboxVModel.options.size(),
            'Should only display active account record types as available options.'
        );
        System.assertEquals(
            '000000000000000001',
            dualListboxVModel.options[0].value,
            'Should only display active account record types as available options.'
        );
        System.assertEquals(
            '000000000000000003',
            dualListboxVModel.options[1].value,
            'Should only display active account record types as available options.'
        );
    }

    /**************************************************************************************************************************
     ****************************************************** STUB CLASS *********************************************************
     **************************************************************************************************************************/

    /*************************************************************************************************************
     * @description Stub class to simulate the response from RecordTypeMapper to return a map of Record Type model by Id
     */
    private class STUB_RecordTypeMapper extends RecordTypeMapper {
        public override Map<Id, RecordTypeModel> getModelByIdMapForSObjectType(Schema.SObjectType sObjectType) {
            Map<Id, RecordTypeModel> recordTypeModelsById = new Map<Id, RecordTypeModel>{
                '000000000000000001' => new RecordTypeModel(
                    '000000000000000001',
                    'Record Type 1',
                    'Record_Type_1',
                    true
                ),
                '000000000000000002' => new RecordTypeModel(
                    '000000000000000002',
                    'Record Type 2',
                    'Record_Type_2',
                    false
                ),
                '000000000000000003' => new RecordTypeModel(
                    '000000000000000003',
                    'Record Type 3',
                    'Record_Type_3',
                    true
                )
            };

            return recordTypeModelsById;
        }
    }
}
public virtual with sharing class LookupFieldMapper {
    /**********************************************************************************
    * @description Instance for Singleton Pattern
    **********************************************************************************/
    @TestVisible
    private static LookupFieldMapper instance;

    /**********************************************************************************
    * @description Empty constructor is not public for Singleton Pattern
    **********************************************************************************/
    protected LookupFieldMapper() {}

    /**********************************************************************************
    * @description Static method to get the current instance for Singleton pattern
    * @return The instance of LookupFieldMapper.
    **********************************************************************************/
    public static LookupFieldMapper getInstance() {
        if (instance == null) {
            instance = new LookupFieldMapper();
        }

        return instance;
    }

    /**********************************************************************************************************
    * @description Retrieve a map of LookupField models representing fields on a specified owner SObject type
    * that is a lookup to a specified target SObject type by field name.
    * @param  sObjectType  The SObject type where the field originates
    * @param  lookupToSObjectType The SObject type where the field lookup targets
    * @return Map<String, LookupFieldModel>
    **********************************************************************************************************/ 
    public virtual Map<String, LookupFieldModel> getModelByNameMapForSObjectType(SObjectType sObjectType, SObjectType lookupToSObjectType) {
        Map<String, LookupFieldModel> lookupFieldModelByName = new Map<String, LookupFieldModel>();

        Map<String, Schema.DescribeFieldResult> sObjectLookupFieldsByName = 
            UTIL_Describe.getFieldsOfType(sObjectType.getDescribe().getName(), 'REFERENCE');

        for (Schema.DescribeFieldResult lookupFieldResult : sObjectLookupFieldsByName.values()){

            if (lookupFieldResult.getReferenceTo().contains(lookupToSObjectType)){
                    lookupFieldModelByName.put(
                    lookupFieldResult.getName(), 
                    new LookupFieldModel(lookupFieldResult.getName(), lookupFieldResult.getLabel())
                );
            } 
        }

        return lookupFieldModelByName;
    }
}
@isTest
public with sharing class LookupFieldMapper_TEST {
    /**************************************************************************************************************************
    * @description Test method to verify that the getInstance method returns a new instance of the 
    * LookupFieldMapper class when one does not already exist.
    ***************************************************************************************************************************/
    @isTest
    private static void getInstanceNew() {

        Test.startTest();
            LookupFieldMapper LookupFieldMapperInstance = LookupFieldMapper.getInstance();
        Test.stopTest();

        System.assertEquals(LookupFieldMapper.instance, LookupFieldMapperInstance, 'Instance of mapper class returned should match static instance variable.');
        System.assertEquals(true, LookupFieldMapperInstance != null, 'Instance of mapper class should not be null.');
    }

    /**************************************************************************************************************************
    * @description Test method to verify that the getInstance method returns the existing instance of the 
    * LookupFieldMapper class when one already exists.
    ***************************************************************************************************************************/
    @isTest
    private static void getInstanceExisting() {

        Test.startTest();
            LookupFieldMapper LookupFieldMapperInstance1 = LookupFieldMapper.getInstance();
            LookupFieldMapper LookupFieldMapperInstance2 = LookupFieldMapper.getInstance();
        Test.stopTest();

        System.assertEquals(LookupFieldMapper.instance, LookupFieldMapperInstance1, 'Instance of mapper class returned should match static instance variable.');
        System.assertEquals(LookupFieldMapperInstance1, LookupFieldMapperInstance2, 'Subsequent retrievals of mapper class instance should return existing instance.');
        System.assertEquals(true, LookupFieldMapperInstance1 != null, 'Instance of mapper class should not be null.');
    }

    /**************************************************************************************************************************
    * @description Test to verify getModelByNameMapForSObjectTypeValid() returns a map with valid lookup field mappings
    * when a specified SObject contains fields that lookup to a specified SObject type.
    **************************************************************************************************************************/
    @isTest 
    private static void getModelByNameMapForSObjectTypeValid(){
        Test.startTest();
        Map<String, LookupFieldModel> lookupFieldModelByNameResult = 
            LookupFieldMapper.getInstance().getModelByNameMapForSObjectType(Contact.SObjectType, Account.SObjectType);
        Test.stopTest();

        System.assertEquals(false, lookupFieldModelByNameResult.isEmpty(), 'Contact object should have fields that lookup to Account.');
        System.assertEquals(true, lookupFieldModelByNameResult.containsKey(UTIL_Namespace.strTokenNSPrefix('Primary_Household__c')), 'Contact object should have field model for \'Primary Household\' field name.');
    }

    /**************************************************************************************************************************
    * @description Test to verify getModelByNameMapForSObjectTypeValid() returns an empty map when a specified SObject 
    * does not contain fields that lookup to a specified SObject type.
    **************************************************************************************************************************/
    @isTest 
    private static void getModelByNameMapForSObjectTypeEmpty(){
        Test.startTest();
        Map<String, LookupFieldModel> lookupFieldModelByNameResult = 
            LookupFieldMapper.getInstance().getModelByNameMapForSObjectType(Trigger_Handler__c.SObjectType, Error__c.SObjectType);
        Test.stopTest();

        System.assertEquals(true, lookupFieldModelByNameResult.isEmpty(), 'Trigger Handler object should have no fields that lookup to Error.');
    }    
}
public with sharing class LookupFieldModel {
    public String name; //developer name
    public String label;

    public LookupFieldModel(String name, String label) {
        this.name = name;
        this.label = label;
    }
}
public virtual with sharing class LookupFieldService {
    /*********************************************
    * @description Instance for Singleton Pattern
    **********************************************/
    @TestVisible
    private static LookupFieldService instance;

    /*********************************************************************
    * @description Empty constructor is not public for Singleton Pattern
    **********************************************************************/
    protected LookupFieldService() {}

    /*****************************************************************************
    * @description Static method to get the current instance for Singleton pattern
    * @return The instance of LookupFieldService.
    ******************************************************************************/
    public static LookupFieldService getInstance() {
            if (instance == null) {
                    instance = new LookupFieldService();
            }

            return instance;
    }

    /********************************************************************************************
    * @description Retrieve a map of LookupFieldModels by Name for a specified SObject 
    * that is a lookup to a specified SObject type.
    * @param  sObjectType The SObject type of the field model
    * @param lookupToSObjectType The SObject type that the field model looks up to 
    * @return A Map<String, LookupFieldModel>
    ********************************************************************************************/
    public virtual Map<String, LookupFieldModel> getModelByNameMapForSObjectType(
        SObjectType sObjectType, 
        SObjectType lookupToSObjectType
    ) {
        return this.locateLookupFieldMapper().getModelByNameMapForSObjectType(sObjectType, lookupToSObjectType);
    }

    /********************************************************************************************
    * @description Retrieve a map of LookupFieldModels by Label for lookup fields on an SObject.
    * @param  lookupFieldModelsByName A map of lookup fields on an SObject by developer name.
    * @return A Map<String, LookupFieldModel>
    ********************************************************************************************/
    public Map<String,LookupFieldModel> getModelByLabelMapForSObjectType(Map<String,LookupFieldModel> lookupFieldModelsByName) {
        Map<String, LookupFieldModel> lookupFieldModelsByLabel = new Map<String, LookupFieldModel>();

        for (LookupFieldModel lookupFieldModel : lookupFieldModelsByName.values()) {
            lookupFieldModelsByLabel.put(lookupFieldModel.label, lookupFieldModel);
        }

        return lookupFieldModelsByLabel;
    }

    /********************************************************************************************
    * @description Retrieve a LookupField model corresponding to a specified field name.
    * @param  fieldName  An SObject field name
    * @return A LookupFieldModel
    ********************************************************************************************/ 
    public virtual LookupFieldModel getLookupFieldModelFromNameMap(
        String fieldName, 
        Map<String, LookupFieldModel> lookupFieldModelByName) 
    {
        return lookupFieldModelByName.get(fieldName);
    }

    /******************************************************************************
    * @description Retrieve a lookup field model for a specified lookup field name or label.
    * @param LookupFieldNameOrLabel A string representing the name or label for a lookup field
    * @param LookupFieldModelByName A map of lookup field models by name
    * @param LookupFieldModelByLabel A map of lookup field models by label
    * @return A lookup field Model corresponding to the specified lookup field label or name
    ******************************************************************************/
    public virtual LookupFieldModel getLookupFieldModelFromNameAndLabelMaps(
        String lookupFieldNameOrLabel, 
        Map<String, LookupFieldModel> lookupFieldModelByName,
        Map<String, LookupFieldModel> lookupFieldModelByLabel
    ) { 
        LookupFieldModel lookupFieldModel = lookupFieldModelByName.get(lookupFieldNameOrLabel);

        if (lookupFieldModel == null) {
            lookupFieldModel = lookupFieldModelByLabel.get(lookupFieldNameOrLabel);
        }

        return lookupFieldModel;
    }

    /********************************************************************************************
    * @description Retrieve a LookupField model corresponding to a specified field label.
    * @param  fieldLabel  An SObject field label
    * @return A LookupFieldModel
    ********************************************************************************************/ 
    public virtual LookupFieldModel getLookupFieldModelFromLabelMap(
        String fieldLabel, 
        Map<String, LookupFieldModel> lookupFieldModelByLabel) 
    {
        return lookupFieldModelByLabel.get(fieldLabel);
    }

    /*****************************************************************************
    * @description Retrieves an instance of the LookupFieldMapper.
    * @return The instance of LookupFieldMapper.
    ******************************************************************************/
    @TestVisible
    private LookupFieldMapper locateLookupFieldMapper(){
        return LookupFieldMapper.getInstance();
    }
}
@isTest
public with sharing class LookupFieldService_TEST {
    /**************************************************************************************************************************
    * @description Test method to verify that the getInstance method returns a new instance of the 
    * LookupFieldService class when one does not already exist.
    ***************************************************************************************************************************/
    @isTest
    private static void getInstanceNew() {

        Test.startTest();
            LookupFieldService LookupFieldServiceInstance = LookupFieldService.getInstance();
        Test.stopTest();

        System.assertEquals(LookupFieldService.instance, LookupFieldServiceInstance, 'Instance of mapper class returned should match static instance variable.');
        System.assertEquals(true, LookupFieldServiceInstance != null, 'Instance of mapper class should not be null.');
    }

    /**************************************************************************************************************************
    * @description Test method to verify that the getInstance method returns the existing instance of the 
    * LookupFieldService class when one already exists.
    ***************************************************************************************************************************/
    @isTest
    private static void getInstanceExisting() {

        Test.startTest();
            LookupFieldService LookupFieldServiceInstance1 = LookupFieldService.getInstance();
            LookupFieldService LookupFieldServiceInstance2 = LookupFieldService.getInstance();
        Test.stopTest();

        System.assertEquals(LookupFieldService.instance, LookupFieldServiceInstance1, 'Instance of mapper class returned should match static instance variable.');
        System.assertEquals(LookupFieldServiceInstance1, LookupFieldServiceInstance2, 'Subsequent retrievals of mapper class instance should return existing instance.');
        System.assertEquals(true, LookupFieldServiceInstance1 != null, 'Instance of mapper class should not be null.');
    }

    /**************************************************************************************************************************
    * @description Test method to verify that the getModelByNameMapForSObjectType method returns the a map of LookupField models
    * by name when an SObject contains fields that lookup to the specified SObject type.
    ***************************************************************************************************************************/
    @isTest 
    private static void getModelByNameMapForSObjectTypeValid(){
        LookupFieldMapper.instance = new STUB_LookupFieldMapperValid();
        LookupFieldService lookupFieldServiceInstance = LookupFieldService.getInstance();

        Test.startTest();
        Map<String, LookupFieldModel> lookupFieldModelByNameResults = 
            lookupFieldServiceInstance.getModelByNameMapForSObjectType(Contact.SObjectType, Account.SObjectType);
        Test.stopTest();

        System.assertEquals(3, lookupFieldModelByNameResults.values().size(), 'Should return 3 mappings to Account lookup fields.');
        System.assertEquals(true, lookupFieldModelByNameResults.containsKey('testName1'), 'Should contain mapping for \'testName1\' field name.');
        System.assertEquals(true, lookupFieldModelByNameResults.containsKey('testName2'), 'Should contain mapping for \'testName2\' field name.');
        System.assertEquals(true, lookupFieldModelByNameResults.containsKey('testName3'), 'Should contain mapping for \'testName3\' field name.');
    }

    /**************************************************************************************************************************
    * @description Test method to verify that the getModelByNameMapForSObjectType method returns an empty map of LookupField models
    * by name when an SObject does not contain fields that lookup to the specified SObject type.
    ***************************************************************************************************************************/
    @isTest 
    private static void getModelByNameMapForSObjectTypeEmpty(){
        LookupFieldMapper.instance = new STUB_LookupFieldMapperEmpty();
        LookupFieldService lookupFieldServiceInstance = LookupFieldService.getInstance();

        Test.startTest();
        Map<String, LookupFieldModel> lookupFieldModelByNameResults = 
            lookupFieldServiceInstance.getModelByNameMapForSObjectType(Trigger_Handler__c.SObjectType, Error__c.SObjectType);
        Test.stopTest();

        System.assertEquals(0, lookupFieldModelByNameResults.values().size(), 'Trigger Handler should have no mappings to Error__c lookup fields.');
    }

    /**************************************************************************************************************************
    * @description Test method to verify that the getModelByLabelMapForSObjectType method returns an map of LookupField models
    * by label when a valid map of lookup field models by name is provided.
    ***************************************************************************************************************************/
    @isTest 
    private static void getModelByLabelMapForSObjectTypeValid(){
        Map<String, LookupFieldModel> lookupFieldsByName = new Map<String, LookupFieldModel>();
        lookupFieldsByName.put('LookupFieldName1', new LookupFieldModel('LookupFieldName1', 'LookupFieldLabel1'));
        lookupFieldsByName.put('LookupFieldName2', new LookupFieldModel('LookupFieldName2', 'LookupFieldLabel2'));
        lookupFieldsByName.put('LookupFieldName3', new LookupFieldModel('LookupFieldName3', 'LookupFieldLabel3'));

        LookupFieldService lookupFieldServiceInstance = LookupFieldService.getInstance();

        Test.startTest();
        Map<String, LookupFieldModel> lookupFieldModelByLabelResults = 
            lookupFieldServiceInstance.getModelByLabelMapForSObjectType(lookupFieldsByName);
        Test.stopTest();

        for (String lookupFieldKey : lookupFieldModelByLabelResults.keySet()) {
            System.assertEquals(true, lookupFieldKey.containsIgnoreCase('LookupFieldLabel'), 'Lookup field models should be mapped by Label');
        }
    }

    /**************************************************************************************************************************
    * @description Test method to verify that the getLookupFieldModelFromNameMap method returns a valid LookupField model when
    * searching by a name that matches one of the values in the provided map.
    ***************************************************************************************************************************/
    @isTest 
    private static void getLookupFieldModelFromNameMapValid() {
        Map<String, LookupFieldModel> lookupFieldModelByName = new Map<String, LookupFieldModel>();

        lookupFieldModelByName.put('TestName1', new LookupFieldModel('TestName1', 'TestLabel1'));
        lookupFieldModelByName.put('TestName2', new LookupFieldModel('TestName2', 'TestLabel2'));
        lookupFieldModelByName.put('TestName3', new LookupFieldModel('TestName3', 'TestLabel3'));

        LookupFieldService lookupFieldServiceInstance = LookupFieldService.getInstance();

        Test.startTest();
        LookupFieldModel lookupFieldModelResult = lookupFieldServiceInstance.getLookupFieldModelFromNameMap('TestName1', lookupFieldModelByName);
        Test.stopTest();

        System.assertEquals('TestLabel1', LookupFieldModelResult.label, 'Field model should have \'TestLabel1\' as label value.');
    }

    /**************************************************************************************************************************
    * @description Test method to verify that the getLookupFieldModelFromLabelMap method returns a valid LookupField model when
    * searching by a label that matches one of the values in the provided map.
    ***************************************************************************************************************************/
    @isTest 
    private static void getLookupFieldModelFromLabelMapValid() {
        Map<String, LookupFieldModel> lookupFieldModelByLabel = new Map<String, LookupFieldModel>();

        lookupFieldModelByLabel.put('TestLabel1', new LookupFieldModel('TestName1', 'TestLabel1'));
        lookupFieldModelByLabel.put('TestLabel2', new LookupFieldModel('TestName2', 'TestLabel2'));
        lookupFieldModelByLabel.put('TestLabel3', new LookupFieldModel('TestName3', 'TestLabel3'));

        LookupFieldService lookupFieldServiceInstance = LookupFieldService.getInstance();

        Test.startTest();
        LookupFieldModel lookupFieldModelResult = lookupFieldServiceInstance.getLookupFieldModelFromLabelMap('TestLabel1', lookupFieldModelByLabel);
        Test.stopTest();

        System.assertEquals('TestName1', LookupFieldModelResult.name, 'Field model should have \'TestName1\' as name value.');
    }

    /**************************************************************************************************************************
    * @description Test method to verify that the getLookupFieldModelFromNameMap method returns a null LookupField model when
    * searching by name that does not match the values in the provided map.
    ***************************************************************************************************************************/
    @isTest 
    private static void getLookupFieldModelFromNameMapInValid() {
        Map<String, LookupFieldModel> lookupFieldModelByName = new Map<String, LookupFieldModel>();

        lookupFieldModelByName.put('TestName1', new LookupFieldModel('TestName1', 'TestLabel1'));
        lookupFieldModelByName.put('TestName2', new LookupFieldModel('TestName2', 'TestLabel2'));
        lookupFieldModelByName.put('TestName3', new LookupFieldModel('TestName3', 'TestLabel3'));

        LookupFieldService lookupFieldServiceInstance = LookupFieldService.getInstance();

        Test.startTest();
        LookupFieldModel lookupFieldModelResult = lookupFieldServiceInstance.getLookupFieldModelFromNameMap('InvalidName', lookupFieldModelByName);
        Test.stopTest();

        System.assertEquals(null, lookupFieldModelResult, 'Should return null value.');
    }

    /**************************************************************************************************************************
    * @description Test method to verify that the getLookupFieldModelFromLabelMap method returns a null LookupField model when
    * searching by label that does not match the values in the provided map.
    ***************************************************************************************************************************/
    @isTest 
    private static void getLookupFieldModelFromLabelMapInValid() {
        Map<String, LookupFieldModel> lookupFieldModelByLabel = new Map<String, LookupFieldModel>();

        lookupFieldModelByLabel.put('TestLabel1', new LookupFieldModel('TestName1', 'TestLabel1'));
        lookupFieldModelByLabel.put('TestLabel2', new LookupFieldModel('TestName2', 'TestLabel2'));
        lookupFieldModelByLabel.put('TestLabel3', new LookupFieldModel('TestName3', 'TestLabel3'));

        LookupFieldService lookupFieldServiceInstance = LookupFieldService.getInstance();

        Test.startTest();
        LookupFieldModel lookupFieldModelResult = lookupFieldServiceInstance.getLookupFieldModelFromLabelMap('InvalidName', lookupFieldModelByLabel);
        Test.stopTest();

        System.assertEquals(null, lookupFieldModelResult, 'Should return null value.');
    }

    /**************************************************************************************************************************
    * @description Test method to verify that getLookupFieldModelFromNameAndLabelMaps returns a valid record type model when a match is found
    * for a specified developer name.
    ***************************************************************************************************************************/
    @isTest 
    private static void getLookupFieldModelFromNameAndLabelMapsByName() {
        Map<String, LookupFieldModel> lookupFieldModelsByName = new Map<String, LookupFieldModel>{
            'Lookup_Field_1' => new LookupFieldModel(
                'Lookup_Field_1',    
                'Lookup Field 1'
            )
        };

        Map<String, LookupFieldModel> lookupFieldModelsByLabel = new Map<String, LookupFieldModel>{
            'Lookup Field' => new LookupFieldModel(
                'Lookup_Field',
                'Lookup Field'
            )
        };

        LookupFieldService lookupFieldServiceInstance = LookupFieldService.getInstance();

        Test.startTest();
        LookupFieldModel lookupFieldModelResult = 
            lookupFieldServiceInstance.getLookupFieldModelFromNameAndLabelMaps(
                'Lookup_Field_1',
                lookupFieldModelsByName,
                lookupFieldModelsByLabel
            );
        Test.stopTest();

        System.assertEquals('Lookup_Field_1', lookupFieldModelResult.name, 'Record type model name should be \'Lookup_Field_1\'.');
        System.assertEquals('Lookup Field 1', lookupFieldModelResult.label, 'Record type model label should be \'Lookup Field 1\'.');
    }

    /**************************************************************************************************************************
    * @description Test method to verify that getLookupFieldModelFromNameAndLabelMaps returns a valid record type model when a match is found
    * for a specified label name.
    ***************************************************************************************************************************/
    @isTest 
    private static void getLookupFieldModelFromNameAndLabelMapsByLabel() {
        Map<String, LookupFieldModel> lookupFieldModelsByName = new Map<String, LookupFieldModel>{
            'Lookup_Field_1' => new LookupFieldModel(
                'Lookup_Field_1',    
                'Lookup Field 1' 
            )
        };

        Map<String, LookupFieldModel> lookupFieldModelsByLabel = new Map<String, LookupFieldModel>{
            'Lookup Field' => new LookupFieldModel(
                'Lookup_Field',
                'Lookup Field'
            )
        };

        LookupFieldService lookupFieldServiceInstance = LookupFieldService.getInstance();

        Test.startTest();
        LookupFieldModel lookupFieldModelResult = 
            lookupFieldServiceInstance.getLookupFieldModelFromNameAndLabelMaps(
                'Lookup Field',
                lookupFieldModelsByName,
                lookupFieldModelsByLabel
            );
        Test.stopTest();

        System.assertEquals('Lookup_Field', lookupFieldModelResult.name, 'Lookup field model name should be \'Lookup_Field\'.');
        System.assertEquals('Lookup Field', lookupFieldModelResult.label, 'Lookup field model label should be \'Lookup Field\'.');
    }

    /**************************************************************************************************************************
    * @description Test method to verify that getLookupFieldModelFromNameAndLabelMaps returns a null record type model when no match is found
    * for a specified developer or label name.
    ***************************************************************************************************************************/
    @isTest 
    private static void getLookupFieldModelFromNameAndLabelMapsNull() {
        Map<String, LookupFieldModel> lookupFieldModelsByName = new Map<String, LookupFieldModel>{
            'Lookup_Field_1' => new LookupFieldModel(
                'Lookup_Field_1', 
                'Lookup Field 1'
            )
        };

        Map<String, LookupFieldModel> lookupFieldModelsByLabel = new Map<String, LookupFieldModel>{
            'Lookup Field' => new LookupFieldModel(
                'Lookup_Field', 
                'Lookup Field'
            )
        };

        LookupFieldService lookupFieldServiceInstance = LookupFieldService.getInstance();

        Test.startTest();
        LookupFieldModel lookupFieldModelResult = 
            lookupFieldServiceInstance.getLookupFieldModelFromNameAndLabelMaps(
                'Non Existent Lookup Field Name',
                lookupFieldModelsByName,
                lookupFieldModelsByLabel
            );
        Test.stopTest();

        System.assertEquals(null, lookupFieldModelResult, 'Lookup field model should be null.');
    }

    /**************************************************************************************************************************
    ****************************************************** STUB CLASS *********************************************************
    **************************************************************************************************************************/

    /*************************************************************************************************************
    * @description Stub class to simulate the response from LookupFieldMapper to return Map<String, LookupFieldModel> 
    * for LookupField models by name and by label with valid mappings
    *************************************************************************************************************/
    private class STUB_LookupFieldMapperValid extends LookupFieldMapper {
        public override Map<String, LookupFieldModel> getModelByNameMapForSObjectType(SObjectType sObjectType, SObjectType lookupToSObjectType) {
            Map<String, LookupFieldModel> testLookupFieldModelsByName = new Map<String, LookupFieldModel>();

            testLookupFieldModelsByName.put('testName1', new LookupFieldModel('testName1', 'testLabel1'));
            testLookupFieldModelsByName.put('testName2', new LookupFieldModel('testName2', 'testLabel2'));
            testLookupFieldModelsByName.put('testName3', new LookupFieldModel('testName3', 'testLabel3'));

            return testLookupFieldModelsByName;
        }
    }

    /*************************************************************************************************************
    * @description Stub class to simulate the response from LookupFieldMapper to return Map<String, LookupFieldModel> 
    * for LookupField models by name and by label with empty mappings
    *************************************************************************************************************/
    private class STUB_LookupFieldMapperEmpty extends LookupFieldMapper {
        public override Map<String, LookupFieldModel> getModelByNameMapForSObjectType(SObjectType sObjectType, SObjectType lookupToSObjectType) {
            return new Map<String, LookupFieldModel>();
        }
    }
}
public virtual with sharing class MAPR_CON_PreferredEmailFields {

    /*********************************************
    * @description Instance for Singleton Pattern
    **********************************************/
    @TestVisible
    private static MAPR_CON_PreferredEmailFields instance;

    /***********************************************
    * @description preferredEmailFieldSettingsModel
    ***********************************************/
    @TestVisible
    private static MODL_PreferredEmailSettings preferredEmailFieldSettingsModel;

    /*****************************************************************************
    * @description Static method to get the current instance for Singleton pattern
    * @return The instance of MAPR_CON_PreferredEmailFields.
    ******************************************************************************/
    public static MAPR_CON_PreferredEmailFields getInstance() {

        if (instance == null) {
            instance = new MAPR_CON_PreferredEmailFields();
        }

        return instance;
    }

    /*********************************************************************
    * @description Empty constructor is not public for Singleton Pattern
    **********************************************************************/
    protected MAPR_CON_PreferredEmailFields() {}

    /**************************************************************************************
    * @description Returns the cached MODL_PreferredEmailSettings
    * @return MODL_PreferredEmailSettings
    **************************************************************************************/
    public MODL_PreferredEmailSettings getPreferredEmailSettingsModel() {

        if (preferredEmailFieldSettingsModel != null) {
            return preferredEmailFieldSettingsModel;
        }

        preferredEmailFieldSettingsModel = this.createEmailFieldSettingsModel();
        return preferredEmailFieldSettingsModel;
    }

    /**************************************************************************************
    * @description Returns the MODL_PreferredEmailSettings
    * @return MODL_PreferredEmailSettings
    **************************************************************************************/
    @TestVisible
    private MODL_PreferredEmailSettings createEmailFieldSettingsModel() {

        Boolean isPreferredEmailValidationEnabled = this.getPreferredEmailValidationEnabled();
        Map<String, Schema.DescribeFieldResult> contactEmailFieldsByApiName = this.getContactEmailFieldByApiName();
        Schema.DescribeFieldResult standardEmailField = contactEmailFieldsByApiName.get('Email');
        Map<String, String> preferredEmailPicklistValuesByLabel = this.getPreferredEmailPicklistValuesByLabel();
        Map<String, String> legacyPreferredEmailPicklistValuesByLabel = this.getLegacyPreferredEmailPicklistValuesByLabel();
        Map<String, String> preferredEmailPicklistLabelByApiName = this.getPreferredEmailPicklistLabelByApiName();
        String alternateEmailFieldPrefLabel;
        Map<String, String> edaEmailFieldAPINamesByLabel = this.getEDAEmailFieldsApiNamesByLabel(contactEmailFieldsByApiName);
        List<MODL_PreferredEmailField> prefEmailFieldModels = new List<MODL_PreferredEmailField>();
        EDAEmailFieldsModel edaEmailFieldModel = new EDAEmailFieldsModel(edaEmailFieldAPINamesByLabel);

        /* Construct a List of MODL_PreferredEmailField.cls records and alternateEmailFieldPrefLabel
           to be then used to create and return MODL_PreferredEmailSettings.cls record */
        for (String contactEmailfieldAPIName: contactEmailFieldsByApiName.keySet()) {

            String contactEmailFieldLabel = contactEmailFieldsByApiName.get(contactEmailfieldAPIName).getLabel();

            if (contactEmailfieldAPIName == standardEmailField.getName() || edaEmailFieldModel.hasDuplicateLabelForEDAField(contactEmailFieldLabel, contactEmailfieldAPIName) == true) {
                continue;
            }

            String preferredLabel = this.getPreferredLabelFromLabel(contactEmailFieldLabel, preferredEmailPicklistValuesByLabel, legacyPreferredEmailPicklistValuesByLabel);
            MODL_PreferredEmailField prefEmailFieldModel = new MODL_PreferredEmailField(contactEmailFieldLabel, contactEmailfieldAPIName, PreferredLabel);

            if (contactEmailfieldAPIName == UTIL_Namespace.StrTokenNSPrefix('AlternateEmail__c')) {
                alternateEmailFieldPrefLabel = prefEmailFieldModel.preferredLabel ;
            }
            prefEmailFieldModels.add(prefEmailFieldModel);
        }

        MODL_PreferredEmailSettings prefEmailSettingsModel = new MODL_PreferredEmailSettings(prefEmailFieldModels, alternateEmailFieldPrefLabel, standardEmailField.getLabel(), isPreferredEmailValidationEnabled, preferredEmailPicklistLabelByApiName);

        return prefEmailSettingsModel;
    }

    /**************************************************************************************
    * @description Returns the prefLabel that needs to be set for Preferred Email
    * @return prefLabel the prefLabel that needs to be set for Preferred Email
    **************************************************************************************/
    @TestVisible
    private String getPreferredLabelFromLabel(String emailTypeFieldLabel, Map<String, String> preferredEmailPicklistValuesByLabel, Map<String, String> legacyPreferredEmailPicklistValuesByLabel) {
        String prefLabel;
        if (preferredEmailPicklistValuesByLabel.containsKey(emailTypeFieldLabel)) {  
            prefLabel = preferredEmailPicklistValuesByLabel.get(emailTypeFieldLabel);
            return prefLabel;  
        }

        if (legacyPreferredEmailPicklistValuesByLabel.containsKey(emailTypeFieldLabel)) {  
            prefLabel = legacyPreferredEmailPicklistValuesByLabel.get(emailTypeFieldLabel);
            return prefLabel;  
        }

        prefLabel = emailTypeFieldLabel;
        return prefLabel;
    }

    /**************************************************************************************
    * @description Returns the value of Disable Preferred Email Enforcement custom settings
    * @return Boolean
    **************************************************************************************/
    @TestVisible
    private Boolean getPreferredEmailValidationEnabled() {
        return !UTIL_CustomSettingsFacade.getSettings().Disable_Preferred_Email_Enforcement__c;
    }

    /**************************************************************************************
    * @description Returns a map of Contact Email Field Describes by their API Names
    * @return Map<String, Schema.DescribeFieldResult>
    **************************************************************************************/
    @TestVisible
    private Map<String, Schema.DescribeFieldResult> getContactEmailFieldByApiName() {
        return UTIL_Describe.getFieldsOfType('Contact', 'EMAIL');
    }

    /**************************************************************************************
    * @description Returns a map of Preferred Email's picklist values by their labels
    * @return Map<String, String>
    **************************************************************************************/
    @TestVisible
    private Map<String, String> getPreferredEmailPicklistValuesByLabel() {
        return UTIL_Describe.getpicklistEntriesLabelToAPIMap('Contact', UTIL_Namespace.StrTokenNSPrefix('') + 'Preferred_Email__c');
    }

    /**************************************************************************************
    * @description Returns a map of Preferred Email's Legacy picklist values by their labels
    * @return Map<String, String>
    **************************************************************************************/
    @TestVisible
    private Map<String, String> getLegacyPreferredEmailPicklistValuesByLabel() {

        Map<String,String> legacyPreferredEmailPicklistValuesByLabel = new Map<String,String> {
                  'University Email' => 'University',
                 'Work Email' => 'Work',
                 'Alternate Email' => 'Alternate'
                };
      
        return legacyPreferredEmailPicklistValuesByLabel;            
    }

    /**************************************************************************************
    * @description Returns a map of Preferred Email's picklist Labels by their API names
    * @return Map<String, String>
    **************************************************************************************/
    @TestVisible
    private Map<String, String> getPreferredEmailPicklistLabelByApiName() {
        return UTIL_Describe.getPicklistEntriesApiToLabelMap('Contact', UTIL_Namespace.StrTokenNSPrefix('') + 'Preferred_Email__c');
    }

    /**************************************************************************************
    * @description Returns True if the API field name passed is an EDA field else false
    * @param fieldApiName The Contact Field's API name to check for
    * @return Boolean
    **************************************************************************************/
    @TestVisible
    private Boolean isEDAField(String fieldApiName) {

        String namespace = UTIL_Namespace.getNamespace();

        if (String.isNotBlank(namespace)) {
            return fieldApiName.startsWithIgnoreCase(namespace);
        }

        return fieldApiName.endsWithIgnoreCase('__c');
    }

    /**************************************************************************************
    * @description Returns A map of EDA Email Field Names By Label
    * @param contactFieldApiNames A map of Field Describes for Contact object by API names
    * @return edaEmailFieldAPINamesByLabels A map of EDA Email Field Names By Label
    **************************************************************************************/
    @TestVisible
    private Map<String,String> getEDAEmailFieldsApiNamesByLabel(Map<String, Schema.DescribeFieldResult> contactFieldApiNames) {

        Map<String, String> edaEmailFieldAPINamesByLabels = new Map<String, String>();

        for (String fieldApiName : contactFieldApiNames.keySet()) {
            if (this.isEDAField(fieldApiName) == true) {
                edaEmailFieldAPINamesByLabels.put(contactFieldApiNames.get(fieldApiName).getLabel(), fieldApiName);
            } 
        }

        return edaEmailFieldAPINamesByLabels;
    }

    /*******************************************************************************************************
    * @description A value object to determine if a field label or API name is a part of EDA Email fields
    ********************************************************************************************************/
    private class EDAEmailFieldsModel {

        private Map<String, String> edaEmailFieldApiNamesByLabel;
 
        private EDAEmailFieldsModel(Map<String, String> edaEmailFieldApiNamesByLabel) {
            this.edaEmailFieldApiNamesByLabel = edaEmailFieldApiNamesByLabel;
        }

        private Boolean hasDuplicateLabelForEDAField(String fieldLabel, String fieldApiName) {
            if (edaEmailFieldApiNamesByLabel.keySet().contains(fieldLabel) == false || 
                edaEmailFieldApiNamesByLabel.get(fieldLabel) == fieldApiName) {
                return false;
            }
            return true;
        }
    }

}
@isTest
private class MAPR_CON_PreferredEmailFields_TEST {

    /**************************************************************************************************************************
    * @description Test method to verify that the getInstance method returns a new instance of the 
    * MAPR_CON_PreferredEmailFields class when one does not already exist.
    ***************************************************************************************************************************/
    @isTest
    private static void getInstanceNew() {

        Test.startTest();
            MAPR_CON_PreferredEmailFields maprConPreferredEmailFieldsInstance = MAPR_CON_PreferredEmailFields.getInstance();
        Test.stopTest();

        System.assertEquals(MAPR_CON_PreferredEmailFields.instance, maprConPreferredEmailFieldsInstance, 'Instance of service class returned should match static instance variable.');
        System.assertEquals(true, maprConPreferredEmailFieldsInstance != null, 'Instance of service class should not be null.');
    }

    /**************************************************************************************************************************
    * @description Test method to verify that the getInstance method returns the existing instance of the 
    * MAPR_CON_PreferredEmailFields class when one already exists.
    ***************************************************************************************************************************/
    @isTest
    private static void getInstanceExisting() {

        Test.startTest();
            MAPR_CON_PreferredEmailFields maprConPreferredEmailFieldsInstance1 = MAPR_CON_PreferredEmailFields.getInstance();
            MAPR_CON_PreferredEmailFields maprConPreferredEmailFieldsInstance2 = MAPR_CON_PreferredEmailFields.getInstance();
        Test.stopTest();

        System.assertEquals(MAPR_CON_PreferredEmailFields.instance, maprConPreferredEmailFieldsInstance1, 'Instance of service class returned should match static instance variable.');
        System.assertEquals(maprConPreferredEmailFieldsInstance1, maprConPreferredEmailFieldsInstance2, 'Subsequent retrievals of service class instance should return existing instance.');
        System.assertEquals(true, maprConPreferredEmailFieldsInstance1 != null, 'Instance of service class should not be null.');
    }

    /*********************************************************************************************************************************************
    * @description Test method to verify that the getPreferredEmailSettingsModel returns MODL_PreferredEmailSettings
    **********************************************************************************************************************************************/
    @isTest
    private static void getPreferredEmailSettingsModelNew() {

        Test.startTest();
            MODL_PreferredEmailSettings prefEmailSettingsModel = MAPR_CON_PreferredEmailFields.getInstance().getPreferredEmailSettingsModel();
        Test.stopTest();

        System.assertEquals(false, prefEmailSettingsModel.preferredEmailFieldModels.isEmpty());
        System.assertEquals(true, String.isNotBlank(prefEmailSettingsModel.alternateEmailPreferredLabel));
        System.assertEquals(true, String.isNotBlank(prefEmailSettingsModel.emailLabel));
        System.assertEquals(false, prefEmailSettingsModel.preferredEmailPicklistLabelByApiName.isEmpty());
        
    }
    
    /*********************************************************************************************************************************************
    * @description Test method to verify that the getPreferredEmailSettingsModel returns cached MODL_PreferredEmailSettings
    **********************************************************************************************************************************************/
    @isTest
    private static void getPreferredEmailSettingsModelExisting() {

        MODL_PreferredEmailSettings prefEmailSettingsModel1 = MAPR_CON_PreferredEmailFields.getInstance().getPreferredEmailSettingsModel();
        Test.startTest();
            MODL_PreferredEmailSettings prefEmailSettingsModel2 = MAPR_CON_PreferredEmailFields.getInstance().getPreferredEmailSettingsModel();
        Test.stopTest();

        System.assertEquals(prefEmailSettingsModel1, prefEmailSettingsModel2);
        System.assertEquals(false, prefEmailSettingsModel2.preferredEmailFieldModels.isEmpty());
        System.assertEquals(true, String.isNotBlank(prefEmailSettingsModel2.alternateEmailPreferredLabel));
        System.assertEquals(true, String.isNotBlank(prefEmailSettingsModel2.emailLabel));
        System.assertEquals(false, prefEmailSettingsModel2.preferredEmailPicklistLabelByApiName.isEmpty());

    }
    
    /*********************************************************************************************************************************************
    * @description Test method to verify that the createEmailFieldSettingsModel returns MODL_PreferredEmailSettings
    **********************************************************************************************************************************************/
    @isTest
    private static void createEmailFieldSettingsModel() {

        Test.startTest();
            MODL_PreferredEmailSettings prefEmailSettingsModel = MAPR_CON_PreferredEmailFields.getInstance().createEmailFieldSettingsModel();
        Test.stopTest();

        System.assertEquals(false, prefEmailSettingsModel.preferredEmailFieldModels.isEmpty());
        System.assertEquals(true, String.isNotBlank(prefEmailSettingsModel.alternateEmailPreferredLabel));
        System.assertEquals(true, String.isNotBlank(prefEmailSettingsModel.emailLabel));
        System.assertEquals(false, prefEmailSettingsModel.preferredEmailPicklistLabelByApiName.isEmpty());

    }

    /*************************************************************************************************************************************************************
    * @description  Test method to verify that the getPreferredLabelFromLabel returns a Label when values is contained in preferredEmailPicklistValuesByLabel map
    *************************************************************************************************************************************************************/
    @isTest
    private static void getPreferredLabelFromLabel() {
        Map<String,String> legacyPreferredEmailPicklistValuesByLabel = new Map<String,String> {
                  'University Email' => 'University',
                 'Work Email' => 'Work',
                 'Alternate Email' => 'Alternate'
                };
                    
        Test.startTest();
            String preferredLabel =  MAPR_CON_PreferredEmailFields.getInstance().getPreferredLabelFromLabel('University Email', 
                                                                                                     UTIL_Describe.getpicklistEntriesLabelToAPIMap('Contact', UTIL_Namespace.StrTokenNSPrefix('') + 'Preferred_Email__c'),
                                                                                                    legacyPreferredEmailPicklistValuesByLabel);
        Test.stopTest();
        
        System.assertEquals('University Email', preferredLabel);
    }
    
    /******************************************************************************************************************************************************************
    * @description  Test method to verify that the getPreferredLabelFromLabel returns a Label when values is contained in legacyPreferredEmailPicklistValuesByLabel map
    ******************************************************************************************************************************************************************/
    @isTest
    private static void getPreferredLabelFromLabelLegacy() {
        Map<String, String> preferredEmailPicklistLabelByApiNameCustom = new Map<String, String>{
                'University' => 'University',
                'Work' => 'Work',
                'Alternate' => 'Alternate'
            };
                
         Map<String,String> legacyPreferredEmailPicklistValuesByLabel = new Map<String,String> {
            'University Email' => 'University',
                'Work Email' => 'Work',
                'Alternate Email' => 'Alternate'
             };
                    
        Test.startTest();
            String preferredLabel =  MAPR_CON_PreferredEmailFields.getInstance().getPreferredLabelFromLabel('University Email', 
                                                                                                     preferredEmailPicklistLabelByApiNameCustom,
                                                                                                     legacyPreferredEmailPicklistValuesByLabel);
        Test.stopTest();
        
        System.assertEquals('University', preferredLabel);
    }

    /******************************************************************************************************************************************************************
    * @description  Test method to verify that the getPreferredLabelFromLabel returns a Label when values is are
    * not in either preferredEmailPicklistValuesByLabel or legacyPreferredEmailPicklistValuesByLabel map
    ******************************************************************************************************************************************************************/
    @isTest
    private static void getPreferredLabelFromLabelCustom() {
        Map<String,String> legacyPreferredEmailPicklistValuesByLabel = new Map<String,String> {
            'University Email' => 'University',
                'Work Email' => 'Work',
                'Alternate Email' => 'Alternate'
                };
                    
        Test.startTest();
            String preferredLabel =  MAPR_CON_PreferredEmailFields.getInstance().getPreferredLabelFromLabel('Test Email Field', 
                                                                                                     UTIL_Describe.getpicklistEntriesLabelToAPIMap('Contact', UTIL_Namespace.StrTokenNSPrefix('') + 'Preferred_Email__c'),
                                                                                                    legacyPreferredEmailPicklistValuesByLabel);
        Test.stopTest();
        
        System.assertEquals('Test Email Field', preferredLabel);
    }

    /******************************************************************************************************************************************************************
    * @description Test method to verify that the getPreferredEmailValidationEnabled returns the negated value strored in Custom Settings
    ******************************************************************************************************************************************************************/
    @isTest
    private static void getPreferredEmailValidationEnabled() {

        UTIL_CustomSettingsFacade.getSettingsForTests(new Hierarchy_Settings__c
                                                      (Disable_Preferred_Email_Enforcement__c = true));
        
        Test.startTest();
            Boolean ispreferredEmailValidationEnabled = MAPR_CON_PreferredEmailFields.getInstance().getPreferredEmailValidationEnabled();
        Test.stopTest();
        
        System.assertEquals(false, ispreferredEmailValidationEnabled);

    }

    /*********************************************************************************************************************************************
    * @description  Test method to verify that the getContactEmailFieldByApiName returns a map of contact Email Field Describess By their API Names
    **********************************************************************************************************************************************/
    @isTest
    private static void getContactEmailFieldByApiName() {

        Test.startTest();
            Map<String, Schema.DescribeFieldResult> contactEmailFieldsByAPIName = MAPR_CON_PreferredEmailFields.getInstance().getContactEmailFieldByApiName();
        Test.stopTest();

        System.assertEquals(false, contactEmailFieldsByAPIName.isEmpty());
        System.assert(contactEmailFieldsByAPIName.get('Email') != null);
    }

    /*********************************************************************************************************************************************
    * @description Test method to verify that the getPreferredEmailPicklistValuesByLabel returns a map of contact Email Fields By their API Names
    **********************************************************************************************************************************************/
    @isTest
    private static void getPreferredEmailPicklistValuesByLabel() {

        Test.startTest();
            Map<String, String> contactEmailFieldsByAPIName = MAPR_CON_PreferredEmailFields.getInstance().getPreferredEmailPicklistValuesByLabel();
        Test.stopTest();

        System.assertEquals(false, contactEmailFieldsByAPIName.isEmpty());
    }

    /**********************************************************************************************************************************************************
    * @description Test method to verify that the getLegacyPreferredEmailPicklistValuesByLabel returns a map of contact legacy Email Fields By their API Names
    **********************************************************************************************************************************************************/
    @isTest
    private static void getLegacyPreferredEmailPicklistValuesByLabel() {

        Test.startTest();
            Map<String, String> contactEmailFieldsByAPIName = MAPR_CON_PreferredEmailFields.getInstance().getLegacyPreferredEmailPicklistValuesByLabel();
        Test.stopTest();

        System.assertEquals(false, contactEmailFieldsByAPIName.isEmpty());
        System.assertEquals('University', contactEmailFieldsByAPIName.get('University Email'));
        System.assertEquals('Work', contactEmailFieldsByAPIName.get('Work Email'));
        System.assertEquals('Alternate', contactEmailFieldsByAPIName.get('Alternate Email'));
    }

    /**********************************************************************************************************************************************************
    * @description Test method to verify that the getPreferredEmailPicklistLabelByApiName returns a map of contact legacy Email Fields By their API Names
    **********************************************************************************************************************************************************/
    @isTest
    private static void getPreferredEmailPicklistLabelByApiName() {

        Test.startTest();
            Map<String, String> preferredEmailPicklistLabelByApiName = MAPR_CON_PreferredEmailFields.getInstance().getPreferredEmailPicklistLabelByApiName();
        Test.stopTest();

        System.assertEquals(false, preferredEmailPicklistLabelByApiName.isEmpty());
    }

    /**********************************************************************************************************************************************************
    * @description Test method to verify that the isEDAField() returns true for a EDA field API name
    **********************************************************************************************************************************************************/
    @isTest
    private static void isEDAFieldPositiveTest() {

        Test.startTest();
            Boolean isEDAField = MAPR_CON_PreferredEmailFields.getInstance().isEDAField(UTIL_Namespace.StrTokenNSPrefix('') + 'Preferred_Email__c');
        Test.stopTest();

        System.assertEquals(true, isEDAField);
    }

    /**********************************************************************************************************************************************************
    * @description Test method to verify that the isEDAField() returns false for a standard field API name
    **********************************************************************************************************************************************************/
    @isTest
    private static void isEDAFieldNegativeTest() {

        Test.startTest();
            Boolean isEDAField = MAPR_CON_PreferredEmailFields.getInstance().isEDAField('Email');
        Test.stopTest();

        System.assertEquals(false, isEDAField);
    }

    /**********************************************************************************************************************************************************
    * @description Test method to verify that the getEDAEmailFieldsApiNamesByLabel() returns a map of edaEmailFieldAPINamesByLabels
    **********************************************************************************************************************************************************/
    @isTest
    private static void getEDAEmailFieldsApiNamesByLabelPoitiveTest() {

        Test.startTest();
            Map<String, String> edaEmailFieldAPINamesByLabels = MAPR_CON_PreferredEmailFields.getInstance().getEDAEmailFieldsApiNamesByLabel(UTIL_Describe.getFieldsOfType('Contact', 'EMAIL'));
        Test.stopTest();

        System.assertEquals(false, edaEmailFieldAPINamesByLabels.isEmpty());
    }

    /**********************************************************************************************************************************************************
    * @description Negative test for getEDAEmailFieldsApiNamesByLabel() to ensure the reurned Map is empty when no EDA Email fields are passed
    **********************************************************************************************************************************************************/
    @isTest
    private static void getEDAEmailFieldsApiNamesByLabelNegativeTest() {

        Map<String, Schema.DescribeFieldResult> contactEmailFieldDescribeByEmailAPI = new Map<String, Schema.DescribeFieldResult>();
        contactEmailFieldDescribeByEmailAPI.put('Email', UTIL_Describe.getFieldDescribe('Contact', 'Email'));

        Test.startTest();
            Map<String, String> edaEmailFieldAPINamesByLabels = MAPR_CON_PreferredEmailFields.getInstance().getEDAEmailFieldsApiNamesByLabel(contactEmailFieldDescribeByEmailAPI);
        Test.stopTest();

        System.assertEquals(true, edaEmailFieldAPINamesByLabels.isEmpty());
    }
}
public virtual with sharing class MAPR_PrimaryAffiliations {

    /*********************************************
    * @description Instance for Singleton Pattern
    **********************************************/
    @TestVisible
    private static MAPR_PrimaryAffiliations instance;

    /*****************************************************************************
    * @description Static method to get the current instance for Singleton pattern
    * @return The instance of MAPR_PrimaryAffiliations.
    ******************************************************************************/
    public static MAPR_PrimaryAffiliations getInstance() {
        if (instance == null) {
            instance = new MAPR_PrimaryAffiliations();
        }

        return instance;
    }

    /*********************************************************************
    * @description Empty constructor is not public for Singleton Pattern
    **********************************************************************/
    protected MAPR_PrimaryAffiliations() {}

    /**************************************************************************************
    * @description Returns the value of Affiliation_Record_Type_Enforced__c custom setting
    * @return boolean
    **************************************************************************************/
    @testVisible
    protected virtual boolean isPrimaryAffiliationValidationOn() {
        return UTIL_CustomSettingsFacade.getSettings().Affiliation_Record_Type_Enforced__c;
    }

    /**************************************************************************************
    * @description Returns a list of Models for Affiliation mappings
    * @return List<MODL_PrimaryAfflMapper>
    **************************************************************************************/
    public List<MODL_PrimaryAfflMapper> getModelsFromSettings() {
        List<Affl_Mappings__c> afflMappingsFromSettingsList = UTIL_CustomSettingsFacade.getPrimaryAfflMappings();
        return getModelsFromMappings(afflMappingsFromSettingsList);
    }

    /*********************************************************************************************************************
    * @description Returns a list of Models for Affiliation mappings for a given list of Affl_Mappings__c custom settings
    * @param afflMappingsList List of Affl_Mappings__c custom settings
    * @return List<MODL_PrimaryAfflMapper> List of models for the given list of Affl_Mappings__c custom settings
    *********************************************************************************************************************/
    @testVisible
    private List<MODL_PrimaryAfflMapper> getModelsFromMappings(List<Affl_Mappings__c> afflMappingsList) {
       List<MODL_PrimaryAfflMapper> affiliationModelsList = new List<MODL_PrimaryAfflMapper>();

       // Sets to ensure duplicate mappings won't have models added to the list to return
       Set<String> contactFieldAPINamesSet = new Set<String>();
       Set<String> accountRecordTypeIdsSet = new Set<String>();

        for (Affl_Mappings__c mapping: afflMappingsList) {
            MODL_PrimaryAfflMapper modelFromMapping = this.getModelFromMapping(mapping);

            if (modelFromMapping == null) {
                continue;
            }

            if ((contactFieldAPINamesSet.isEmpty() == false && contactFieldAPINamesSet.contains(modelFromMapping.getContactFieldApiName())) || 
                (accountRecordTypeIdsSet.isEmpty() == false && accountRecordTypeIdsSet.contains(modelFromMapping.getAccountRecordTypeId()))) {      
                continue;
            }

            affiliationModelsList.add(modelFromMapping);
            contactFieldAPINamesSet.add(modelFromMapping.getContactFieldApiName());
            accountRecordTypeIdsSet.add(modelFromMapping.getAccountRecordTypeId());

        }
       return affiliationModelsList;
    }

    /*****************************************************************************************************
    * @description Returns a Model for a given Affl_Mappings__c record
    * @param afflMapping An Affl_Mappings__c custom settings record
    * @return MODL_PrimaryAfflMapper A model for given Affl_Mappings__c record
    *****************************************************************************************************/
    @testVisible
    private MODL_PrimaryAfflMapper getModelFromMapping(Affl_Mappings__c afflMapping) {
        Boolean isValid = true;
        String invalidErrorMessage = '';

        List<MODL_PrimaryAfflMapper> primaryAfflModelsList = new List<MODL_PrimaryAfflMapper>();
        Set<Affl_Mappings__c> afflMappingSet = new Set<Affl_Mappings__c>();

        // Check if the Primary Affl Field an API name
        Schema.DescribeFieldResult primaryAfflFieldDescribe;

        try {
            primaryAfflFieldDescribe = UTIL_Describe.getFieldDescribe('Contact', afflMapping.Primary_Affl_Field__c);
        } catch (UTIL_Describe.SchemaDescribeException ex) {
            try{
                primaryAfflFieldDescribe = UTIL_Describe.getFieldDescribeByLabel('Contact', afflMapping.Primary_Affl_Field__c);
            } catch (UTIL_Describe.SchemaDescribeException exp) {
                return null;
            }
        }

        if (primaryAfflFieldDescribe == null) {
            // Affiliation mapping to Contact field that doesn't exist - skip mapping
            return null; 
        }

        if (UTIL_Describe.isLookupFieldTo(primaryAfflFieldDescribe, Account.SObjectType) == false){
            // Affiliation mapping to contact field that is not type Lookup(Account)
            List<String> params = new List<String>{
                Label.stgColContactPrimaryAfflField,
                afflMapping.Primary_Affl_Field__c
            };

            invalidErrorMessage = StringHandlingService.getInstance().formatStringWithApostrophesAndParameters(label.invalidContactFieldInAffiliationMapping, params);
        }
            
        // Get the record type info by developer name
        Schema.RecordTypeInfo accountRecTypeInfo = UTIL_Describe.getRecordTypeInfoByDeveloperName('Account', afflMapping.Account_Record_Type__c);
        // If we dont have a record type info, get the record type info by name
        if (accountRecTypeInfo == null) {
            accountRecTypeInfo = UTIL_Describe.getRecordTypeInfoByName('Account', afflMapping.Account_Record_Type__c);
        }

        if (accountRecTypeInfo == null) {
            if (this.isPrimaryAffiliationValidationOn() == true) {
                // Affiliation mapping to invalid record type
                isValid = false;

                // set custom error message text
                List<String> params = new List<String>{
                    Label.stgColAccountRecordType,
                    afflMapping.Account_Record_Type__c
                };
    
                invalidErrorMessage = StringHandlingService.getInstance().formatStringWithApostrophesAndParameters(label.invalidRecordTypeInAffiliationMapping, params);
            }

            MODL_PrimaryAfflMapper primaryAfflModel = new MODL_PrimaryAfflMapper(
                primaryAfflFieldDescribe, 
                afflMapping.Primary_Affl_Field__c, 
                afflMapping.Account_Record_Type__c, 
                isValid, 
                invalidErrorMessage);       

            return primaryAfflModel;
        }

        // primaryAfflFieldDescribe is null if contact field label mapping is invalid
        MODL_PrimaryAfflMapper primaryAfflModel = new MODL_PrimaryAfflMapper(
            accountRecTypeInfo, 
            primaryAfflFieldDescribe, 
            afflMapping.Primary_Affl_Field__c, 
            afflMapping.Account_Record_Type__c, 
            isValid,
            invalidErrorMessage);

        return primaryAfflModel;
    }
}
@isTest
private class MAPR_PrimaryAffiliations_TEST {

    /**************************************************************************************************************************************
    * @description Helper method to generate error message associated with a mapping to a field that does not lookup to Account.
    * @param  affiliationMapping An affiliation mapping with an invalid lookup field mapping.
    * @return The expected error message associated with the generated model.
    **************************************************************************************************************************************/
    private static String getExpectedInvalidFieldMappingErrorMessage(Affl_Mappings__c affiliationMapping){
        List<String> params = new List<String>{
            Label.stgColContactPrimaryAfflField,
            affiliationMapping.Primary_Affl_Field__c
        };

        return StringHandlingService.getInstance().formatStringWithApostrophesAndParameters(label.invalidContactFieldInAffiliationMapping, params);
    }

    /**************************************************************************************************************************************
    * @description Helper method to generate error message associated with a mapping to an invalid record type.
    * @param  affiliationMapping An affiliation mapping with an invalid record type mapping.
    * @return The expected error message associated with the generated model.
    **************************************************************************************************************************************/
    private static String getExpectedInvalidRTMappingErrorMessage(Affl_Mappings__c affiliationMapping){
        List<String> params = new List<String>{
            Label.stgColAccountRecordType,
            affiliationMapping.Account_Record_Type__c
        };

        return StringHandlingService.getInstance().formatStringWithApostrophesAndParameters(label.invalidRecordTypeInAffiliationMapping, params);
    }

    /**************************************************************************************************************************************
    * @description Inserts Affiliation mappings with RecordTypeDevName and PrimaryAffiliationFieldAPI
    ***************************************************************************************************************************************/
    static void insertAfflMappingsWithRecordTypeDevNameAndPrimaryFieldAPIs() {
        String prefix = UTIL_Namespace.StrTokenNSPrefix('');

        List<Affl_Mappings__c> mappings = new List<Affl_Mappings__c>();
        mappings.add(new Affl_Mappings__c(Name = 'Business Organization', Account_Record_Type__c = 'Business_Organization', Primary_Affl_Field__c = prefix + 'Primary_Organization__c'));
        mappings.add(new Affl_Mappings__c(Name = 'Household Account', Account_Record_Type__c = 'HH_Account', Primary_Affl_Field__c =  prefix + 'Primary_Household__c'));
        insert mappings;
    }

    /**************************************************************************************************************************************
    * @description Inserts Affiliation mappings with RecordTypeDevName and PrimaryAffiliationFieldLabels
    ***************************************************************************************************************************************/
    static void insertAfflMappingsWithRecordTypeDevNameAndPrimaryFieldLabels() {
        List<Affl_Mappings__c> mappings = new List<Affl_Mappings__c>();
        mappings.add(new Affl_Mappings__c(Name = 'Business Organization', Account_Record_Type__c = 'Business_Organization', Primary_Affl_Field__c = 'Primary Business Organization'));
        mappings.add(new Affl_Mappings__c(Name = 'Household Account', Account_Record_Type__c = 'HH_Account', Primary_Affl_Field__c = 'Primary Household'));
        insert mappings;
    } 

    /**************************************************************************************************************************************
    * @description Inserts Affiliation mappings with RecordTypeDevName and PrimaryAffiliationFieldAPIs
    ***************************************************************************************************************************************/
    static void insertAfflMappingsWithRecordTypeNameAndPrimaryFieldAPIs() {
        String prefix = UTIL_Namespace.StrTokenNSPrefix('');

        List<Affl_Mappings__c> mappings = new List<Affl_Mappings__c>();
        mappings.add(new Affl_Mappings__c(Name = 'Business Organization', Account_Record_Type__c = 'Business Organization', Primary_Affl_Field__c = prefix + 'Primary_Organization__c'));
        mappings.add(new Affl_Mappings__c(Name = 'Household Account', Account_Record_Type__c = 'Household Account', Primary_Affl_Field__c = prefix + 'Primary_Household__c'));
        insert mappings;
    }

    /**************************************************************************************************************************************
    * @description Inserts Affiliation mappings with RecordTypeName and PrimaryAffiliationFieldLabels
    ***************************************************************************************************************************************/
    static void insertAfflMappingsWithRecordTypeNameAndPrimaryFieldLabels() {
        List<Affl_Mappings__c> mappings = new List<Affl_Mappings__c>();
        mappings.add(new Affl_Mappings__c(Name = 'Business Organization', Account_Record_Type__c = 'Business Organization', Primary_Affl_Field__c = 'Primary Business Organization'));
        mappings.add(new Affl_Mappings__c(Name = 'Household Account', Account_Record_Type__c = 'Household Account', Primary_Affl_Field__c = 'Primary Household'));
        insert mappings;
    }

    /**************************************************************************************************************************************
    * @description Inserts Affiliation mappings with RecordTypeName and inaccurate PrimaryAffiliationFieldLabels
    ***************************************************************************************************************************************/
    static void insertAfflMappingsWithRecordTypeNameAndInaccuratePrimaryFieldLabels() {
        List<Affl_Mappings__c> mappings = new List<Affl_Mappings__c>();
        mappings.add(new Affl_Mappings__c(Name = 'Business Organization', Account_Record_Type__c = 'Business Organization', Primary_Affl_Field__c = 'Wrong field Label1'));
        mappings.add(new Affl_Mappings__c(Name = 'Household Account', Account_Record_Type__c = 'Household Account', Primary_Affl_Field__c = 'Wrong field Label2'));
        insert mappings;
    }

    /**************************************************************************************************************************************
    * @description Inserts Affiliation mappings with valid RecordTypeName and valid PrimaryAffiliationFieldLabels to a field that does not
    * lookup to Account.
    ***************************************************************************************************************************************/
    static void insertAfflMappingsWithValidRecordTypeNameAndNonLookupPrimaryFieldLabels() {
        List<Affl_Mappings__c> mappings = new List<Affl_Mappings__c>();
        mappings.add(new Affl_Mappings__c(Name = 'Business Organization', Account_Record_Type__c = 'Business Organization', Primary_Affl_Field__c = 'FirstName'));
        mappings.add(new Affl_Mappings__c(Name = 'Household Account', Account_Record_Type__c = 'Household Account', Primary_Affl_Field__c = 'Wrong field Label2'));
        insert mappings;
    }

    /**************************************************************************************************************************************
    * @description Inserts Affiliation mappings with inaccurate RecordTypeName and accurate PrimaryAffiliationFieldLabels
    ***************************************************************************************************************************************/
    static void insertAfflMappingsWithInaccurateRecordTypeNameAndAccuratePrimaryFieldLabels() {
        List<Affl_Mappings__c> mappings = new List<Affl_Mappings__c>();
        mappings.add(new Affl_Mappings__c(Name = 'Business Organization', Account_Record_Type__c = 'Business Org test', Primary_Affl_Field__c = 'Primary Business Organization'));
        mappings.add(new Affl_Mappings__c(Name = 'Household Account', Account_Record_Type__c = 'Household Org Account test', Primary_Affl_Field__c = 'Primary Household'));
        insert mappings;
    }

    /**************************************************************************************************************************************
    * @description Inserts Affiliation mappings with inaccurate RecordTypeName and PrimaryAffiliationFieldLabels for a valid field that 
    * does not lookup to Account.
    ***************************************************************************************************************************************/
    static void insertAfflMappingsWithInaccurateRecordTypeNameAndNonLookupPrimaryFieldLabels() {
        List<Affl_Mappings__c> mappings = new List<Affl_Mappings__c>();
        mappings.add(new Affl_Mappings__c(Name = 'Business Organization', Account_Record_Type__c = 'Business Org test', Primary_Affl_Field__c = 'FirstName'));
        mappings.add(new Affl_Mappings__c(Name = 'Household Account', Account_Record_Type__c = 'Household Org Account test', Primary_Affl_Field__c = 'Primary Household'));
        insert mappings;
    }

    /**************************************************************************************************************************************
    * @description Inserts Affiliation mappings with inaccurate RecordTypeName and inaccurate PrimaryAffiliationFieldLabels
    ***************************************************************************************************************************************/
    static void insertAfflMappingsWithInaccurateRecordTypeNameAndInAccuratePrimaryFieldLabels() {

        List<Affl_Mappings__c> mappings = new List<Affl_Mappings__c>();
        mappings.add(new Affl_Mappings__c(Name = 'Business Organization', Account_Record_Type__c = 'Business Org test', Primary_Affl_Field__c = 'Primary Business Organization test'));
        mappings.add(new Affl_Mappings__c(Name = 'Household Account', Account_Record_Type__c = 'Household Org Account test', Primary_Affl_Field__c = 'Primary Household test'));
        insert mappings;
    }

    /**************************************************************************************************************************
    * @description Test method to verify that the getInstance method returns a new instance of the 
    * MAPR_PrimaryAffiliations class when one does not already exist.
    ***************************************************************************************************************************/
    @isTest
    private static void getInstanceNew() {
        Test.startTest();
            MAPR_PrimaryAffiliations maprPrimaryAfflInstance = MAPR_PrimaryAffiliations.getInstance();
        Test.stopTest();
        System.assertEquals(MAPR_PrimaryAffiliations.instance, maprPrimaryAfflInstance, 'Instance of service class returned should match static instance variable.');
        System.assertEquals(true, maprPrimaryAfflInstance != null, 'Instance of service class should not be null.');
    }

    /**************************************************************************************************************************
    * @description Test method to verify that the getInstance method returns the existing instance of the 
    * MAPR_PrimaryAffiliations class when one already exists.
    ***************************************************************************************************************************/
    @isTest
    private static void getInstanceExisting() {
        Test.startTest();
            MAPR_PrimaryAffiliations maprPrimaryAfflInstance1 = MAPR_PrimaryAffiliations.getInstance();
            MAPR_PrimaryAffiliations maprPrimaryAfflInstance2 = MAPR_PrimaryAffiliations.getInstance();
        Test.stopTest();

        System.assertEquals(MAPR_PrimaryAffiliations.instance, maprPrimaryAfflInstance1, 'Instance of service class returned should match static instance variable.');
        System.assertEquals(maprPrimaryAfflInstance1, maprPrimaryAfflInstance2, 'Subsequent retrievals of service class instance should return existing instance.');
        System.assertEquals(true, maprPrimaryAfflInstance1 != null, 'Instance of service class should not be null.');
    }

    /**************************************************************************************************************************
    * @description Test method to verify that the isPrimaryAffiliationValidationOn method returns 
    * the value from Custom Settings
    ***************************************************************************************************************************/
    @isTest
    private static void isPrimaryAffiliationValidationOnTrueTest() {
        UTIL_CustomSettings_API.getSettingsForTests(new Hierarchy_Settings__c(Affiliation_Record_Type_Enforced__c = true));

        Test.startTest();
            Boolean isValidationOn = MAPR_PrimaryAffiliations.getInstance().isPrimaryAffiliationValidationOn();
        Test.stopTest();

        System.assertEquals(true, isValidationOn);
    }

    /**************************************************************************************************************************
    * @description Test method to verify that the isPrimaryAffiliationValidationOn method returns 
    * the value from Custom Settings
    ***************************************************************************************************************************/
    @isTest
    private static void isPrimaryAffiliationValidationOnFalseTest() {
        UTIL_CustomSettings_API.getSettingsForTests(new Hierarchy_Settings__c(Affiliation_Record_Type_Enforced__c = false));
        Test.startTest();
            Boolean isValidationOn = MAPR_PrimaryAffiliations.getInstance().isPrimaryAffiliationValidationOn();
        Test.stopTest();

        System.assertEquals(false, isValidationOn);
    }

    /**************************************************************************************************************************************
    * @description Test method to verify that the getModelsFromSettings method with 
    * Record Type Dev Name And Primary Field APIs in Settings returns models
    ***************************************************************************************************************************************/
    @isTest
    private static void getModelsFromSettingsTestDevNameAndPrimaryFieldAPIs() {
        MAPR_PrimaryAffiliations_TEST.insertAfflMappingsWithRecordTypeDevNameAndPrimaryFieldAPIs();
        MAPR_PrimaryAffiliations maprPrimaryAfflInstance = MAPR_PrimaryAffiliations.getInstance();

        Test.startTest();
            List<MODL_PrimaryAfflMapper> primaryAfflModels = maprPrimaryAfflInstance.getModelsFromSettings();
        Test.stopTest();

        System.assertEquals(2, primaryAfflModels.size());
    }
    
    /**************************************************************************************************************************************
    * @description Test method to verify that the getModelsFromSettings method with 
    * Record Type Dev Name And Primary Field Labels in Settings returns models
    ***************************************************************************************************************************************/
    @isTest
    private static void getModelsFromSettingsTestDevNameAndPrimaryFieldLabels() {
        MAPR_PrimaryAffiliations_TEST.insertAfflMappingsWithRecordTypeDevNameAndPrimaryFieldLabels();
        MAPR_PrimaryAffiliations maprPrimaryAfflInstance = MAPR_PrimaryAffiliations.getInstance();

        Test.startTest();
            List<MODL_PrimaryAfflMapper> primaryAfflModels = maprPrimaryAfflInstance.getModelsFromSettings();
        Test.stopTest();

        System.assertEquals(2, primaryAfflModels.size());
    }
    
    /**************************************************************************************************************************************
    * @description Test method to verify that the getModelsFromSettings method with 
    * Record Type Name And Primary Field APIs in Settings returns models
    ***************************************************************************************************************************************/
    @isTest
    private static void getModelsFromSettingsTestWithRecTypeNameAndPrimaryFieldAPIs() {
        MAPR_PrimaryAffiliations_TEST.insertAfflMappingsWithRecordTypeNameAndPrimaryFieldAPIs();
        MAPR_PrimaryAffiliations maprPrimaryAfflInstance = MAPR_PrimaryAffiliations.getInstance();

        Test.startTest();
            List<MODL_PrimaryAfflMapper> primaryAfflModels = maprPrimaryAfflInstance.getModelsFromSettings();
        Test.stopTest();

        System.assertEquals(2, primaryAfflModels.size());

    }
    
    /**************************************************************************************************************************************
    * @description Test method to verify that the getModelsFromSettings method with 
    * Record Type Name And Primary Field Labels in Settings returns models
    ***************************************************************************************************************************************/
    @isTest
    private static void getModelsFromSettingsTestWithRecTypeNameAndPrimaryFieldLabels() {
        MAPR_PrimaryAffiliations_TEST.insertAfflMappingsWithRecordTypeNameAndPrimaryFieldLabels();
        MAPR_PrimaryAffiliations maprPrimaryAfflInstance = MAPR_PrimaryAffiliations.getInstance();

        Test.startTest();
            List<MODL_PrimaryAfflMapper> primaryAfflModels = maprPrimaryAfflInstance.getModelsFromSettings();
        Test.stopTest();

        System.assertEquals(2, primaryAfflModels.size());
    }

    /**************************************************************************************************************************************
    * @description Test method to verify that the getModelsFrommappings method with 
    * Record Type Dev Name And Primary Field APIs in Settings returns models
    ***************************************************************************************************************************************/
    @isTest
    private static void getModelsFromMappingsTestWithRecTypeDevNameAndPrimaryFieldAPIs() {
        MAPR_PrimaryAffiliations_TEST.insertAfflMappingsWithRecordTypeDevNameAndPrimaryFieldAPIs();
        MAPR_PrimaryAffiliations maprPrimaryAfflInstance = MAPR_PrimaryAffiliations.getInstance();

        List<Affl_Mappings__c> primaryAfflMappings = UTIL_CustomSettingsFacade.getPrimaryAfflMappings();
        Test.startTest();
            List<MODL_PrimaryAfflMapper> primaryAfflModels = maprPrimaryAfflInstance.getModelsFromMappings(primaryAfflMappings);
        Test.stopTest();
 
        System.assertEquals(2, primaryAfflModels.size());
    }

    /**************************************************************************************************************************************
    * @description Test method to verify that the getModelsFromMappings method with 
    * Record Type Dev Name And Primary Field APIs in Settings returns no models
    ***************************************************************************************************************************************/
    @isTest
    private static void getModelsFromMappingsTestNoModelTest() {
        MAPR_PrimaryAffiliations_TEST.insertAfflMappingsWithRecordTypeNameAndInaccuratePrimaryFieldLabels();
        MAPR_PrimaryAffiliations maprPrimaryAfflInstance = new STUB_PrimaryAffiliationValidationOff();

        List<Affl_Mappings__c> primaryAfflMappings = UTIL_CustomSettingsFacade.getPrimaryAfflMappings();
        Test.startTest();
            List<MODL_PrimaryAfflMapper> primaryAfflModels = maprPrimaryAfflInstance.getModelsFromMappings(primaryAfflMappings);
        Test.stopTest();
 
        System.assertEquals(true, primaryAfflModels.isEmpty());
    }

    /**************************************************************************************************************************************
    * @description Test method to verify that the getModelsFromSettings method with 
    * duplicate Settings will filter duplicate models 
    ***************************************************************************************************************************************/
    @isTest
    private static void getModelsFromMappingsTestWithDevNameAndPrimaryFieldAPIsWithDuplicates() {
        String prefix = UTIL_Namespace.StrTokenNSPrefix('');

        MAPR_PrimaryAffiliations_TEST.insertAfflMappingsWithRecordTypeDevNameAndPrimaryFieldAPIs();
        MAPR_PrimaryAffiliations maprPrimaryAfflInstance = MAPR_PrimaryAffiliations.getInstance();

        List<Affl_Mappings__c> mappings = new List<Affl_Mappings__c>();
        mappings.add(new Affl_Mappings__c(Name = 'Business Organization duplicate', Account_Record_Type__c = 'Business_Organization', Primary_Affl_Field__c = prefix + 'Primary_Organization__c'));
        insert mappings;
 
        List<Affl_Mappings__c> primaryAfflMappings = UTIL_CustomSettingsFacade.getPrimaryAfflMappings();

        Test.startTest();
            List<MODL_PrimaryAfflMapper> primaryAfflModels = maprPrimaryAfflInstance.getModelsFromMappings(primaryAfflMappings);
        Test.stopTest();

        System.assertEquals(2, primaryAfflModels.size());
    }

    /**************************************************************************************************************************************
    * @description Test method to verify that the getModelFromMapping method with valid
    * Record Type Dev Name And valid Primary Field APIs in Settings returns valid Affiliation Mapping model
    ***************************************************************************************************************************************/
    @isTest
    private static void getModelFromMappingTestRecTypeDevNameAndPrimaryFieldAPI() {
        MAPR_PrimaryAffiliations_TEST.insertAfflMappingsWithRecordTypeDevNameAndPrimaryFieldAPIs();
        MAPR_PrimaryAffiliations maprPrimaryAfflInstance = MAPR_PrimaryAffiliations.getInstance();

        List<Affl_Mappings__c> primaryAfflMappings = UTIL_CustomSettingsFacade.getPrimaryAfflMappings();

        Test.startTest();
            MODL_PrimaryAfflMapper primaryAfflModel = maprPrimaryAfflInstance.getModelFromMapping(primaryAfflMappings[0]);
        Test.stopTest();

        String prefix = UTIL_Namespace.StrTokenNSPrefix('');

        System.assert(primaryAfflModel != null);
        System.assertEquals(true, primaryAfflModel.getIsValid());
        System.assertEquals(true, String.isBlank(primaryAfflModel.getInvalidErrorMessage()));
        System.assertEquals('Business_Organization', primaryAfflModel.getSettingsRecordTypeFieldValue());
        System.assertEquals(prefix + 'Primary_Organization__c', primaryAfflModel.getSettingsContactFieldValue());
        System.assertEquals(prefix + 'Primary_Organization__c', primaryAfflModel.getContactFieldApiName());
        System.assertEquals(UTIL_Describe_API.getBizAccRecTypeID(), primaryAfflModel.getAccountRecordTypeId());
    }
    
    /**************************************************************************************************************************************
    * @description Test method to verify that the getModelFromMapping method with valid
    * RecordType Dev Name And valid Primary Field Label in Settings returns valid Affiliation mapping model
    ***************************************************************************************************************************************/
    @isTest
    private static void getModelFromMappingTestWithRecTypeDevNameAndFieldLabel() {
        MAPR_PrimaryAffiliations_TEST.insertAfflMappingsWithRecordTypeDevNameAndPrimaryFieldLabels();
        MAPR_PrimaryAffiliations maprPrimaryAfflInstance = MAPR_PrimaryAffiliations.getInstance();

        List<Affl_Mappings__c> primaryAfflMappings = UTIL_CustomSettingsFacade.getPrimaryAfflMappings();

        Test.startTest();
            MODL_PrimaryAfflMapper primaryAfflModel = maprPrimaryAfflInstance.getModelFromMapping(primaryAfflMappings[0]);
        Test.stopTest();

        String prefix = UTIL_Namespace.StrTokenNSPrefix('');

        System.assert(primaryAfflModel != null);
        System.assertEquals(true, primaryAfflModel.getIsValid());
        System.assertEquals(true, String.isBlank(primaryAfflModel.getInvalidErrorMessage()));
        System.assertEquals('Business_Organization', primaryAfflModel.getSettingsRecordTypeFieldValue());
        System.assertEquals('Primary Business Organization', primaryAfflModel.getSettingsContactFieldValue());
        System.assertEquals(prefix + 'Primary_Organization__c', primaryAfflModel.getContactFieldApiName());
        System.assertEquals(UTIL_Describe_API.getBizAccRecTypeID(), primaryAfflModel.getAccountRecordTypeId());
    }

    /**************************************************************************************************************************************
    * @description Test method to verify that the getModelFromMapping method with 
    * valid Record Type Name And valid Primary Field API in Settings return valid Affiliation mapping model
    ***************************************************************************************************************************************/
    @isTest
    private static void getModelFromMappingTestWithRecTypeNameAndFieldAPI() {
        MAPR_PrimaryAffiliations_TEST.insertAfflMappingsWithRecordTypeNameAndPrimaryFieldAPIs();
        MAPR_PrimaryAffiliations maprPrimaryAfflInstance = MAPR_PrimaryAffiliations.getInstance();

        List<Affl_Mappings__c> primaryAfflMappings = UTIL_CustomSettingsFacade.getPrimaryAfflMappings();

        Test.startTest();
            MODL_PrimaryAfflMapper primaryAfflModel = maprPrimaryAfflInstance.getModelFromMapping(primaryAfflMappings[0]);
        Test.stopTest();

        String prefix = UTIL_Namespace.StrTokenNSPrefix('');

        System.assert(primaryAfflModel != null);
        System.assertEquals(true, primaryAfflModel.getIsValid());
        System.assertEquals(true, String.isBlank(primaryAfflModel.getInvalidErrorMessage()));
        System.assertEquals('Business Organization', primaryAfflModel.getSettingsRecordTypeFieldValue());
        System.assertEquals(prefix + 'Primary_Organization__c', primaryAfflModel.getSettingsContactFieldValue());
        System.assertEquals(prefix + 'Primary_Organization__c', primaryAfflModel.getContactFieldApiName());
        System.assertEquals(UTIL_Describe_API.getBizAccRecTypeID(), primaryAfflModel.getAccountRecordTypeId());
    }

    /**************************************************************************************************************************************
    * @description Test method to verify that the getModelFromMapping method with 
    * valid RecordType Name And valid Primary Field Label in Settings returns a valid Affiliation mapping model
    ***************************************************************************************************************************************/
    @isTest
    private static void getModelFromMappingTestWithRecTypeNameAndFieldLabel() {
        MAPR_PrimaryAffiliations_TEST.insertAfflMappingsWithRecordTypeNameAndPrimaryFieldLabels();
        MAPR_PrimaryAffiliations maprPrimaryAfflInstance = MAPR_PrimaryAffiliations.getInstance();

        List<Affl_Mappings__c> primaryAfflMappings = UTIL_CustomSettingsFacade.getPrimaryAfflMappings();

        Test.startTest();
            MODL_PrimaryAfflMapper primaryAfflModel = maprPrimaryAfflInstance.getModelFromMapping(primaryAfflMappings[0]);
        Test.stopTest();

        String prefix = UTIL_Namespace.StrTokenNSPrefix('');

        System.assert(primaryAfflModel != null);
        System.assertEquals(true, primaryAfflModel.getIsValid());
        System.assertEquals(true, String.isBlank(primaryAfflModel.getInvalidErrorMessage()));
        System.assertEquals('Business Organization', primaryAfflModel.getSettingsRecordTypeFieldValue());
        System.assertEquals('Primary Business Organization', primaryAfflModel.getSettingsContactFieldValue());
        System.assertEquals(prefix + 'Primary_Organization__c', primaryAfflModel.getContactFieldApiName());
        System.assertEquals(UTIL_Describe_API.getBizAccRecTypeID(), primaryAfflModel.getAccountRecordTypeId());
    }

    /**************************************************************************************************************************************
    * @description Test method to verify that the getModelFromMapping method with accurate
    * Record Type Name And inaccurate Primary Field Label in Settings returns a null value when Record Type Validation is enabled.
    ***************************************************************************************************************************************/
    @isTest
    private static void getModelFromMappingTestWithAccurateRecordTypeAndInaccurateFieldLabelWithValidationOn() {
        MAPR_PrimaryAffiliations_TEST.insertAfflMappingsWithRecordTypeNameAndInaccuratePrimaryFieldLabels();
        MAPR_PrimaryAffiliations maprPrimaryAfflInstance = new STUB_PrimaryAffiliationValidationOn();

        List<Affl_Mappings__c> primaryAfflMappings = UTIL_CustomSettingsFacade.getPrimaryAfflMappings();

        Test.startTest();
        MODL_PrimaryAfflMapper primAffMapResult = maprPrimaryAfflInstance.getModelFromMapping(primaryAfflMappings[0]);
        Test.stopTest();

        System.assertEquals(null, primAffMapResult, 'Affiliation mapping with invalid Contact field should return null value when validation is enabled.');
    } 

    /**************************************************************************************************************************************
    * @description Test method to verify that the getModelFromMapping method with 
    * accurate RecordType Name And invalid Primary Field Label in Settings when validation is off returns null
    ***************************************************************************************************************************************/
    @isTest
    private static void getModelFromMappingTestWithAccurateRecordTypeAndInaccurateFieldLabelWithValidationOff() {
        MAPR_PrimaryAffiliations_TEST.insertAfflMappingsWithRecordTypeNameAndInaccuratePrimaryFieldLabels();
        MAPR_PrimaryAffiliations maprPrimaryAfflInstance = new STUB_PrimaryAffiliationValidationOff();

        List<Affl_Mappings__c> primaryAfflMappings = UTIL_CustomSettingsFacade.getPrimaryAfflMappings();

        Test.startTest();
        MODL_PrimaryAfflMapper primaryAfflModel = maprPrimaryAfflInstance.getModelFromMapping(primaryAfflMappings[0]);
        Test.stopTest();

        System.assertEquals(null, primaryAfflModel, 'Affiliation mapping with invalid Contact field should return null value when validation is not enabled.');
    }

    /**************************************************************************************************************************************
    * @description Test method to verify that the getModelFromMapping method with a valid RecordType Dev Name and valid Primary Field Label
    * that is a not a lookup to Account in Settings generates a valid affiliation mapping model with an error indicating an invalid field mapping.
    ***************************************************************************************************************************************/
    @isTest
    private static void getModelFromMappingTestWithTextFieldAsLabelAndValidationOn() {
        String bizAccRecordTypeId = UTIL_Describe_API.getBizAccRecTypeID(); 

        List<Affl_Mappings__c> mappings = new List<Affl_Mappings__c>();
        mappings.add(new Affl_Mappings__c(Name = 'Business Organization', Account_Record_Type__c = 'Business_Organization', Primary_Affl_Field__c = 'Gender'));
        insert mappings;

        MAPR_PrimaryAffiliations maprPrimaryAfflInstance = new STUB_PrimaryAffiliationValidationOn();

        List<Affl_Mappings__c> primaryAfflMappings = UTIL_CustomSettingsFacade.getPrimaryAfflMappings();

        Test.startTest();
        MODL_PrimaryAfflMapper primaryAfflModel = maprPrimaryAfflInstance.getModelFromMapping(primaryAfflMappings[0]);
        Test.stopTest();

        String prefix = UTIL_Namespace.StrTokenNSPrefix('');
       
        System.assertEquals(true, primaryAfflModel.getIsValid(), 'Affiliation mapping for valid Contact field and Account record type should be valid.');
        System.assertEquals (MAPR_PrimaryAffiliations_TEST.getExpectedInvalidFieldMappingErrorMessage(primaryAfflMappings[0]), primaryAfflModel.getInvalidErrorMessage(), 'Invalid error message should be populated for non lookup field mapping.');
        System.assertEquals(bizAccRecordTypeId, primaryAfflModel.getAccountRecordTypeId(), 'Record type for Affiliation mapping should be Business Organization.');
        System.assertEquals(prefix + 'Gender__c', primaryAfflModel.getContactFieldApiName(), 'Contact field API name for Affiliation mapping should be Gender__c.');
        System.assertEquals('Gender', primaryAfflModel.getSettingsContactFieldValue(), 'Contact field name for Affiliation mapping should be Gender.');
        System.assertEquals('Business_Organization', primaryAfflModel.getSettingsRecordTypeFieldValue(), 'Record type name for Affiliation mapping should be Business_Organization.');
    } 

    /**************************************************************************************************************************************
    * @description Test method to verify that the getModelFromMapping method with a valid RecordType Dev Name an invalid Primary Field API
    * in Settings returns null.
    ***************************************************************************************************************************************/
    @isTest
    private static void getModelFromMappingTestWithLookupFieldAsAPIAndValidationOn() {
        List<Affl_Mappings__c> mappings = new List<Affl_Mappings__c>();
        mappings.add(new Affl_Mappings__c(Name = 'Business Organization', Account_Record_Type__c = 'Business_Organization', Primary_Affl_Field__c = 'Not a Contact Field'));
        insert mappings;

        MAPR_PrimaryAffiliations maprPrimaryAfflInstance = new STUB_PrimaryAffiliationValidationOn();

        List<Affl_Mappings__c> primaryAfflMappings = UTIL_CustomSettingsFacade.getPrimaryAfflMappings();

        Test.startTest();
        MODL_PrimaryAfflMapper primAffMapResult = maprPrimaryAfflInstance.getModelFromMapping(primaryAfflMappings[0]);
        Test.stopTest();

        System.assertEquals(null, primAffMapResult, 'An invalid Contact field mapping should return null when validation is enabled.');
    } 

    /**************************************************************************************************************************************
    * @description Test method to verify that the getModelFromMapping method with invalid 
    * RecordType Name And and valid Primary Field Label in Settings generates and invalid model when Record Type validations is enabled.
    ***************************************************************************************************************************************/
    @isTest
    private static void getModelFromMappingTestWithInaccurateRecordTypeAndValidationOn() {
        MAPR_PrimaryAffiliations_TEST.insertAfflMappingsWithInaccurateRecordTypeNameAndAccuratePrimaryFieldLabels();
        MAPR_PrimaryAffiliations maprPrimaryAfflInstance = new STUB_PrimaryAffiliationValidationOn();

        List<Affl_Mappings__c> primaryAfflMappings = UTIL_CustomSettingsFacade.getPrimaryAfflMappings();

        Test.startTest();
            MODL_PrimaryAfflMapper primaryAfflModel = maprPrimaryAfflInstance.getModelFromMapping(primaryAfflMappings[0]);
        Test.stopTest();

        String prefix = UTIL_Namespace.StrTokenNSPrefix('');
        
        System.assertEquals(
            false, 
            primaryAfflModel.getIsValid(), 
            'Affiliation mapping model should be invalid for invalid Account Record Type.'
        );
        System.assertEquals(
            MAPR_PrimaryAffiliations_TEST.getExpectedInvalidRTMappingErrorMessage(primaryAfflMappings[0]), 
            primaryAfflModel.getInvalidErrorMessage(), 
            'Invalid error message should be populated.'
        );
        System.assertEquals(
            prefix + 'Primary_Organization__c', 
            primaryAfflModel.getContactFieldApiName(), 
            'Contact field API name for Affiliation mapping model should be Primary_Organization__c.'
        );
        System.assertEquals(
            'Primary Business Organization', 
            primaryAfflModel.getSettingsContactFieldValue(), 
            'Contact field API name for Affiliation mapping model should be Primary Business Organization.'
        );
        System.assertEquals(
            'Business Org test', 
            primaryAfflModel.getSettingsRecordTypeFieldValue(), 
            'Record type for Affiliation mapping model should be set as Business org test.'
        );
    }

    /**************************************************************************************************************************************
    * @description Test method to verify that the getModelFromMapping method will return a valid Affiliation mapping model when 
    * inaccurate RecordType Dev Name and valid Primary Field Label in Settings when validation is Off
    ***************************************************************************************************************************************/
    @isTest
    private static void getModelFromMappingTestWithInaccurateRecordTypeAndValidationOff() {
        MAPR_PrimaryAffiliations_TEST.insertAfflMappingsWithInaccurateRecordTypeNameAndAccuratePrimaryFieldLabels();
        MAPR_PrimaryAffiliations maprPrimaryAfflInstance = new STUB_PrimaryAffiliationValidationOff();

        List<Affl_Mappings__c> primaryAfflMappings = UTIL_CustomSettingsFacade.getPrimaryAfflMappings();

        Test.startTest();
            MODL_PrimaryAfflMapper primaryAfflModel = maprPrimaryAfflInstance.getModelFromMapping(primaryAfflMappings[0]);
        Test.stopTest();

        String prefix = UTIL_Namespace.StrTokenNSPrefix('');

        System.assert(primaryAfflModel != null);
        System.assertEquals(true, primaryAfflModel.getIsValid());
        System.assertEquals(true, String.isBlank(primaryAfflModel.getInvalidErrorMessage()));
        System.assertEquals('Business Org test', primaryAfflModel.getAccountRecordTypeId());
        System.assertEquals(prefix + 'Primary_Organization__c', primaryAfflModel.getContactFieldApiName());
        System.assertEquals('Primary Business Organization', primaryAfflModel.getSettingsContactFieldValue());
        System.assertEquals('Business Org test', primaryAfflModel.getSettingsRecordTypeFieldValue());
    }

    /**************************************************************************************************************************************
    * @description Test method to verify that the getModelFromMapping method with 
    * Inaccurate RecordType Name And inaccurate Primary Field Label in EDA Settings when validation is off returns null
    ***************************************************************************************************************************************/
    @isTest
    private static void getModelFromMappingTestWithInaccurateRecordTypeAndFieldWithValidationOff() {
        MAPR_PrimaryAffiliations_TEST.insertAfflMappingsWithInaccurateRecordTypeNameAndInAccuratePrimaryFieldLabels();
        MAPR_PrimaryAffiliations maprPrimaryAfflInstance = new STUB_PrimaryAffiliationValidationOff();

        List<Affl_Mappings__c> primaryAfflMappings = UTIL_CustomSettingsFacade.getPrimaryAfflMappings();

        Test.startTest();
        MODL_PrimaryAfflMapper primAffMapResult = maprPrimaryAfflInstance.getModelFromMapping(primaryAfflMappings[0]);
        Test.stopTest();

        System.assertEquals(null, primAffMapResult, 'Invalid Contact field and Record Type mappings should return null when validation is not enabled.');
    }

    /**************************************************************************************************************************************
    * @description Test to ensure that getModelFromMapping returns a valid model with an error message indicating an invalid lookup field 
    * mapping when validation is off, an invalid record type is specified and a valid field that does not lookup to Account is mapped.
    **************************************************************************************************************************************/ 
    private static void getModelFromMappingInvalidRTAndNonLookupFieldValidationOff(){        
        MAPR_PrimaryAffiliations_TEST.insertAfflMappingsWithInaccurateRecordTypeNameAndNonLookupPrimaryFieldLabels();
        MAPR_PrimaryAffiliations maprPrimaryAfflInstance = new STUB_PrimaryAffiliationValidationOff();

        List<Affl_Mappings__c> primaryAfflMappings = UTIL_CustomSettingsFacade.getPrimaryAfflMappings();

        Test.startTest();
            MODL_PrimaryAfflMapper primaryAfflModel = maprPrimaryAfflInstance.getModelFromMapping(primaryAfflMappings[0]);
        Test.stopTest();

        String prefix = UTIL_Namespace.StrTokenNSPrefix('');

        System.assert(primaryAfflModel != null);
        System.assertEquals(true, primaryAfflModel.getIsValid());
        System.assertEquals(MAPR_PrimaryAffiliations_TEST.getExpectedInvalidFieldMappingErrorMessage(primaryAfflMappings[0]), primaryAfflModel.getInvalidErrorMessage());
        System.assertEquals('Business Org test', primaryAfflModel.getAccountRecordTypeId());
        System.assertEquals(prefix + 'FirstName', primaryAfflModel.getContactFieldApiName());
        System.assertEquals('FirstName', primaryAfflModel.getSettingsContactFieldValue());
        System.assertEquals('Business Org test', primaryAfflModel.getSettingsRecordTypeFieldValue());
    }

    /**************************************************************************************************************************************
    * @description Test to ensure that getModelFromMapping returns a valid model with an error message indicating an invalid lookup field 
    * mapping when validation is on, a valid record type is specified and a valid field that does not lookup to Account is mapped.
    **************************************************************************************************************************************/ 
    private static void getModelFromMappingValidRTAndNonLookupFieldValidationOff(){
        MAPR_PrimaryAffiliations_TEST.insertAfflMappingsWithValidRecordTypeNameAndNonLookupPrimaryFieldLabels();
        MAPR_PrimaryAffiliations maprPrimaryAfflInstance = new STUB_PrimaryAffiliationValidationOff();

        List<Affl_Mappings__c> primaryAfflMappings = UTIL_CustomSettingsFacade.getPrimaryAfflMappings();

        Test.startTest();
            MODL_PrimaryAfflMapper primaryAfflModel = maprPrimaryAfflInstance.getModelFromMapping(primaryAfflMappings[0]);
        Test.stopTest();

        String prefix = UTIL_Namespace.StrTokenNSPrefix('');

        System.assert(primaryAfflModel != null);
        System.assertEquals(true, primaryAfflModel.getIsValid());
        System.assertEquals(MAPR_PrimaryAffiliations_TEST.getExpectedInvalidFieldMappingErrorMessage(primaryAfflMappings[0]), primaryAfflModel.getInvalidErrorMessage());
        System.assertEquals('Business Organization', primaryAfflModel.getAccountRecordTypeId());
        System.assertEquals(prefix + 'FirstName', primaryAfflModel.getContactFieldApiName());
        System.assertEquals('FirstName', primaryAfflModel.getSettingsContactFieldValue());
        System.assertEquals('Business Organization', primaryAfflModel.getSettingsRecordTypeFieldValue());
    }

    /**************************************************************************************************************************************
    * @description Test to ensure that getModelFromMapping returns a valid model with an error message indicating an invalid record type 
    * mapping when validation is on, an invalid record type is specified and a valid field that does not lookup to Account is mapped.
    **************************************************************************************************************************************/ 
    private static void getModelFromMappingInvalidRTAndNonLookupFieldValidationOn(){
        MAPR_PrimaryAffiliations_TEST.insertAfflMappingsWithInaccurateRecordTypeNameAndNonLookupPrimaryFieldLabels();
        MAPR_PrimaryAffiliations maprPrimaryAfflInstance = new STUB_PrimaryAffiliationValidationOn();

        List<Affl_Mappings__c> primaryAfflMappings = UTIL_CustomSettingsFacade.getPrimaryAfflMappings();

        Test.startTest();
            MODL_PrimaryAfflMapper primaryAfflModel = maprPrimaryAfflInstance.getModelFromMapping(primaryAfflMappings[0]);
        Test.stopTest();

        String prefix = UTIL_Namespace.StrTokenNSPrefix('');

        System.assert(primaryAfflModel != null);
        System.assertEquals(false, primaryAfflModel.getIsValid());
        System.assertEquals(MAPR_PrimaryAffiliations_TEST.getExpectedInvalidRTMappingErrorMessage(primaryAfflMappings[0]), primaryAfflModel.getInvalidErrorMessage());
        System.assertEquals('Business Org test', primaryAfflModel.getAccountRecordTypeId());
        System.assertEquals(prefix + 'FirstName', primaryAfflModel.getContactFieldApiName());
        System.assertEquals('FirstName', primaryAfflModel.getSettingsContactFieldValue());
        System.assertEquals('Business Org test', primaryAfflModel.getSettingsRecordTypeFieldValue());
    }

    /**************************************************************************************************************************************
    * @description Test to ensure that getModelFromMapping returns a valid model with an error message indicating an invalid record type 
    * mapping when validation is on, an invalid record type is specified and a valid field that does lookup to Account is mapped.
    **************************************************************************************************************************************/ 
    private static void getModelFromMappingInvalidRTAndLookupFieldValidationOn(){
        MAPR_PrimaryAffiliations_TEST.insertAfflMappingsWithInaccurateRecordTypeNameAndAccuratePrimaryFieldLabels();
        MAPR_PrimaryAffiliations maprPrimaryAfflInstance = new STUB_PrimaryAffiliationValidationOn();

        List<Affl_Mappings__c> primaryAfflMappings = UTIL_CustomSettingsFacade.getPrimaryAfflMappings();

        Test.startTest();
            MODL_PrimaryAfflMapper primaryAfflModel = maprPrimaryAfflInstance.getModelFromMapping(primaryAfflMappings[0]);
        Test.stopTest();

        String prefix = UTIL_Namespace.StrTokenNSPrefix('');

        System.assert(primaryAfflModel != null);
        System.assertEquals(false, primaryAfflModel.getIsValid());
        System.assertEquals(MAPR_PrimaryAffiliations_TEST.getExpectedInvalidRTMappingErrorMessage(primaryAfflMappings[0]), primaryAfflModel.getInvalidErrorMessage());
        System.assertEquals('Business Org test', primaryAfflModel.getAccountRecordTypeId());
        System.assertEquals(prefix + 'Primary_Organization__c', primaryAfflModel.getContactFieldApiName());
        System.assertEquals('Primary_Organization__c', primaryAfflModel.getSettingsContactFieldValue());
        System.assertEquals('Business Org test', primaryAfflModel.getSettingsRecordTypeFieldValue());
    }

    /**************************************************************************************************************************************
    * @description Test to ensure that getModelFromMapping returns a valid model with an error message indicating an invalid lookup field 
    * mapping when validation is on, a valid record type is specified and a valid field that does not lookup to Account is mapped.
    **************************************************************************************************************************************/ 
    private static void getModelFromMappingValidRTAndNonLookupFieldValidationOn(){
        MAPR_PrimaryAffiliations_TEST.insertAfflMappingsWithValidRecordTypeNameAndNonLookupPrimaryFieldLabels();
        MAPR_PrimaryAffiliations maprPrimaryAfflInstance = new STUB_PrimaryAffiliationValidationOn();

        List<Affl_Mappings__c> primaryAfflMappings = UTIL_CustomSettingsFacade.getPrimaryAfflMappings();

        Test.startTest();
            MODL_PrimaryAfflMapper primaryAfflModel = maprPrimaryAfflInstance.getModelFromMapping(primaryAfflMappings[0]);
        Test.stopTest();

        String prefix = UTIL_Namespace.StrTokenNSPrefix('');

        System.assert(primaryAfflModel != null);
        System.assertEquals(false, primaryAfflModel.getIsValid());
        System.assertEquals(MAPR_PrimaryAffiliations_TEST.getExpectedInvalidFieldMappingErrorMessage(primaryAfflMappings[0]), primaryAfflModel.getInvalidErrorMessage());
        System.assertEquals('Business Organization', primaryAfflModel.getAccountRecordTypeId());
        System.assertEquals(prefix + 'FirstName', primaryAfflModel.getContactFieldApiName());
        System.assertEquals('FirstName', primaryAfflModel.getSettingsContactFieldValue());
        System.assertEquals('Business Organization', primaryAfflModel.getSettingsRecordTypeFieldValue());
    }

    /***************************************************************************************************************
    * STUB class which extends MAPR_PrimaryAffiliations, overrides isPrimaryAffiliationValidationOn to return true
    ***************************************************************************************************************/
    private class STUB_PrimaryAffiliationValidationOn extends MAPR_PrimaryAffiliations {
        @TestVisible
        protected override boolean isPrimaryAffiliationValidationOn() {
            return true;
        }
    }

    /***************************************************************************************************************
    * STUB class which extends MAPR_PrimaryAffiliations, overrides isPrimaryAffiliationValidationOn to return false
    ***************************************************************************************************************/
    private class STUB_PrimaryAffiliationValidationOff extends MAPR_PrimaryAffiliations {
        @TestVisible
        protected override boolean isPrimaryAffiliationValidationOn() {
            return false;
        }
    }
}
public class MODL_PrimaryAfflMapper {

    private Id accRecordTypeId;
    private Boolean isValid;
    private String accRecTypeDeveloperName;
    private String accRecTypeName;
    private String contactFieldApiName;
    private String contactFieldLabel;
    private String primaryAfflFieldValueFromSettings;
    private String accRecTypeValueFromSettings;
    private String invalidErrorMessage;

    /*******************************************************************************************************
    * @description Constructor with 5 parameters
    * @param accountRecordTypeInfo Schema.RecordTypeInfo of Account
    * @param contactDescribeFieldResult Schema.DescribeFieldResult for Contact's field
    * @param settingsContactFieldValue 'Contact Primary Affl Field' from EDA Settings.
    * @param settingsRecordTypeValue 'Account Record Type' value from EDA Settings.
    * @param isValid Boolean flag to indicate whether the Record Type Affiliation maps to a valid Account record type.
    *******************************************************************************************************/ 
    public MODL_PrimaryAfflMapper(Schema.RecordTypeInfo accountRecordTypeInfo, 
                                  Schema.DescribeFieldResult contactDescribeFieldResult, 
                                  String settingsContactFieldValue, 
                                  String settingsRecordTypeValue, 
                                  Boolean isValid,
                                  String invalidErrorMessage) {

        this.accRecordTypeId = accountRecordTypeInfo.getRecordTypeId();
        this.isValid = isValid;
        this.accRecTypeDeveloperName = accountRecordTypeInfo.getDeveloperName();
        this.accRecTypeName = accountRecordTypeInfo.getName();
        this.contactFieldApiName = contactDescribeFieldResult.getName();
        this.contactFieldLabel = contactDescribeFieldResult.getLabel();
        this.primaryAfflFieldValueFromSettings = settingsContactFieldValue;
        this.accRecTypeValueFromSettings = settingsRecordTypeValue;
        this.invalidErrorMessage = invalidErrorMessage;
    }

    /*******************************************************************************************************
    * @description Constructor with 4 parameters
    * @param contactDescribeFieldResult Schema.DescribeFieldResult for Contact's field
    * @param settingsContactFieldValue 'Contact Primary Affl Field' from EDA Settings.
    * @param settingsRecordTypeValue 'Account Record Type' value from EDA Settings.
    * @param isValid Boolean flag to indicate whether the Record Type Affiliation maps to a valid Account record type.
    *******************************************************************************************************/ 
    public MODL_PrimaryAfflMapper(Schema.DescribeFieldResult contactDescribeFieldResult, 
                                  String settingsContactFieldValue, 
                                  String settingsRecordTypeValue, 
                                  Boolean isValid,
                                  String invalidErrorMessage) {

        this.isValid = isValid;
        this.contactFieldApiName = contactDescribeFieldResult.getName();
        this.contactFieldLabel = contactDescribeFieldResult.getLabel();
        this.primaryAfflFieldValueFromSettings = settingsContactFieldValue;
        this.accRecTypeValueFromSettings = settingsRecordTypeValue;
        this.invalidErrorMessage = invalidErrorMessage;
    }

    /*******************************************************************************************************
    * @description Constructor with 4 parameters
    * @param accountRecordTypeInfo Schema.RecordTypeInfo of Account
    * @param settingsContactFieldValue 'Contact Primary Affl Field' from EDA Settings.
    * @param settingsRecordTypeValue 'Account Record Type' value from EDA Settings.
    * @param isValid Boolean flag to indicate whether the Record Type Affiliation maps to a valid Account record type.
    *******************************************************************************************************/ 
    public MODL_PrimaryAfflMapper(Schema.RecordTypeInfo accountRecordTypeInfo, 
                                  String settingsContactFieldValue, 
                                  String settingsRecordTypeValue, 
                                  Boolean isValid,
                                  String invalidErrorMessage) {

        this.accRecordTypeId = accountRecordTypeInfo.getRecordTypeId();
        this.isValid = isValid;
        this.accRecTypeDeveloperName = accountRecordTypeInfo.getDeveloperName();
        this.accRecTypeName = accountRecordTypeInfo.getName();
        this.primaryAfflFieldValueFromSettings = settingsContactFieldValue;
        this.accRecTypeValueFromSettings = settingsRecordTypeValue;
        this.invalidErrorMessage = invalidErrorMessage;
    }

    /*******************************************************************************************************
    * @description Getter method to return the Account Record Type Id. If it is not available then returns
    * 'Account Record Type' value from EDA Settings.
    * @return Account Record Type Id or 'Account Record Type' value from EDA Settings
    *******************************************************************************************************/ 
    public String getAccountRecordTypeId() {
        if (this.accRecordTypeId == null) {
            return this.accRecTypeValueFromSettings;
        }
        return (String)this.accRecordTypeId;
    }

    /*******************************************************************************************************
    * @description Getter method to return the isValid property.
    * @return True if setting is valid, False otherwise.
    *******************************************************************************************************/ 
    public Boolean getIsValid() {
        return this.isValid;
    }

    /*******************************************************************************************************
    * @description Getter method to return the Contact Field API name. If it is not available then returns
    * 'Contact Primary Affl Field' from EDA Settings.
    * @return Field API name for Contact or 'Primary Affl Field' value from EDA Settings
    *******************************************************************************************************/ 
    public String getContactFieldApiName() {
        if (String.isEmpty(this.contactFieldApiName) == true) {
            return this.primaryAfflFieldValueFromSettings; 
        }
        return this.contactFieldApiName;
    }

    /*******************************************************************************************************
    * @description Getter method to return the 'Contact Primary Affl Field' value from EDA Settings.
    * @return 'Primary Affl Field' value from EDA Settings
    *******************************************************************************************************/ 
    public String getSettingsContactFieldValue() {
        return this.primaryAfflFieldValueFromSettings;
    }

    /*******************************************************************************************************
    * @description Getter method to return the 'Account Record Type' value from EDA Settings.
    * 'Account Record Type' value from EDA Settings
    *******************************************************************************************************/ 
    public String getSettingsRecordTypeFieldValue() {
        return this.accRecTypeValueFromSettings;
    }

    public String getInvalidErrorMessage(){
        return this.invalidErrorMessage;
    }
}
@isTest
private class MODL_PrimaryAfflMapper_TEST {

    /**********************************************************************************************************
    * @description Tests that MODL_PrimaryAfflMapper generates a valid model with all the four Parameters 
    **********************************************************************************************************/
    @isTest
    static void constructorWithAllParametersTestValid() {

        String namespace = UTIL_Namespace.getNamespace();
        String prefix = (String.isNotBlank(namespace)) ? namespace + '__' : '';

        Schema.RecordTypeInfo busiOrgInfo = UTIL_Describe.getRecordTypeInfoByDeveloperName('Account', 'Business_Organization');
        Schema.DescribeFieldResult contactFieldDescribeResult = UTIL_Describe.getFieldDescribe('Contact', prefix + 'Primary_Organization__c');

        List<Affl_Mappings__c> mappings = new List<Affl_Mappings__c>();
        mappings.add(new Affl_Mappings__c(Name = 'Business Organization', Account_Record_Type__c = 'Business Organization', Primary_Affl_Field__c = 'Primary Business Organization'));
        insert mappings;

        Test.startTest();
            MODL_PrimaryAfflMapper conPrimaryAfflModl = new MODL_PrimaryAfflMapper(busiOrgInfo, contactFieldDescribeResult, mappings[0].Primary_Affl_Field__c, mappings[0].Account_Record_Type__c, true, '');
        Test.stopTest();

        System.assertEquals(true, conPrimaryAfflModl.getIsValid());
        System.assertEquals(true, String.isEmpty(conPrimaryAfflModl.getInvalidErrorMessage()));
        System.assertEquals(UTIL_Describe_API.getBizAccRecTypeID(), conPrimaryAfflModl.getAccountRecordTypeId());
        System.assertEquals(prefix + 'Primary_Organization__c', conPrimaryAfflModl.getContactFieldApiName());
        System.assertEquals(mappings[0].Primary_Affl_Field__c, conPrimaryAfflModl.getSettingsContactFieldValue());
        System.assertEquals(mappings[0].Account_Record_Type__c, conPrimaryAfflModl.getSettingsRecordTypeFieldValue());
    }

    /**********************************************************************************************************
    * @description Tests that MODL_PrimaryAfflMapper generates an invalid model with all the four Parameters 
    **********************************************************************************************************/
    @isTest
    static void constructorWithAllParametersTestNotValid() {

        String namespace = UTIL_Namespace.getNamespace();
        String prefix = (String.isNotBlank(namespace)) ? namespace + '__' : '';
        String errorString = 'Invalid affiliation mapping found';

        Schema.RecordTypeInfo busiOrgInfo = UTIL_Describe.getRecordTypeInfoByDeveloperName('Account', 'Business_Organization');
        Schema.DescribeFieldResult contactFieldDescribeResult = UTIL_Describe.getFieldDescribe('Contact', prefix + 'Primary_Organization__c');

        List<Affl_Mappings__c> mappings = new List<Affl_Mappings__c>();
        mappings.add(new Affl_Mappings__c(Name = 'Business Organization', Account_Record_Type__c = 'Business Organization', Primary_Affl_Field__c = 'Primary Business Organization'));
        insert mappings;

        Test.startTest();
            MODL_PrimaryAfflMapper conPrimaryAfflModl = new MODL_PrimaryAfflMapper(busiOrgInfo, contactFieldDescribeResult, mappings[0].Primary_Affl_Field__c, mappings[0].Account_Record_Type__c, false, errorString);
        Test.stopTest();

        System.assertEquals(false, conPrimaryAfflModl.getIsValid());
        System.assertEquals(errorString, conPrimaryAfflModl.getInvalidErrorMessage());
        System.assertEquals(UTIL_Describe_API.getBizAccRecTypeID(), conPrimaryAfflModl.getAccountRecordTypeId());
        System.assertEquals(prefix + 'Primary_Organization__c', conPrimaryAfflModl.getContactFieldApiName());
        System.assertEquals(mappings[0].Primary_Affl_Field__c, conPrimaryAfflModl.getSettingsContactFieldValue());
        System.assertEquals(mappings[0].Account_Record_Type__c, conPrimaryAfflModl.getSettingsRecordTypeFieldValue());
    }

    /**********************************************************************************************************
    * @description Tests that MODL_PrimaryAfflMapper generates a valid model with  
    * ContactDescribeFieldResult, Mapping Settings Parameters and no Schema.RecordTypeInfo 
    **********************************************************************************************************/
    @isTest
    static void  constructorWithContactDescribeFieldResultValidTest() {

        String namespace = UTIL_Namespace.getNamespace();
        String prefix = (String.isNotBlank(namespace)) ? namespace + '__' : '';

        Schema.DescribeFieldResult contactFieldDescribeResult = UTIL_Describe.getFieldDescribe('Contact', prefix + 'Primary_Organization__c');

        List<Affl_Mappings__c> mappings = new List<Affl_Mappings__c>();
        mappings.add(new Affl_Mappings__c(Name = 'Business Organization', Account_Record_Type__c = 'Business Organization', Primary_Affl_Field__c = 'Primary Business Organization'));
        insert mappings;

        Test.startTest();
            MODL_PrimaryAfflMapper conPrimaryAfflModl = new MODL_PrimaryAfflMapper(contactFieldDescribeResult, mappings[0].Primary_Affl_Field__c, mappings[0].Account_Record_Type__c, true, '');
        Test.stopTest();

        System.assertEquals(true, conPrimaryAfflModl.getIsValid());
        System.assertEquals(true, String.isBlank(conPrimaryAfflModl.getInvalidErrorMessage()));
        System.assertEquals(mappings[0].Account_Record_Type__c, conPrimaryAfflModl.getAccountRecordTypeId());
        System.assertEquals(prefix + 'Primary_Organization__c', conPrimaryAfflModl.getContactFieldApiName());
        System.assertEquals(mappings[0].Primary_Affl_Field__c, conPrimaryAfflModl.getSettingsContactFieldValue());
        System.assertEquals(mappings[0].Account_Record_Type__c, conPrimaryAfflModl.getSettingsRecordTypeFieldValue());
    }

    /**********************************************************************************************************
    * @description Tests that MODL_PrimaryAfflMapper generates an invalid model with  
    * ContactDescribeFieldResult, Mapping Settings Parameters and no Schema.RecordTypeInfo 
    **********************************************************************************************************/
    @isTest
    static void  constructorWithContactDescribeFieldResultNotValidTest() {

        String namespace = UTIL_Namespace.getNamespace();
        String prefix = (String.isNotBlank(namespace)) ? namespace + '__' : '';
        String errorString = 'Invalid affiliation mapping found';

        Schema.DescribeFieldResult contactFieldDescribeResult = UTIL_Describe.getFieldDescribe('Contact', prefix + 'Primary_Organization__c');

        List<Affl_Mappings__c> mappings = new List<Affl_Mappings__c>();
        mappings.add(new Affl_Mappings__c(Name = 'Business Organization', Account_Record_Type__c = 'Business Organization', Primary_Affl_Field__c = 'Primary Business Organization'));
        insert mappings;

        Test.startTest();
            MODL_PrimaryAfflMapper conPrimaryAfflModl = new MODL_PrimaryAfflMapper(contactFieldDescribeResult, mappings[0].Primary_Affl_Field__c, mappings[0].Account_Record_Type__c, false, errorString);
        Test.stopTest();

        System.assertEquals(false, conPrimaryAfflModl.getIsValid());
        System.assertEquals(errorString, conPrimaryAfflModl.getInvalidErrorMessage());
        System.assertEquals(mappings[0].Account_Record_Type__c, conPrimaryAfflModl.getAccountRecordTypeId());
        System.assertEquals(prefix + 'Primary_Organization__c', conPrimaryAfflModl.getContactFieldApiName());
        System.assertEquals(mappings[0].Primary_Affl_Field__c, conPrimaryAfflModl.getSettingsContactFieldValue());
        System.assertEquals(mappings[0].Account_Record_Type__c, conPrimaryAfflModl.getSettingsRecordTypeFieldValue());
    }

    /**********************************************************************************************************
    * @description Tests that MODL_PrimaryAfflMapper generates a valid model with Schema.RecordTypeInfo, 
    * Mapping Settings Parameters and no ContactDescribeFieldResult
    **********************************************************************************************************/
    @isTest
    static void  constructorWithRecordTypeInfoValidTest() {

        String namespace = UTIL_Namespace.getNamespace();
        String prefix = (String.isNotBlank(namespace)) ? namespace + '__' : '';

        Schema.RecordTypeInfo busiOrgInfo = UTIL_Describe.getRecordTypeInfoByDeveloperName('Account', 'Business_Organization');

        List<Affl_Mappings__c> mappings = new List<Affl_Mappings__c>();
        mappings.add(new Affl_Mappings__c(Name = 'Business Organization', Account_Record_Type__c = 'Business Organization', Primary_Affl_Field__c = 'Primary Business Organization'));
        insert mappings;

        Test.startTest();
            MODL_PrimaryAfflMapper conPrimaryAfflModl = new MODL_PrimaryAfflMapper(busiOrgInfo, mappings[0].Primary_Affl_Field__c, mappings[0].Account_Record_Type__c, true, '');
        Test.stopTest();

        System.assertEquals(true, conPrimaryAfflModl.getIsValid());
        System.assertEquals(true, String.isEmpty(conPrimaryAfflModl.getInvalidErrorMessage()));
        System.assertEquals(UTIL_Describe_API.getBizAccRecTypeID(), conPrimaryAfflModl.getAccountRecordTypeId());
        System.assertEquals(mappings[0].Primary_Affl_Field__c, conPrimaryAfflModl.getContactFieldApiName());
        System.assertEquals(mappings[0].Primary_Affl_Field__c, conPrimaryAfflModl.getSettingsContactFieldValue());
        System.assertEquals(mappings[0].Account_Record_Type__c, conPrimaryAfflModl.getSettingsRecordTypeFieldValue());
    }

    /**********************************************************************************************************
    * @description Tests that MODL_PrimaryAfflMapper generates an invalid model with Schema.RecordTypeInfo, 
    * Mapping Settings Parameters and no ContactDescribeFieldResult
    **********************************************************************************************************/
    @isTest
    static void  constructorWithRecordTypeInfoNotValidTest() {

        String namespace = UTIL_Namespace.getNamespace();
        String prefix = (String.isNotBlank(namespace)) ? namespace + '__' : '';
        String errorString = 'Invalid affiliation mapping found';

        Schema.RecordTypeInfo busiOrgInfo = UTIL_Describe.getRecordTypeInfoByDeveloperName('Account', 'Business_Organization');

        List<Affl_Mappings__c> mappings = new List<Affl_Mappings__c>();
        mappings.add(new Affl_Mappings__c(Name = 'Business Organization', Account_Record_Type__c = 'Business Organization', Primary_Affl_Field__c = 'Primary Business Organization'));
        insert mappings;

        Test.startTest();
            MODL_PrimaryAfflMapper conPrimaryAfflModl = new MODL_PrimaryAfflMapper(busiOrgInfo, mappings[0].Primary_Affl_Field__c, mappings[0].Account_Record_Type__c, false, errorString);
        Test.stopTest();

        System.assertEquals(false, conPrimaryAfflModl.getIsValid());
        System.assertEquals(errorString, conPrimaryAfflModl.getInvalidErrorMessage());
        System.assertEquals(UTIL_Describe_API.getBizAccRecTypeID(), conPrimaryAfflModl.getAccountRecordTypeId());
        System.assertEquals(mappings[0].Primary_Affl_Field__c, conPrimaryAfflModl.getContactFieldApiName());
        System.assertEquals(mappings[0].Primary_Affl_Field__c, conPrimaryAfflModl.getSettingsContactFieldValue());
        System.assertEquals(mappings[0].Account_Record_Type__c, conPrimaryAfflModl.getSettingsRecordTypeFieldValue());
    }
}
public without sharing class ObjectUsageTelemetryModel {
    public Integer countBadgeCredentials = 0;
    public Integer countHouseholdAccounts = 0;
    public Integer countLicenseCredentials = 0;
    public Integer countAdministrativeAccounts = 0;
    public Integer countCertificationCredentials = 0;
    public Integer countDegreeAcademicCertifications = 0;
    public Integer countDiplomaAcademicCertifications = 0;
    public Integer countCertificateAcademicCertifications = 0;

    public Integer numErrors;
    public Integer numFacilities;
    public Integer numTermGrades;
    public Integer numCredentials;
    public Integer numProgramPlans;
    public Integer numPlanRequirements;
    public Integer numCourseEnrollments;
    public Integer numAcademicCertifications;
    public Integer numCourseOfferingSchedules;
    public Integer numAutoEnrollmentAffMappings;
    public Integer numSeasonalAddresses;
    public Integer numCurrentYearSeasonalAddesses;

    public ObjectUsageTelemetryModel() {
        this.numErrors = [SELECT COUNT() FROM Error__c];
        this.numFacilities = [SELECT COUNT() FROM Facility__c];
        this.numTermGrades = [SELECT COUNT() FROM Term_Grade__c];
        this.numCredentials = [SELECT COUNT() FROM Credential__c];
        this.numProgramPlans = [SELECT COUNT() FROM Program_Plan__c];
        this.numPlanRequirements = [SELECT COUNT() FROM Plan_Requirement__c];
        this.numCourseEnrollments = [SELECT COUNT() FROM Course_Enrollment__c];
        this.numAcademicCertifications = [SELECT COUNT() FROM Academic_Certification__c];
        this.numCourseOfferingSchedules = [SELECT COUNT() FROM Course_Offering_Schedule__c];

        this.numAutoEnrollmentAffMappings = [
            SELECT COUNT()
            FROM Affl_Mappings__c
            WHERE Auto_Program_Enrollment__c = TRUE
        ];

        this.numSeasonalAddresses = [
            SELECT COUNT()
            FROM Address__c
            WHERE
                Seasonal_Start_Month__c != NULL
                AND Seasonal_Start_Day__c != NULL
                AND Seasonal_End_Month__c != NULL
                AND Seasonal_End_Day__c != NULL
        ];

        this.numCurrentYearSeasonalAddesses = [
            SELECT COUNT()
            FROM Address__c
            WHERE
                Seasonal_Start_Month__c != NULL
                AND Seasonal_Start_Day__c != NULL
                AND Seasonal_End_Month__c != NULL
                AND Seasonal_End_Day__c != NULL
                AND CreatedDate = LAST_N_DAYS:365
        ];

        if (UTIL_Describe.getCustomAdminAccRecTypeId() != null) {
            this.countAdministrativeAccounts = [
                SELECT COUNT()
                FROM Account
                WHERE RecordTypeId = :UTIL_Describe.getCustomAdminAccRecTypeId()
            ];
        }

        if (UTIL_Describe.getCustomHHAccRecTypeID() != null) {
            this.countHouseholdAccounts = [
                SELECT COUNT()
                FROM Account
                WHERE RecordTypeId = :UTIL_Describe.getCustomHHAccRecTypeID()
            ];
        }

        if (UTIL_Describe.getCertificateAcademicCertificationRecTypeId() != null) {
            this.countCertificateAcademicCertifications = [
                SELECT COUNT()
                FROM Academic_Certification__c
                WHERE RecordTypeId = :UTIL_Describe.getCertificateAcademicCertificationRecTypeId()
            ];
        }

        if (UTIL_Describe.getDegreeAcademicCertificationRecTypeId() != null) {
            this.countDegreeAcademicCertifications = [
                SELECT COUNT()
                FROM Academic_Certification__c
                WHERE RecordTypeId = :UTIL_Describe.getDegreeAcademicCertificationRecTypeId()
            ];
        }

        if (UTIL_Describe.getDiplomaAcademicCertificationRecTypeId() != null) {
            this.countDiplomaAcademicCertifications = [
                SELECT COUNT()
                FROM Academic_Certification__c
                WHERE RecordTypeId = :UTIL_Describe.getDiplomaAcademicCertificationRecTypeId()
            ];
        }

        if (UTIL_Describe.getBadgeCredentialRecTypeId() != null) {
            this.countBadgeCredentials = [
                SELECT COUNT()
                FROM Credential__c
                WHERE RecordTypeId = :UTIL_Describe.getBadgeCredentialRecTypeId()
            ];
        }

        if (UTIL_Describe.getLicenseCredentialRecTypeId() != null) {
            this.countLicenseCredentials = [
                SELECT COUNT()
                FROM Credential__c
                WHERE RecordTypeId = :UTIL_Describe.getLicenseCredentialRecTypeId()
            ];
        }

        if (UTIL_Describe.getCertificationCredentialRecTypeId() != null) {
            this.countCertificationCredentials = [
                SELECT COUNT()
                FROM Credential__c
                WHERE RecordTypeId = :UTIL_Describe.getCertificationCredentialRecTypeId()
            ];
        }
    }
}
@isTest
public with sharing class PPlan_CannotDelete_TEST {
    
    /*********************************************************************************************************
    * @description Tests the deletion of Program Plan with Plan Requirement as related child records
    * and when Prevent Program Plan Deletion is enabled.
    */
    @isTest
    public static void pPlanCannotDeleteWithPlanRequirement() {
        
        // Enable Custom Settings
        UTIL_CustomSettingsFacade.getSettingsForTests(new Hierarchy_Settings__c(Prevent_Program_Plan_Deletion__c = TRUE));
        
        // Insert Program Plan
        List<Program_Plan__c> pPlans = UTIL_UnitTestData_TEST.getMultipleTestProgramPlans(1);
        insert pPlans;
       
       // Insert Plan Requirement
        List<Plan_Requirement__c> prs = UTIL_UnitTestData_TEST.getMultipleTestPlanRequirements(2);
        for (Plan_Requirement__c pr : prs) {
            pr.Program_Plan__c = pPlans[0].Id;
        }
        insert prs;

        Test.startTest();
            Database.DeleteResult[] results = Database.delete(pPlans, false);
        Test.stopTest();

        //Verify pPlan was not successfully deleted
        List<Program_Plan__c> assertPps = [select ID from Program_Plan__c];
        System.assertEquals(1, assertPps.size());

        System.assertEquals(false, results[0].success);
        System.assertEquals(Label.CannotDelete, results[0].errors[0].message);
    }
    
    /*********************************************************************************************************
    * @description Tests the deletion of Program Enrollments with Program Enrollment as related child records
    * and when Prevent Program Plan Deletion is enabled.
    */
    @isTest
    public static void pPlanCannotDeleteWithProgramEnrollments() {
        
        // Enable Custom Settings
        UTIL_CustomSettingsFacade.getSettingsForTests(new Hierarchy_Settings__c(Prevent_Program_Plan_Deletion__c = TRUE));
        
        // Insert Account
        List<Account> academicPrograms = UTIL_UnitTestData_TEST.getMultipleTestAccounts(1, UTIL_Describe.getAcademicAccRecTypeID());
        insert academicPrograms;
        
        // Insert Program Plan
        List<Program_Plan__c> pPlans = UTIL_UnitTestData_TEST.getMultipleTestProgramPlans(1);
        insert pPlans;
        
        // Insert Plan Enrollment
        List<Program_Enrollment__c> pes = UTIL_UnitTestData_TEST.getMultipleTestProgramEnrollments(2, academicPrograms[0].Id);
        for (Program_Enrollment__c pe : pes) {
            pe.Program_Plan__c = pPlans[0].Id;
        }
        insert pes;

        Test.startTest();
            Database.DeleteResult[] results = Database.delete(pPlans, false);
        Test.stopTest();

        //Verify pPlan was not successfully deleted
        List<Program_Plan__c> assertPps = [select ID from Program_Plan__c];
        System.assertEquals(1, assertPps.size());

        System.assertEquals(false, results[0].success);
        System.assertEquals(Label.CannotDelete, results[0].errors[0].message);
    }
    /*********************************************************************************************************
    * @description Tests the deletion of Program Enrollments with Program Enrollment and Plan Requirement
    * as related child records and when Prevent Program Plan Deletion is disabled.
    */
    @isTest
    public static void pPlanCannotDeleteWProgramEnrollmentsAndPlanReq() {
        
        // Disable Custom Settings
        UTIL_CustomSettingsFacade.getSettingsForTests(new Hierarchy_Settings__c(Prevent_Program_Plan_Deletion__c = FALSE));

        // Insert Account
        List<Account> academicPrograms = UTIL_UnitTestData_TEST.getMultipleTestAccounts(1, UTIL_Describe.getAcademicAccRecTypeID());
        insert academicPrograms;
        
        // Insert Program plan
        List<Program_Plan__c> pPlans = UTIL_UnitTestData_TEST.getMultipleTestProgramPlans(1);
        insert pPlans;
        
        // Insert Program Enrollment
        List<Program_Enrollment__c> pes = UTIL_UnitTestData_TEST.getMultipleTestProgramEnrollments(2, academicPrograms[0].Id);
        for (Program_Enrollment__c pe : pes) {
            pe.Program_Plan__c = pPlans[0].Id;
        }
        insert pes;
        
        // Insert Plan Requirement
        List<Plan_Requirement__c> prs = UTIL_UnitTestData_TEST.getMultipleTestPlanRequirements(2);
        for (Plan_Requirement__c pr : prs) {
            pr.Program_Plan__c = pPlans[0].Id;
        }
        insert prs;
    
        Test.startTest();
           delete pPlans;
        Test.stopTest();    
        
        //Verify pPlan was successfully deleted
        List<Program_Plan__c> assertPps = [select ID from Program_Plan__c];
        System.assertEquals(0, assertPps.size());
    }
}
public with sharing class PPlan_Primary_TDTM extends TDTM_Runnable {
    /*******************************************************************************************************
    * @description Handles primary program plans.
    * @param listNew the list of Accounts from trigger new.
    * @param listOld the list of Accounts from trigger old.
    * @param triggerAction which trigger event (BeforeInsert, AfterInsert, etc.).
    * @param objResult the describe for Accounts
    * @return dmlWrapper.
    ********************************************************************************************************/
    public override DmlWrapper run(List<SObject> newlist, List<SObject> oldlist,
    TDTM_Runnable.Action triggerAction, Schema.DescribeSObjectResult objResult) {
        DmlWrapper dmlWrapper = new DmlWrapper();

        Set<Id> acccountIdsNeedNonPrimarycount = new Set<Id>();
        Set<Id> primaryProgramIds = new Set<Id>();
        
        boolean afterInsertRecursionFlag = TDTM_ProcessControl.getRecursionFlag(TDTM_ProcessControl.registeredTrigger.PPlan_Primary_TDTM_After_Insert);

        // AFTER INSERT
        if ( newlist != null && triggerAction == TDTM_Runnable.Action.AfterInsert && !afterInsertRecursionFlag) {    
            for (integer i = 0; i < newlist.size(); i++) {
                Program_Plan__c newPPlan = (Program_Plan__c)newlist[i];
                if (isNewlyPrimaryOrPrimaryAndAccountChanged(null, newPPlan)) {
                    //if multiple program plans under one single account are set as primary in same transation
                    //Use the first program plan as the primary
                    if (!acccountIdsNeedNonPrimarycount.contains(newPPlan.Account__c)) {
                        primaryProgramIds.add(newPPlan.Id);
                    }
                    acccountIdsNeedNonPrimarycount.add(newPPlan.Account__c);
                }
            }
        }

        boolean afterUpdateRecursionFlag = TDTM_ProcessControl.getRecursionFlag(TDTM_ProcessControl.registeredTrigger.PPlan_Primary_TDTM_After_Update);
    
        // AFTER UPDATE
        if ( newlist != null && triggerAction == TDTM_Runnable.Action.AfterUpdate && !afterUpdateRecursionFlag) {                
             for (integer i = 0; i < newlist.size(); i++) {
                Program_Plan__c newPPlan = (Program_Plan__c)newlist[i];
                Program_Plan__c oldPPlan = (Program_Plan__c)oldlist[i];
                if (isNewlyPrimaryOrPrimaryAndAccountChanged(oldPPlan, newPPlan)) {
                    //if multiple program plans under one single account are set as primary in same transation
                    //Use the first program plan as the primary
                    if (!acccountIdsNeedNonPrimarycount.contains(newPPlan.Account__c)) {
                        primaryProgramIds.add(newPPlan.Id);
                    }
                    acccountIdsNeedNonPrimarycount.add(newPPlan.Account__c);
                }
            }
        }

        if (acccountIdsNeedNonPrimarycount.size() > 0) {
            dmlWrapper.objectsToUpdate.addAll(makeOtherPPlanNotPrimary(acccountIdsNeedNonPrimarycount, primaryProgramIds));
        }
        
        if (triggerAction == TDTM_Runnable.Action.AfterUpdate) {
            TDTM_ProcessControl.setRecursionFlag(TDTM_ProcessControl.registeredTrigger.PPlan_Primary_TDTM_After_Update, false);
        } else if (triggerAction == TDTM_Runnable.Action.AfterInsert) {
            TDTM_ProcessControl.setRecursionFlag(TDTM_ProcessControl.registeredTrigger.PPlan_Primary_TDTM_After_Insert, false);
        }
        
        return dmlWrapper;
    }

    /*******************************************************************************************************
    * @description Compares oldPPlan (if present), and newPPlan to see if newly Primary, or if Account was changed.
    * Requires Is_Primary__c and Account__c fields to be populated.
    * @param oldPPlan old value of Program_Plan__c record (or null if new record) 
    * @param new PPlan new value of Program_Plan__c record
    * @return Boolean true if newly marked primary, or if currently primary and related Account__c was changed, false otherwise
    ********************************************************************************************************/
    @testVisible private static boolean isNewlyPrimaryOrPrimaryAndAccountChanged(Program_Plan__c oldPPlan, Program_Plan__c newPPlan) {
        boolean wasPrimary = ((oldPPlan != null) && (oldPPlan.Is_Primary__c));
        boolean isPrimary = ((newPPlan != null) && (newPPlan.Is_Primary__c));  
        Id oldAcctId = (oldPPlan != null) ? oldPPlan.Account__c : null;
        Id newAcctId = (newPPlan != null) ? newPPlan.Account__c : null;

        boolean acctChange = ((oldPPlan != null) && (oldAcctId != newAcctId));

        return (isPrimary) && ((!wasPrimary) || (acctChange));
    }

    private List<Program_Plan__c> makeOtherPPlanNotPrimary(Set<Id> accountIdsNeedNonPrimary, Set<Id> primaryProgramIds) {
        List<Program_Plan__c> pPlansNeedNonPrimary = new List<Program_Plan__c>();
        for (Program_Plan__c pPlan : [SELECT Id,
                                            Is_Primary__c
                                    From Program_Plan__c
                                    WHERE Account__c IN :accountIdsNeedNonPrimary
                                        AND Id NOT IN :primaryProgramIds
                                        AND IS_Primary__c = true]) {
            pPlan.Is_Primary__c = false;
            pPlansNeedNonPrimary.add(pPlan);
        }
        return pPlansNeedNonPrimary;
    }
}
@IsTest
private class PPlan_Primary_TEST {
    /*********************************************************************************************************
    * @description Set other program plans as non-primary
    * when a program plan is set as primary
    */
    @IsTest
    static void setOtherProgramPlanNonPrimaryUpdate() {
        List<Account> accts = UTIL_UnitTestData_TEST.getMultipleTestAccounts(1, UTIL_Describe.getCustomAdminAccRecTypeID());
        insert accts[0];

        List<Program_Plan__c> pPlans = UTIL_UnitTestData_TEST.getMultipleTestProgramPlans(3);
        for (Program_Plan__c pPlan : pPlans) {
            pPlan.Account__c = accts[0].Id;
        }
        insert pPlans;

        pPlans[0].Is_Primary__c = true;
        update pPlans[0];

        Test.startTest();
        pPlans[1].Is_Primary__c = true;
        update pPlans[1];
        Test.stopTest();

        //assert
        List<Program_Plan__c> assertProgramPlans = [SELECT Is_Primary__c FROM Program_Plan__c where Account__c = :accts[0].Id];
        for (Program_Plan__c pPlan : assertProgramPlans) {
            if (pPlan.Id != pPlans[1].Id) {
                system.assertEquals(false, pPlan.Is_Primary__c);
            }else {
                system.assertEquals(true, pPlan.Is_Primary__c);
            }
        }
    }

    /*********************************************************************************************************
     * @description Set other program plans as non-primary
     * when a new program plan is inserted and set as primary
     */
    @IsTest
    static void setOtherProgramPlanNonPrimaryInsert() {
        List<Account> accts = UTIL_UnitTestData_TEST.getMultipleTestAccounts(1, UTIL_Describe.getCustomAdminAccRecTypeID());
        insert accts[0];

        List<Program_Plan__c> pPlans = UTIL_UnitTestData_TEST.getMultipleTestProgramPlans(3);
        for (Program_Plan__c pPlan : pPlans) {
            pPlan.Account__c = accts[0].Id;
        }
        insert pPlans;

        pPlans[0].Is_Primary__c = true;
        update pPlans[0];

        Test.startTest();
        Program_Plan__c newPPlan = UTIL_UnitTestData_TEST.getProgramPlan();
        newPPlan.Account__c = accts[0].Id;
        newPPlan.Is_Primary__c = true;
        insert newPPlan;
        Test.stopTest();

        //assert
        List<Program_Plan__c> assertProgramPlans = [SELECT Is_Primary__c FROM Program_Plan__c where Account__c = :accts[0].Id];
        for (Program_Plan__c pPlan : assertProgramPlans) {
            if (pPlan.Id != newPPlan.Id) {
                system.assertEquals(false, pPlan.Is_Primary__c);
            }else {
                system.assertEquals(true, pPlan.Is_Primary__c);
            }
        }
    }

    /*********************************************************************************************************
     * @description Set other program plans as non-primary
     * when a program plan is set as primary and linked to the account
     */
    @IsTest
    static void setOtherProgramPlanNonPrimaryLinkToAccount() {
        List<Account> accts = UTIL_UnitTestData_TEST.getMultipleTestAccounts(1, UTIL_Describe.getCustomAdminAccRecTypeID());
        insert accts[0];

        List<Program_Plan__c> pPlans = UTIL_UnitTestData_TEST.getMultipleTestProgramPlans(3);
        for (Program_Plan__c pPlan : pPlans) {
            pPlan.Account__c = accts[0].Id;
        }
        insert pPlans;

        pPlans[0].Is_Primary__c = true;
        update pPlans[0];

        Test.startTest();
        Program_Plan__c newPPlan = UTIL_UnitTestData_TEST.getProgramPlan();
        newPPlan.Is_Primary__c = true;
        insert newPPlan;
        newPPlan.Account__c = accts[0].Id;
        update newPPlan;
        Test.stopTest();

        //assert
        List<Program_Plan__c> assertProgramPlans = [SELECT Is_Primary__c FROM Program_Plan__c where Account__c = :accts[0].Id];
        for (Program_Plan__c pPlan : assertProgramPlans) {
            if (pPlan.Id != newPPlan.Id) {
                system.assertEquals(false, pPlan.Is_Primary__c);
            }else {
                system.assertEquals(true, pPlan.Is_Primary__c);
            }
        }
    }

    /*********************************************************************************************************
     * @description Confirm various scenarios with isNewlyPrimaryOrPrimaryAccountChanged method
     *
     */
    @IsTest
    static void isNewlyPrimaryOrPrimaryAndAccountChanged() {
         List<Account> accts = UTIL_UnitTestData_TEST.getMultipleTestAccounts(2, UTIL_Describe.getCustomAdminAccRecTypeID());
        insert accts[0];

        List<Program_Plan__c> pPlans = UTIL_UnitTestData_TEST.getMultipleTestProgramPlans(1);
        for (Program_Plan__c pPlan : pPlans) {
            pPlan.Account__c = accts[0].Id;
        }
        insert pPlans;
        
        Program_Plan__c oldPPlan = pPlans[0].clone(true, true, true, true);
        Program_Plan__c newPPlan = pPlans[0].clone(true, true, true, true); 
                
        System.assertEquals (false, PPlan_Primary_TDTM.isNewlyPrimaryOrPrimaryAndAccountChanged(null, newPPlan), 'Test #1 - New Plan, Not Primary');
        
        newPPlan.IS_Primary__c = true;
        System.assertEquals (true, PPlan_Primary_TDTM.isNewlyPrimaryOrPrimaryAndAccountChanged(null, newPPlan), 'Test #2 - New Plan, Primary');

        oldPPlan.IS_Primary__c = false;
        newPPlan.IS_Primary__c = false;

        System.assertEquals (false, PPlan_Primary_TDTM.isNewlyPrimaryOrPrimaryAndAccountChanged(oldPPlan, newPPlan), 'Test #3 - Plan Update, neither are primary');

        oldPPlan.Is_Primary__c = false;
        newPPlan.Is_Primary__c = true;
        System.assertEquals (true, PPlan_Primary_TDTM.isNewlyPrimaryOrPrimaryAndAccountChanged(oldPPlan, newPPlan), 'Test #4 - Plan Update, Old Plan Not Primary, New Plan Primary');

        newPPlan.Is_Primary__c = true;
        oldPPlan.Is_Primary__c = true;
        System.assertEquals (false, PPlan_Primary_TDTM.isNewlyPrimaryOrPrimaryAndAccountChanged(oldPPlan, newPPlan), 'Test #5 - Plan Update, Old Plan Primary, New Plan Primary');

        oldPPlan.Is_Primary__c = true;
        newPPlan.Is_Primary__c = false;
        System.assertEquals (false, PPlan_Primary_TDTM.isNewlyPrimaryOrPrimaryAndAccountChanged(oldPPlan, newPPlan), 'Test #6 - Plan Update, Old Plan Primary, New Plan Not Primary');

        oldPPlan.Is_Primary__c = true;
        newPPlan.Is_Primary__c = true;
        newPPlan.Account__c = accts[1].Id;
        System.assertEquals (true, PPlan_Primary_TDTM.isNewlyPrimaryOrPrimaryAndAccountChanged(oldPPlan, newPPlan), 'Test #7 - Plan Update, Old Plan Primary, New Plan Primary, New Plan Account Changed');

        oldPPlan.Is_Primary__c = false;
        newPPlan.Is_Primary__c = false;
        newPPlan.Account__c = accts[1].Id;
        System.assertEquals (false, PPlan_Primary_TDTM.isNewlyPrimaryOrPrimaryAndAccountChanged(oldPPlan, newPPlan), 'Test #7 - Plan Update, Old Plan Not Primary, New Plan Not Primary, New Plan Account Changed');

        oldPPlan.Is_Primary__c = false;
        newPPlan.Is_Primary__c = true;
        newPPlan.Account__c = accts[1].Id;
        System.assertEquals (true, PPlan_Primary_TDTM.isNewlyPrimaryOrPrimaryAndAccountChanged(oldPPlan, newPPlan), 'Test #8 - Plan Update, Old Plan Not Primary, New Plan Primary, New Plan Account Changed');

        oldPPlan.Is_Primary__c = true;
        newPPlan.Is_Primary__c = false;
        newPPlan.Account__c = accts[1].Id;
        System.assertEquals (false, PPlan_Primary_TDTM.isNewlyPrimaryOrPrimaryAndAccountChanged(oldPPlan, newPPlan), 'Test #9 - Plan Update, Old Plan Primary, New Plan Not Primary, New Plan Account Changed');

    }
}
public class PREN_Affiliation_TDTM extends TDTM_Runnable {

    /*******************************************************************************************************
    * @description Handles Affiliation management for Program Enrollment.
    * @param listNew the list of Program Enrollments from trigger new. 
    * @param listOld the list of Program Enrollments from trigger old. 
    * @param triggerAction which trigger event (BeforeInsert, AfterInsert, etc.). 
    * @param objResult the describe for Program Enrollment. 
    * @return dmlWrapper.  
    ********************************************************************************************************/
    public override DmlWrapper run(List<SObject> newlist, List<SObject> oldlist, 
        TDTM_Runnable.Action triggerAction, Schema.DescribeSObjectResult objResult) {
    
        DmlWrapper dmlWrapper = new DmlWrapper();

        if (newlist != null && newlist.size() > 0) {
            // Because this runs on BeforeInsert, we don't need to worry about reentrancy here. The same program 
            // enrollment can't be inserted more than once! If inserting affiliation records creates or deletes 
            // more program enrollment records, we'd *want* these to be processed!
            createRelatedAffls(newlist, triggerAction);
        }
        
        if (oldlist != null && oldlist.size() > 0) {
            // Because this runs on AfterDelete, we don't need to worry about reentrancy here. The same program
            // enrollment can't be deleted more than once! If updating affiliation records creates or deletes
            // more program enrollment records, we'd *want* these to be processed!
            updateDeleteRelatedAffls(getDeletedPEsAfflIDs(oldlist, triggerAction), oldlist, dmlWrapper);
        }
        
        return dmlWrapper;
    }

    private void createRelatedAffls(List<SObject> newlist, TDTM_Runnable.Action triggerAction) {
        List<Affiliation__c> newAffls = new List<Affiliation__c>();

        for (SObject so : newlist) {
            Program_Enrollment__c enrollment = (Program_Enrollment__c)so;

            if (triggerAction == TDTM_Runnable.Action.BeforeInsert) {
                //Automatically create an Affiliation record if a Program Enrollment record has been created without an affiliation.
                if (enrollment.Contact__c != null && enrollment.Account__c != null && enrollment.Affiliation__c == null) {
                    Date afflEndDate = (UTIL_CustomSettingsFacade.getSettings().Affl_ProgEnroll_Copy_End_Date__c == true ? enrollment.End_Date__c : null);
                    Date afflStartDate = (UTIL_CustomSettingsFacade.getSettings().Affl_ProgEnroll_Copy_Start_Date__c == true ? enrollment.Start_Date__c : null);
                    String afflRole = (UTIL_CustomSettingsFacade.getSettings().Affl_ProgEnroll_Set_Role__c == true ? UTIL_CustomSettingsFacade.getSettings().Affl_ProgEnroll_Role_Map__c : null);

                    Affiliation__c affl = new Affiliation__c(Contact__c = enrollment.Contact__c,
                                                            Account__c = enrollment.Account__c,
                                                            EndDate__c = afflEndDate,
                                                            StartDate__c = afflStartDate,
                                                            Status__c = UTIL_CustomSettingsFacade.getSettings().Affl_ProgEnroll_Status_Map__c,
                                                            Role__c = afflRole);
                    newAffls.add(affl);
                }
            }
        }
        
        if (newAffls.size() > 0) {
            //Turn off AFFL_MultiRecordType_TDTM_After_Insert so EDA won't create duplicate program enrollment
            TDTM_ProcessControl.turnOffRecursionFlag(TDTM_ProcessControl.registeredTrigger.AFFL_MultiRecordType_TDTM_After_Insert);
            //We manually insert the affiliations because we need the IDs, in order to link the Program Enrollments with the Affls.
            insert newAffls;
            
            for (Integer i = 0; i < newAffls.size(); i++) {
                Program_Enrollment__c enrollment = (Program_Enrollment__c)newlist[i];
                enrollment.Affiliation__c = newAffls[i].ID;
            }
            //We don't need to add these enrollment records to dmlWrapper because we are in BeforeInsert.
        }
    }
    
    private List<ID> getDeletedPEsAfflIDs(List<SObject> oldlist, TDTM_Runnable.Action triggerAction) {
        List<ID> afflsToUpdateDelIDs = new List<ID>();
        //Only need to loop through the list when deleting Program Enrollment records
        if (triggerAction == TDTM_Runnable.Action.AfterDelete) {  
            
            for (SObject so : oldlist) {            
                Program_Enrollment__c oldEnrollment = (Program_Enrollment__c)so;
                
                if (oldEnrollment.Affiliation__c != null) {
                    //Get related Affls ids
                    afflsToUpdateDelIDs.add(oldEnrollment.Affiliation__c);
                }
            }
            
        }

        return afflsToUpdateDelIDs;
    }
    
    private void updateDeleteRelatedAffls(List<ID> afflsToUpdateDelIDs, List<SObject> oldlist, DmlWrapper dmlWrapper) {
        //Delete or update related affiliations when Program Enrollment records are deleted.
        List<Affiliation__c> afflsToUpdateDel = new List<Affiliation__c>();
        
        List<Program_Enrollment__c> otherProgramEnrollments = [SELECT Id, Affiliation__c FROM Program_Enrollment__c WHERE Affiliation__c IN :afflsToUpdateDelIDs AND Id NOT IN :oldList];
        Set<Id> affiliationIdsToIgnore = new Set<Id>();
        
        for (Program_Enrollment__c otherProgramEnrollment : otherProgramEnrollments) {
            affiliationIdsToIgnore.add(otherProgramEnrollment.Affiliation__c);
        }
        
        if (UTIL_CustomSettingsFacade.getSettings().Affl_ProgEnroll_Del__c) {
            
            for (ID affiliationId : afflsToUpdateDelIDs) {
                //Only delete the Affiliation if there are no other Program Enrollment records associated to it.
                if (!affiliationIdsToIgnore.contains(affiliationId)) {
                    afflsToUpdateDel.add(new Affiliation__c(ID = affiliationId));
                }
            }
            
            dmlWrapper.objectsToDelete.addAll((List<SObject>)afflsToUpdateDel);
        } else {
            String affiliationStatusOnPEDelete = UTIL_CustomSettingsFacade.getSettings().Affl_ProgEnroll_Del_Status__c;
            List<Affiliation__c> potentialAffiliationsToUpdate = [SELECT Id, Status__c FROM Affiliation__c WHERE ID IN :afflsToUpdateDelIDs];
            
            for (Affiliation__c affl : potentialAffiliationsToUpdate) {
                //Only update the Affiliation if there are no other Program Enrollment records associated to it.
                if (!affiliationIdsToIgnore.contains(affl.Id)) {
                    affl.Status__c = affiliationStatusOnPEDelete;
                    afflsToUpdateDel.add(affl);
                }
            }
            
            dmlWrapper.objectsToUpdate.addAll((List<SObject>)afflsToUpdateDel);
        }
    }
}
@isTest
private class PREN_Affiliation_TEST {
    /*********************************************************************************************************
     * @description Verifies that an Affiliation is automatically created when a Program Enrollment record is
     * manually created from a Contact.
     */
    @isTest
    public static void createAfflFromProgramEnrollment() {
        STG_InstallScript.insertMappings();

        Contact contact = new Contact(FirstName = 'Test', LastName = 'Testerson');
        insert contact;

        ID orgRecTypeID = UTIL_Describe_API.getBizAccRecTypeID();

        //Create account of Business Organization record type
        Account acc = new Account(Name = 'Acme', RecordTypeId = orgRecTypeID);
        insert acc;

        //Create Program Enrollment
        Program_Enrollment__c enrollment = new Program_Enrollment__c(Contact__c = contact.ID, Account__c = acc.ID);
        Test.startTest();
        insert enrollment;
        Test.stopTest();

        //An Affiliation should have been automatically created from the Program Enrollment
        List<Affiliation__c> affls = [SELECT Contact__c, Account__c FROM Affiliation__c WHERE Account__c = :acc.ID];
        System.assertEquals(1, affls.size());

        //The Program Enrollment record should be related to the Affiliation just created
        enrollment = [SELECT Affiliation__c FROM Program_Enrollment__c WHERE ID = :enrollment.ID];
        System.assertEquals(affls[0].ID, enrollment.Affiliation__c);

        //Only should one program enrollment exist
        List<Program_Enrollment__c> assertProgramEnrollments = [SELECT Id FROM Program_Enrollment__c];
        System.assertEquals(1, assertProgramEnrollments.size());
    }

    /*********************************************************************************************************
     * @description Creating a Program Enrollment copies the related Affiliation End Date when
     * Affl_ProgEnroll_Copy_End_Date__c setting is set to true.
     */
    @isTest
    public static void copyAfflFromProgramEnrollmentEndDateYes() {
        UTIL_CustomSettingsFacade.getSettingsForTests(
            new Hierarchy_Settings__c(Affl_ProgEnroll_Copy_End_Date__c = true)
        );

        Contact contact = new Contact(FirstName = 'Test', LastName = 'Testerson');
        insert contact;

        ID orgRecTypeID = UTIL_Describe_API.getBizAccRecTypeID();

        //Create account of Business Organization record type
        Account acc = new Account(Name = 'Acme', RecordTypeId = orgRecTypeID);
        insert acc;

        //Test for end date
        Date testDate = Date.newInstance(1970, 1, 1);

        //Create Program Enrollment
        Program_Enrollment__c enrollment = new Program_Enrollment__c(
            Contact__c = contact.ID,
            Account__c = acc.ID,
            End_Date__c = testDate
        );
        Test.startTest();
        insert enrollment;
        Test.stopTest();

        //An Affiliation should have been automatically created from the Program Enrollment
        List<Affiliation__c> affls = [SELECT EndDate__c FROM Affiliation__c WHERE Account__c = :acc.ID];
        System.assertEquals(1, affls.size());
        System.assertEquals(testDate, affls[0].EndDate__c);

        //Only should one program enrollment exist
        List<Program_Enrollment__c> assertProgramEnrollments = [SELECT Id FROM Program_Enrollment__c];
        System.assertEquals(1, assertProgramEnrollments.size());
    }

    /*********************************************************************************************************
     * @description Creating a Program Enrollment doesn't copy the related Affiliation End Date when
     * Affl_ProgEnroll_Copy_End_Date__c setting is set to false.
     */
    @isTest
    public static void copyAfflFromProgramEnrollmentEndDateNo() {
        UTIL_CustomSettingsFacade.getSettingsForTests(
            new Hierarchy_Settings__c(Affl_ProgEnroll_Copy_End_Date__c = false)
        );

        Contact contact = new Contact(FirstName = 'Test', LastName = 'Testerson');
        insert contact;

        ID orgRecTypeID = UTIL_Describe_API.getBizAccRecTypeID();

        //Create account of Business Organization record type
        Account acc = new Account(Name = 'Acme', RecordTypeId = orgRecTypeID);
        insert acc;

        //Test for end date
        Date testDate = Date.newInstance(1970, 1, 1);

        //Create Program Enrollment
        Program_Enrollment__c enrollment = new Program_Enrollment__c(
            Contact__c = contact.ID,
            Account__c = acc.ID,
            End_Date__c = testDate
        );
        Test.startTest();
        insert enrollment;
        Test.stopTest();

        //An Affiliation should have been automatically created from the Program Enrollment
        List<Affiliation__c> affls = [SELECT EndDate__c FROM Affiliation__c WHERE Account__c = :acc.ID];
        System.assertEquals(1, affls.size());
        System.assertEquals(null, affls[0].EndDate__c);

        //Only should one program enrollment exist
        List<Program_Enrollment__c> assertProgramEnrollments = [SELECT Id FROM Program_Enrollment__c];
        System.assertEquals(1, assertProgramEnrollments.size());
    }

    /*********************************************************************************************************
     * @description Creating a Program Enrollment copies the related Affiliation Start Date when
     * Affl_ProgEnroll_Copy_Start_Date__c setting is set to true.
     */
    @isTest
    public static void copyAfflFromProgramEnrollmentStartDateYes() {
        UTIL_CustomSettingsFacade.getSettingsForTests(
            new Hierarchy_Settings__c(Affl_ProgEnroll_Copy_Start_Date__c = true)
        );

        Contact contact = new Contact(FirstName = 'Test', LastName = 'Testerson');
        insert contact;

        ID orgRecTypeID = UTIL_Describe_API.getBizAccRecTypeID();

        //Create account of Business Organization record type
        Account acc = new Account(Name = 'Acme', RecordTypeId = orgRecTypeID);
        insert acc;

        //Test for end date
        Date testDate = Date.newInstance(1970, 1, 1);

        //Create Program Enrollment
        Program_Enrollment__c enrollment = new Program_Enrollment__c(
            Contact__c = contact.ID,
            Account__c = acc.ID,
            Start_Date__c = testDate
        );
        Test.startTest();
        insert enrollment;
        Test.stopTest();

        //An Affiliation should have been automatically created from the Program Enrollment
        List<Affiliation__c> affls = [SELECT StartDate__c FROM Affiliation__c WHERE Account__c = :acc.ID];
        System.assertEquals(1, affls.size());
        System.assertEquals(testDate, affls[0].StartDate__c);

        //Only should one program enrollment exist
        List<Program_Enrollment__c> assertProgramEnrollments = [SELECT Id FROM Program_Enrollment__c];
        System.assertEquals(1, assertProgramEnrollments.size());
    }

    /*********************************************************************************************************
     * @description Creating a Program Enrollment doesn't copy the related Affiliation Start Date when
     * Affl_ProgEnroll_Copy_Start_Date__c setting is set to false.
     */
    @isTest
    public static void copyAfflFromProgramEnrollmentStartDateNo() {
        UTIL_CustomSettingsFacade.getSettingsForTests(
            new Hierarchy_Settings__c(Affl_ProgEnroll_Copy_Start_Date__c = false)
        );

        Contact contact = new Contact(FirstName = 'Test', LastName = 'Testerson');
        insert contact;

        ID orgRecTypeID = UTIL_Describe_API.getBizAccRecTypeID();

        //Create account of Business Organization record type
        Account acc = new Account(Name = 'Acme', RecordTypeId = orgRecTypeID);
        insert acc;

        //Test for end date
        Date testDate = Date.newInstance(1970, 1, 1);

        //Create Program Enrollment
        Program_Enrollment__c enrollment = new Program_Enrollment__c(
            Contact__c = contact.ID,
            Account__c = acc.ID,
            Start_Date__c = testDate
        );
        Test.startTest();
        insert enrollment;
        Test.stopTest();

        //An Affiliation should have been automatically created from the Program Enrollment
        List<Affiliation__c> affls = [SELECT StartDate__c FROM Affiliation__c WHERE Account__c = :acc.ID];
        System.assertEquals(1, affls.size());
        System.assertNotEquals(testDate, affls[0].StartDate__c);

        //Only should one program enrollment exist
        List<Program_Enrollment__c> assertProgramEnrollments = [SELECT Id FROM Program_Enrollment__c];
        System.assertEquals(1, assertProgramEnrollments.size());
    }

    /*********************************************************************************************************
     * @description Creating a Program Enrollment sets the related Affiliation Role when
     * Affl_ProgEnroll_Set_Role__c setting is set to true.
     */
    @isTest
    public static void setAfflFromProgramEnrollmentRoleYes() {
        UTIL_CustomSettingsFacade.getSettingsForTests(
            new Hierarchy_Settings__c(
                Affl_ProgEnroll_Set_Role__c = true,
                Affl_ProgEnroll_Role_Map__c = AffiliationTestSetupFactory_TEST.PROG_ENROLL_ROLE_STUDENT
            )
        );

        Contact contact = new Contact(FirstName = 'Test', LastName = 'Testerson');
        insert contact;

        ID orgRecTypeID = UTIL_Describe_API.getBizAccRecTypeID();

        //Create account of Business Organization record type
        Account acc = new Account(Name = 'Acme', RecordTypeId = orgRecTypeID);
        insert acc;

        //Create Program Enrollment
        Program_Enrollment__c enrollment = new Program_Enrollment__c(Contact__c = contact.ID, Account__c = acc.ID);
        Test.startTest();
        insert enrollment;
        Test.stopTest();

        //An Affiliation should have been automatically created from the Program Enrollment
        List<Affiliation__c> affls = [SELECT Role__c FROM Affiliation__c WHERE Account__c = :acc.ID];
        System.assertEquals(1, affls.size());
        System.assertEquals(AffiliationTestSetupFactory_TEST.PROG_ENROLL_ROLE_STUDENT, affls[0].Role__c);

        //Only should one program enrollment exist
        List<Program_Enrollment__c> assertProgramEnrollments = [SELECT Id FROM Program_Enrollment__c];
        System.assertEquals(1, assertProgramEnrollments.size());
    }

    /*********************************************************************************************************
     * @description Creating a Program Enrollment does not set the related Affiliation Role when
     * Affl_ProgEnroll_Set_Role__c setting is set to false.
     * Test Scenario: T-3939003
     */
    @isTest
    public static void setAfflFromProgramEnrollmentRoleNo() {
        UTIL_CustomSettingsFacade.getSettingsForTests(
            new Hierarchy_Settings__c(
                Affl_ProgEnroll_Set_Role__c = false,
                Affl_ProgEnroll_Role_Map__c = AffiliationTestSetupFactory_TEST.PROG_ENROLL_ROLE_STUDENT
            )
        );

        Contact contact = new Contact(FirstName = 'Test', LastName = 'Testerson');
        insert contact;

        ID orgRecTypeID = UTIL_Describe_API.getBizAccRecTypeID();

        //Create account of Business Organization record type
        Account acc = new Account(Name = 'Acme', RecordTypeId = orgRecTypeID);
        insert acc;

        //Create Program Enrollment
        Program_Enrollment__c enrollment = new Program_Enrollment__c(Contact__c = contact.ID, Account__c = acc.ID);
        Test.startTest();
        insert enrollment;
        Test.stopTest();

        //An Affiliation should have been automatically created from the Program Enrollment
        List<Affiliation__c> affls = [SELECT Role__c FROM Affiliation__c WHERE Account__c = :acc.ID];
        System.assertEquals(1, affls.size());
        System.assertEquals(null, affls[0].Role__c);

        //Only should one program enrollment exist
        List<Program_Enrollment__c> assertProgramEnrollments = [SELECT Id FROM Program_Enrollment__c];
        System.assertEquals(1, assertProgramEnrollments.size());
    }

    /*********************************************************************************************************
     * @description Creating a Program Enrollment sets the related Affiliation Status when
     * to Affiliation_Program_Enrollment_Stat_Map.
     * Test Scenario: T-3939003
     */
    @isTest
    public static void setAfflFromProgramEnrollmentStatus() {
        UTIL_CustomSettingsFacade.getSettingsForTests(
            new Hierarchy_Settings__c(
                Affl_ProgEnroll_Status_Map__c = AffiliationTestSetupFactory_TEST.PROG_ENROLL_STATUS_FORMER
            )
        );

        Contact contact = new Contact(FirstName = 'Test', LastName = 'Testerson');
        insert contact;

        ID orgRecTypeID = UTIL_Describe_API.getBizAccRecTypeID();

        //Create account of Business Organization record type
        Account acc = new Account(Name = 'Acme', RecordTypeId = orgRecTypeID);
        insert acc;

        //Create Program Enrollment
        Program_Enrollment__c enrollment = new Program_Enrollment__c(Contact__c = contact.ID, Account__c = acc.ID);
        Test.startTest();
        insert enrollment;
        Test.stopTest();

        //An Affiliation should have been automatically created from the Program Enrollment
        List<Affiliation__c> affls = [SELECT Status__c FROM Affiliation__c WHERE Account__c = :acc.ID];
        System.assertEquals(1, affls.size());
        System.assertEquals(AffiliationTestSetupFactory_TEST.PROG_ENROLL_STATUS_FORMER, affls[0].Status__c);

        //Only should one program enrollment exist
        List<Program_Enrollment__c> assertProgramEnrollments = [SELECT Id FROM Program_Enrollment__c];
        System.assertEquals(1, assertProgramEnrollments.size());
    }

    /*********************************************************************************************************
     * @description Creating a Program Enrollment sets the related Affiliation Role when
     * Affl_ProgEnroll_Set_Role__c setting is set to true and sets the related Affiliation Status
     * to Affiliation_Program_Enrollment_Stat_Map
     * Test Scenario: T-3939003
     */
    @isTest
    public static void setAfflFromProgramEnrollmentRoleYesStatus() {
        UTIL_CustomSettingsFacade.getSettingsForTests(
            new Hierarchy_Settings__c(
                Affl_ProgEnroll_Set_Role__c = true,
                Affl_ProgEnroll_Role_Map__c = AffiliationTestSetupFactory_TEST.PROG_ENROLL_ROLE_STUDENT,
                Affl_ProgEnroll_Status_Map__c = AffiliationTestSetupFactory_TEST.PROG_ENROLL_STATUS_CURRENT
            )
        );

        STG_InstallScript.insertMappings();

        Contact contact = new Contact(FirstName = 'Test', LastName = 'Testerson');
        insert contact;

        //Create account of Business Organization record type
        Account acc = new Account(Name = 'Acme', RecordTypeId = UTIL_Describe_API.getAcademicAccRecTypeID());
        insert acc;

        //Create Program Enrollment
        Program_Enrollment__c enrollment = new Program_Enrollment__c(Contact__c = contact.ID, Account__c = acc.ID);
        Test.startTest();
        insert enrollment;
        Test.stopTest();

        //An Affiliation should have been automatically created from the Program Enrollment
        List<Affiliation__c> affls = [SELECT Role__c FROM Affiliation__c WHERE Account__r.ID = :acc.ID];
        System.assertEquals(1, affls.size());
        System.assertEquals(AffiliationTestSetupFactory_TEST.PROG_ENROLL_ROLE_STUDENT, affls[0].Role__c);

        //Only should one program enrollment exist
        List<Program_Enrollment__c> assertProgramEnrollments = [SELECT Id FROM Program_Enrollment__c];
        System.assertEquals(1, assertProgramEnrollments.size());
    }

    /*********************************************************************************************************
     * @description Deleting a Program Enrollment deletes the related Affiliation when Affl_ProgEnroll_Del__c setting
     * is set to true.
     */
    @isTest
    public static void deletePEnrollDelAfflYes() {
        STG_InstallScript.insertMappings();

        UTIL_CustomSettings_API.getSettingsForTests(new Hierarchy_Settings__c(Affl_ProgEnroll_Del__c = true));

        Contact contact = UTIL_UnitTestData_TEST.getContact();
        insert contact;

        //Create account of Business Organization record type
        Account acc = UTIL_UnitTestData_TEST.getMultipleTestAccounts(1, UTIL_Describe_API.getBizAccRecTypeID())[0];
        insert acc;

        //Create Program Enrollment
        Program_Enrollment__c enrollment = new Program_Enrollment__c(Contact__c = contact.ID, Account__c = acc.ID);
        insert enrollment;

        //An Affiliation should have been automatically created from the Program Enrollment
        List<Affiliation__c> affls = [SELECT Contact__c, Account__c FROM Affiliation__c WHERE Account__c = :acc.ID];
        System.assertEquals(1, affls.size());

        //The Program Enrollment record should be related to the Affiliation just created
        enrollment = [SELECT Affiliation__c FROM Program_Enrollment__c WHERE ID = :enrollment.ID];
        System.assertEquals(affls[0].ID, enrollment.Affiliation__c);
        ID enrollmentAfflID = enrollment.Affiliation__c; //Storing it to use it in next query

        //Create additional Program Enrollment
        Program_Enrollment__c enrollment2 = new Program_Enrollment__c(
            Contact__c = contact.ID,
            Account__c = acc.ID,
            Affiliation__c = enrollmentAfflID
        );
        insert enrollment2;

        //Delete both Program Enrollments
        Test.startTest();
        delete new List<Program_Enrollment__c>{ enrollment, enrollment2 };
        Test.stopTest();

        //Related Affiliation should have been automatically deleted
        affls = [SELECT ID FROM Affiliation__c WHERE ID = :enrollmentAfflID];
        System.assertEquals(0, affls.size());
    }

    /*********************************************************************************************************
     * @description Deleting a Program Enrollment does not delete the related Affiliation when Affl_ProgEnroll_Del__c setting
     * is set to true but other Program Enrollments are associated to the same Affiliation.
     */
    @isTest
    public static void deletePEnrollDelAfflYes_existingPEPreventsAffiliationDeletion() {
        STG_InstallScript.insertMappings();

        UTIL_CustomSettings_API.getSettingsForTests(new Hierarchy_Settings__c(Affl_ProgEnroll_Del__c = true));

        Contact contact = UTIL_UnitTestData_TEST.getContact();
        insert contact;

        //Create account of Business Organization record type
        Account acc = UTIL_UnitTestData_TEST.getMultipleTestAccounts(1, UTIL_Describe_API.getBizAccRecTypeID())[0];
        insert acc;

        //Create Program Enrollment
        Program_Enrollment__c enrollment = new Program_Enrollment__c(Contact__c = contact.ID, Account__c = acc.ID);
        insert enrollment;

        //An Affiliation should have been automatically created from the Program Enrollment
        List<Affiliation__c> affls = [SELECT Contact__c, Account__c FROM Affiliation__c WHERE Account__c = :acc.ID];
        System.assertEquals(1, affls.size());

        //The Program Enrollment record should be related to the Affiliation just created
        enrollment = [SELECT Affiliation__c FROM Program_Enrollment__c WHERE ID = :enrollment.ID];
        System.assertEquals(affls[0].ID, enrollment.Affiliation__c);
        ID enrollmentAfflID = enrollment.Affiliation__c; //Storing it to use it in next query

        //Create additional Program Enrollment
        Program_Enrollment__c enrollment2 = new Program_Enrollment__c(
            Contact__c = contact.ID,
            Account__c = acc.ID,
            Affiliation__c = enrollmentAfflID
        );
        insert enrollment2;

        //Delete Program Enrollment
        Test.startTest();
        delete enrollment;
        Test.stopTest();

        //Related Affiliation should have NOT been automatically deleted
        affls = [SELECT ID FROM Affiliation__c WHERE ID = :enrollmentAfflID];
        System.assertEquals(1, affls.size());
    }

    /*********************************************************************************************************
     * @description Deleting a Program Enrollment doesn't delete the related Affiliation when Affl_ProgEnroll_Del__c setting
     * is set to false. It just changes the status to what is defined in Affl_ProgEnroll_Del_Status__c.
     */
    @isTest
    public static void deletePEnrollDelAfflNo() {
        STG_InstallScript.insertMappings();

        String afflStatus = AffiliationTestSetupFactory_TEST.PROG_ENROLL_STATUS_FORMER;
        UTIL_CustomSettings_API.getSettingsForTests(
            new Hierarchy_Settings__c(Affl_ProgEnroll_Del__c = false, Affl_ProgEnroll_Del_Status__c = afflStatus)
        );

        Contact contact = UTIL_UnitTestData_TEST.getContact();
        insert contact;

        //Create account of Business Organization record type
        Account acc = UTIL_UnitTestData_TEST.getMultipleTestAccounts(1, UTIL_Describe_API.getBizAccRecTypeID())[0];
        insert acc;

        //Create Program Enrollment
        Program_Enrollment__c enrollment = new Program_Enrollment__c(Contact__c = contact.ID, Account__c = acc.ID);
        insert enrollment;

        //An Affiliation should have been automatically created from the Program Enrollment
        List<Affiliation__c> affls = [SELECT Contact__c, Account__c FROM Affiliation__c WHERE Account__c = :acc.ID];
        System.assertEquals(1, affls.size());

        //The Program Enrollment record should be related to the Affiliation just created
        enrollment = [SELECT Affiliation__c FROM Program_Enrollment__c WHERE ID = :enrollment.ID];
        System.assertEquals(affls[0].ID, enrollment.Affiliation__c);

        ID enrollmentAfflID = enrollment.Affiliation__c; //Storing it to use it in next query

        //Delete Program Enrollment
        Test.startTest();
        delete enrollment;
        Test.stopTest();

        //Related Affiliation status should have been automatically updated
        affls = [SELECT Status__c FROM Affiliation__c WHERE ID = :enrollmentAfflID];
        System.assertEquals(1, affls.size());
        System.assertEquals(afflStatus, affls[0].Status__c);
    }

    /*********************************************************************************************************
     * @description Deleting a Program Enrollment doesn't delete the related Affiliation when Affl_ProgEnroll_Del__c setting
     * is set to false, nor does it change the status to what is defined in Affl_ProgEnroll_Del_Status__c when there are
     * other Program Enrollments that are associated to the same Affiliation.
     */
    @isTest
    public static void deletePEnrollDelAfflNo_existingPEPreventsAffiliationDeletion() {
        STG_InstallScript.insertMappings();

        String afflStatus = AffiliationTestSetupFactory_TEST.PROG_ENROLL_STATUS_FORMER;
        UTIL_CustomSettings_API.getSettingsForTests(
            new Hierarchy_Settings__c(Affl_ProgEnroll_Del__c = false, Affl_ProgEnroll_Del_Status__c = afflStatus)
        );

        Contact contact = UTIL_UnitTestData_TEST.getContact();
        insert contact;

        //Create account of Business Organization record type
        Account acc = UTIL_UnitTestData_TEST.getMultipleTestAccounts(1, UTIL_Describe_API.getBizAccRecTypeID())[0];
        insert acc;

        //Create Program Enrollment
        Program_Enrollment__c enrollment = new Program_Enrollment__c(Contact__c = contact.ID, Account__c = acc.ID);
        insert enrollment;

        //An Affiliation should have been automatically created from the Program Enrollment
        List<Affiliation__c> affls = [
            SELECT Contact__c, Account__c, Status__c
            FROM Affiliation__c
            WHERE Account__c = :acc.ID
        ];
        System.assertEquals(1, affls.size());

        //The Program Enrollment record should be related to the Affiliation just created
        enrollment = [SELECT Affiliation__c FROM Program_Enrollment__c WHERE ID = :enrollment.ID];
        System.assertEquals(affls[0].ID, enrollment.Affiliation__c);

        ID enrollmentAfflID = enrollment.Affiliation__c; //Storing it to use it in next query
        String createdStatus = affls[0].Status__c;

        //Create additional Program Enrollment
        Program_Enrollment__c enrollment2 = new Program_Enrollment__c(
            Contact__c = contact.ID,
            Account__c = acc.ID,
            Affiliation__c = enrollmentAfflID
        );
        insert enrollment2;

        //Delete Program Enrollment
        Test.startTest();
        delete enrollment;
        Test.stopTest();

        //Related Affiliation status should NOT have been automatically updated
        affls = [SELECT Status__c FROM Affiliation__c WHERE ID = :enrollmentAfflID];
        System.assertEquals(1, affls.size());
        System.assertNotEquals(afflStatus, affls[0].Status__c);
        System.assertEquals(createdStatus, affls[0].Status__c);
    }
}
@isTest
private class PREN_CannotDelete_TEST {
    /*********************************************************************************************************
    * @description Retrieves the Administrative record type Id. 
    */
    public static String adminAccRecTypeId = UTIL_Describe.getAdminAccRecTypeID(); 
    
    /*********************************************************************************************************
    * @description Retrieves the Academic Program record type Id. 
    */
    public static String academicAccRecTypeId = UTIL_Describe.getAcademicAccRecTypeID(); 
    
    /*********************************************************************************************************
    * @description Test method to test if Prevent_Program_Enrollment_Deletion__c is enabled in Hierarchy Settings, and
    * Program Enrollment has a Course Connection record associated to it, then it cannot be deleted.
    */
    @isTest
    public static void cannotDeleteProgramEnrollmentWithCourseConn(){
        UTIL_CustomSettingsFacade.getSettingsForTests(new Hierarchy_Settings__c
                                                        (Account_Processor__c = PREN_CannotDelete_TEST.adminAccRecTypeId,
                                                        Prevent_Program_Enrollment_Deletion__c = True));
        
        List<Account> accounts = UTIL_UnitTestData_TEST.getMultipleTestAccounts(1, PREN_CannotDelete_TEST.academicAccRecTypeId); 
        insert accounts; 
        
        List<Contact> contacts = UTIL_UnitTestData_TEST.getMultipleTestContacts(2);
        insert contacts; 
        
        List<Program_Enrollment__c> programEnrollments = UTIL_UnitTestData_TEST.getMultipleTestProgramEnrollments(2, accounts[0].Id); 
        programEnrollments[0].Contact__c = contacts[0].Id; 
        programEnrollments[1].Contact__c = contacts[1].Id; 
        insert programEnrollments; 
        
        Course__c course = new Course__c(Name = 'Intro to Neuroscience', Account__c = accounts[0].Id); 
        insert course; 
        
        Term__c term = UTIL_UnitTestData_TEST.getTerm(accounts[0].Id, 'Fall'); 
        insert term; 

        Course_Offering__c courseOffering1 = UTIL_UnitTestData_TEST.createCourseOffering(course.Id, term.Id); 
        Course_Offering__c courseOffering2 = UTIL_UnitTestData_TEST.createCourseOffering(course.Id, term.Id);
        
        Course_Enrollment__c courseConnection1 = UTIL_UnitTestData_TEST.getCourseConnection(contacts[0].Id, courseOffering1.Id); 
        Course_Enrollment__c courseConnection2 = UTIL_UnitTestData_TEST.getCourseConnection(contacts[1].Id, courseOffering2.Id);
        courseConnection1.Program_Enrollment__c = programEnrollments[0].Id; 
        courseConnection2.Program_Enrollment__c = programEnrollments[1].Id; 
        insert courseConnection1;
        insert courseConnection2; 
        
        Test.startTest();
        Database.DeleteResult[] results = Database.delete(programEnrollments, false);
        Test.stopTest();

        List<Program_Enrollment__c> returnProgramEnrollments = [SELECT Id
                                                                FROM Program_Enrollment__c
                                                                WHERE Id IN :programEnrollments]; 
        System.assertEquals(2, returnProgramEnrollments.size());
        System.assertEquals(Label.CannotDelete, results[0].errors[0].message);  
    }
    
    /*********************************************************************************************************
    * @description Test method to test if Prevent_Program_Enrollment_Deletion__c is disabled in Hierarchy Settings, and
    * Program Enrollment has a Course Connection record associated to it, then it can be deleted.
    */
    @isTest
    public static void canDeleteProgramEnrollmentWithCourseConn(){
        UTIL_CustomSettingsFacade.getSettingsForTests(new Hierarchy_Settings__c
                                                        (Account_Processor__c = PREN_CannotDelete_TEST.adminAccRecTypeId,
                                                        Prevent_Program_Enrollment_Deletion__c = False));

        List<Account> accounts = UTIL_UnitTestData_TEST.getMultipleTestAccounts(1, PREN_CannotDelete_TEST.academicAccRecTypeId); 
        insert accounts; 

        List<Contact> contacts = UTIL_UnitTestData_TEST.getMultipleTestContacts(2);
        insert contacts; 

        List<Program_Enrollment__c> programEnrollments = UTIL_UnitTestData_TEST.getMultipleTestProgramEnrollments(2, accounts[0].Id); 
        programEnrollments[0].Contact__c = contacts[0].Id; 
        programEnrollments[1].Contact__c = contacts[1].Id; 
        insert programEnrollments; 

        Course__c course = new Course__c(Name = 'Intro to Neuroscience', Account__c = accounts[0].Id); 
        insert course; 

        Term__c term = UTIL_UnitTestData_TEST.getTerm(accounts[0].Id, 'Fall'); 
        insert term; 

        Course_Offering__c courseOffering1 = UTIL_UnitTestData_TEST.createCourseOffering(course.Id, term.Id); 
        Course_Offering__c courseOffering2 = UTIL_UnitTestData_TEST.createCourseOffering(course.Id, term.Id);

        Course_Enrollment__c courseConnection1 = UTIL_UnitTestData_TEST.getCourseConnection(contacts[0].Id, courseOffering1.Id); 
        Course_Enrollment__c courseConnection2 = UTIL_UnitTestData_TEST.getCourseConnection(contacts[1].Id, courseOffering2.Id);
        courseConnection1.Program_Enrollment__c = programEnrollments[0].Id; 
        courseConnection2.Program_Enrollment__c = programEnrollments[1].Id; 
        insert courseConnection1;
        insert courseConnection2; 

        Test.startTest();
        Database.DeleteResult[] results = Database.delete(programEnrollments, false);
        Test.stopTest();

        List<Program_Enrollment__c> returnProgramEnrollments = [SELECT Id
                                                                FROM Program_Enrollment__c
                                                                WHERE Id IN :programEnrollments]; 
        System.assertEquals(0, returnProgramEnrollments.size());
    }
    
    /*********************************************************************************************************
    * @description Tests the hasChildRecords method that the Program Enrollment record has child records. 
    */
    @isTest
    public static void testProgramEnrollmentHasChildRecords(){
        UTIL_CustomSettingsFacade.getSettingsForTests(new Hierarchy_Settings__c
                                                        (Account_Processor__c = PREN_CannotDelete_TEST.adminAccRecTypeId,
                                                        Prevent_Program_Enrollment_Deletion__c = True));
        
        List<Account> accounts = UTIL_UnitTestData_TEST.getMultipleTestAccounts(1, PREN_CannotDelete_TEST.academicAccRecTypeId); 
        insert accounts; 
        
        List<Contact> contacts = UTIL_UnitTestData_TEST.getMultipleTestContacts(2);
        insert contacts; 
        
        List<Program_Enrollment__c> programEnrollments = UTIL_UnitTestData_TEST.getMultipleTestProgramEnrollments(2, accounts[0].Id); 
        programEnrollments[0].Contact__c = contacts[0].Id; 
        programEnrollments[1].Contact__c = contacts[1].Id; 
        insert programEnrollments; 
        
        Course__c course = new Course__c(Name = 'Intro to Neuroscience', Account__c = accounts[0].Id); 
        insert course; 
        
        Term__c term = UTIL_UnitTestData_TEST.getTerm(accounts[0].Id, 'Fall'); 
        insert term; 

        Course_Offering__c courseOffering1 = UTIL_UnitTestData_TEST.createCourseOffering(course.Id, term.Id); 
        Course_Offering__c courseOffering2 = UTIL_UnitTestData_TEST.createCourseOffering(course.Id, term.Id);
        
        Course_Enrollment__c courseConnection1 = UTIL_UnitTestData_TEST.getCourseConnection(contacts[0].Id, courseOffering1.Id); 
        Course_Enrollment__c courseConnection2 = UTIL_UnitTestData_TEST.getCourseConnection(contacts[1].Id, courseOffering2.Id);
        courseConnection1.Program_Enrollment__c = programEnrollments[0].Id; 
        courseConnection2.Program_Enrollment__c = programEnrollments[1].Id; 
        insert courseConnection1;
        insert courseConnection2; 
        
        List<Program_Enrollment__c> returnProgramEnrollments = [SELECT Id,
                                                                (SELECT Id FROM Program_Enrollment__c.Course_Enrollments__r LIMIT 1)
                                                                FROM Program_Enrollment__c
                                                                WHERE Id IN :programEnrollments]; 
        
        PREN_CannotDelete_TDTM myClass = new PREN_CannotDelete_TDTM(); 
        for (Program_Enrollment__c programEnroll: returnProgramEnrollments) {
            System.assertEquals(True, myClass.hasChildRecords(programEnroll)); 
        }
    }
    
    /*********************************************************************************************************
    * @description Tests the hasChildRecords method that the Program Enrollment record has no child records. 
    */
    @isTest
    public static void testProgramEnrollmentHasNoChildRecords(){
        UTIL_CustomSettingsFacade.getSettingsForTests(new Hierarchy_Settings__c
                                                        (Account_Processor__c = PREN_CannotDelete_TEST.adminAccRecTypeId,
                                                        Prevent_Program_Enrollment_Deletion__c = True));
        
        List<Account> accounts = UTIL_UnitTestData_TEST.getMultipleTestAccounts(1, PREN_CannotDelete_TEST.academicAccRecTypeId); 
        insert accounts; 
        
        List<Contact> contacts = UTIL_UnitTestData_TEST.getMultipleTestContacts(2);
        insert contacts; 
        
        List<Program_Enrollment__c> programEnrollments = UTIL_UnitTestData_TEST.getMultipleTestProgramEnrollments(2, accounts[0].Id); 
        programEnrollments[0].Contact__c = contacts[0].Id; 
        programEnrollments[1].Contact__c = contacts[1].Id; 
        insert programEnrollments; 

        List<Program_Enrollment__c> returnProgramEnrollments = [SELECT Id,
                                                                (SELECT Id FROM Program_Enrollment__c.Course_Enrollments__r LIMIT 1)
                                                                FROM Program_Enrollment__c
                                                                WHERE Id IN :programEnrollments]; 
        
        PREN_CannotDelete_TDTM myClass = new PREN_CannotDelete_TDTM(); 
        for (Program_Enrollment__c programEnroll: returnProgramEnrollments) {
            System.assertEquals(False, myClass.hasChildRecords(programEnroll)); 
        }
    }
}
public with sharing class PREN_ProgramPlan_TDTM extends TDTM_Runnable{

    //Variables for Process Control
    static boolean beforeInsertRecursionFlag = TDTM_ProcessControl.getRecursionFlag(TDTM_ProcessControl.registeredTrigger.PREN_ProgramPlan_TDTM_Before_Insert);

    /*******************************************************************************************************
    * @description Handles Program Plan management for Program Enrollment.
    * @param listNew the list of Program Enrollments from trigger new.
    * @param listOld the list of Program Enrollments from trigger old.
    * @param triggerAction which trigger event (BeforeInsert, AfterInsert, etc.).
    * @param objResult the describe for Program Enrollment.
    * @return dmlWrapper.
    ********************************************************************************************************/
    public override DmlWrapper run(List<SObject> newlist, List<SObject> oldlist,
            TDTM_Runnable.Action triggerAction, Schema.DescribeSObjectResult objResult) {

        DmlWrapper dmlWrapper = new DmlWrapper();
                
        //Before Insert
        if (newlist != null
            	&& newlist.size() > 0
            	&& triggerAction == TDTM_Runnable.Action.BeforeInsert 
            	&& !beforeInsertRecursionFlag) {
            if(newlist != null && newlist.size() > 0) {
                populatePrimaryProgramPlan(newlist);
            }
        }
                
		if (triggerAction == TDTM_Runnable.Action.BeforeInsert) {
            TDTM_ProcessControl.setRecursionFlag(TDTM_ProcessControl.registeredTrigger.PREN_ProgramPlan_TDTM_Before_Insert, false);
        }
        return dmlWrapper;
    }

    /*******************************************************************************************************
    * @description Populate primary program plan when a program enrollment is created
    * @param List<SObject> newList the Contact
    * @return void
    */
    private void populatePrimaryProgramPlan(List<SObject> newlist) {
        Set<Id> setAcademicProgramIds = new Set<Id>();
        Map<Id, Id> mapAcademicProgramIdToPrimaryPPId = new Map<Id, Id>();
        for (SObject so : newlist) {
            Program_Enrollment__c newPe = (Program_Enrollment__c)so;
            //Build a set of academic program ids
            setAcademicProgramIds.add(newPe.Account__c);
        }

        //Query academic program and build a map of
        //Academic Program id and Primary Program Plan id
        for (Program_Plan__c pp : [SELECT Id, Account__c
                                    FROM Program_Plan__c
                                    WHERE Account__c in :setAcademicProgramIds
                                        AND Is_Primary__c = TRUE]) {
            if (pp.Account__c != null) {
                mapAcademicProgramIdToPrimaryPPId.put(pp.Account__c, pp.Id);
            }
        }

        //Loop through program enrollment again and populate primary program plan
        for (SObject so : newlist) {
            Program_Enrollment__c newPe = (Program_Enrollment__c)so;
            if (mapAcademicProgramIdToPrimaryPPId.containsKey(newPe.Account__c)
                    && mapAcademicProgramIdToPrimaryPPId.get(newPe.Account__c) != null) {
                newPe.Program_Plan__c = mapAcademicProgramIdToPrimaryPPId.get(newPe.Account__c);
            }
        }
    }

}
@isTest
private class PREQ_PreventPPlanParent_TEST {

    //Make sure an error is thrown when creating a Plan Requirement who is a child of another plan requirement,
    //linking to the same program plan and the setting of Validate_Program_Plan_for_Nested_PR__c is on
    @isTest
    public static void pReqInsertChildPRWithSamePP() {
        UTIL_CustomSettingsFacade.getSettingsForTests(new Hierarchy_Settings__c(Validate_Program_Plan_for_Nested_PR__c = true));

        List<Program_Plan__c> pPlans = UTIL_UnitTestData_TEST.getMultipleTestProgramPlans(2);
        insert pPlans;

        List<Plan_Requirement__c> prs = UTIL_UnitTestData_TEST.getMultipleTestPlanRequirements(2);
        prs[0].Program_Plan__c = pPlans[0].Id;
        insert prs[0];

        Test.startTest();
        prs[1].Plan_Requirement__c = prs[0].Id;
        prs[1].Program_Plan__c = pPlans[0].Id;
        Database.saveResult results = Database.insert(prs[1], false);
        Test.stopTest();

        //Verify new plan requirement is not saved
        List<Plan_Requirement__c> assertPReqs = [select ID from Plan_Requirement__c];

        System.assertEquals(false, results.success);    
        System.assertEquals(1, assertPReqs.size());
        System.assertEquals(Label.nestedPlanRequirementPPExp, results.errors[0].message);
    }

    //Make sure an error is thrown when creating a Plan Requirement who is a child of another plan requirement,
    //linking to a different program plan and the setting of Validate_Program_Plan_for_Nested_PR__c is on
    @isTest
    public static void pReqInsertChildPRWithDifferentPP() {
        UTIL_CustomSettingsFacade.getSettingsForTests(new Hierarchy_Settings__c(Validate_Program_Plan_for_Nested_PR__c = true));

        List<Program_Plan__c> pPlans = UTIL_UnitTestData_TEST.getMultipleTestProgramPlans(2);
        insert pPlans;

        List<Plan_Requirement__c> prs = UTIL_UnitTestData_TEST.getMultipleTestPlanRequirements(2);
        prs[0].Program_Plan__c = pPlans[0].Id;
        insert prs[0];

        Test.startTest();
        prs[1].Plan_Requirement__c = prs[0].Id;
        prs[1].Program_Plan__c = pPlans[1].Id;
        Database.saveResult results = Database.insert(prs[1], false);
        Test.stopTest();

        //Verify new plan requirement is not saved
        List<Plan_Requirement__c> assertPReqs = [select ID from Plan_Requirement__c];

        System.assertEquals(false, results.success);
        System.assertEquals(1, assertPReqs.size());
        System.assertEquals(Label.nestedPlanRequirementPPExp, results.errors[0].message);
    }

    //Make sure an error is thrown when updating a Plan Requirement who is a child of another plan requirement,
    //linking to the same program plan and the setting of Validate_Program_Plan_for_Nested_PR__c is on
    @isTest
    public static void pReqUpdateChildPRWithSamePP() {
        UTIL_CustomSettingsFacade.getSettingsForTests(new Hierarchy_Settings__c(Validate_Program_Plan_for_Nested_PR__c = true));

        List<Program_Plan__c> pPlans = UTIL_UnitTestData_TEST.getMultipleTestProgramPlans(2);
        insert pPlans;

        List<Plan_Requirement__c> prs = UTIL_UnitTestData_TEST.getMultipleTestPlanRequirements(2);
        prs[0].Program_Plan__c = pPlans[0].Id;
        insert prs[0];
        prs[1].Plan_Requirement__c = prs[0].Id;
        insert prs[1];

        Test.startTest();
        prs[1].Program_Plan__c = pPlans[0].Id;
        Database.saveResult results = Database.update(prs[1], false);
        Test.stopTest();

        //Verify new plan requirement is not saved
        List<Plan_Requirement__c> assertPReqs = [SELECT ID,Program_Plan__c
                                                FROM Plan_Requirement__c
                                                WHERE ID = :prs[1].Id
                                                LIMIT 1];

        System.assertEquals(false, results.success);                                        
        System.assertEquals(null, assertPReqs[0].Program_Plan__c);
        System.assertEquals(Label.nestedPlanRequirementPPExp, results.errors[0].message);
    }

    //Make sure an error is thrown when updating a Plan Requirement who is a child of another plan requirement,
    //linking to a different program plan and the setting of Validate_Program_Plan_for_Nested_PR__c is on
    @isTest
    public static void pReqUpdateChildPRWithDifferentPP() {
        UTIL_CustomSettingsFacade.getSettingsForTests(new Hierarchy_Settings__c(Validate_Program_Plan_for_Nested_PR__c = true));

        List<Program_Plan__c> pPlans = UTIL_UnitTestData_TEST.getMultipleTestProgramPlans(2);
        insert pPlans;

        List<Plan_Requirement__c> prs = UTIL_UnitTestData_TEST.getMultipleTestPlanRequirements(2);
        prs[0].Program_Plan__c = pPlans[0].Id;
        insert prs[0];
        prs[1].Plan_Requirement__c = prs[0].Id;
        insert prs[1];

        Test.startTest();
        prs[1].Program_Plan__c = pPlans[1].Id;
        Database.saveResult results = Database.update(prs[1], false);
        Test.stopTest();

        //Verify new plan requirement is not saved
        List<Plan_Requirement__c> assertPReqs = [SELECT ID,Program_Plan__c
                                                FROM Plan_Requirement__c
                                                WHERE ID = :prs[1].Id
                                                LIMIT 1];

        System.assertEquals(false, results.success);                                        
        System.assertEquals(null, assertPReqs[0].Program_Plan__c);
        System.assertEquals(Label.nestedPlanRequirementPPExp, results.errors[0].message);
    }

    //Make sure no error is thrown when creating a Plan Requirement who is a child of another plan requirement,
    //linking to the same program plan and the setting of Validate_Program_Plan_for_Nested_PR__c is off
    @isTest
    public static void pReqInsertChildPRWithSamePPSettingOff() {
        UTIL_CustomSettingsFacade.getSettingsForTests(new Hierarchy_Settings__c(Validate_Program_Plan_for_Nested_PR__c = false));

        List<Program_Plan__c> pPlans = UTIL_UnitTestData_TEST.getMultipleTestProgramPlans(2);
        insert pPlans;

        List<Plan_Requirement__c> prs = UTIL_UnitTestData_TEST.getMultipleTestPlanRequirements(2);
        prs[0].Program_Plan__c = pPlans[0].Id;
        insert prs[0];

        Test.startTest();
        prs[1].Plan_Requirement__c = prs[0].Id;
        prs[1].Program_Plan__c = pPlans[0].Id;
        Database.saveResult results = Database.insert(prs[1], false);
        Test.stopTest();

        //Verify new plan requirement is saved
        List<Plan_Requirement__c> assertPReqs = [select ID from Plan_Requirement__c];

        System.assertEquals(true, results.success);
        System.assertEquals(2, assertPReqs.size());
    }

    //Make sure no error is thrown when updating a Plan Requirement who is a child of another plan requirement,
    //linking to a different program plan and the setting of Validate_Program_Plan_for_Nested_PR__c is off
    @isTest
    public static void pReqUpdateChildPRWithDifferentPPSettingOff() {
        UTIL_CustomSettingsFacade.getSettingsForTests(new Hierarchy_Settings__c(Validate_Program_Plan_for_Nested_PR__c = false));

        List<Program_Plan__c> pPlans = UTIL_UnitTestData_TEST.getMultipleTestProgramPlans(2);
        insert pPlans;

        List<Plan_Requirement__c> prs = UTIL_UnitTestData_TEST.getMultipleTestPlanRequirements(2);
        prs[0].Program_Plan__c = pPlans[0].Id;
        insert prs[0];
        prs[1].Plan_Requirement__c = prs[0].Id;
        insert prs[1];

        Test.startTest();
        prs[1].Program_Plan__c = pPlans[1].Id;
        Database.saveResult results = Database.update(prs[1], false);
        Test.stopTest();

        //Verify new plan requirement is saved
        List<Plan_Requirement__c> assertPReqs = [SELECT ID,Program_Plan__c
                                                FROM Plan_Requirement__c
                                                WHERE ID = :prs[1].Id
                                                LIMIT 1];

        System.assertEquals(true, results.success);
        System.assertEquals(pPlans[1].Id, assertPReqs[0].Program_Plan__c);
    }

    //Make sure no error is thrown when inserting a Plan Requirement who is not a child of another plan requirement,
    //linking to program plan and the setting of Validate_Program_Plan_for_Nested_PR__c is on
    @isTest
    public static void pReqInsertNonChildPRWithPPSettingOn() {
        UTIL_CustomSettingsFacade.getSettingsForTests(new Hierarchy_Settings__c(Validate_Program_Plan_for_Nested_PR__c = true));

        List<Program_Plan__c> pPlans = UTIL_UnitTestData_TEST.getMultipleTestProgramPlans(1);
        insert pPlans;

        List<Plan_Requirement__c> prs = UTIL_UnitTestData_TEST.getMultipleTestPlanRequirements(1);

        Test.startTest();
        prs[0].Program_Plan__c = pPlans[0].Id;
        Database.saveResult results = Database.insert(prs[0], false);
        Test.stopTest();

        //Verify new plan requirement is saved
        List<Plan_Requirement__c> assertPReqs = [SELECT ID,Program_Plan__c
                                                FROM Plan_Requirement__c
                                                WHERE ID = :prs[0].Id
                                                LIMIT 1];

        System.assertEquals(true, results.success);
        System.assertEquals(pPlans[0].Id, assertPReqs[0].Program_Plan__c);
    }
}
@isTest
public with sharing class PReq_CannotDelete_TEST {
    /*********************************************************************************************************
    * @description Retrieves the Business Account record type Id. 
    */
    public static String bizAccRecordTypeId = UTIL_Describe_API.getBizAccRecTypeID(); 
    
    /*********************************************************************************************************
    * @description Test method to test if Prevent_Plan_Requirement_Deletion__c is enabled in Hierarchy Settings, 
    * and Plan Requirement has a Plan Requirement record associated to it, then it cannot be deleted.
    */
    @isTest
    public static void pReqCannotDeleteWithPlanRequirement() {
        UTIL_CustomSettingsFacade.getSettingsForTests(new Hierarchy_Settings__c
                                                         (Account_Processor__c = bizAccRecordTypeId,
                                                          Prevent_Plan_Requirement_Deletion__c = TRUE));
        
        List<Program_Plan__c> pPlans = UTIL_UnitTestData_TEST.getMultipleTestProgramPlans(1);
        insert pPlans;
        
        List<Plan_Requirement__c> parentPReqs = UTIL_UnitTestData_TEST.getMultipleTestPlanRequirements(2); 
        insert parentPReqs; 
        
        List<Plan_Requirement__c> childrenPReqs = UTIL_UnitTestData_TEST.getMultipleTestPlanRequirements(2); 
        childrenPReqs[0].Plan_Requirement__c = parentPReqs[0].Id;
        childrenPReqs[1].Plan_Requirement__c = parentPReqs[1].Id;
        insert childrenPReqs; 

        Test.startTest(); 
        Database.DeleteResult[] results = Database.delete(parentPReqs, false);
        Test.stopTest();

        //Verify Plan Requirement was not successfully deleted
        List<Plan_Requirement__c> returnParentPReqs = [SELECT ID
                                                       FROM Plan_Requirement__c
                                                       WHERE ID IN :parentPReqs];
        System.assertEquals(2, returnParentPReqs.size());
        System.assertEquals(false, results[0].success);
        System.assertEquals(Label.CannotDelete, results[0].errors[0].message);
    }
    
    /*********************************************************************************************************
    * @description Test method to test if Prevent_Plan_Requirement_Deletion__c is enabled in Hierarchy Settings, 
    * and if some Plan Requirement records do not have Plan Requirement child records, then the Plan Requirement
    * record can be deleted. 
    */
    @isTest
    public static void pReqCanDeleteSomePlanRequirement() {
        UTIL_CustomSettingsFacade.getSettingsForTests(new Hierarchy_Settings__c
                                                         (Account_Processor__c = bizAccRecordTypeId,
                                                          Prevent_Plan_Requirement_Deletion__c = TRUE));
        
        List<Program_Plan__c> pPlans = UTIL_UnitTestData_TEST.getMultipleTestProgramPlans(1);
        insert pPlans;
        
        List<Plan_Requirement__c> parentPReqs = UTIL_UnitTestData_TEST.getMultipleTestPlanRequirements(2);
        insert parentPReqs; 
       
        List<Plan_Requirement__c> childrenPReqs = UTIL_UnitTestData_TEST.getMultipleTestPlanRequirements(2); 
        childrenPReqs[0].Plan_Requirement__c = parentPReqs[0].Id;
        insert childrenPReqs; 

        Test.startTest(); 
        Database.DeleteResult[] results = Database.delete(parentPReqs, false);
        Test.stopTest();

        //Verify Plan Requirement was not successfully deleted
        List<Plan_Requirement__c> returnParentPReqs = [SELECT ID
                                                       FROM Plan_Requirement__c
                                                       WHERE ID IN :parentPReqs];
        
        System.assertEquals(1, returnParentPReqs.size());
        System.assertEquals(true, results[1].success);
        System.assertEquals(false, results[0].success);
        System.assertEquals(Label.CannotDelete, results[0].errors[0].message);
    }
    
    /*********************************************************************************************************
    * @description Test method to test if Prevent_Plan_Requirement_Deletion__c is disabled in Hierarchy Settings, 
    * and Plan Requirement has a Plan Requirement record associated to it, then it can be deleted.
    */
    @isTest
    public static void pReqCanDeleteWithPlanRequirement() {
        UTIL_CustomSettingsFacade.getSettingsForTests(new Hierarchy_Settings__c
                                                         (Account_Processor__c = bizAccRecordTypeId,
                                                          Prevent_Plan_Requirement_Deletion__c = FALSE));
        
        List<Program_Plan__c> pPlans = UTIL_UnitTestData_TEST.getMultipleTestProgramPlans(1);
        insert pPlans;
        
        List<Plan_Requirement__c> parentPReqs = UTIL_UnitTestData_TEST.getMultipleTestPlanRequirements(2); 
        insert parentPReqs; 
        
        List<Plan_Requirement__c> childrenPReqs = UTIL_UnitTestData_TEST.getMultipleTestPlanRequirements(2); 
        childrenPReqs[0].Plan_Requirement__c = parentPReqs[0].Id;
        childrenPReqs[1].Plan_Requirement__c = parentPReqs[1].Id;
        insert childrenPReqs; 

        Test.startTest(); 
        Database.DeleteResult[] results = Database.delete(parentPReqs, false);
        Test.stopTest();

        //Verify Plan Requirement was not successfully deleted
        List<Plan_Requirement__c> returnParentPReqs = [SELECT ID
                                                       FROM Plan_Requirement__c
                                                       WHERE ID IN :parentPReqs];
        System.assertEquals(0, returnParentPReqs.size());
        System.assertEquals(true, results[0].success);
    }
}
@isTest
public with sharing class PermissionSetAssignmentMapper_TEST {
    /**************************************************************************************************************************
     * @description Test method to verify that the getInstance method returns a new instance of the
     * PermissionSetAssignmentMapper class when one does not already exist.
     ***************************************************************************************************************************/
    @isTest
    private static void getInstanceNew() {
        Test.startTest();
        PermissionSetAssignmentMapper permissionSetAssignmentMapperInstance = PermissionSetAssignmentMapper.getInstance();
        Test.stopTest();

        System.assertEquals(
            PermissionSetAssignmentMapper.instance,
            permissionSetAssignmentMapperInstance,
            'Instance of mapper class returned should match static instance variable.'
        );
        System.assertEquals(
            true,
            permissionSetAssignmentMapperInstance != null,
            'Instance of mapper class should not be null.'
        );
    }

    /**************************************************************************************************************************
     * @description Test method to verify that the getInstance method returns the existing instance of the
     * PermissionSetAssignmentMapper class when one already exists.
     ***************************************************************************************************************************/
    @isTest
    private static void getInstanceExisting() {
        Test.startTest();
        PermissionSetAssignmentMapper permissionSetAssignmentMapperInstance1 = PermissionSetAssignmentMapper.getInstance();
        PermissionSetAssignmentMapper permissionSetAssignmentMapperInstance2 = PermissionSetAssignmentMapper.getInstance();
        Test.stopTest();

        System.assertEquals(
            PermissionSetAssignmentMapper.instance,
            permissionSetAssignmentMapperInstance1,
            'Instance of mapper class returned should match static instance variable.'
        );
        System.assertEquals(
            permissionSetAssignmentMapperInstance1,
            permissionSetAssignmentMapperInstance2,
            'Subsequent retrievals of mapper class instance should return existing instance.'
        );
        System.assertEquals(
            true,
            permissionSetAssignmentMapperInstance1 != null,
            'Instance of mapper class should not be null.'
        );
    }

    /**************************************************************************************************************************
     * @description Test method to verify that the getAssignedPermissionSetIdSetForCurrentUser method
     * returns a set of permission set ids assigned to the current user when there are some assigned
     ***************************************************************************************************************************/
    @isTest
    private static void getAssignedPermissionSetIdsSetForCurrentUserExisting() {
        User user = UTIL_UnitTestData_TEST.createNewUserForTests('testUser@eda.com');

        List<PermissionSet> permissionSets = new List<PermissionSet>();
        for (Integer i = 0; i < 5; i++) {
            PermissionSet permissionSet = new PermissionSet(
                PermissionsCustomizeApplication = false,
                Name = 'testName' + i,
                Label = 'testLabel' + i
            );
            permissionSets.add(permissionSet);
        }
        insert permissionSets;

        List<PermissionSetAssignment> permissionSetAssignments = new List<PermissionSetAssignment>();
        for (PermissionSet permissionSet : permissionSets) {
            PermissionSetAssignment permissionSetAssignment = new PermissionSetAssignment(
                AssigneeId = user.Id,
                PermissionSetId = permissionSet.Id
            );
            permissionSetAssignments.add(permissionSetAssignment);
        }
        insert permissionSetAssignments;

        Test.startTest();
        Set<Id> assignedPermissionSetIdsSet = new Set<Id>();
        System.runAs(user) {
            assignedPermissionSetIdsSet = PermissionSetAssignmentMapper.getInstance()
                .getAssignedPermissionSetIdsSetForCurrentUser();
        }
        Test.stopTest();

        System.assertEquals(
            true,
            assignedPermissionSetIdsSet.contains(permissionSets[0].Id),
            'assignedPermissionSetIdSet should contain every test permission set created'
        );
        System.assertEquals(
            true,
            assignedPermissionSetIdsSet.contains(permissionSets[1].Id),
            'assignedPermissionSetIdSet should contain every test permission set created'
        );
        System.assertEquals(
            true,
            assignedPermissionSetIdsSet.contains(permissionSets[2].Id),
            'assignedPermissionSetIdSet should contain every test permission set created'
        );
        System.assertEquals(
            true,
            assignedPermissionSetIdsSet.contains(permissionSets[3].Id),
            'assignedPermissionSetIdSet should contain every test permission set created'
        );
        System.assertEquals(
            true,
            assignedPermissionSetIdsSet.contains(permissionSets[4].Id),
            'assignedPermissionSetIdSet should contain every test permission set created'
        );
    }

    /**************************************************************************************************************************
     * @description Test method to verify that the getAssignedPermissionSetIdSetForCurrentUser method
     * returns a empty set of permission set ids assigned to the current user when there is no assigned
     ***************************************************************************************************************************/
    @isTest
    private static void getAssignedPermissionSetIdsSetForCurrentUserNoneAssigned() {
        User user = UTIL_UnitTestData_TEST.createNewUserForTests('testUser@eda.com');

        List<PermissionSet> permissionSets = new List<PermissionSet>();
        for (Integer i = 0; i < 5; i++) {
            PermissionSet permissionSet = new PermissionSet(
                PermissionsCustomizeApplication = false,
                Name = 'testName' + i,
                Label = 'testLabel' + i
            );
            permissionSets.add(permissionSet);
        }
        insert permissionSets;

        Test.startTest();
        Set<Id> assignedPermissionSetIdsSet = new Set<Id>();
        System.runAs(user) {
            assignedPermissionSetIdsSet = PermissionSetAssignmentMapper.getInstance()
                .getAssignedPermissionSetIdsSetForCurrentUser();
        }
        Test.stopTest();

        System.assertNotEquals(
            true,
            assignedPermissionSetIdsSet.contains(permissionSets[0].Id),
            'assignedPermissionSetIdSet should contain every test permission set created'
        );
        System.assertNotEquals(
            true,
            assignedPermissionSetIdsSet.contains(permissionSets[1].Id),
            'assignedPermissionSetIdSet should contain every test permission set created'
        );
        System.assertNotEquals(
            true,
            assignedPermissionSetIdsSet.contains(permissionSets[2].Id),
            'assignedPermissionSetIdSet should contain every test permission set created'
        );
        System.assertNotEquals(
            true,
            assignedPermissionSetIdsSet.contains(permissionSets[3].Id),
            'assignedPermissionSetIdSet should contain every test permission set created'
        );
        System.assertNotEquals(
            true,
            assignedPermissionSetIdsSet.contains(permissionSets[4].Id),
            'assignedPermissionSetIdSet should contain every test permission set created'
        );
    }
}
@isTest
public with sharing class PermissionSetMapper_TEST {
    /**************************************************************************************************************************
     * @description Test method to verify that the getInstance method returns a new instance of the
     * PermissionSetMapper class when one does not already exist.
     ***************************************************************************************************************************/
    @isTest
    private static void getInstanceNew() {
        Test.startTest();
        PermissionSetMapper permissionSetMapperInstance = PermissionSetMapper.getInstance();
        Test.stopTest();

        System.assertEquals(
            PermissionSetMapper.instance,
            permissionSetMapperInstance,
            'Instance of mapper class returned should match static instance variable.'
        );
        System.assertEquals(true, permissionSetMapperInstance != null, 'Instance of mapper class should not be null.');
    }

    /**************************************************************************************************************************
     * @description Test method to verify that the getInstance method returns the existing instance of the
     * PermissionSetMapper class when one already exists.
     ***************************************************************************************************************************/
    @isTest
    private static void getInstanceExisting() {
        Test.startTest();
        PermissionSetMapper permissionSetMapperInstance1 = PermissionSetMapper.getInstance();
        PermissionSetMapper permissionSetMapperInstance2 = PermissionSetMapper.getInstance();
        Test.stopTest();

        System.assertEquals(
            PermissionSetMapper.instance,
            permissionSetMapperInstance1,
            'Instance of mapper class returned should match static instance variable.'
        );
        System.assertEquals(
            permissionSetMapperInstance1,
            permissionSetMapperInstance2,
            'Subsequent retrievals of mapper class instance should return existing instance.'
        );
        System.assertEquals(true, permissionSetMapperInstance1 != null, 'Instance of mapper class should not be null.');
    }

    /**************************************************************************************************************************
     * @description Test method to verify that the checkPermissionSetsWithCustomizeApplicationFromIds method returns true
     * if any provided permission set has access to view setup
     * TODO: Commented out because PermissionsManageTranslation failing beta builds and downstream packages.
     ***************************************************************************************************************************/
    /*@isTest
    private static void checkPermissionSetsWithCustomizeApplicationFromIdsTrue() {
        List<PermissionSet> permissionSets = new List<PermissionSet>();
        for (Integer i = 0; i < 5; i++) {
            PermissionSet permissionSet = new PermissionSet(
                PermissionsCustomizeApplication = false,
                Name = 'testName' + i,
                Label = 'testLabel' + i
            );
            permissionSets.add(permissionSet);
        }
        permissionSets[0].PermissionsViewSetup = true;
        permissionSets[0].PermissionsViewRoles = true;
        permissionSets[0].PermissionsManageCustomPermissions = true;
        permissionSets[0].PermissionsManageTranslation = true;
        permissionSets[0].PermissionsCustomizeApplication = true;
        insert permissionSets;

        Test.startTest();
        Set<Id> permissionSetIdsSet = new Set<Id>();
        for (PermissionSet permissionSet : permissionSets) {
            permissionSetIdsSet.add(permissionSet.Id);
        }
        Boolean permissionSetsWithCustomizeApplication = PermissionSetMapper.getInstance()
            .checkPermissionSetsWithCustomizeApplicationFromIds(permissionSetIdsSet);
        Test.stopTest();

        System.assertEquals(
            true,
            permissionSetsWithCustomizeApplication,
            'Some of the provided permission sets should have access to view setup'
        );
    }*/

    /**************************************************************************************************************************
     * @description Test method to verify that the checkPermissionSetsWithCustomizeApplicationFromIds method returns false
     * if no provided permission set has access to view setup
     ***************************************************************************************************************************/
    @isTest
    private static void checkPermissionSetsWithCustomizeApplicationFromIdsFalse() {
        List<PermissionSet> permissionSets = new List<PermissionSet>();
        for (Integer i = 0; i < 5; i++) {
            PermissionSet permissionSet = new PermissionSet(
                PermissionsCustomizeApplication = false,
                Name = 'testName' + i,
                Label = 'testLabel' + i
            );
            permissionSets.add(permissionSet);
        }
        insert permissionSets;

        Test.startTest();
        Set<Id> permissionSetIdsSet = new Set<Id>();
        for (PermissionSet permissionSet : permissionSets) {
            permissionSetIdsSet.add(permissionSet.Id);
        }
        Boolean permissionSetsWithCustomizeApplication = PermissionSetMapper.getInstance()
            .checkPermissionSetsWithCustomizeApplicationFromIds(permissionSetIdsSet);
        Test.stopTest();

        System.assertEquals(
            false,
            permissionSetsWithCustomizeApplication,
            'None of the provided permission sets should have access to view setup'
        );
    }
}
public virtual with sharing class PicklistEntryMapper {

    /*********************************************
    * @description Instance for Singleton Pattern
    **********************************************/
    @TestVisible
    private static PicklistEntryMapper instance;

    /*********************************************************************
    * @description Empty constructor is not public for Singleton Pattern
    **********************************************************************/
    protected PicklistEntryMapper() {}

    /*****************************************************************************
    * @description Static method to get the current instance for Singleton pattern
    * @return The instance of PicklistEntryMapper.
    ******************************************************************************/
    public static PicklistEntryMapper getInstance() {

        if (instance == null) {
            instance = new PicklistEntryMapper();
        }

        return instance;
    }

    /*******************************************************************************************
    * @description Returns a map of  PicklistEntry models by their API Names
    * @return Map<String, PicklistEntryModel> A map of  PicklistEntry models by their API Names
    *******************************************************************************************/
    public virtual Map<String, PicklistEntryModel> getModelsByNameForSObjectField(SObjectType sObjectTypeName, SObjectField SObjectFieldName) {

        List<Schema.PicklistEntry> picklistEntriesList = UTIL_Describe.getFieldPicklistEntries(sObjectTypeName.getDescribe().getName(), SObjectFieldName.getDescribe().getName());
        Map<String, PicklistEntryModel> picklistEntryModelByPicklistEntryName = new Map<String, PicklistEntryModel>();

        for (Schema.PicklistEntry each: picklistEntriesList) {
            PicklistEntryModel PcklstEntryModel = new PicklistEntryModel(each.getValue(), each.getLabel(), each.isActive());
            picklistEntryModelByPicklistEntryName.put(each.getValue(), PcklstEntryModel);
        }

       return picklistEntryModelByPicklistEntryName;
    }
}
@isTest
private class PicklistEntryService_TEST {
    /**************************************************************************************************************************
     * @description Test method to verify that the getInstance method returns a new instance of the
     * PicklistEntryService class when one does not already exist.
     ***************************************************************************************************************************/
    @isTest
    private static void getInstanceNew() {
        Test.startTest();
        PicklistEntryService picklistEntryServiceInstance = PicklistEntryService.getInstance();
        Test.stopTest();

        System.assertEquals(
            PicklistEntryService.instance,
            picklistEntryServiceInstance,
            'Instance of service class returned should match static instance variable.'
        );
        System.assertEquals(
            true,
            picklistEntryServiceInstance != null,
            'Instance of service class should not be null.'
        );
    }

    /**************************************************************************************************************************
     * @description Test method to verify that the getInstance method returns the existing instance of the
     * PicklistEntryService class when one already exists.
     ***************************************************************************************************************************/
    @isTest
    private static void getInstanceExisting() {
        Test.startTest();
        PicklistEntryService picklistEntryServiceInstance1 = PicklistEntryService.getInstance();
        PicklistEntryService picklistEntryServiceInstance2 = PicklistEntryService.getInstance();
        Test.stopTest();

        System.assertEquals(
            PicklistEntryService.instance,
            picklistEntryServiceInstance1,
            'Instance of service class returned should match static instance variable.'
        );
        System.assertEquals(
            picklistEntryServiceInstance1,
            picklistEntryServiceInstance2,
            'Subsequent retrievals of service class instance should return existing instance.'
        );
        System.assertEquals(
            true,
            picklistEntryServiceInstance1 != null,
            'Instance of service class should not be null.'
        );
    }

    /***********************************************************************************************************************************
     * @description Test method to verify that the locatePicklistEntryMapper method returns instance of PicklistEntryMapper
     ***********************************************************************************************************************************/
    @isTest
    private static void locatePicklistEntryMapper() {
        Test.startTest();
        PicklistEntryMapper pcklstEntryMapper = PicklistEntryService.getInstance().locatePicklistEntryMapper();
        Test.stopTest();

        System.assertEquals(
            PicklistEntryMapper.getInstance(),
            pcklstEntryMapper,
            'Should return the instance of PicklistEntryMapper'
        );
    }

    /***********************************************************************************************************************************
     * @description Test method to verify that the getModelsByNameForSObjectField method returns instance of PicklistEntry Models
     ***********************************************************************************************************************************/
    @isTest
    private static void getModelsByNameForSObjectField() {
        PicklistEntryMapper.instance = new STUB_PicklistEntryMapper();

        Test.startTest();
        Map<String, PicklistEntryModel> picklistEntryModelsByPicklistEntryName = PicklistEntryService.getInstance()
            .getModelsByNameForSObjectField(Account.getSObjectType(), Account.Type.getDescribe().getSObjectField());
        Test.stopTest();

        System.assertEquals(
            1,
            picklistEntryModelsByPicklistEntryName.size(),
            'Retieved map should contain models for all the picklist entries'
        );
        System.assertEquals(
            'Prospect',
            picklistEntryModelsByPicklistEntryName.get('Prospect').name,
            'Map should retrieve the name of the picklist entry'
        );
        System.assertEquals(
            'Prospect',
            picklistEntryModelsByPicklistEntryName.get('Prospect').label,
            'Map should retrieve the label of the picklist entry'
        );
        System.assertEquals(
            true,
            picklistEntryModelsByPicklistEntryName.get('Prospect').isActive,
            'Map should retrieve active status of the picklist entry'
        );
    }

    /***********************************************************************************************************************************
     * @description Test method to verify that the getActivePicklistEntryModelsByName method returns a map containing only active
     * picklist entry values.
     ***********************************************************************************************************************************/
    @isTest
    private static void getActivePicklistEntryModelsByNameValid() {
        Map<String, PicklistEntryModel> picklistEntryModelsByString = new Map<String, PicklistEntryModel>{
            'Entry_1' => new PicklistEntryModel('Entry_1', 'Entry1', true),
            'Entry2' => new PicklistEntryModel('Entry_2', 'Entry2', false),
            'Entry_3' => new PicklistEntryModel('Entry_3', 'Entry3', true)
        };

        PicklistEntryService PicklistEntryServiceInstance = PicklistEntryService.getInstance();

        Test.startTest();
        Map<String, PicklistEntryModel> activePicklistEntryModelsByName = PicklistEntryServiceInstance.getActivePicklistEntryModelsByName(
            picklistEntryModelsByString
        );
        Test.stopTest();

        System.assertEquals(
            2,
            activePicklistEntryModelsByName.values().size(),
            'Should only contain active picklist entry values.'
        );
        System.assertEquals(
            'Entry_1',
            activePicklistEntryModelsByName.values()[0].name,
            'Name should match picklist entry name.'
        );
        System.assertEquals(
            'Entry1',
            activePicklistEntryModelsByName.values()[0].label,
            'Label should match picklist entry label.'
        );

        System.assertEquals(
            'Entry_3',
            activePicklistEntryModelsByName.values()[1].name,
            'Name should match picklist entry name.'
        );
        System.assertEquals(
            'Entry3',
            activePicklistEntryModelsByName.values()[1].label,
            'Label should match picklist entry label.'
        );
    }

    /***********************************************************************************************************************************
     * @description Test method to verify that the getActivePicklistEntryModelsByName method returns an empty map when no active
     * picklist values exist.
     ***********************************************************************************************************************************/
    @isTest
    private static void getActivePicklistEntryModelsByNameEmpty() {
        PicklistEntryService PicklistEntryServiceInstance = PicklistEntryService.getInstance();

        Test.startTest();
        Map<String, PicklistEntryModel> activePicklistEntryModelsByName = PicklistEntryServiceInstance.getActivePicklistEntryModelsByName(
            new Map<String, PicklistEntryModel>()
        );
        Test.stopTest();

        System.assertEquals(0, activePicklistEntryModelsByName.values().size(), 'Should return empty map.');
    }

    /***********************************************************************************************************************************
     ****************************************************** STUBS ***********************************************************************
     ***********************************************************************************************************************************/

    /**************************************************************************************************************************************
     * @description Stub class to simulate the response from PicklistEntryMapper to return a map of picklistEntryModelsByPicklistEntryName
     **************************************************************************************************************************************/
    private class STUB_PicklistEntryMapper extends PicklistEntryMapper {
        public override Map<String, PicklistEntryModel> getModelsByNameForSObjectField(
            SObjectType sObjectTypeName,
            SObjectField sObjectFieldName
        ) {
            Map<String, PicklistEntryModel> picklistEntryModelsByPicklistEntryName = new Map<String, PicklistEntryModel>();

            PicklistEntryModel pcklstEntryModel = new PicklistEntryModel('Prospect', 'Prospect', true);
            picklistEntryModelsByPicklistEntryName.put('Prospect', pcklstEntryModel);

            return picklistEntryModelsByPicklistEntryName;
        }
    }
}
@isTest
private with sharing class PreferredContactInfoSettingsMapper_TEST {
    /**************************************************************************************************************************
     * @description Test method to verify that the getInstance method returns a new instance of the
     * PreferredContactInfoSettingsMapper class when one does not already exist.
     ***************************************************************************************************************************/
    @isTest
    private static void getInstanceNew() {
        Test.startTest();
        PreferredContactInfoSettingsMapper preferredContactInfoSettingsMapperInstance = PreferredContactInfoSettingsMapper.getInstance();
        Test.stopTest();

        System.assertEquals(
            PreferredContactInfoSettingsMapper.instance,
            preferredContactInfoSettingsMapperInstance,
            'Instance of mapper class returned should match static instance variable.'
        );
        System.assertEquals(
            true,
            preferredContactInfoSettingsMapperInstance != null,
            'Instance of mapper class should not be null.'
        );
    }

    /**************************************************************************************************************************
     * @description Test method to verify that the getInstance method returns the existing instance of the
     * PreferredContactInfoSettingsMapper class when one already exists.
     ***************************************************************************************************************************/
    @isTest
    private static void getInstanceExisting() {
        Test.startTest();
        PreferredContactInfoSettingsMapper preferredContactInfoSettingsMapper1 = PreferredContactInfoSettingsMapper.getInstance();
        PreferredContactInfoSettingsMapper preferredContactInfoSettingsMapper2 = PreferredContactInfoSettingsMapper.getInstance();
        Test.stopTest();

        System.assertEquals(
            PreferredContactInfoSettingsMapper.instance,
            preferredContactInfoSettingsMapper1,
            'Instance of mapper class returned should match static instance variable.'
        );
        System.assertEquals(
            preferredContactInfoSettingsMapper1,
            preferredContactInfoSettingsMapper2,
            'Subsequent retrievals of mapper class instance should return existing instance.'
        );
        System.assertEquals(
            true,
            preferredContactInfoSettingsMapper1 != null,
            'Instance of mapper class should not be null.'
        );
    }

    /**************************************************************************************************************************
     * @description Test method to verify that the getPreferredContactInfoSettingsModel method returns a PreferredContactInfoSettingsModel
     * with all properties set to match the corresponding values in hierarchy settings.  In the case of Disable_Preferred_Email_Enforcement__c
     * and Disable_Preferred_Phone_Enforcement__c, the model values should be the invers of the hierarchy setting values.
     ***************************************************************************************************************************/
    @isTest
    private static void getPreferredContactInfoSettingsModelValid() {
        Hierarchy_Settings__c hierarchySettings = UTIL_CustomSettings_API.getSettingsForTests(
            new Hierarchy_Settings__c(
                Disable_Preferred_Email_Enforcement__c = true, //false
                Enable_New_Preferred_Phone_Sync__c = true,
                Disable_Preferred_Phone_Enforcement__c = true, //false
                Preferred_Phone_Selection__c = 'Test Phone Field'
            )
        );
        PreferredContactInfoSettingsMapper preferredContactInfoSettingsMapperInstance = PreferredContactInfoSettingsMapper.getInstance();

        Test.startTest();
        PreferredContactInfoSettingsModel preferredContactInfoSettingsModel = preferredContactInfoSettingsMapperInstance.getPreferredContactInfoSettingsModel();
        Test.stopTest();

        System.assertEquals(
            false,
            preferredContactInfoSettingsModel.requirePreferredEmail,
            'True value for hierarchy setting Disable_Preferred_Email_Enforcement__c, should set requirePreferredEmail property to false.'
        );

        System.assertEquals(
            true,
            preferredContactInfoSettingsModel.enhancedPhoneFunctionality,
            'True value for hierarchy setting Enable_New_Preferred_Phone_Sync__c, should set enhancedPhoneFunctionality property to true.'
        );

        System.assertEquals(
            false,
            preferredContactInfoSettingsModel.preferredPhoneEnforcement,
            'True value for hierarchy setting Disable_Preferred_Phone_Enforcement__c, should set preferredPhoneEnforcement property to false.'
        );

        System.assertEquals(
            'Test Phone Field',
            preferredContactInfoSettingsModel.defaultPreferredPhone,
            'defaultPreferredPhone property should be set to match Preferred_Phone_Selection__c hierarchy setting.'
        );
    }

    /**************************************************************************************************************************
     * @description Test method to verify that the getPreferredContactInfoSettingsModel method returns a PreferredContactInfoSettingsModel
     * with all properties set to match the corresponding values in hierarchy settings and specify a blank value when no preferred
     * phone value is specified.  In the case of Disable_Preferred_Email_Enforcement__c
     * and Disable_Preferred_Phone_Enforcement__c, the model values should be the invers of the hierarchy setting values.
     ***************************************************************************************************************************/
    @isTest
    private static void getPreferredContactInfoSettingsModelBlankString() {
        Hierarchy_Settings__c hierarchySettings = UTIL_CustomSettings_API.getSettingsForTests(
            new Hierarchy_Settings__c(
                Disable_Preferred_Email_Enforcement__c = false, //true
                Enable_New_Preferred_Phone_Sync__c = false,
                Disable_Preferred_Phone_Enforcement__c = false, //true
                Preferred_Phone_Selection__c = ''
            )
        );
        PreferredContactInfoSettingsMapper preferredContactInfoSettingsMapperInstance = PreferredContactInfoSettingsMapper.getInstance();

        Test.startTest();
        PreferredContactInfoSettingsModel preferredContactInfoSettingsModel = preferredContactInfoSettingsMapperInstance.getPreferredContactInfoSettingsModel();
        Test.stopTest();

        System.assertEquals(
            true,
            preferredContactInfoSettingsModel.requirePreferredEmail,
            'False value for hierarchy setting Disable_Preferred_Email_Enforcement__c, should set requirePreferredEmail property to true.'
        );

        System.assertEquals(
            false,
            preferredContactInfoSettingsModel.enhancedPhoneFunctionality,
            'False value for hierarchy setting Enable_New_Preferred_Phone_Sync__c, should set enhancedPhoneFunctionality property to false.'
        );

        System.assertEquals(
            true,
            preferredContactInfoSettingsModel.preferredPhoneEnforcement,
            'False value for hierarchy setting Disable_Preferred_Phone_Enforcement__c, should set preferredPhoneEnforcement property to true.'
        );

        System.assertEquals(
            '""',
            preferredContactInfoSettingsModel.defaultPreferredPhone,
            'defaultPreferredPhone property should be blank when no valud is specified for Preferred_Phone_Selection__c hierarchy setting.'
        );
    }
}
@isTest
private with sharing class PreferredContactInfoSettingsModel_TEST {
    /****************************************************************************
     * @description Test method to verify 4 argument constructor returns a model
     * with all properties populated
     ****************************************************************************/
    @isTest
    private static void fourArgumentConstructorValid() {
        Test.startTest();
        PreferredContactInfoSettingsModel referredContactInfoSettingsModel = new PreferredContactInfoSettingsModel(
            true,
            false,
            false,
            'Test Phone Field'
        );
        Test.stopTest();

        System.assertEquals(
            true,
            referredContactInfoSettingsModel.requirePreferredEmail,
            'Should require preferred email.'
        );
        System.assertEquals(
            false,
            referredContactInfoSettingsModel.enhancedPhoneFunctionality,
            'Should not require enhanced phone functionality.'
        );
        System.assertEquals(
            false,
            referredContactInfoSettingsModel.preferredPhoneEnforcement,
            'Should not require preferred phone enforcement.'
        );
        System.assertEquals(
            'Test Phone Field',
            referredContactInfoSettingsModel.defaultPreferredPhone,
            'Default preferred phone field should be specified.'
        );
    }

    /****************************************************************************
     * @description Test method to verify 4 argument constructor returns a model
     * with all properties appropriately defaulted when blank or null values are
     * provided.
     ****************************************************************************/
    @isTest
    private static void fourArgumentConstructorEmptyString() {
        Test.startTest();
        PreferredContactInfoSettingsModel referredContactInfoSettingsModel = new PreferredContactInfoSettingsModel(
            false,
            false,
            true,
            ''
        );
        Test.stopTest();

        System.assertEquals(
            false,
            referredContactInfoSettingsModel.requirePreferredEmail,
            'Preferred email value should be set to false.'
        );
        System.assertEquals(
            false,
            referredContactInfoSettingsModel.enhancedPhoneFunctionality,
            'Enhanced phone functionality should be set to false.'
        );
        System.assertEquals(
            true,
            referredContactInfoSettingsModel.preferredPhoneEnforcement,
            'Preferred phone enforcement should be set to true.'
        );
        System.assertEquals(
            '""',
            referredContactInfoSettingsModel.defaultPreferredPhone,
            'Blank value for default preferred phone field should be represented as blank value.'
        );
    }
}
@isTest
private with sharing class PreferredContactInfoSettingsService_TEST {
    /**************************************************************************************************************************
     * @description Test method to verify that the getInstance method returns a new instance of the
     * PreferredContactInfoSettingsService class when one does not already exist.
     ***************************************************************************************************************************/
    @isTest
    private static void getInstanceNew() {
        Test.startTest();
        PreferredContactInfoSettingsService preferredContactInfoSettingsServiceInstance = PreferredContactInfoSettingsService.getInstance();
        Test.stopTest();

        System.assertEquals(
            PreferredContactInfoSettingsService.instance,
            preferredContactInfoSettingsServiceInstance,
            'Instance of mapper class returned should match static instance variable.'
        );
        System.assertEquals(
            true,
            preferredContactInfoSettingsServiceInstance != null,
            'Instance of mapper class should not be null.'
        );
    }

    /**************************************************************************************************************************
     * @description Test method to verify that the getInstance method returns the existing instance of the
     * PreferredContactInfoSettingsService class when one already exists.
     ***************************************************************************************************************************/
    @isTest
    private static void getInstanceExisting() {
        Test.startTest();
        PreferredContactInfoSettingsService preferredContactInfoSettingsService1 = PreferredContactInfoSettingsService.getInstance();
        PreferredContactInfoSettingsService preferredContactInfoSettingsService2 = PreferredContactInfoSettingsService.getInstance();
        Test.stopTest();

        System.assertEquals(
            PreferredContactInfoSettingsService.instance,
            preferredContactInfoSettingsService1,
            'Instance of mapper class returned should match static instance variable.'
        );
        System.assertEquals(
            preferredContactInfoSettingsService1,
            preferredContactInfoSettingsService2,
            'Subsequent retrievals of mapper class instance should return existing instance.'
        );
        System.assertEquals(
            true,
            preferredContactInfoSettingsService1 != null,
            'Instance of mapper class should not be null.'
        );
    }

    /***********************************************************************************************************************************
     * @description Test method to verify that the locatePreferredContactInfoSettingsMapper method returns instance of PreferredContactInfoSettingsMapper
     ***********************************************************************************************************************************/
    @isTest
    private static void locatePreferredContactInfoSettingsMapper() {
        PreferredContactInfoSettingsService preferredContactInfoSettingsServiceInstance = PreferredContactInfoSettingsService.getInstance();

        Test.startTest();
        PreferredContactInfoSettingsMapper preferredContactInfoSettingsMapperInstance = preferredContactInfoSettingsServiceInstance.locatePreferredContactInfoSettingsMapper();
        Test.stopTest();

        System.assertEquals(
            PreferredContactInfoSettingsMapper.getInstance(),
            preferredContactInfoSettingsMapperInstance,
            'Should return the instance of PreferredContactInfoSettingsMapper'
        );
    }

    /***********************************************************************************************************************************
     * @description Test method to verify that the getPreferredContactInfoSettingsModel method returns a valid PreferredContactInfoSettingsModel
     ***********************************************************************************************************************************/
    @isTest
    private static void getPreferredContactInfoSettingsModelValid() {
        PreferredContactInfoSettingsMapper.instance = new STUB_PreferredContactInfoSettingsMapper();

        Hierarchy_Settings__c hierarchySettings = UTIL_CustomSettings_API.getSettingsForTests(
            new Hierarchy_Settings__c(
                Disable_Preferred_Email_Enforcement__c = false,
                Enable_New_Preferred_Phone_Sync__c = true,
                Disable_Preferred_Phone_Enforcement__c = false,
                Preferred_Phone_Selection__c = 'Test Phone Field'
            )
        );

        PreferredContactInfoSettingsService preferredContactInfoSettingsServiceInstance = PreferredContactInfoSettingsService.getInstance();

        Test.startTest();
        PreferredContactInfoSettingsModel preferredContactInfoSettingsModel = preferredContactInfoSettingsServiceInstance.getPreferredContactInfoSettingsModel();
        Test.stopTest();

        System.assertEquals(
            true,
            preferredContactInfoSettingsModel.requirePreferredEmail,
            'Should be set to inverse of value in hierarchy settings.'
        );
        System.assertEquals(
            true,
            preferredContactInfoSettingsModel.enhancedPhoneFunctionality,
            'Should match value in hierarchy settings.'
        );
        System.assertEquals(
            true,
            preferredContactInfoSettingsModel.preferredPhoneEnforcement,
            'Should be set to inverse of value in hierarchy settings.'
        );
        System.assertEquals(
            'Test Phone Field',
            preferredContactInfoSettingsModel.defaultPreferredPhone,
            'Should match value in hierarchy settings.'
        );
    }

    /***********************************************************************************************************************************
     ****************************************************** STUBS ***********************************************************************
     ***********************************************************************************************************************************/

    /**************************************************************************************************************************************
     * @description Stub class to simulate the response from PreferredContactInfoSettingsMapper to return a valid PreferredContactInfoSettingsModel
     **************************************************************************************************************************************/
    private class STUB_PreferredContactInfoSettingsMapper extends PreferredContactInfoSettingsMapper {
        public override PreferredContactInfoSettingsModel getPreferredContactInfoSettingsModel() {
            return new PreferredContactInfoSettingsModel(true, true, true, 'Test Phone Field');
        }
    }
}
@isTest
private with sharing class PreferredContactInfoSettingsVModel_TEST {
    private static Integer loopCounter = 5;

    /**************************************************************************************************************************
     * @description Test method to verify the four argument constructor returns a PreferredContactInfoSettingsVModel with all
     * properties populated.
     ***************************************************************************************************************************/
    @isTest
    private static void fourArugmentConstructorValid() {
        List<ComboboxValueVModel> preferredPhoneOptionComboboxValueVModelsList = new List<ComboboxValueVModel>();

        for (Integer i = 0; i < loopCounter; i++) {
            preferredPhoneOptionComboboxValueVModelsList.add(
                new ComboboxValueVModel('Phone Field Label ' + i, 'Phone Field Value ' + i)
            );
        }

        ComboboxVModel preferredPhoneComboboxVModel = new ComboboxVModel(
            'Phone Field Value 1',
            preferredPhoneOptionComboboxValueVModelsList
        );

        Test.startTest();
        PreferredContactInfoSettingsVModel preferredContactInfoSettingsVModel = new PreferredContactInfoSettingsVModel(
            true,
            true,
            false,
            preferredPhoneComboboxVModel
        );
        Test.stopTest();

        System.assertEquals(
            true,
            preferredContactInfoSettingsVModel.requirePreferredEmail,
            'Require Preferred Email setting in view model should match argument value.'
        );

        System.assertEquals(
            true,
            preferredContactInfoSettingsVModel.enhancedPhoneFunctionality,
            'Enhanced Phone Functionality setting in view model should match argument value.'
        );

        System.assertEquals(
            false,
            preferredContactInfoSettingsVModel.preferredPhoneEnforcement,
            'Preferred Phone Enforcement setting in view model should match argument value.'
        );

        System.assertEquals(
            'Phone Field Value 1',
            preferredContactInfoSettingsVModel.defaultPreferredPhone.value,
            'Default Preferred Phone selected value in view model should match value in specified ComboboxVModel.'
        );

        for (Integer i = 0; i < loopCounter; i++) {
            System.assertEquals(
                'Phone Field Label ' + i,
                preferredContactInfoSettingsVModel.defaultPreferredPhone.options[i].label,
                'Label for preferred phone option should match value in specified ComboboxVModel.'
            );

            System.assertEquals(
                'Phone Field Value ' + i,
                preferredContactInfoSettingsVModel.defaultPreferredPhone.options[i].value,
                'Value for preferred phone option should match value in specified ComboboxVModel.'
            );
        }
    }
}
@isTest
private with sharing class PreferredPhoneEmailBatchController_TEST {
    /***********************************************************************************************************************************
     * @description Test method to verify that the locatePrefEmailPhoneService method returns instance of locatePrefEmailPhoneService
     ***********************************************************************************************************************************/
    @isTest
    private static void locatePrefEmailPhoneService() {
        Test.startTest();
        SRVC_Contact_PreferredEmail prefEmailPhoneServiceInstance = PreferredPhoneEmailBatchController.locatePrefEmailPhoneService();
        Test.stopTest();

        System.assertEquals(
            SRVC_Contact_PreferredEmail.getInstance(),
            prefEmailPhoneServiceInstance,
            'Should return the instance of SRVC_Contact_PreferredEmail'
        );
    }

    /***********************************************************************************************************************************
     * @description Test method to verify runPreferredPhoneAndEmailCleanupJob method runs successfully
     ***********************************************************************************************************************************/
    @isTest
    private static void runPreferredPhoneAndEmailCleanupJobValid() {
        SRVC_Contact_PreferredEmail.instance = new STUB_PrefEmailPhoneServiceValid();
        Test.startTest();
        Boolean batchJobSuccessful = PreferredPhoneEmailBatchController.runPreferredPhoneAndEmailCleanupJob();
        Test.stopTest();

        System.assertEquals(true, batchJobSuccessful, 'Should return true if the batch job has run successfully');
    }

    /***********************************************************************************************************************************
     * @description Test method to verify runPreferredPhoneAndEmailCleanupJob method throws an error
     ***********************************************************************************************************************************/
    @isTest
    private static void runPreferredPhoneAndEmailCleanupJobError() {
        SRVC_Contact_PreferredEmail.instance = new STUB_PrefEmailPhoneServiceError();
        try {
            Test.startTest();
            Boolean batchJobSuccessful = PreferredPhoneEmailBatchController.runPreferredPhoneAndEmailCleanupJob();
            Test.stopTest();
            System.assert(false, 'should always throw an exception');
        } catch (AuraHandledException e) {
            System.assertEquals('Script-thrown exception', e.getMessage(), 'Should throw exception.');
        }
    }

    /**************************************************************************************************************************
     ****************************************************** STUBS **************************************************************
     **************************************************************************************************************************/

    /**************************************************************************************************************************************************
     * @description Stub class to simulate the response from SRVC_Contact_PreferredEmail to return a true for runPreferredPhoneAndEmailCleanupJob method .
     **************************************************************************************************************************************************/
    private class STUB_PrefEmailPhoneServiceValid extends SRVC_Contact_PreferredEmail {
        public override Boolean runPreferredPhoneAndEmailCleanupJob() {
            return true;
        }
    }

    /***************************************************************************************************************************************************
     * @description Stub class to simulate the response from SRVC_Contact_PreferredEmail to throw an error for runPreferredPhoneAndEmailCleanupJob method
     ***************************************************************************************************************************************************/
    private class STUB_PrefEmailPhoneServiceError extends SRVC_Contact_PreferredEmail {
        public override Boolean runPreferredPhoneAndEmailCleanupJob() {
            throw new AuraHandledException(Label.BatchJobRunningProblem);
        }
    }
}
@isTest
private with sharing class PrimaryAffiliationSettingsVModel_TEST {
    private static Integer loopCounter = 5;

    /****************************************************************************************
     * @description Test method to verify constructor returns a PrimaryAffiliationSettingsVModel
     * with all properties populated.
     ****************************************************************************************/
    @isTest
    private static void singleArgumentConstructorValid() {
        List<PrimaryAffiliationMappingVModel> primaryAffiliationMappings = new List<PrimaryAffiliationMappingVModel>();

        for (Integer i = 0; i < loopCounter; i++) {
            primaryAffiliationMappings.add(
                new PrimaryAffiliationMappingVModel(
                    'mappingName' + i,
                    'accountRecordTypeName' + i,
                    'accountRecordTypeLabel' + i,
                    'contactFieldName' + i,
                    'contactFieldLabel' + i,
                    true
                )
            );
        }

        Test.startTest();
        PrimaryAffiliationSettingsVModel primaryAffiliationSettingsVModel = new PrimaryAffiliationSettingsVModel(
            primaryAffiliationMappings
        );
        Test.stopTest();

        System.assertEquals(
            loopCounter,
            primaryAffiliationSettingsVModel.primaryAffiliationMappings.size(),
            'Settings View model should contain ' +
            loopCounter +
            ' primary affiliation mapping models.'
        );

        for (Integer i = 0; i < loopCounter; i++) {
            System.assertEquals(
                'mappingName' + i,
                primaryAffiliationSettingsVModel.primaryAffiliationMappings[i].mappingName,
                'Mapping name of primary affiliation mapping model should match value provided as argument.'
            );

            System.assertEquals(
                'accountRecordTypeName' + i,
                primaryAffiliationSettingsVModel.primaryAffiliationMappings[i].accountRecordTypeName,
                'Account Record Type Name of primary affiliation mapping model should match value provided as argument.'
            );

            System.assertEquals(
                'accountRecordTypeLabel' + i,
                primaryAffiliationSettingsVModel.primaryAffiliationMappings[i].accountRecordTypeLabel,
                'Account Record Type Label of primary affiliation mapping model should match value provided as argument.'
            );

            System.assertEquals(
                'contactFieldName' + i,
                primaryAffiliationSettingsVModel.primaryAffiliationMappings[i].contactFieldName,
                'Contact Field Name of primary affiliation mapping model should match value provided as argument.'
            );

            System.assertEquals(
                'contactFieldLabel' + i,
                primaryAffiliationSettingsVModel.primaryAffiliationMappings[i].contactFieldLabel,
                'Contact Field Label of primary affiliation mapping model should match value provided as argument.'
            );
        }
    }
}
public virtual with sharing class PrimaryAffiliationsSettingsVMapper {
    /**********************************************************************************
     * @description Instance for Singleton Pattern
     **********************************************************************************/
    @TestVisible
    private static PrimaryAffiliationsSettingsVMapper instance;

    /**********************************************************************************
     * @description Empty constructor is not public for Singleton Pattern
     **********************************************************************************/
    protected PrimaryAffiliationsSettingsVMapper() {
    }

    /**********************************************************************************
     * @description Static method to get the current instance for Singleton pattern
     * @return The instance of AffiliationsSettingsVMapper.
     **********************************************************************************/
    public static PrimaryAffiliationsSettingsVMapper getInstance() {
        if (instance == null) {
            instance = new PrimaryAffiliationsSettingsVMapper();
        }

        return instance;
    }

    /**********************************************************************************************************
     * @description Retrieve a PrimaryffiliationsSettingsVModel for affiliations mappings
     * @return  A PrimaryffiliationsSettingsVModel
     *********************************************************************************************************/
    public virtual PrimaryAffiliationSettingsVModel getPrimaryAffiliationsSettingsVModel() {
        List<AffiliationMappingsModel> affiliationMappingsModelsList = this.locateAffiliationMappingsService()
            .getAffiliationMappingsModels();

        Map<Id, RecordTypeModel> accRecordTypeModelsById = this.locateRecordTypeService()
            .getModelByIdMapForSObjectType(Account.SObjectType);

        Map<String, RecordTypeModel> accountRecordTypeModelsByName = this.locateRecordTypeService()
            .getRecordTypeModelMapByName(accRecordTypeModelsById);
        Map<String, RecordTypeModel> accountRecordTypeModelsByLabel = this.locateRecordTypeService()
            .getRecordTypeModelMapByLabel(accRecordTypeModelsById);

        Map<String, LookupFieldModel> accountLookupsOnContactFieldModelsByName = this.locateLookupFieldService()
            .getModelByNameMapForSObjectType(Contact.SObjectType, Account.SObjectType);
        Map<String, LookupFieldModel> accountLookupsOnContactFieldModelsByLabel = this.locateLookupFieldService()
            .getModelByLabelMapForSObjectType(accountLookupsOnContactFieldModelsByName);

        List<PrimaryAffiliationMappingVModel> primaryAffiliationMappingVModelList = new List<PrimaryAffiliationMappingVModel>();

        for (AffiliationMappingsModel affiliationMappingsModel : affiliationMappingsModelsList) {
            primaryAffiliationMappingVModelList.add(
                this.getPrimaryAffiliationsMappingVModel(
                    affiliationMappingsModel,
                    accountRecordTypeModelsByName,
                    accountRecordTypeModelsByLabel,
                    accountLookupsOnContactFieldModelsByName,
                    accountLookupsOnContactFieldModelsByLabel
                )
            );
        }

        return new PrimaryAffiliationSettingsVModel(primaryAffiliationMappingVModelList);
    }

    /**********************************************************************************************************
     * @description Generate a view model representing the settings specified for an affiliation mapping.
     * @param  affiliationMappingsModel A model representing the affililation mapping
     * @param  accountRecordTypeModelsByName A Map of Account Record Type models by developer name
     * @param  accountRecordTypeModelsByLabel A Map of Account Record Type models by label
     * @param  accountLookupsOnContactFieldModelsByName A Map of Lookup fields of type Account on the Contact object by name
     * @param  accountLookupsOnContactFieldModelsByLabel A Map of Lookup fields of type Account on the Contact object by label
     * @return A PrimaryAffiliationMappingVModel
     **********************************************************************************************************/
    @TestVisible
    protected PrimaryAffiliationMappingVModel getPrimaryAffiliationsMappingVModel(
        AffiliationMappingsModel affiliationMappingsModel,
        Map<String, RecordTypeModel> accountRecordTypeModelsByName,
        Map<String, RecordTypeModel> accountRecordTypeModelsByLabel,
        Map<String, LookupFieldModel> accountLookupsOnContactFieldModelsByName,
        Map<String, LookupFieldModel> accountLookupsOnContactFieldModelsByLabel
    ) {
        String accountRecordTypeName = affiliationMappingsModel.accountRecordTypeFieldValue;
        String accountRecordTypeLabel = affiliationMappingsModel.accountRecordTypeFieldValue;
        String contactFieldName = affiliationMappingsModel.primaryAffiliationField;
        String contactFieldLabel = affiliationMappingsModel.primaryAffiliationField;

        // get RecordType model matching Account Record Type specified in Affiliation mapping
        RecordTypeModel recordTypeModel = this.locateRecordTypeService()
            .getRecordTypeModelFromNameAndLabelMaps(
                affiliationMappingsModel.accountRecordTypeFieldValue,
                accountRecordTypeModelsByName,
                accountRecordTypeModelsByLabel
            );

        if (recordTypeModel != null) {
            accountRecordTypeName = recordTypeModel.developerName;
            accountRecordTypeLabel = recordTypeModel.name;
        }

        // get LookupField model matching Primary Affiliation Field specified in Affiliation mapping
        LookupFieldModel lookupFieldModel = this.locateLookupFieldService()
            .getLookupFieldModelFromNameAndLabelMaps(
                affiliationMappingsModel.primaryAffiliationField,
                accountLookupsOnContactFieldModelsByName,
                accountLookupsOnContactFieldModelsByLabel
            );

        if (lookupFieldModel != null) {
            contactFieldName = lookupFieldModel.name;
            contactFieldLabel = lookupFieldModel.label;
        }

        return new PrimaryAffiliationMappingVModel(
            affiliationMappingsModel.name,
            accountRecordTypeName,
            accountRecordTypeLabel,
            contactFieldName,
            contactFieldLabel,
            affiliationMappingsModel.autoProgramEnrollment
        );
    }

    /**********************************************************************************************************
     * @description Retrieve a ComboBoxVModel for all active account record types
     * @param recordTypeToCheck Selected account record type in the modal
     * @return  A ComboBoxVModel
     *********************************************************************************************************/
    public virtual ComboBoxVModel getAccountRecordTypeComboboxVModel(String recordTypeToCheck) {
        String comboboxValue = recordTypeToCheck;
        List<ComboboxValueVModel> comboboxValues = new List<ComboboxValueVModel>();

        // Get all recordtype models for the account
        Map<Id, RecordTypeModel> accRecordTypeModelsById = this.locateRecordTypeService()
            .getModelByIdMapForSObjectType(Account.SObjectType);

        // Filter to get the active recordtypes model map
        Map<Id, RecordTypeModel> activeAccountRecordTypeModelsById = this.locateRecordTypeService()
            .getActiveRecordTypeModelsById(accRecordTypeModelsById.values());

        Map<String, RecordTypeModel> activeAccountRecordTypeModelsByName = this.locateRecordTypeService()
            .getRecordTypeModelMapByName(activeAccountRecordTypeModelsById);
        Map<String, RecordTypeModel> activeAccountRecordTypeModelsByLabel = this.locateRecordTypeService()
            .getRecordTypeModelMapByLabel(activeAccountRecordTypeModelsById);

        if (String.isBlank(recordTypeToCheck)) {
            comboboxValues.addAll(
                this.getComboboxVModelOptionsForActiveAccountRecordTypes(activeAccountRecordTypeModelsById.values())
            );

            return new ComboboxVModel(comboboxValue, comboboxValues);
        }

        RecordTypeModel recordTypeModel = this.locateRecordTypeService()
            .getRecordTypeModelFromNameAndLabelMaps(
                recordTypeToCheck,
                activeAccountRecordTypeModelsByName,
                activeAccountRecordTypeModelsByLabel
            );

        if (recordTypeModel == null) {
            comboboxValues.add(new ComboboxValueVModel(recordTypeToCheck, recordTypeToCheck));
        } else {
            comboboxValue = recordTypeModel.developerName;
        }

        comboboxValues.addAll(
            this.getComboboxVModelOptionsForActiveAccountRecordTypes(activeAccountRecordTypeModelsById.values())
        );

        return new ComboboxVModel(comboboxValue, comboboxValues);
    }

    /**********************************************************************************************************************
     * @description Helper method to generate a list of comboboxValueVModels for all active Account record types.
     * @param  activeAccountRecordTypeModelsList A list of RecordType models corresponding to active Account record types.
     * @return A List<ComboboxValueVModel> containing comboboxValueVModels for all active Account record types.
     **********************************************************************************************************************/
    @TestVisible
    private List<ComboboxValueVModel> getComboboxVModelOptionsForActiveAccountRecordTypes(
        List<RecordTypeModel> activeAccountRecordTypeModelsList
    ) {
        List<ComboboxValueVModel> activeRecordTypeComboboxValueVModelsList = new List<ComboboxValueVModel>();

        for (RecordTypeModel activeAccountRecordTypeModel : activeAccountRecordTypeModelsList) {
            activeRecordTypeComboboxValueVModelsList.add(
                new ComboboxValueVModel(activeAccountRecordTypeModel.name, activeAccountRecordTypeModel.developerName)
            );
        }

        return activeRecordTypeComboboxValueVModelsList;
    }

    /**********************************************************************************************************
     * @description Retrieve a ComboBoxVModel for all Contact Account Lookup Fields
     * @return  A ComboBoxVModel
     *********************************************************************************************************/
    public virtual ComboBoxVModel getContactAccountLookupFieldComboboxVModel(String contactFieldToCheck) {
        String comboboxValue = contactFieldToCheck;
        List<ComboboxValueVModel> comboboxValues = new List<ComboboxValueVModel>();

        Map<String, LookupFieldModel> accountLookupsOnContactFieldModelsByName = this.locateLookupFieldService()
            .getModelByNameMapForSObjectType(Contact.SObjectType, Account.SObjectType);
        Map<String, LookupFieldModel> accountLookupsOnContactFieldModelsByLabel = this.locateLookupFieldService()
            .getModelByLabelMapForSObjectType(accountLookupsOnContactFieldModelsByName);

        if (String.isBlank(contactFieldToCheck)) {
            comboboxValues.addAll(
                this.getComboboxVModelOptionsForContactAccountLookupFields(
                    accountLookupsOnContactFieldModelsByName.values()
                )
            );

            return new ComboboxVModel(comboboxValue, comboboxValues);
        }

        LookupFieldModel lookupFieldModel = this.locateLookupFieldService()
            .getLookupFieldModelFromNameAndLabelMaps(
                contactFieldToCheck,
                accountLookupsOnContactFieldModelsByName,
                accountLookupsOnContactFieldModelsByLabel
            );

        if (lookupFieldModel == null) {
            comboboxValues.add(new ComboboxValueVModel(contactFieldToCheck, contactFieldToCheck));
        } else {
            comboboxValue = lookupFieldModel.name;
        }

        comboboxValues.addAll(
            this.getComboboxVModelOptionsForContactAccountLookupFields(
                accountLookupsOnContactFieldModelsByName.values()
            )
        );

        return new ComboboxVModel(comboboxValue, comboboxValues);
    }

    /**********************************************************************************************************************
     * @description Helper method to generate a list of comboboxValueVModels for all Contact Account Lookup Fields.
     * @param  contactLookupFieldModelList A list of LookupField models corresponding to Contact Account Lookup Fields.
     * @return A List<ComboboxValueVModel> containing comboboxValueVModels for all Contact Account Lookup Fields.
     **********************************************************************************************************************/
    @TestVisible
    private List<ComboboxValueVModel> getComboboxVModelOptionsForContactAccountLookupFields(
        List<LookupFieldModel> contactLookupFieldModelList
    ) {
        List<ComboboxValueVModel> contactAccountLookupFieldComboboxValueVModelsList = new List<ComboboxValueVModel>();

        for (LookupFieldModel contactLookupFieldModel : contactLookupFieldModelList) {
            contactAccountLookupFieldComboboxValueVModelsList.add(
                new ComboboxValueVModel(contactLookupFieldModel.label, contactLookupFieldModel.name)
            );
        }

        return contactAccountLookupFieldComboboxValueVModelsList;
    }

    /*****************************************************************************
     * @description Retrieve an instance of the AffiliationMappingsService class.
     * @return An instance of AffiliationMappingsService.
     *****************************************************************************/
    @TestVisible
    private AffiliationMappingsService locateAffiliationMappingsService() {
        return AffiliationMappingsService.getInstance();
    }

    /*****************************************************************************
     * @description Retrieve an instance of the RecordTypeService class.
     * @return An instance of RecordTypeService.
     *****************************************************************************/
    @TestVisible
    private RecordTypeService locateRecordTypeService() {
        return RecordTypeService.getInstance();
    }

    /*****************************************************************************
     * @description Retrieve an instance of the LookupFieldService class.
     * @return An instance of LookupFieldService.
     *****************************************************************************/
    @TestVisible
    private LookupFieldService locateLookupFieldService() {
        return LookupFieldService.getInstance();
    }
}
@isTest
private with sharing class PrimaryAffiliationsSettingsVMapper_TEST {
    private static Integer loopCounter = 5;

    /**************************************************************************************************
     * @description Test method to verify that the getInstance method returns a new instance of the
     * PrimaryAffiliationsSettingsVMapper class when one does not already exist.
     **************************************************************************************************/
    @isTest
    private static void getInstanceNew() {
        Test.startTest();
        PrimaryAffiliationsSettingsVMapper primaryAffiliationsSettingsVMapperInstance = PrimaryAffiliationsSettingsVMapper.getInstance();
        Test.stopTest();

        System.assertEquals(
            PrimaryAffiliationsSettingsVMapper.instance,
            primaryAffiliationsSettingsVMapperInstance,
            'Instance of mapper class returned should match static instance variable.'
        );
        System.assertEquals(
            true,
            primaryAffiliationsSettingsVMapperInstance != null,
            'Instance of mapper class should not be null.'
        );
    }

    /**************************************************************************************************
     * @description Test method to verify that the getInstance method returns the existing instance of the
     * PrimaryAffiliationsSettingsVMapper class when one already exists.
     **************************************************************************************************/
    @isTest
    private static void getInstanceExisting() {
        Test.startTest();
        PrimaryAffiliationsSettingsVMapper primaryAffiliationsSettingsVMapperInstance1 = PrimaryAffiliationsSettingsVMapper.getInstance();
        PrimaryAffiliationsSettingsVMapper primaryAffiliationsSettingsVMapperInstance2 = PrimaryAffiliationsSettingsVMapper.getInstance();
        Test.stopTest();

        System.assertEquals(
            PrimaryAffiliationsSettingsVMapper.instance,
            primaryAffiliationsSettingsVMapperInstance1,
            'Instance of mapper class returned should match static instance variable.'
        );
        System.assertEquals(
            primaryAffiliationsSettingsVMapperInstance1,
            primaryAffiliationsSettingsVMapperInstance2,
            'Subsequent retrievals of mapper class instance should return existing instance.'
        );
        System.assertEquals(
            true,
            primaryAffiliationsSettingsVMapperInstance1 != null,
            'Instance of mapper class should not be null.'
        );
    }

    /****************************************************************************************
     * @description Test method to verify locateLookupFieldService() returns an instance of
     * the LookupFieldService class.
     ****************************************************************************************/
    @isTest
    private static void locateLookupFieldServiceValid() {
        PrimaryAffiliationsSettingsVMapper primaryAffiliationsSettingsVMapperInstance = PrimaryAffiliationsSettingsVMapper.getInstance();

        Test.startTest();
        LookupFieldService lookupFieldServiceInstance = primaryAffiliationsSettingsVMapperInstance.locateLookupFieldService();
        Test.stopTest();

        System.assertEquals(
            LookupFieldService.getInstance(),
            lookupFieldServiceInstance,
            'Should return instance of LookupFieldService class.'
        );
    }

    /****************************************************************************************
     * @description Test method to verify locateRecordTypeService() returns an instance of
     * the RecordTypeService class.
     ****************************************************************************************/
    @isTest
    private static void locateRecordTypeServiceValid() {
        PrimaryAffiliationsSettingsVMapper primaryAffiliationsSettingsVMapperInstance = PrimaryAffiliationsSettingsVMapper.getInstance();

        Test.startTest();
        RecordTypeService recordTypeServiceInstance = primaryAffiliationsSettingsVMapperInstance.locateRecordTypeService();
        Test.stopTest();

        System.assertEquals(
            RecordTypeService.getInstance(),
            recordTypeServiceInstance,
            'Should return instance of RecordTypeService class.'
        );
    }

    /****************************************************************************************
     * @description Test method to verify locateAffiliationMappingsService() returns an instance of
     * the AffiliationMappingsService class.
     ****************************************************************************************/
    @isTest
    private static void locateAffiliationMappingsServiceValid() {
        PrimaryAffiliationsSettingsVMapper primaryAffiliationsSettingsVMapperInstance = PrimaryAffiliationsSettingsVMapper.getInstance();

        Test.startTest();
        AffiliationMappingsService affiliationMappingsServiceInstance = primaryAffiliationsSettingsVMapperInstance.locateAffiliationMappingsService();
        Test.stopTest();

        System.assertEquals(
            AffiliationMappingsService.getInstance(),
            affiliationMappingsServiceInstance,
            'Should return instance of AffiliationMappingsService class.'
        );
    }

    /****************************************************************************************
     * @description Test method to verify getComboboxVModelOptionsForContactAccountLookupFields()
     * returns a list of ComboboxValueVModels representing the Account lookup fields on the
     * Contact object.
     ****************************************************************************************/
    @isTest
    private static void getComboboxVModelOptionsForContactAccountLookupFieldsValid() {
        List<LookupFieldModel> contactLookupFieldModelList = new List<LookupFieldModel>();

        for (Integer i = 0; i < loopCounter; i++) {
            contactLookupFieldModelList.add(new LookupFieldModel('Lookup Field Name ' + i, 'Lookup Field Label ' + i));
        }

        PrimaryAffiliationsSettingsVMapper primaryAffiliationsSettingsVMapperInstance = PrimaryAffiliationsSettingsVMapper.getInstance();

        Test.startTest();
        List<ComboboxValueVModel> lookupFieldComboboxValueVModelsList = primaryAffiliationsSettingsVMapperInstance.getComboboxVModelOptionsForContactAccountLookupFields(
            contactLookupFieldModelList
        );
        Test.stopTest();

        System.assertEquals(
            loopCounter,
            lookupFieldComboboxValueVModelsList.size(),
            'Should return ' +
            loopCounter +
            ' ComboboxValueVModels.'
        );

        for (Integer i = 0; i < loopCounter; i++) {
            System.assertEquals(
                'Lookup Field Name ' + i,
                lookupFieldComboboxValueVModelsList[i].value,
                'ComoboboxValueVModel value should match lookup field model name.'
            );

            System.assertEquals(
                'Lookup Field Label ' + i,
                lookupFieldComboboxValueVModelsList[i].label,
                'ComoboboxValueVModel label should match lookup field model label.'
            );
        }
    }

    /****************************************************************************************
     * @description Test method to verify getContactAccountLookupFieldComboboxVModel()
     * returns a ComboboxVModel representing the selected Account lookup field and a list of
     * options all account lookup fields on contact.
     ****************************************************************************************/
    @isTest
    private static void getContactAccountLookupFieldComboboxVModelValid() {
        LookupFieldService.instance = new STUB_LookupFieldService();

        PrimaryAffiliationsSettingsVMapper primaryAffiliationsSettingsVMapperInstance = PrimaryAffiliationsSettingsVMapper.getInstance();

        Test.startTest();
        ComboBoxVModel accountLookupFieldComboBoxVModel = primaryAffiliationsSettingsVMapperInstance.getContactAccountLookupFieldComboboxVModel(
            'Contact Account Lookup Name 1'
        );
        Test.stopTest();

        System.assertEquals(
            'Contact Account Lookup Name 1',
            accountLookupFieldComboBoxVModel.value,
            'Selected value in combobox view model should match contact field to check.'
        );

        System.assertEquals(
            2,
            accountLookupFieldComboBoxVModel.options.size(),
            'Combobox options should include only existing account lookup fields.'
        );
    }

    /****************************************************************************************
     * @description Test method to verify getContactAccountLookupFieldComboboxVModel()
     * returns a ComboboxVModel representing a list of options all account lookup fields on contact.
     ****************************************************************************************/
    @isTest
    private static void getContactAccountLookupFieldComboboxVModelEmpty() {
        LookupFieldService.instance = new STUB_LookupFieldService();

        PrimaryAffiliationsSettingsVMapper primaryAffiliationsSettingsVMapperInstance = PrimaryAffiliationsSettingsVMapper.getInstance();

        Test.startTest();
        ComboBoxVModel accountLookupFieldComboBoxVModel = primaryAffiliationsSettingsVMapperInstance.getContactAccountLookupFieldComboboxVModel(
            null
        );
        Test.stopTest();

        System.assertEquals(
            null,
            accountLookupFieldComboBoxVModel.value,
            'Selected value in combobox view model should be null.'
        );

        System.assertEquals(
            2,
            accountLookupFieldComboBoxVModel.options.size(),
            'Combobox options should include only existing account lookup fields.'
        );
    }

    /****************************************************************************************
     * @description Test method to verify getContactAccountLookupFieldComboboxVModel()
     * returns a ComboboxVModel representing the selected Account lookup field and a list of
     * options that includes the selected lookup field when it is not currently a specified field.
     ****************************************************************************************/
    @isTest
    private static void getContactAccountLookupFieldComboboxVModelInValid() {
        LookupFieldService.instance = new STUB_LookupFieldService();

        PrimaryAffiliationsSettingsVMapper primaryAffiliationsSettingsVMapperInstance = PrimaryAffiliationsSettingsVMapper.getInstance();

        Test.startTest();
        ComboBoxVModel accountLookupFieldComboBoxVModel = primaryAffiliationsSettingsVMapperInstance.getContactAccountLookupFieldComboboxVModel(
            'Invalid Field Name'
        );
        Test.stopTest();

        System.assertEquals(
            'Invalid Field Name',
            accountLookupFieldComboBoxVModel.value,
            'Selected value in combobox view model should match contact field to check.'
        );

        System.assertEquals(
            3,
            accountLookupFieldComboBoxVModel.options.size(),
            'Combobox options should include invalid field name as an option in addition to existing account lookup fields.'
        );
    }

    /****************************************************************************************
     * @description Test method to verify getComboboxVModelOptionsForActiveAccountRecordTypes()
     * returns a List<ComboboxValueVModel> representing the record type models provided as
     * arguments.
     ****************************************************************************************/
    @isTest
    private static void getComboboxVModelOptionsForActiveAccountRecordTypesValid() {
        List<RecordTypeModel> activeAccountRecordTypeModelsList = new List<RecordTypeModel>();

        for (Integer i = 0; i < loopCounter; i++) {
            activeAccountRecordTypeModelsList.add(
                new RecordTypeModel('00000000000000000' + i, 'AcctRT' + i, 'Acct_RT_' + i, true)
            );
        }

        PrimaryAffiliationsSettingsVMapper primaryAffiliationsSettingsVMapperInstance = PrimaryAffiliationsSettingsVMapper.getInstance();

        Test.startTest();
        List<ComboboxValueVModel> activeRecordTypeComboboxValueVModelsList = primaryAffiliationsSettingsVMapperInstance.getComboboxVModelOptionsForActiveAccountRecordTypes(
            activeAccountRecordTypeModelsList
        );
        Test.stopTest();

        System.assertEquals(
            loopCounter,
            activeRecordTypeComboboxValueVModelsList.size(),
            'Should return ' +
            loopCounter +
            ' comboboxValueVModels corresponding to active record type models.'
        );

        for (Integer i = 0; i < loopCounter; i++) {
            System.assertEquals(
                'AcctRT' + i,
                activeRecordTypeComboboxValueVModelsList[i].label,
                'ComboboxVModel label should correspond to record type model name.'
            );

            System.assertEquals(
                'Acct_RT_' + i,
                activeRecordTypeComboboxValueVModelsList[i].value,
                'ComboboxVModel label should correspond to record type model developer name.'
            );
        }
    }

    /****************************************************************************************
     * @description Test method to verify getAccountRecordTypeComboboxVModel()
     * returns a ComboboxVModel representing a selected account record type that is also an
     * existing value.
     ****************************************************************************************/
    @isTest
    private static void getAccountRecordTypeComboboxVModelValid() {
        RecordTypeService.instance = new STUB_RecordTypeService();

        PrimaryAffiliationsSettingsVMapper primaryAffiliationsSettingsVMapperInstance = PrimaryAffiliationsSettingsVMapper.getInstance();

        Test.startTest();
        ComboBoxVModel accountRTComboboxVModel = primaryAffiliationsSettingsVMapperInstance.getAccountRecordTypeComboboxVModel(
            'Record_Type_2'
        );
        Test.stopTest();

        System.assertEquals(
            'Record_Type_2',
            accountRTComboboxVModel.value,
            'Selected account record type should match record type to check.'
        );
        System.assertEquals(
            2,
            accountRTComboboxVModel.options.size(),
            'Account record type options list should consist only of active values.'
        );
    }

    /****************************************************************************************
     * @description Test method to verify getAccountRecordTypeComboboxVModel()
     * returns a ComboboxVModel representing a list of all active Account Record Types
     ****************************************************************************************/
    @isTest
    private static void getAccountRecordTypeComboboxVModelEmpty() {
        RecordTypeService.instance = new STUB_RecordTypeService();

        PrimaryAffiliationsSettingsVMapper primaryAffiliationsSettingsVMapperInstance = PrimaryAffiliationsSettingsVMapper.getInstance();

        Test.startTest();
        ComboBoxVModel accountRTComboboxVModel = primaryAffiliationsSettingsVMapperInstance.getAccountRecordTypeComboboxVModel(
            null
        );
        Test.stopTest();

        System.assertEquals(null, accountRTComboboxVModel.value, 'Selected account record type should be null.');
        System.assertEquals(
            2,
            accountRTComboboxVModel.options.size(),
            'Account record type options list should consist only of active values.'
        );
    }

    /****************************************************************************************
     * @description Test method to verify getAccountRecordTypeComboboxVModel()
     * returns a ComboboxVModel representing a selected account record type that is not an
     * existing value.
     ****************************************************************************************/
    @isTest
    private static void getAccountRecordTypeComboboxVModelInValid() {
        RecordTypeService.instance = new STUB_RecordTypeService();

        PrimaryAffiliationsSettingsVMapper primaryAffiliationsSettingsVMapperInstance = PrimaryAffiliationsSettingsVMapper.getInstance();

        Test.startTest();
        ComboBoxVModel accountRTComboboxVModel = primaryAffiliationsSettingsVMapperInstance.getAccountRecordTypeComboboxVModel(
            'New Record Type'
        );
        Test.stopTest();

        System.assertEquals(
            'New Record Type',
            accountRTComboboxVModel.value,
            'Selected account record type should match record type to check.'
        );
        System.assertEquals(
            3,
            accountRTComboboxVModel.options.size(),
            'Account record type options list should include new value with active values.'
        );
    }

    /****************************************************************************************
     * @description Test method to verify getPrimaryAffiliationsMappingVModel()
     * returns a PrimaryAffiliationMappingVModel with account record type and lookup field names
     * and labels corresponding to the matching model properties when matching models exists.
     ****************************************************************************************/
    @isTest
    private static void getPrimaryAffiliationsMappingVModelValid() {
        RecordTypeService.instance = new STUB_RecordTypeServiceValid();
        LookupFieldService.instance = new STUB_LookupFieldServiceValid();

        AffiliationMappingsModel affiliationMappingsModel = new AffiliationMappingsModel(
            'Affliation Name',
            'Account Record Type',
            'Primary Affiliation Field',
            true,
            'autoProgramEnrollmentStatus',
            'autoProgramEnrollmentRole'
        );
        Map<String, RecordTypeModel> accountRecordTypeModelsByName = new Map<String, RecordTypeModel>{
            'Account_Record_Type' => new RecordTypeModel(
                '000000000000000009',
                'Account Record Type',
                'Account_Record_Type',
                true
            )
        };

        Map<String, RecordTypeModel> accountRecordTypeModelsByLabel = new Map<String, RecordTypeModel>{
            'Account Record Type' => new RecordTypeModel(
                '000000000000000009',
                'Account Record Type',
                'Account_Record_Type',
                true
            )
        };

        Map<String, LookupFieldModel> accountLookupsOnContactFieldModelsByName = new Map<String, LookupFieldModel>{
            'Account Field Name' => new LookupFieldModel('Account Field Name', 'Account Field Label')
        };

        Map<String, LookupFieldModel> accountLookupsOnContactFieldModelsByLabel = new Map<String, LookupFieldModel>{
            'Account Field Label' => new LookupFieldModel('Account Field Name', 'Account Field Label')
        };

        PrimaryAffiliationsSettingsVMapper primaryAffiliationsSettingsVMapperInstance = PrimaryAffiliationsSettingsVMapper.getInstance();

        Test.startTest();
        PrimaryAffiliationMappingVModel primaryAffiliationMappingVModel = primaryAffiliationsSettingsVMapperInstance.getPrimaryAffiliationsMappingVModel(
            affiliationMappingsModel,
            accountRecordTypeModelsByName,
            accountRecordTypeModelsByLabel,
            accountLookupsOnContactFieldModelsByName,
            accountLookupsOnContactFieldModelsByLabel
        );
        Test.stopTest();

        System.assertEquals(
            'Affliation Name',
            PrimaryAffiliationMappingVModel.mappingName,
            'Mapping name should match name of affiliation mapping.'
        );

        System.assertEquals(
            'Account_Record_Type',
            PrimaryAffiliationMappingVModel.accountRecordTypeName,
            'Account Record Type name should match developer name of Record Type model corresponding to record type specified for the affiliation mapping.'
        );

        System.assertEquals(
            'Account Record Type',
            PrimaryAffiliationMappingVModel.accountRecordTypeLabel,
            'Account Record Type label should match label of Record Type model corresponding to record type specified for the affiliation mapping.'
        );

        System.assertEquals(
            'Account Field Name',
            PrimaryAffiliationMappingVModel.contactFieldName,
            'Contact field name should match name of Lookup Field model corresponding to primary affiliation field specified for the affiliation mapping.'
        );

        System.assertEquals(
            'Account Field Label',
            PrimaryAffiliationMappingVModel.contactFieldLabel,
            'Contact field label should match label of Lookup Field model corresponding to primary affiliation field specified for the affiliation mapping.'
        );

        System.assertEquals(
            true,
            PrimaryAffiliationMappingVModel.autoProgramEnrollment,
            'Auto-enrollment enablement should match value specified for the affiliation mapping.'
        );
    }

    /****************************************************************************************
     * @description Test method to verify getPrimaryAffiliationsMappingVModel()
     * returns a PrimaryAffiliationMappingVModel with account record type and lookup field names
     * and labels corresponding to the properties specified for the affiliation mapping
     * when matching models do not exist.
     ****************************************************************************************/
    @isTest
    private static void getPrimaryAffiliationsMappingVModelInValid() {
        RecordTypeService.instance = new STUB_RecordTypeServiceInvalid();
        LookupFieldService.instance = new STUB_LookupFieldServiceInvalid();

        AffiliationMappingsModel affiliationMappingsModel = new AffiliationMappingsModel(
            'Affliation Name',
            'Invalid Account Record Type',
            'Invalid Primary Affiliation Field',
            false,
            'autoProgramEnrollmentStatus',
            'autoProgramEnrollmentRole'
        );
        Map<String, RecordTypeModel> accountRecordTypeModelsByName = new Map<String, RecordTypeModel>{
            'Account_Record_Type' => new RecordTypeModel(
                '000000000000000009',
                'Account Record Type',
                'Account_Record_Type',
                true
            )
        };

        Map<String, RecordTypeModel> accountRecordTypeModelsByLabel = new Map<String, RecordTypeModel>{
            'Account Record Type' => new RecordTypeModel(
                '000000000000000009',
                'Account Record Type',
                'Account_Record_Type',
                true
            )
        };

        Map<String, LookupFieldModel> accountLookupsOnContactFieldModelsByName = new Map<String, LookupFieldModel>{
            'Account Field Name' => new LookupFieldModel('Account Field Name', 'Account Field Label')
        };

        Map<String, LookupFieldModel> accountLookupsOnContactFieldModelsByLabel = new Map<String, LookupFieldModel>{
            'Account Field Label' => new LookupFieldModel('Account Field Name', 'Account Field Label')
        };

        PrimaryAffiliationsSettingsVMapper primaryAffiliationsSettingsVMapperInstance = PrimaryAffiliationsSettingsVMapper.getInstance();

        Test.startTest();
        PrimaryAffiliationMappingVModel primaryAffiliationMappingVModel = primaryAffiliationsSettingsVMapperInstance.getPrimaryAffiliationsMappingVModel(
            affiliationMappingsModel,
            accountRecordTypeModelsByName,
            accountRecordTypeModelsByLabel,
            accountLookupsOnContactFieldModelsByName,
            accountLookupsOnContactFieldModelsByLabel
        );
        Test.stopTest();

        System.assertEquals(
            'Affliation Name',
            PrimaryAffiliationMappingVModel.mappingName,
            'Mapping name should match name of affiliation mapping.'
        );

        System.assertEquals(
            'Invalid Account Record Type',
            PrimaryAffiliationMappingVModel.accountRecordTypeName,
            'Account Record Type name should match value specified for the affiliation mapping.'
        );

        System.assertEquals(
            'Invalid Account Record Type',
            PrimaryAffiliationMappingVModel.accountRecordTypeLabel,
            'Account Record Type label should match value specified for the affiliation mapping.'
        );

        System.assertEquals(
            'Invalid Primary Affiliation Field',
            PrimaryAffiliationMappingVModel.contactFieldName,
            'Contact field name should match value specified for the affiliation mapping.'
        );

        System.assertEquals(
            'Invalid Primary Affiliation Field',
            PrimaryAffiliationMappingVModel.contactFieldLabel,
            'Contact field label should match value specified for the affiliation mapping.'
        );

        System.assertEquals(
            false,
            PrimaryAffiliationMappingVModel.autoProgramEnrollment,
            'Auto-enrollment enablement should match value specified for the affiliation mapping.'
        );
    }

    /****************************************************************************************
     * @description Test method to verify getPrimaryAffiliationsSettingsVModel()
     * returns a PrimaryAffiliationSettingsVModel with a list of PrimaryAffiliationMappingVModels
     * corresponding to the affiliation mappings with account record type and lookup field names
     * and labels matching the corresponding models when matching models exist.
     ****************************************************************************************/
    @isTest
    private static void getPrimaryAffiliationsSettingsVModelValid() {
        AffiliationMappingsService.instance = new STUB_AffiliationMappingsService();
        RecordTypeService.instance = new STUB_RecordTypeService();
        LookupFieldService.instance = new STUB_LookupFieldService();

        PrimaryAffiliationsSettingsVMapper primaryAffiliationsSettingsVMapperInstance = PrimaryAffiliationsSettingsVMapper.getInstance();

        Test.startTest();
        PrimaryAffiliationSettingsVModel primaryAffiliationSettingsVModel = primaryAffiliationsSettingsVMapperInstance.getPrimaryAffiliationsSettingsVModel();
        Test.stopTest();

        System.assertEquals(
            2,
            PrimaryAffiliationSettingsVModel.primaryAffiliationMappings.size(),
            'Should return 2 PrimaryAffiliationMappingVModels.'
        );

        for (Integer i = 0; i < PrimaryAffiliationSettingsVModel.primaryAffiliationMappings.size(); i++) {
            System.assertEquals(
                'Affiliation Name ' + (i + 1),
                PrimaryAffiliationSettingsVModel.primaryAffiliationMappings[i].mappingName,
                'Mapping name on PrimaryAffiliationMappingVModel should match affiliation.'
            );

            System.assertEquals(
                'Record_Type_' + (i + 1),
                PrimaryAffiliationSettingsVModel.primaryAffiliationMappings[i].accountRecordTypeName,
                'Account record type name on PrimaryAffiliationMappingVModel should match developer name of corresponding record type model.'
            );

            System.assertEquals(
                'Record Type ' + (i + 1),
                PrimaryAffiliationSettingsVModel.primaryAffiliationMappings[i].accountRecordTypeLabel,
                'Account record type label on PrimaryAffiliationMappingVModel should match label of corresponding record type model.'
            );

            System.assertEquals(
                'Contact Account Lookup Name ' + (i + 1),
                PrimaryAffiliationSettingsVModel.primaryAffiliationMappings[i].contactFieldName,
                'Contact field name on PrimaryAffiliationMappingVModel should match name of corresponding lookup field model.'
            );

            System.assertEquals(
                'Contact Account Lookup Label ' + (i + 1),
                PrimaryAffiliationSettingsVModel.primaryAffiliationMappings[i].contactFieldLabel,
                'Contact field label on PrimaryAffiliationMappingVModel should match label of corresponding lookup field model.'
            );

            System.assertEquals(
                true,
                PrimaryAffiliationSettingsVModel.primaryAffiliationMappings[i].autoProgramEnrollment,
                'Auto-Enrollment enablement on PrimaryAffiliationMappingVModel should match affiliation.'
            );
        }
    }

    /****************************************************************************************
     * @description Test method to verify getPrimaryAffiliationsSettingsVModel()
     * returns a PrimaryAffiliationSettingsVModel with a list of PrimaryAffiliationMappingVModels
     * corresponding to the affiliation mappings with account record type and lookup field names
     * and labels matching the affiliation model properties when matching models do not exist.
     ****************************************************************************************/
    @isTest
    private static void getPrimaryAffiliationsSettingsVModelInValid() {
        AffiliationMappingsService.instance = new STUB_AffiliationMappingsService();
        RecordTypeService.instance = new STUB_RecordTypeServiceInvalid();
        LookupFieldService.instance = new STUB_LookupFieldServiceInvalid();

        PrimaryAffiliationsSettingsVMapper primaryAffiliationsSettingsVMapperInstance = PrimaryAffiliationsSettingsVMapper.getInstance();

        Test.startTest();
        PrimaryAffiliationSettingsVModel primaryAffiliationSettingsVModel = primaryAffiliationsSettingsVMapperInstance.getPrimaryAffiliationsSettingsVModel();
        Test.stopTest();

        System.assertEquals(
            2,
            PrimaryAffiliationSettingsVModel.primaryAffiliationMappings.size(),
            'Should return 2 PrimaryAffiliationMappingVModels.'
        );

        for (Integer i = 0; i < PrimaryAffiliationSettingsVModel.primaryAffiliationMappings.size(); i++) {
            System.assertEquals(
                'Affiliation Name ' + (i + 1),
                PrimaryAffiliationSettingsVModel.primaryAffiliationMappings[i].mappingName,
                'Mapping name on PrimaryAffiliationMappingVModel should match affiliation.'
            );

            System.assertEquals(
                'Record Type ' + (i + 1),
                PrimaryAffiliationSettingsVModel.primaryAffiliationMappings[i].accountRecordTypeName,
                'Account record type name on PrimaryAffiliationMappingVModel should match affiliation.'
            );

            System.assertEquals(
                'Record Type ' + (i + 1),
                PrimaryAffiliationSettingsVModel.primaryAffiliationMappings[i].accountRecordTypeLabel,
                'Account record type label on PrimaryAffiliationMappingVModel should match affiliation.'
            );

            System.assertEquals(
                'Contact Account Lookup Label ' + (i + 1),
                PrimaryAffiliationSettingsVModel.primaryAffiliationMappings[i].contactFieldName,
                'Contact field name on PrimaryAffiliationMappingVModel should match affiliation.'
            );

            System.assertEquals(
                'Contact Account Lookup Label ' + (i + 1),
                PrimaryAffiliationSettingsVModel.primaryAffiliationMappings[i].contactFieldLabel,
                'Contact field label on PrimaryAffiliationMappingVModel should match affiliation.'
            );

            System.assertEquals(
                true,
                PrimaryAffiliationSettingsVModel.primaryAffiliationMappings[i].autoProgramEnrollment,
                'Auto-Enrollment enablement on PrimaryAffiliationMappingVModel should match affiliation.'
            );
        }
    }

    /***********************************************************************************************************************************
     ****************************************************** STUBS ***********************************************************************
     ***********************************************************************************************************************************/

    /**************************************************************************************************************************************
     * @description Stub class to simulate valid responses from AffiliationMappingsService
     **************************************************************************************************************************************/
    private class STUB_AffiliationMappingsService extends AffiliationMappingsService {
        public override List<AffiliationMappingsModel> getAffiliationMappingsModels() {
            return new List<AffiliationMappingsModel>{
                new AffiliationMappingsModel(
                    'Affiliation Name 1',
                    'Record Type 1',
                    'Contact Account Lookup Label 1',
                    true,
                    'autoProgramEnrollmentStatus1',
                    'autoProgramEnrollmentRole1'
                ),
                new AffiliationMappingsModel(
                    'Affiliation Name 2',
                    'Record Type 2',
                    'Contact Account Lookup Label 2',
                    true,
                    'autoProgramEnrollmentStatus2',
                    'autoProgramEnrollmentRole2'
                )
            };
        }
    }

    /**************************************************************************************************************************************
     * @description Stub class to simulate valid responses from LookupFieldService
     **************************************************************************************************************************************/
    private class STUB_LookupFieldService extends LookupFieldService {
        public override Map<String, LookupFieldModel> getModelByNameMapForSObjectType(
            SObjectType sObjectType,
            SObjectType lookupToSObjectType
        ) {
            return new Map<String, LookupFieldModel>{
                'Contact Account Lookup Name 1' => new LookupFieldModel(
                    'Contact Account Lookup Name 1',
                    'Contact Account Lookup Label 1'
                ),
                'Contact Account Lookup Name 2' => new LookupFieldModel(
                    'Contact Account Lookup Name 2',
                    'Contact Account Lookup Label 2'
                )
            };
        }
    }

    /**************************************************************************************************************************************
     * @description Stub class to simulate valid responses from LookupFieldService
     **************************************************************************************************************************************/
    private class STUB_LookupFieldServiceValid extends LookupFieldService {
        public override LookupFieldModel getLookupFieldModelFromNameAndLabelMaps(
            String lookupFieldNameOrLabel,
            Map<String, LookupFieldModel> lookupFieldModelByName,
            Map<String, LookupFieldModel> lookupFieldModelByLabel
        ) {
            return new LookupFieldModel('Account Field Name', 'Account Field Label');
        }
    }

    /**************************************************************************************************************************************
     * @description Stub class to simulate valid responses from RecordTypeService
     **************************************************************************************************************************************/
    private class STUB_RecordTypeService extends RecordTypeService {
        public override Map<Id, RecordTypeModel> getModelByIdMapForSObjectType(Schema.SObjectType sObjectType) {
            return new Map<Id, RecordTypeModel>{
                '000000000000000001' => new RecordTypeModel(
                    '000000000000000001',
                    'Record Type 1',
                    'Record_Type_1',
                    true
                ),
                '000000000000000002' => new RecordTypeModel(
                    '000000000000000002',
                    'Record Type 2',
                    'Record_Type_2',
                    true
                ),
                '000000000000000003' => new RecordTypeModel(
                    '000000000000000003',
                    'Record Type 3',
                    'Record_Type_3',
                    false
                )
            };
        }
    }

    /**************************************************************************************************************************************
     * @description Stub class to simulate valid responses from RecordTypeService
     **************************************************************************************************************************************/
    private class STUB_RecordTypeServiceValid extends RecordTypeService {
        public override RecordTypeModel getRecordTypeModelFromNameAndLabelMaps(
            String recordTypeNameOrLabel,
            Map<String, RecordTypeModel> recordTypeModelByName,
            Map<String, RecordTypeModel> recordTypeModelByLabel
        ) {
            return new RecordTypeModel('000000000000000009', 'Account Record Type', 'Account_Record_Type', true);
        }
    }

    /**************************************************************************************************************************************
     * @description Stub class to simulate invalid responses from LookupFieldService
     **************************************************************************************************************************************/
    private class STUB_LookupFieldServiceInvalid extends LookupFieldService {
        public override LookupFieldModel getLookupFieldModelFromNameAndLabelMaps(
            String lookupFieldNameOrLabel,
            Map<String, LookupFieldModel> lookupFieldModelByName,
            Map<String, LookupFieldModel> lookupFieldModelByLabel
        ) {
            return null;
        }
    }

    /**************************************************************************************************************************************
     * @description Stub class to simulate invalid responses from RecordTypeService
     **************************************************************************************************************************************/
    private class STUB_RecordTypeServiceInvalid extends RecordTypeService {
        public override RecordTypeModel getRecordTypeModelFromNameAndLabelMaps(
            String recordTypeNameOrLabel,
            Map<String, RecordTypeModel> recordTypeModelByName,
            Map<String, RecordTypeModel> recordTypeModelByLabel
        ) {
            return null;
        }
    }
}
@isTest
private with sharing class ProgramEnrollDeletionSettingsMapper_TEST {
    /**************************************************************************************************************************
     * @description Test method to verify that the getInstance method returns a new instance of the
     * ProgramEnrollmentDeletionSettingsMapper class when one does not already exist.
     ***************************************************************************************************************************/
    @isTest
    private static void getInstanceNew() {
        Test.startTest();
        ProgramEnrollmentDeletionSettingsMapper programEnrollmentDeletionSettingsMapperInstance = ProgramEnrollmentDeletionSettingsMapper.getInstance();
        Test.stopTest();

        System.assertEquals(
            ProgramEnrollmentDeletionSettingsMapper.instance,
            programEnrollmentDeletionSettingsMapperInstance,
            'Instance of mapper class returned should match static instance variable.'
        );
        System.assertEquals(
            true,
            programEnrollmentDeletionSettingsMapperInstance != null,
            'Instance of mapper class should not be null.'
        );
    }

    /**************************************************************************************************************************
     * @description Test method to verify that the getInstance method returns the existing instance of the
     * ProgramEnrollmentDeletionSettingsMapper class when one already exists.
     ***************************************************************************************************************************/
    @isTest
    private static void getInstanceExisting() {
        Test.startTest();
        ProgramEnrollmentDeletionSettingsMapper programEnrollmentDeletionSettingsMapper1 = ProgramEnrollmentDeletionSettingsMapper.getInstance();
        ProgramEnrollmentDeletionSettingsMapper programEnrollmentDeletionSettingsMapper2 = ProgramEnrollmentDeletionSettingsMapper.getInstance();
        Test.stopTest();

        System.assertEquals(
            ProgramEnrollmentDeletionSettingsMapper.instance,
            programEnrollmentDeletionSettingsMapper1,
            'Instance of mapper class returned should match static instance variable.'
        );
        System.assertEquals(
            programEnrollmentDeletionSettingsMapper1,
            programEnrollmentDeletionSettingsMapper2,
            'Subsequent retrievals of mapper class instance should return existing instance.'
        );
        System.assertEquals(
            true,
            programEnrollmentDeletionSettingsMapper1 != null,
            'Instance of mapper class should not be null.'
        );
    }

    /**************************************************************************************************************************
     * @description Test method to verify that the getProgramEnrollmentDeletionSettingsModel method returns a
     * ProgramEnrollmentDeletionSettingsModel matching the program enrollment deletion settings specified in hierarchy
     * settings.
     ***************************************************************************************************************************/
    @isTest
    private static void getProgramEnrollmentDeletionSettingsModelValid() {
        Hierarchy_Settings__c hierarchySettings = UTIL_CustomSettings_API.getSettingsForTests(
            new Hierarchy_Settings__c(Affl_ProgEnroll_Del__c = false, Affl_ProgEnroll_Del_Status__c = 'Former Status')
        );

        ProgramEnrollmentDeletionSettingsMapper programEnrollmentDeletionSettingsMapperInstance = ProgramEnrollmentDeletionSettingsMapper.getInstance();

        Test.startTest();
        ProgramEnrollmentDeletionSettingsModel programEnrollmentDeletionSettingsModel = programEnrollmentDeletionSettingsMapperInstance.getProgramEnrollmentDeletionSettingsModel();
        Test.stopTest();

        System.assertEquals(
            false,
            programEnrollmentDeletionSettingsModel.programEnrollmentDeletion,
            'Program Enrollment Deletion should not be enabled.'
        );
        System.assertEquals(
            'Former Status',
            programEnrollmentDeletionSettingsModel.programEnrollmentDeletionStatus,
            'Program Enrollment Deletion Status should be \'Former Status\'.'
        );
    }

    /**************************************************************************************************************************
     * @description Test method to verify that the getProgramEnrollmentDeletionSettingsModel method returns a
     * ProgramEnrollmentDeletionSettingsModel matching the program enrollment deletion settings specified in hierarchy
     * settings with a blank string for the deletion status when the corresponding hierarchy setting field is blank.
     ***************************************************************************************************************************/
    @isTest
    private static void getProgramEnrollmentDeletionSettingsModelEmptyValid() {
        Hierarchy_Settings__c hierarchySettings = UTIL_CustomSettings_API.getSettingsForTests(
            new Hierarchy_Settings__c(Affl_ProgEnroll_Del__c = true, Affl_ProgEnroll_Del_Status__c = '')
        );

        ProgramEnrollmentDeletionSettingsMapper programEnrollmentDeletionSettingsMapperInstance = ProgramEnrollmentDeletionSettingsMapper.getInstance();

        Test.startTest();
        ProgramEnrollmentDeletionSettingsModel programEnrollmentDeletionSettingsModel = programEnrollmentDeletionSettingsMapperInstance.getProgramEnrollmentDeletionSettingsModel();
        Test.stopTest();

        System.assertEquals(
            true,
            programEnrollmentDeletionSettingsModel.programEnrollmentDeletion,
            'Program Enrollment Deletion should be enabled.'
        );
        System.assertEquals(
            '""',
            programEnrollmentDeletionSettingsModel.programEnrollmentDeletionStatus,
            'Program Enrollment Deletion Status should be a blank string.'
        );
    }
}
@isTest
private with sharing class ProgramEnrollDeletionSettingsModel_TEST {
    /*******************************************************************************
     * @description Test method to verify 2 argument constructor returns a
     * ProgramEnrollmentDeletionSettingsModel with all properties populated.
     *******************************************************************************/
    @isTest
    private static void twoArgumentConstructorValid() {
        Test.startTest();
        ProgramEnrollmentDeletionSettingsModel programEnrollmentDeletionSettingsModel = new ProgramEnrollmentDeletionSettingsModel(
            true,
            'Test Status'
        );
        Test.stopTest();

        System.assertEquals(
            true,
            programEnrollmentDeletionSettingsModel.programEnrollmentDeletion,
            'Program enrollment deletion enablement should match value specified.'
        );
        System.assertEquals(
            'Test Status',
            programEnrollmentDeletionSettingsModel.programEnrollmentDeletionStatus,
            'Program enrollment deletion status should match value specified.'
        );
    }

    /*******************************************************************************
     * @description Test method to verify 2 argument constructor returns a
     * ProgramEnrollmentDeletionSettingsModel with all properties populated when a blank
     * string is provided as an argument.
     *******************************************************************************/
    @isTest
    private static void twoArgumentConstructorWithBlankValid() {
        Test.startTest();
        ProgramEnrollmentDeletionSettingsModel programEnrollmentDeletionSettingsModel = new ProgramEnrollmentDeletionSettingsModel(
            false,
            ''
        );
        Test.stopTest();

        System.assertEquals(
            false,
            programEnrollmentDeletionSettingsModel.programEnrollmentDeletion,
            'Program enrollment deletion enablement should match value specified.'
        );
        System.assertEquals(
            '""',
            programEnrollmentDeletionSettingsModel.programEnrollmentDeletionStatus,
            'Program enrollment deletion status should be blank.'
        );
    }

    /*******************************************************************************
     * @description Test method to verify 2 argument constructor returns a
     * ProgramEnrollmentDeletionSettingsModel with all properties populated when a null
     * string is provided as an argument.
     *******************************************************************************/
    @isTest
    private static void twoArgumentConstructorWithNullValid() {
        Test.startTest();
        ProgramEnrollmentDeletionSettingsModel programEnrollmentDeletionSettingsModel = new ProgramEnrollmentDeletionSettingsModel(
            false,
            null
        );
        Test.stopTest();

        System.assertEquals(
            false,
            programEnrollmentDeletionSettingsModel.programEnrollmentDeletion,
            'Program enrollment deletion enablement should match value specified.'
        );
        System.assertEquals(
            '""',
            programEnrollmentDeletionSettingsModel.programEnrollmentDeletionStatus,
            'Program enrollment deletion status should be blank.'
        );
    }
}
@isTest
private with sharing class ProgramEnrollDeletionSettingsSrvc_TEST {
    /**************************************************************************************************************************
     * @description Test method to verify that the getInstance method returns a new instance of the
     * ProgramEnrollmentDeletionSettingsService class when one does not already exist.
     ***************************************************************************************************************************/
    @isTest
    private static void getInstanceNew() {
        Test.startTest();
        ProgramEnrollmentDeletionSettingsService programEnrollmentDeletionSettingsServiceInstance = ProgramEnrollmentDeletionSettingsService.getInstance();
        Test.stopTest();

        System.assertEquals(
            ProgramEnrollmentDeletionSettingsService.instance,
            programEnrollmentDeletionSettingsServiceInstance,
            'Instance of service class returned should match static instance variable.'
        );
        System.assertEquals(
            true,
            programEnrollmentDeletionSettingsServiceInstance != null,
            'Instance of service class should not be null.'
        );
    }

    /**************************************************************************************************************************
     * @description Test method to verify that the getInstance method returns the existing instance of the
     * ProgramEnrollmentDeletionSettingsService class when one already exists.
     ***************************************************************************************************************************/
    @isTest
    private static void getInstanceExisting() {
        Test.startTest();
        ProgramEnrollmentDeletionSettingsService programEnrollmentDeletionSettingsMapper1 = ProgramEnrollmentDeletionSettingsService.getInstance();
        ProgramEnrollmentDeletionSettingsService programEnrollmentDeletionSettingsMapper2 = ProgramEnrollmentDeletionSettingsService.getInstance();
        Test.stopTest();

        System.assertEquals(
            ProgramEnrollmentDeletionSettingsService.instance,
            programEnrollmentDeletionSettingsMapper1,
            'Instance of service class returned should match static instance variable.'
        );
        System.assertEquals(
            programEnrollmentDeletionSettingsMapper1,
            programEnrollmentDeletionSettingsMapper2,
            'Subsequent retrievals of service class instance should return existing instance.'
        );
        System.assertEquals(
            true,
            programEnrollmentDeletionSettingsMapper1 != null,
            'Instance of service class should not be null.'
        );
    }

    /**************************************************************************************************************************
     * @description Test method to verify that the locateProgramEnrollmentDeletionSettingsMapper method returns an instance
     * of the ProgramEnrollmentDeletionSettingsMapper class.
     ***************************************************************************************************************************/
    @isTest
    private static void locateProgramEnrollmentDeletionSettingsMapperValid() {
        ProgramEnrollmentDeletionSettingsService programEnrollmentDeletionSettingsServiceInstance = ProgramEnrollmentDeletionSettingsService.getInstance();

        Test.startTest();
        ProgramEnrollmentDeletionSettingsMapper programEnrollmentDeletionSettingsMapperInstance = programEnrollmentDeletionSettingsServiceInstance.locateProgramEnrollmentDeletionSettingsMapper();
        Test.stopTest();

        System.assertEquals(
            ProgramEnrollmentDeletionSettingsMapper.getInstance(),
            programEnrollmentDeletionSettingsMapperInstance,
            'Should return instance of ProgramEnrollmentDeletionSettingsMapper class.'
        );
    }

    /**************************************************************************************************************************
     * @description Test method to verify that the getProgramEnrollmentDeletionSettingsModel method returns a ProgramEnrollmentDeletionSettingsModel
     ***************************************************************************************************************************/
    @isTest
    private static void getProgramEnrollmentDeletionSettingsModelValid() {
        ProgramEnrollmentDeletionSettingsMapper.instance = new STUB_ProgramEnrollmentDeletionSettingsMapper();

        ProgramEnrollmentDeletionSettingsService programEnrollmentDeletionSettingsServiceInstance = ProgramEnrollmentDeletionSettingsService.getInstance();

        Test.startTest();
        ProgramEnrollmentDeletionSettingsModel programEnrollmentDeletionSettingsModel = programEnrollmentDeletionSettingsServiceInstance.getProgramEnrollmentDeletionSettingsModel();
        Test.stopTest();

        System.assertEquals(
            false,
            programEnrollmentDeletionSettingsModel.programEnrollmentDeletion,
            'Program enrollment deletion should not be enabled.'
        );
        System.assertEquals(
            'Left Behind',
            programEnrollmentDeletionSettingsModel.programEnrollmentDeletionStatus,
            'Program enrollment deletion status should be \'Left Behind\'.'
        );
    }

    /***********************************************************************************************************************************
     ****************************************************** STUBS ***********************************************************************
     ***********************************************************************************************************************************/

    /**************************************************************************************************************************************
     * @description Stub class to simulate the response from ProgramEnrollmentDeletionSettingsMapper to return
     * a valid ProgramEnrollmentDeletionSettingsModel
     **************************************************************************************************************************************/
    private class STUB_ProgramEnrollmentDeletionSettingsMapper extends ProgramEnrollmentDeletionSettingsMapper {
        public override ProgramEnrollmentDeletionSettingsModel getProgramEnrollmentDeletionSettingsModel() {
            return new ProgramEnrollmentDeletionSettingsModel(false, 'Left Behind');
        }
    }
}
public virtual with sharing class ProgramEnrollmentDeletionSettingsVMapper {
    /**********************************************************************************
     * @description Instance for Singleton Pattern
     **********************************************************************************/
    @TestVisible
    private static ProgramEnrollmentDeletionSettingsVMapper instance;

    /**********************************************************************************
     * @description Empty constructor is not public for Singleton Pattern
     **********************************************************************************/
    protected ProgramEnrollmentDeletionSettingsVMapper() {
    }

    /**********************************************************************************
     * @description Static method to get the current instance for Singleton pattern
     * @return The instance of AffiliationsSettingsVMapper.
     **********************************************************************************/
    public static ProgramEnrollmentDeletionSettingsVMapper getInstance() {
        if (instance == null) {
            instance = new ProgramEnrollmentDeletionSettingsVMapper();
        }

        return instance;
    }

    /**********************************************************************************************************
     * @description Retrieve an instance of ProgramEnrollmentDeletionSettingsVModel
     * @return An instance of ProgramEnrollmentDeletionSettingsVModel
     *********************************************************************************************************/
    public virtual ProgramEnrollmentDeletionSettingsVModel getProgramEnrollmentDeletionSettingsVModel() {
        ProgramEnrollmentDeletionSettingsModel programSettingsModel = this.locateProgramEnrollmentDeletionSettingsService()
            .getProgramEnrollmentDeletionSettingsModel();

        List<ComboboxValueVModel> programEnrollmentDeletionStatusOptions = new List<ComboboxValueVModel>();

        Map<String, PicklistEntryModel> affiliationStatusPicklistEntryModelsByName = this.locatePicklistEntryService()
            .getModelsByNameForSObjectField(Affiliation__c.SObjectType, Affiliation__c.Status__c);

        Map<String, PicklistEntryModel> activeAffiliationStatusPicklistEntryModelsByName = this.locatePicklistEntryService()
            .getActivePicklistEntryModelsByName(affiliationStatusPicklistEntryModelsByName);

        for (
            PicklistEntryModel activeAffiliationStatusPicklistEntryModel : activeAffiliationStatusPicklistEntryModelsByName.values()
        ) {
            programEnrollmentDeletionStatusOptions.add(
                new ComboboxValueVModel(
                    activeAffiliationStatusPicklistEntryModel.label,
                    activeAffiliationStatusPicklistEntryModel.name
                )
            );
        }

        ComboboxVModel programEnrollmentDeletionStatusComboboxVModel = new ComboboxVModel(
            programSettingsModel.programEnrollmentDeletionStatus,
            programEnrollmentDeletionStatusOptions
        );

        return new ProgramEnrollmentDeletionSettingsVModel(
            programSettingsModel.programEnrollmentDeletion,
            programEnrollmentDeletionStatusComboboxVModel
        );
    }

    /*****************************************************************************
     * @description Retrieve an instance of the ProgramEnrollmentDeletionSettingsService class.
     * @return An instance of ProgramEnrollmentDeletionSettingsService.
     *****************************************************************************/
    @TestVisible
    private ProgramEnrollmentDeletionSettingsService locateProgramEnrollmentDeletionSettingsService() {
        return ProgramEnrollmentDeletionSettingsService.getInstance();
    }

    /*****************************************************************************
     * @description Retrieve an instance of the PicklistEntryService class.
     * @return An instance of PicklistEntryService.
     *****************************************************************************/
    @TestVisible
    private PicklistEntryService locatePicklistEntryService() {
        return PicklistEntryService.getInstance();
    }
}
@isTest
public with sharing class ProgramPlanSettingsController_TEST {
    /****************************************************************************************
     * @description Test method to verify locateProgramPlanSettingsVMapper() returns an instance of
     * the ProgramPlanSettingsVMapper class.
     ****************************************************************************************/
    @isTest
    private static void locateProgramPlanSettingsVMapperValid() {
        Test.startTest();
        ProgramPlanSettingsVMapper programPlanSettingsVMapperInstance = ProgramPlanSettingsController.locateProgramPlanSettingsVMapper();
        Test.stopTest();

        System.assertEquals(
            ProgramPlanSettingsVMapper.getInstance(),
            programPlanSettingsVMapperInstance,
            'Should return instance of ProgramPlanSettingsVMapper class.'
        );
    }

    /****************************************************************************************
     * @description Test method to verify getProgramPlanSettingsVModel()
     * throws an exception when exception occurs.
     ****************************************************************************************/
    @isTest
    private static void getProgramPlanSettingsVModelValid() {
        ProgramPlanSettingsVMapper.instance = new STUB_ProgramPlanSettingsVMapperValid();

        Test.startTest();
        ProgramPlanSettingsVModel programPlanSettingsVModelInstance = ProgramPlanSettingsController.getProgramPlanSettingsVModel();
        Test.stopTest();

        System.assertEquals(
            true,
            programPlanSettingsVModelInstance.validateProgramPlanForNestedPR,
            'validateProgramPlanForNestedPR should return true'
        );
    }

    /****************************************************************************************
     * @description Test method to verify getProgramPlanSettingsVModel()
     * throws an exception when exception occurs.
     ****************************************************************************************/
    @isTest
    private static void getProgramPlanSettingsVModelException() {
        ProgramPlanSettingsVMapper.instance = new STUB_ExceptionProgramPlanSettingsVMapper();

        try {
            Test.startTest();
            ProgramPlanSettingsVModel programPlanSettingsVModelInstance = ProgramPlanSettingsController.getProgramPlanSettingsVModel();
            Test.stopTest();
            System.assert(false, 'should always throw an exception');
        } catch (AuraHandledException e) {
            System.assertEquals('Script-thrown exception', e.getMessage(), 'Should throw exception.');
        }
    }

    /***********************************************************************************************************************************
     ****************************************************** STUBS ***********************************************************************
     ***********************************************************************************************************************************/

    /**************************************************************************************************************************************
     * @description Stub class to simulate valid responses from ProgramPlanSettingsVMapper
     **************************************************************************************************************************************/
    private class STUB_ProgramPlanSettingsVMapperValid extends ProgramPlanSettingsVMapper {
        public override ProgramPlanSettingsVModel getProgramPlanSettingsVModel() {
            return new ProgramPlanSettingsVModel(true);
        }
    }

    /**************************************************************************************************************************************
     * @description Stub class to simulate exception responses from ProgramPlanSettingsVMapper
     **************************************************************************************************************************************/
    private class STUB_ExceptionProgramPlanSettingsVMapper extends ProgramPlanSettingsVMapper {
        public override ProgramPlanSettingsVModel getProgramPlanSettingsVModel() {
            throw new TestException('Exception encountered!');
        }
    }

    private class TestException extends Exception {
    }
}
@isTest
public with sharing class ProgramPlanSettingsMapper_TEST {
    /**************************************************************************************************************************
     * @description Test method to verify that the getInstance method returns a new instance of the
     * programPlanSettingsMapperInstance class when one does not already exist.
     ***************************************************************************************************************************/
    @isTest
    private static void getInstanceNew() {
        Test.startTest();
        ProgramPlanSettingsMapper programPlanSettingsMapperInstance = ProgramPlanSettingsMapper.getInstance();
        Test.stopTest();

        System.assertEquals(
            ProgramPlanSettingsMapper.instance,
            programPlanSettingsMapperInstance,
            'Instance of mapper class returned should match static instance variable.'
        );
        System.assertEquals(
            true,
            programPlanSettingsMapperInstance != null,
            'Instance of mapper class should not be null.'
        );
    }

    /**************************************************************************************************************************
     * @description Test method to verify that the getInstance method returns the existing instance of the
     * programPlanSettingsMapperInstance class when one already exists.
     ***************************************************************************************************************************/
    @isTest
    private static void getInstanceExisting() {
        Test.startTest();
        ProgramPlanSettingsMapper programPlanSettingsMapperInstance1 = ProgramPlanSettingsMapper.getInstance();
        ProgramPlanSettingsMapper programPlanSettingsMapperInstance2 = ProgramPlanSettingsMapper.getInstance();
        Test.stopTest();

        System.assertEquals(
            ProgramPlanSettingsMapper.instance,
            programPlanSettingsMapperInstance1,
            'Instance of mapper class returned should match static instance variable.'
        );
        System.assertEquals(
            programPlanSettingsMapperInstance1,
            programPlanSettingsMapperInstance1,
            'Subsequent retrievals of mapper class instance should return existing instance.'
        );
        System.assertEquals(
            true,
            programPlanSettingsMapperInstance1 != null,
            'Instance of mapper class should not be null.'
        );
    }

    /**************************************************************************************************************************
     * @description Test method to verify that the getProgramPlanSettingsModel method returns a
     * ProgramPlanSettingsModel matching the program plan settings specified in hierarchy
     * settings.
     ***************************************************************************************************************************/
    @isTest
    private static void getProgramPlanSettingsModelValid() {
        Hierarchy_Settings__c hierarchySettings = UTIL_CustomSettings_API.getSettingsForTests(
            new Hierarchy_Settings__c(Validate_Program_Plan_for_Nested_PR__c = true)
        );

        ProgramPlanSettingsMapper programPlanSettingsMapperInstance = ProgramPlanSettingsMapper.getInstance();

        Test.startTest();
        ProgramPlanSettingsModel programPlanSettingsModelInstance = programPlanSettingsMapperInstance.getProgramPlanSettingsModel();
        Test.stopTest();

        System.assertEquals(
            true,
            programPlanSettingsModelInstance.validateProgramPlanForNestedPR,
            'validateProgramPlanForNestedPR should be enabled.'
        );
    }
}
@isTest
public with sharing class ProgramPlanSettingsService_TEST {
    /**************************************************************************************************************************
     * @description Test method to verify that the getInstance method returns a new instance of the
     * ProgramPlanSettingsService class when one does not already exist.
     ***************************************************************************************************************************/
    @isTest
    private static void getInstanceNew() {
        Test.startTest();
        ProgramPlanSettingsService programPlanSettingsServiceInstance = ProgramPlanSettingsService.getInstance();
        Test.stopTest();

        System.assertEquals(
            ProgramPlanSettingsService.instance,
            programPlanSettingsServiceInstance,
            'Instance of service class returned should match static instance variable.'
        );
        System.assertEquals(
            true,
            programPlanSettingsServiceInstance != null,
            'Instance of service class should not be null.'
        );
    }

    /**************************************************************************************************************************
     * @description Test method to verify that the getInstance method returns the existing instance of the
     * ProgramPlanSettingsService class when one already exists.
     ***************************************************************************************************************************/
    @isTest
    private static void getInstanceExisting() {
        Test.startTest();
        ProgramPlanSettingsService ppSettingsMapper1 = ProgramPlanSettingsService.getInstance();
        ProgramPlanSettingsService ppSettingsMapper2 = ProgramPlanSettingsService.getInstance();
        Test.stopTest();

        System.assertEquals(
            ProgramPlanSettingsService.instance,
            ppSettingsMapper1,
            'Instance of service class returned should match static instance variable.'
        );
        System.assertEquals(
            ppSettingsMapper1,
            ppSettingsMapper2,
            'Subsequent retrievals of service class instance should return existing instance.'
        );
        System.assertEquals(true, ppSettingsMapper1 != null, 'Instance of service class should not be null.');
    }

    /**************************************************************************************************************************
     * @description Test method to verify that the locateProgramPlanSettingsMapper method returns an instance
     * of the ProgramPlanSettingsMapper class.
     ***************************************************************************************************************************/
    @isTest
    private static void locateProgramPlanSettingsMapperValid() {
        ProgramPlanSettingsService programPlanSettingsServiceInstance = ProgramPlanSettingsService.getInstance();

        Test.startTest();
        ProgramPlanSettingsMapper programPlanSettingsMapperInstance = programPlanSettingsServiceInstance.locateProgramPlanSettingsMapper();
        Test.stopTest();

        System.assertEquals(
            ProgramPlanSettingsMapper.getInstance(),
            programPlanSettingsMapperInstance,
            'Should return instance of ProgramPlanSettingsMapper class.'
        );
    }

    /**************************************************************************************************************************
     * @description Test method to verify that the getProgramPlanSettingsModel method returns a ProgramPlanSettingsModel
     ***************************************************************************************************************************/
    @isTest
    private static void getProgramEnrollmentDeletionSettingsModelValid() {
        ProgramPlanSettingsMapper.instance = new STUB_ProgramPlanSettingsMapper();

        ProgramPlanSettingsService programPlanSettingsServiceInstance = ProgramPlanSettingsService.getInstance();

        Test.startTest();
        ProgramPlanSettingsModel ppSettingsModel = programPlanSettingsServiceInstance.getProgramPlanSettingsModel();
        Test.stopTest();

        System.assertEquals(
            false,
            ppSettingsModel.validateProgramPlanForNestedPR,
            'validateProgramPlanForNestedPR should not be enabled.'
        );
    }

    /***********************************************************************************************************************************
     ****************************************************** STUBS ***********************************************************************
     ***********************************************************************************************************************************/

    /**************************************************************************************************************************************
     * @description Stub class to simulate the response from ProgramPlanSettingsMapper to return
     * a valid ProgramPlanSettingsModel
     **************************************************************************************************************************************/
    private class STUB_ProgramPlanSettingsMapper extends ProgramPlanSettingsMapper {
        public override ProgramPlanSettingsModel getProgramPlanSettingsModel() {
            return new ProgramPlanSettingsModel(false);
        }
    }
}
@isTest
public with sharing class ProgramPlanSettingsVMapper_TEST {
    /**************************************************************************************************
     * @description Test method to verify that the getInstance method returns a new instance of the
     * ProgramPlanSettingsVMapper class when one does not already exist.
     **************************************************************************************************/
    @isTest
    private static void getInstanceNew() {
        Test.startTest();
        ProgramPlanSettingsVMapper programPlanSettingsVMapperInstance = ProgramPlanSettingsVMapper.getInstance();
        Test.stopTest();

        System.assertEquals(
            ProgramPlanSettingsVMapper.instance,
            programPlanSettingsVMapperInstance,
            'Instance of mapper class returned should match static instance variable.'
        );
        System.assertEquals(
            true,
            ProgramPlanSettingsVMapperInstance != null,
            'Instance of mapper class should not be null.'
        );
    }

    /**************************************************************************************************
     * @description Test method to verify that the getInstance method returns the existing instance of the
     * ProgramPlanSettingsVMapper class when one already exists.
     **************************************************************************************************/
    @isTest
    private static void getInstanceExisting() {
        Test.startTest();
        ProgramPlanSettingsVMapper programPlanSettingsVMapperInstance1 = ProgramPlanSettingsVMapper.getInstance();
        ProgramPlanSettingsVMapper programPlanSettingsVMapperInstance2 = ProgramPlanSettingsVMapper.getInstance();
        Test.stopTest();

        System.assertEquals(
            ProgramPlanSettingsVMapper.instance,
            programPlanSettingsVMapperInstance1,
            'Instance of mapper class returned should match static instance variable.'
        );
        System.assertEquals(
            programPlanSettingsVMapperInstance1,
            programPlanSettingsVMapperInstance2,
            'Subsequent retrievals of mapper class instance should return existing instance.'
        );
        System.assertEquals(
            true,
            ProgramPlanSettingsVMapperInstance1 != null,
            'Instance of mapper class should not be null.'
        );
    }

    /****************************************************************************************
     * @description Test method to verify locateProgramPlanSettingsService() returns an instance of
     * the ProgramPlanSettingsService class.
     ****************************************************************************************/
    @isTest
    private static void locateProgramPlanSettingsServiceValid() {
        ProgramPlanSettingsVMapper ProgramPlanSettingsVMapperInstance = ProgramPlanSettingsVMapper.getInstance();

        Test.startTest();
        ProgramPlanSettingsService programSettingsSettingsServiceInstance = ProgramPlanSettingsVMapperInstance.locateProgramPlanSettingsService();
        Test.stopTest();

        System.assertEquals(
            ProgramPlanSettingsService.getInstance(),
            programSettingsSettingsServiceInstance,
            'Should return instance of ProgramPlanSettingsService class.'
        );
    }

    /************************************************************************************************************************************
     * @description Test method to verify getProgramPlanSettingsVModel returns a ProgramPlanSettingsVModel
     * corresponding to the Program Plan settings specified in Hierarchy Settings
     ************************************************************************************************************************************/
    @isTest
    private static void getProgramPlanSettingsVModelValid() {
        ProgramPlanSettingsService.instance = new STUB_ProgramPlanSettingsService();

        ProgramPlanSettingsVMapper programPlanSettingsVMapperInstance = ProgramPlanSettingsVMapper.getInstance();

        Test.startTest();
        ProgramPlanSettingsVModel programPlanSettingsVModelInstance = programPlanSettingsVMapperInstance.getProgramPlanSettingsVModel();
        Test.stopTest();

        System.assertEquals(
            false,
            programPlanSettingsVModelInstance.validateProgramPlanForNestedPR,
            'validateProgramPlanForNestedPR should not be enabled.'
        );
    }

    /***********************************************************************************************************************************
     ****************************************************** STUBS ***********************************************************************
     ***********************************************************************************************************************************/

    /**************************************************************************************************************************************
     * @description Stub class to simulate the response from ProgramPlanSettingsService to return a valid respose
     **************************************************************************************************************************************/
    private class STUB_ProgramPlanSettingsService extends ProgramPlanSettingsService {
        public override ProgramPlanSettingsModel getProgramPlanSettingsModel() {
            return new ProgramPlanSettingsModel(false);
        }
    }
}
public with sharing class ProgramSettingsController {
    /************************************************************************************
     * @description Retrieve an instance of AutoEnrollmentMappingsVModel representing the current values
     * specified for Settings fields in Hierarchy Settings.
     * @return An instance of AutoEnrollmentMappingsVModel
     ************************************************************************************/
    @AuraEnabled(cacheable=true)
    public static AutoEnrollmentMappingsVModel getAutoEnrollmentMappingsVModel() {
        try {
            return ProgramSettingsController.locateAutoEnrollmentMappingsVMapper().getAutoEnrollmentMappingsVModel();
        } catch (Exception e) {
            throw new AuraHandledException(e.getMessage());
        }
    }

    /**********************************************************************************************************
     * @description Retrieve an integer representing the number of unmapped record types
     * @return The number of unmapped record types.
     *********************************************************************************************************/
    @AuraEnabled
    public static Boolean unmappedRecordTypesExist() {
        try {
            return ProgramSettingsController.locateAutoEnrollmentMappingsVMapper().unmappedRecordTypesExist();
        } catch (Exception e) {
            throw new AuraHandledException(e.getMessage());
        }
    }

    /************************************************************************************
     * @description Retrieve a ComoboxVModel representing the list of active Account
     * Record Types
     * @return A ComboboxVModel
     ************************************************************************************/
    @AuraEnabled
    public static ComboBoxVModel getAccountRecordTypeComboboxVModel(String accountRecordType) {
        try {
            return ProgramSettingsController.locateAutoEnrollmentMappingsVMapper()
                .getAccountRecordTypeComboboxVModel(accountRecordType);
        } catch (Exception e) {
            throw new AuraHandledException(e.getMessage());
        }
    }

    /************************************************************************************
     * @description Retrieve a ComoboxVModel for auto enrollment status.
     * @return A ComboboxVModel
     ************************************************************************************/
    @AuraEnabled(cacheable=true)
    public static ComboBoxVModel getAutoEnrollmentMappingStatusComboboxVModel(String autoProgramEnrollmentStatus) {
        try {
            return ProgramSettingsController.locateAutoEnrollmentMappingsVMapper()
                .getAutoEnrollmentMappingStatusComboboxVModel(autoProgramEnrollmentStatus);
        } catch (Exception e) {
            throw new AuraHandledException(e.getMessage());
        }
    }

    /************************************************************************************
     * @description Retrieve a ComoboxVModel for auto enrollment role.
     * @return A ComboboxVModel
     ************************************************************************************/
    @AuraEnabled(cacheable=true)
    public static ComboBoxVModel getAutoEnrollmentMappingRoleComboboxVModel(String autoProgramEnrollmentRole) {
        try {
            return ProgramSettingsController.locateAutoEnrollmentMappingsVMapper()
                .getAutoEnrollmentMappingRoleComboboxVModel(autoProgramEnrollmentRole);
        } catch (Exception e) {
            throw new AuraHandledException(e.getMessage());
        }
    }

    /***
     * @description Update the affiliation mappping with new auto enrollment mapping.
     * @param accountRecordType The account record type for the auto enrollment mapping
     * @param status The status for the auto enrollment mapping
     * @param role The role for the auto enrollment mapping
     * @return The account record type of the mapping updated.
     */
    @AuraEnabled
    public static String createAutoEnrollmentMapping(String accountRecordType, String status, String role) {
        try {
            return ProgramSettingsController.locateAutoEnrollmentMappingService()
                .createAutoEnrollmentMapping(accountRecordType, status, role)
                .accountRecordTypeFieldValue;
        } catch (Exception e) {
            throw new AuraHandledException(e.getMessage());
        }
    }

    /**
     * @description Updates auto enrollment mappings
     * @param mappingName The name of the original auto enrollment mapping
     * @param accountRecordType The account record type for the original auto enrollment mapping
     * @param newAccountRecordType The account record type for the updated auto enrollment mapping
     * @param status The status for the auto enrollment mapping
     * @param role The role for the auto enrollment mapping
     * @return The account record type of the mapping updated.
     */
    @AuraEnabled
    public static String updateAutoEnrollmentMappings(
        String mappingName,
        String accountRecordType,
        String newAccountRecordType,
        String status,
        String role
    ) {
        try {
            return ProgramSettingsController.locateAutoEnrollmentMappingService()
                .updateAutoEnrollmentMappings(mappingName, accountRecordType, newAccountRecordType, status, role)
                .accountRecordTypeFieldValue;
        } catch (Exception e) {
            throw new AuraHandledException(e.getMessage());
        }
    }

    /**
     * @description Deletes auto enrollment mapping
     * @param mappingName The name of the original auto enrollment mapping
     * @return The account record type of the mapping deleted or null if no mapping found.
     */
    @AuraEnabled
    public static String deleteAutoEnrollmentMappings(String mappingName) {
        try {
            AutoEnrollmentMappingModel deletedMappingModel = ProgramSettingsController.locateAutoEnrollmentMappingService()
                .deleteAutoEnrollmentMappings(mappingName);
            return deletedMappingModel == null ? null : deletedMappingModel.accountRecordTypeFieldValue;
        } catch (Exception e) {
            throw new AuraHandledException(e.getMessage());
        }
    }

    /********************************************************************************
     * @description Retrieve a view model representing the Program Enrollment Deletion
     * settings specified in Hierarchy Settings.
     * @return A ProgramEnrollmentDeletionSettingsVModel.
     ********************************************************************************/
    @AuraEnabled(cacheable=true)
    public static ProgramEnrollmentDeletionSettingsVModel getProgramEnrollmentDeletionSettingsVModel() {
        try {
            return ProgramSettingsController.locateProgramEnrollmentDeletionSettingsVMapper()
                .getProgramEnrollmentDeletionSettingsVModel();
        } catch (Exception e) {
            throw new AuraHandledException(e.getMessage());
        }
    }

    /**********************************************************************************
     * @description Locates and returns an instance of ProgramSettingsVMapper.
     * @return An instance of ProgramSettingsVMapper
     **********************************************************************************/
    @TestVisible
    private static AutoEnrollmentMappingsVMapper locateAutoEnrollmentMappingsVMapper() {
        return AutoEnrollmentMappingsVMapper.getInstance();
    }

    /*****************************************************************************
     * @description Retrieve an instance of the AutoEnrollmentMappingService class.
     * @return An instance of AutoEnrollmentMappingService.
     *****************************************************************************/
    @TestVisible
    private static AutoEnrollmentMappingService locateAutoEnrollmentMappingService() {
        return AutoEnrollmentMappingService.getInstance();
    }

    /**********************************************************************************
     * @description Locates and returns an instance of ProgramEnrollmentDeletionSettingsVMapper.
     * @return An instance of ProgramEnrollmentDeletionSettingsVMapper
     **********************************************************************************/
    @TestVisible
    private static ProgramEnrollmentDeletionSettingsVMapper locateProgramEnrollmentDeletionSettingsVMapper() {
        return ProgramEnrollmentDeletionSettingsVMapper.getInstance();
    }
}
@isTest
private with sharing class ProgramSettingsController_TEST {
    private static Integer loopCounter = 5;

    /****************************************************************************************
     * @description Test method to verify locateAutoEnrollmentMappingsVMapper() returns an instance of
     * the AutoEnrollmentMappingsVMapper class.
     ****************************************************************************************/
    @isTest
    private static void locateAutoEnrollmentMappingsVMapperValid() {
        Test.startTest();
        AutoEnrollmentMappingsVMapper autoEnrollmentMappingsVMapperInstance = ProgramSettingsController.locateAutoEnrollmentMappingsVMapper();
        Test.stopTest();

        System.assertEquals(
            AutoEnrollmentMappingsVMapper.getInstance(),
            autoEnrollmentMappingsVMapperInstance,
            'Should return instance of AutoEnrollmentMappingsVMapper class.'
        );
    }

    /****************************************************************************************
     * @description Test method to verify AutoEnrollmentMappingService() returns an instance of
     * the AutoEnrollmentMappingService class.
     ****************************************************************************************/
    @isTest
    private static void locateAutoEnrollmentMappingService() {
        Test.startTest();
        AutoEnrollmentMappingService autoEnrollmentMappingServiceInstance = ProgramSettingsController.locateAutoEnrollmentMappingService();
        Test.stopTest();

        System.assertEquals(
            AutoEnrollmentMappingService.getInstance(),
            autoEnrollmentMappingServiceInstance,
            'Should return instance of AutoEnrollmentMappingService class.'
        );
    }

    /****************************************************************************************
     * @description Test method to verify getAutoEnrollmentMappingsVModel()
     * returns an instance of AutoEnrollmentMappingsVModel with valid values from valid stub.
     ****************************************************************************************/
    @isTest
    private static void getAutoEnrollmentMappingsVModelValid() {
        AutoEnrollmentMappingsVMapper.instance = new STUB_AutoEnrollmentMappingsVMapperValid();

        Test.startTest();
        AutoEnrollmentMappingsVModel autoEnrollmentMappingsVModel = ProgramSettingsController.getAutoEnrollmentMappingsVModel();
        Test.stopTest();

        System.assertEquals(
            2,
            autoEnrollmentMappingsVModel.autoEnrollmentMappingVModels.size(),
            'Should return 2 autoEnrollmentMappingVModels.'
        );

        for (Integer i = 0; i < autoEnrollmentMappingsVModel.autoEnrollmentMappingVModels.size(); i++) {
            System.assertEquals(
                'Record_Type_' + (i + 1),
                autoEnrollmentMappingsVModel.autoEnrollmentMappingVModels[i].accountRecordTypeName,
                'Account record type name should match developer name of corresponding record type model.'
            );

            System.assertEquals(
                'Record Type ' + (i + 1),
                autoEnrollmentMappingsVModel.autoEnrollmentMappingVModels[i].accountRecordTypeLabel,
                'Account record type label should match label of corresponding record type model.'
            );

            System.assertEquals(
                'autoProgramEnrollmentStatus' + (i + 1),
                autoEnrollmentMappingsVModel.autoEnrollmentMappingVModels[i].autoProgramEnrollmentStatus,
                'Auto-Enrollment status should match.'
            );

            System.assertEquals(
                'autoProgramEnrollmentRole' + (i + 1),
                autoEnrollmentMappingsVModel.autoEnrollmentMappingVModels[i].autoProgramEnrollmentRole,
                'Auto-Enrollment role should match.'
            );
        }
    }

    /****************************************************************************************
     * @description Test method to verify getAutoEnrollmentMappingsVModel()
     * throws an exception when exception occurs.
     ****************************************************************************************/
    @isTest
    private static void getAutoEnrollmentMappingsVModelException() {
        AutoEnrollmentMappingsVMapper.instance = new STUB_ExceptionAutoEnrollmentMappingsVMapper();

        try {
            Test.startTest();
            AutoEnrollmentMappingsVModel autoEnrollmentMappingsVModel = ProgramSettingsController.getAutoEnrollmentMappingsVModel();
            Test.stopTest();
            System.assert(false, 'should always throw an exception');
        } catch (AuraHandledException e) {
            System.assertEquals('Script-thrown exception', e.getMessage(), 'Should throw exception.');
        }
    }

    /****************************************************************************************
     * @description Test method to verify getAccountRecordTypeComboboxVModelValid()
     * returns an instance of ComboBoxVModel with valid values from valid stub.
     ****************************************************************************************/
    @isTest
    private static void getAccountRecordTypeComboboxVModelValid() {
        AutoEnrollmentMappingsVMapper.instance = new STUB_AutoEnrollmentMappingsVMapperValid();

        Test.startTest();
        ComboBoxVModel accountRecordTypeComboboxVModel = ProgramSettingsController.getAccountRecordTypeComboboxVModel(
            'Record_Type_1'
        );
        Test.stopTest();

        System.assertEquals(
            'Record_Type_1',
            accountRecordTypeComboboxVModel.value,
            'The value of accountRecordTypeComboboxVModel should be Record_Type_1'
        );

        System.assertEquals(
            1,
            accountRecordTypeComboboxVModel.options.size(),
            'The size of accountRecordTypeComboboxVModel options should be 1'
        );

        System.assertEquals(
            'Record_Type_1',
            accountRecordTypeComboboxVModel.options[0].value,
            'The value of accountRecordTypeComboboxVModel option 1 should be Record_Type_1'
        );

        System.assertEquals(
            'Record Type 1',
            accountRecordTypeComboboxVModel.options[0].label,
            'The label of accountRecordTypeComboboxVModel option 1 should be Record Type 1'
        );
    }

    /****************************************************************************************
     * @description Test method to verify getAccountRecordTypeComboboxVModel()
     * throws an exception when exception occurs.
     ****************************************************************************************/
    @isTest
    private static void getAccountRecordTypeComboboxVModelException() {
        AutoEnrollmentMappingsVMapper.instance = new STUB_ExceptionAutoEnrollmentMappingsVMapper();
        try {
            Test.startTest();
            ComboBoxVModel accountRecordTypeComboboxVModel = ProgramSettingsController.getAccountRecordTypeComboboxVModel(
                'Record_Type_1'
            );
            Test.stopTest();
            System.assert(false, 'should always throw an exception');
        } catch (AuraHandledException e) {
            System.assertEquals('Script-thrown exception', e.getMessage(), 'Should throw exception.');
        }
    }

    /****************************************************************************************
     * @description Test method to verify getAutoEnrollmentMappingStatusComboboxVModel()
     * returns an instance of ComboBoxVModel with valid values from valid stub.
     ****************************************************************************************/
    @isTest
    private static void getAutoEnrollmentMappingStatusComboboxVModelValid() {
        AutoEnrollmentMappingsVMapper.instance = new STUB_AutoEnrollmentMappingsVMapperValid();

        Test.startTest();
        ComboBoxVModel autoEnrollmentMappingStatusComboboxVModel = ProgramSettingsController.getAutoEnrollmentMappingStatusComboboxVModel(
            'Test_Status'
        );
        Test.stopTest();

        System.assertEquals(
            'Test_Status',
            autoEnrollmentMappingStatusComboboxVModel.value,
            'The value of autoEnrollmentMappingStatusComboboxVModel should be Test_Status'
        );

        System.assertEquals(
            1,
            autoEnrollmentMappingStatusComboboxVModel.options.size(),
            'The size of autoEnrollmentMappingStatusComboboxVModel options should be 1'
        );

        System.assertEquals(
            'Test_Status',
            autoEnrollmentMappingStatusComboboxVModel.options[0].value,
            'The value of autoEnrollmentMappingStatusComboboxVModel option 1 should be Test_Status'
        );

        System.assertEquals(
            'Test Status',
            autoEnrollmentMappingStatusComboboxVModel.options[0].label,
            'The label of autoEnrollmentMappingStatusComboboxVModel option 1 should be Test Status'
        );
    }

    /****************************************************************************************
     * @description Test method to verify getAutoEnrollmentMappingStatusComboboxVModel()
     * throws an exception when exception occurs.
     ****************************************************************************************/
    @isTest
    private static void getAutoEnrollmentMappingStatusComboboxVModelException() {
        AutoEnrollmentMappingsVMapper.instance = new STUB_ExceptionAutoEnrollmentMappingsVMapper();
        try {
            Test.startTest();
            ComboBoxVModel autoEnrollmentMappingStatusComboboxVModel = ProgramSettingsController.getAutoEnrollmentMappingStatusComboboxVModel(
                'Test_Status'
            );
            Test.stopTest();
            System.assert(false, 'should always throw an exception');
        } catch (AuraHandledException e) {
            System.assertEquals('Script-thrown exception', e.getMessage(), 'Should throw exception.');
        }
    }

    /****************************************************************************************
     * @description Test method to verify getAutoEnrollmentMappingRoleComboboxVModel()
     * returns an instance of ComboBoxVModel with valid values from valid stub.
     ****************************************************************************************/
    @isTest
    private static void getAutoEnrollmentMappingRoleComboboxVModelValid() {
        AutoEnrollmentMappingsVMapper.instance = new STUB_AutoEnrollmentMappingsVMapperValid();

        Test.startTest();
        ComboBoxVModel autoEnrollmentMappingRoleComboboxVModel = ProgramSettingsController.getAutoEnrollmentMappingRoleComboboxVModel(
            'Test_Role'
        );
        Test.stopTest();

        System.assertEquals(
            'Test_Role',
            autoEnrollmentMappingRoleComboboxVModel.value,
            'The value of autoEnrollmentMappingRoleComboboxVModel should be Test_Role'
        );

        System.assertEquals(
            1,
            autoEnrollmentMappingRoleComboboxVModel.options.size(),
            'The size of autoEnrollmentMappingRoleComboboxVModel options should be 1'
        );

        System.assertEquals(
            'Test_Role',
            autoEnrollmentMappingRoleComboboxVModel.options[0].value,
            'The value of autoEnrollmentMappingRoleComboboxVModel option 1 should be Test_Role'
        );

        System.assertEquals(
            'Test Role',
            autoEnrollmentMappingRoleComboboxVModel.options[0].label,
            'The label of autoEnrollmentMappingRoleComboboxVModel option 1 should be Test Role'
        );
    }

    /****************************************************************************************
     * @description Test method to verify getAutoEnrollmentMappingRoleComboboxVModel()
     * throws an exception when exception occurs.
     ****************************************************************************************/
    @isTest
    private static void getAutoEnrollmentMappingRoleComboboxVModelException() {
        AutoEnrollmentMappingsVMapper.instance = new STUB_ExceptionAutoEnrollmentMappingsVMapper();
        try {
            Test.startTest();
            ComboBoxVModel autoEnrollmentMappingRoleComboboxVModel = ProgramSettingsController.getAutoEnrollmentMappingRoleComboboxVModel(
                'Test_Role'
            );
            Test.stopTest();
            System.assert(false, 'should always throw an exception');
        } catch (AuraHandledException e) {
            System.assertEquals('Script-thrown exception', e.getMessage(), 'Should throw exception.');
        }
    }

    /****************************************************************************************
     * @description Test method to verify getProgramEnrollmentDeletionSettingsVModel()
     * returns an instance of ProgramEnrollmentDeletionSettingsVModel with valid values from valid stub.
     ****************************************************************************************/
    @isTest
    private static void getProgramEnrollmentDeletionSettingsVModelValid() {
        ProgramEnrollmentDeletionSettingsVMapper.instance = new STUB_ProgramEnrollmentDeletionSettingsVMapperValid();

        Test.startTest();
        ProgramEnrollmentDeletionSettingsVModel programEnrollmentDeletionSettingsVModel = ProgramSettingsController.getProgramEnrollmentDeletionSettingsVModel();
        Test.stopTest();

        System.assertEquals(
            false,
            programEnrollmentDeletionSettingsVModel.programEnrollmentDeletion,
            'Program Enrollment Deletion should not be enabled.'
        );
        System.assertEquals(
            'Selected Status',
            programEnrollmentDeletionSettingsVModel.programEnrollmentDeletionStatus.value,
            'Selected Program Enrollment Deletion status should be \'Selected Status\'.'
        );
        System.assertEquals(
            loopCounter + 1,
            programEnrollmentDeletionSettingsVModel.programEnrollmentDeletionStatus.options.size(),
            'Should have ' +
            (loopCounter + 1) +
            ' status options.'
        );
    }

    /****************************************************************************************
     * @description Test method to verify getProgramEnrollmentDeletionSettingsVModel()
     * throws an exception when exception occurs.
     ****************************************************************************************/
    @isTest
    private static void getProgramEnrollmentDeletionSettingsVModelException() {
        ProgramEnrollmentDeletionSettingsVMapper.instance = new STUB_ExceptionProgramEnrollmentDeletionSettingsVMapper();

        try {
            Test.startTest();
            ProgramEnrollmentDeletionSettingsVModel programEnrollmentDeletionSettingsVModel = ProgramSettingsController.getProgramEnrollmentDeletionSettingsVModel();
            Test.stopTest();
            System.assert(false, 'should always throw an exception');
        } catch (AuraHandledException e) {
            System.assertEquals('Script-thrown exception', e.getMessage(), 'Should throw exception.');
        }
    }

    /****************************************************************************************
     * @description Test method to verify createAutoEnrollmentMapping() updates auto
     * enrollment on affiliation mappings
     ****************************************************************************************/
    @isTest
    private static void createAutoEnrollmentMapping() {
        AutoEnrollmentMappingService.instance = new STUB_AutoEnrollmentMappingService();
        Test.startTest();
        String accountRecordTypeDeveloperName = ProgramSettingsController.createAutoEnrollmentMapping(
            'Record_Type_1',
            'Test_Status_1',
            'Test_Role_1'
        );
        Test.stopTest();

        System.assertEquals(
            accountRecordTypeDeveloperName,
            'Record_Type_1',
            'The affected mapping should be that of the same account record type'
        );
    }

    /****************************************************************************************
     * @description Test method to verify createAutoEnrollmentMapping()
     * when exception occurs
     ****************************************************************************************/
    @isTest
    private static void createAutoEnrollmentMappingException() {
        AutoEnrollmentMappingService.instance = new STUB_ExceptionAutoEnrollmentMappingService();

        try {
            Test.startTest();
            String accountRecordTypeDeveloperName = ProgramSettingsController.createAutoEnrollmentMapping(
                'Record_Type_1',
                'Test_Status_1',
                'Test_Role_1'
            );
            Test.stopTest();
            System.assert(false, 'should always throw an exception');
        } catch (AuraHandledException e) {
            System.assertEquals('Script-thrown exception', e.getMessage(), 'Should throw exception.');
        }
    }

    /****************************************************************************************
     * @description Test method to verify deleteAutoEnrollmentMapping() deletes auto
     * enrollment on affiliation mappings
     ****************************************************************************************/
    @isTest
    private static void deleteAutoEnrollmentMapping() {
        AutoEnrollmentMappingService.instance = new STUB_AutoEnrollmentMappingService();
        Test.startTest();
        String accountRecordTypeDeveloperName = ProgramSettingsController.deleteAutoEnrollmentMappings(
            'Mapping_Name_1'
        );
        Test.stopTest();

        System.assertEquals(
            accountRecordTypeDeveloperName,
            'Record_Type_1',
            'The affected mapping should be that of the same account record type'
        );
    }

    /****************************************************************************************
     * @description Test method to verify deleteAutoEnrollmentMapping()
     * when exception occurs
     ****************************************************************************************/
    @isTest
    private static void deleteAutoEnrollmentMappingException() {
        AutoEnrollmentMappingService.instance = new STUB_ExceptionAutoEnrollmentMappingService();

        try {
            Test.startTest();
            String accountRecordTypeDeveloperName = ProgramSettingsController.deleteAutoEnrollmentMappings(
                'Mapping_Name_1'
            );
            Test.stopTest();
            System.assert(false, 'should always throw an exception');
        } catch (AuraHandledException e) {
            System.assertEquals('Script-thrown exception', e.getMessage(), 'Should throw exception.');
        }
    }

    /****************************************************************************************
     * @description Test method to verify unmappedRecordTypesExist()
     ****************************************************************************************/
    @isTest
    private static void unmappedRecordTypesExist() {
        AutoEnrollmentMappingsVMapper.instance = new STUB_AutoEnrollmentMappingsVMapperValid();

        Test.startTest();
        Boolean unmappedRecordTypesExistValue = ProgramSettingsController.unmappedRecordTypesExist();
        Test.stopTest();

        System.assertEquals(true, unmappedRecordTypesExistValue, 'Unmapped Record Types');
    }

    /****************************************************************************************
     * @description Test method to verify updateAutoEnrollmentMappings() updates auto
     * enrollment on affiliation mappings when account record type passed are the same
     ****************************************************************************************/
    @isTest
    private static void updateAutoEnrollmentMappingsSameAccountRecordType() {
        AutoEnrollmentMappingService.instance = new STUB_AutoEnrollmentMappingService();
        Test.startTest();
        String accountRecordTypeDeveloperName = ProgramSettingsController.updateAutoEnrollmentMappings(
            'Test Affl Mapping 1',
            'Record_Type_1',
            'Record_Type_1',
            'Test_Status_3',
            'Test_Role_3'
        );
        Test.stopTest();

        System.assertEquals(
            accountRecordTypeDeveloperName,
            'Record_Type_1',
            'The affected mapping should be that of the same account record type'
        );
    }

    /****************************************************************************************
     * @description Test method to verify updateAutoEnrollmentMappings() updates
     * auto enrollment on affiliation mappings when account record type passed are different
     ****************************************************************************************/
    @isTest
    private static void updateAutoEnrollmentMappingsDifferentAccountRecordType() {
        AutoEnrollmentMappingService.instance = new STUB_AutoEnrollmentMappingService();
        Test.startTest();
        String accountRecordTypeDeveloperName = ProgramSettingsController.updateAutoEnrollmentMappings(
            'Test Affl Mapping 1',
            'Record_Type_1',
            'Record_Type_2',
            'Test_Status_3',
            'Test_Role_3'
        );
        Test.stopTest();

        System.assertEquals(
            accountRecordTypeDeveloperName,
            'Record_Type_2',
            'The affected mapping should be that of the new account record type'
        );
    }

    /****************************************************************************************
     * @description Test method to verify updateAutoEnrollmentMappings()
     * when exception occurs
     ****************************************************************************************/
    @isTest
    private static void updateAutoEnrollmentMappingsException() {
        AutoEnrollmentMappingService.instance = new STUB_ExceptionAutoEnrollmentMappingService();

        try {
            Test.startTest();
            String mappingName = ProgramSettingsController.updateAutoEnrollmentMappings(
                'Test Affl Mapping 1',
                'Record_Type_1',
                'Record_Type_2',
                'Test_Status_3',
                'Test_Role_3'
            );
            Test.stopTest();
            System.assert(false, 'should always throw an exception');
        } catch (AuraHandledException e) {
            System.assertEquals('Script-thrown exception', e.getMessage(), 'Should throw exception.');
        }
    }

    /***********************************************************************************************************************************
     ****************************************************** STUBS ***********************************************************************
     ***********************************************************************************************************************************/

    /**************************************************************************************************************************************
     * @description Stub class to simulate valid responses from AutoEnrollmentMappingsVMapper
     **************************************************************************************************************************************/
    private class STUB_AutoEnrollmentMappingsVMapperValid extends AutoEnrollmentMappingsVMapper {
        public override Boolean unmappedRecordTypesExist() {
            return true;
        }

        public override AutoEnrollmentMappingsVModel getAutoEnrollmentMappingsVModel() {
            List<AutoEnrollmentMappingVModel> autoEnrollmentMappingVModelsList = new List<AutoEnrollmentMappingVModel>();
            autoEnrollmentMappingVModelsList.add(
                new AutoEnrollmentMappingVModel(
                    'Mapping 1',
                    'Record_Type_1',
                    'Record Type 1',
                    'autoProgramEnrollmentStatus1',
                    'autoProgramEnrollmentRole1'
                )
            );
            autoEnrollmentMappingVModelsList.add(
                new AutoEnrollmentMappingVModel(
                    'Mapping 2',
                    'Record_Type_2',
                    'Record Type 2',
                    'autoProgramEnrollmentStatus2',
                    'autoProgramEnrollmentRole2'
                )
            );
            return new AutoEnrollmentMappingsVModel(autoEnrollmentMappingVModelsList);
        }

        public override ComboBoxVModel getAccountRecordTypeComboboxVModel(String accountRecordType) {
            List<ComboboxValueVModel> comboboxOptions = new List<ComboboxValueVModel>();
            comboboxOptions.add(new ComboboxValueVModel('Record Type 1', 'Record_Type_1'));
            return new ComboBoxVModel('Record_Type_1', comboboxOptions);
        }

        public override ComboBoxVModel getAutoEnrollmentMappingStatusComboboxVModel(
            String autoProgramEnrollmentStatus
        ) {
            List<ComboboxValueVModel> comboboxOptions = new List<ComboboxValueVModel>();
            comboboxOptions.add(new ComboboxValueVModel('Test Status', 'Test_Status'));
            return new ComboBoxVModel('Test_Status', comboboxOptions);
        }

        public override ComboBoxVModel getAutoEnrollmentMappingRoleComboboxVModel(String autoProgramEnrollmentRole) {
            List<ComboboxValueVModel> comboboxOptions = new List<ComboboxValueVModel>();
            comboboxOptions.add(new ComboboxValueVModel('Test Role', 'Test_Role'));
            return new ComboBoxVModel('Test_Role', comboboxOptions);
        }
    }

    /**************************************************************************************************************************************
     * @description Stub class to simulate valid responses from ProgramEnrollmentDeletionSettingsVMapper
     **************************************************************************************************************************************/
    private class STUB_ProgramEnrollmentDeletionSettingsVMapperValid extends ProgramEnrollmentDeletionSettingsVMapper {
        public override ProgramEnrollmentDeletionSettingsVModel getProgramEnrollmentDeletionSettingsVModel() {
            List<ComboboxValueVModel> programEnrollmentDeletionStatusOptions = new List<ComboboxValueVModel>();

            programEnrollmentDeletionStatusOptions.add(new ComboboxValueVModel('Selected Status', 'Selected_Status'));

            for (Integer i = 0; i < loopCounter; i++) {
                programEnrollmentDeletionStatusOptions.add(new ComboboxValueVModel('Status ' + i, 'Status_' + i));
            }

            ComboboxVModel programEnrollmentDeletionStatusComboboxVModel = new ComboboxVModel(
                'Selected Status',
                programEnrollmentDeletionStatusOptions
            );
            return new ProgramEnrollmentDeletionSettingsVModel(false, programEnrollmentDeletionStatusComboboxVModel);
        }
    }

    /**************************************************************************************************************************************
     * @description Stub class to simulate valid responses from AutoEnrollmentMappingService
     **************************************************************************************************************************************/
    private class STUB_AutoEnrollmentMappingService extends AutoEnrollmentMappingService {
        public override AutoEnrollmentMappingModel createAutoEnrollmentMapping(
            String accountRecordType,
            String status,
            String role
        ) {
            return new AutoEnrollmentMappingModel(accountRecordType, accountRecordType, status, role, true);
        }

        public override AutoEnrollmentMappingModel updateAutoEnrollmentMappings(
            String mappingName,
            String accountRecordType,
            String newAccountRecordType,
            String status,
            String role
        ) {
            if (accountRecordType != newAccountRecordType) {
                return new AutoEnrollmentMappingModel(accountRecordType, newAccountRecordType, status, role, true);
            }

            return new AutoEnrollmentMappingModel(mappingName, accountRecordType, status, role, true);
        }

        public override AutoEnrollmentMappingModel deleteAutoEnrollmentMappings(String mappingName) {
            return new AutoEnrollmentMappingModel(mappingName, 'Record_Type_1', null, null, false);
        }
    }

    /**************************************************************************************************************************************
     * @description Stub class to simulate exception responses from ProgramSettingsVMapper
     **************************************************************************************************************************************/
    private class STUB_ExceptionAutoEnrollmentMappingsVMapper extends AutoEnrollmentMappingsVMapper {
        public override AutoEnrollmentMappingsVModel getAutoEnrollmentMappingsVModel() {
            throw new TestException('Exception encountered!');
        }

        public override ComboBoxVModel getAccountRecordTypeComboboxVModel(String accountRecordType) {
            throw new TestException('Exception encountered!');
        }

        public override ComboBoxVModel getAutoEnrollmentMappingStatusComboboxVModel(
            String autoProgramEnrollmentStatus
        ) {
            throw new TestException('Exception encountered!');
        }

        public override ComboBoxVModel getAutoEnrollmentMappingRoleComboboxVModel(String autoProgramEnrollmentRole) {
            throw new TestException('Exception encountered!');
        }
    }

    /**************************************************************************************************************************************
     * @description Stub class to simulate exception responses from AutoEnrollmentMappingService
     **************************************************************************************************************************************/
    private class STUB_ExceptionAutoEnrollmentMappingService extends AutoEnrollmentMappingService {
        public override AutoEnrollmentMappingModel createAutoEnrollmentMapping(
            String accountRecordType,
            String status,
            String role
        ) {
            throw new TestException('Exception encountered!');
        }

        public override AutoEnrollmentMappingModel updateAutoEnrollmentMappings(
            String mappingName,
            String accountRecordType,
            String newAccountRecordType,
            String status,
            String role
        ) {
            throw new TestException('Exception encountered!');
        }

        public override AutoEnrollmentMappingModel deleteAutoEnrollmentMappings(String mappingName) {
            throw new TestException('Exception encountered!');
        }
    }

    /**************************************************************************************************************************************
     * @description Stub class to simulate exception responses from ProgramEnrollmentDeletionSettingsVMapper
     **************************************************************************************************************************************/
    private class STUB_ExceptionProgramEnrollmentDeletionSettingsVMapper extends ProgramEnrollmentDeletionSettingsVMapper {
        public override ProgramEnrollmentDeletionSettingsVModel getProgramEnrollmentDeletionSettingsVModel() {
            throw new TestException('Exception encountered!');
        }
    }

    private class TestException extends Exception {
    }
}
public class REL_Relationships_Cm_TDTM extends TDTM_Runnable {

    @testVisible
    private static Boolean reentrancyPrevented;

    public override DmlWrapper run(List<SObject> newList, List<SObject> oldList, 
    TDTM_Runnable.Action triggerAction, Schema.DescribeSObjectResult objResult) {

        List<CampaignMember> newListCasted = (newList == null ? new List<CampaignMember>(): (List<CampaignMember>)newList);
        List<CampaignMember> oldListCasted = (oldList == null ? new List<CampaignMember>(): (List<CampaignMember>)oldList);
        Map<Id, CampaignMember> oldMap = new Map<Id, CampaignMember>(oldListCasted);
            
        DmlWrapper dmlWrapper = new DmlWrapper();

        if (TDTM_ProcessControl.getRecursionFlag(TDTM_ProcessControl.registeredTrigger.REL_Relationships_Cm_TDTM)) {
            reentrancyPrevented = true;
            return dmlWrapper;
         }
        
        List<Id> contactIds = new List<Id>();
        List<Id> reciprocalIds = new List<Id>();
        List<String> types = new List<String>();
        List<Id> cIds = new List<Id>();  
        
        // Create Campaign map based on newMap keyset, then get type and use that map to determine if type matched
        for (CampaignMember cm : newListCasted){
            cIds.add(cm.CampaignId);
        }
        
        Map<Id, Campaign> cMap = new Map<Id, Campaign>([SELECT Id, Type FROM Campaign WHERE Id IN :cIds]);
                
        for (CampaignMember cm : newListCasted){
            // Ignore campaign members for leads
            if (cm.ContactId == null) {
                continue;
            }

            for(String s : REL_Utils.getAutoCreateMap().keySet()){
                Relationship_Auto_Create__c rac = REL_Utils.getAutoCreateMap().get(s);

                if (rac.Object__c != 'CampaignMember' || rac.Campaign_Types__c == null) {
                    continue;
                }
                
                //retrieve the campaign for matching type
                Campaign c = cMap.get(cm.CampaignId);
                UTIL_Debug.debug('****Current Campaign Type: ' + c.Type);
                
                //create a set from the rac
                List<String> cTypeList = rac.Campaign_Types__c.split(';');
                UTIL_Debug.debug('****All Campaign Types: ' + cTypeList);
                Set<String> cTypeSet = new Set<String>();
                cTypeSet.addAll(cTypeList);                            
                
                if (cTypeSet.contains(c.Type)){                     
                    Id relatedContactId;
                    try{
                        //get the id from the field                        
                        relatedContactId = (Id)cm.get(rac.Field__c);
                    }catch(Exception e) {
                        cm.addError(Label.AutoCreateFieldError); 
                    }
                    
                    if(triggerAction == TDTM_Runnable.Action.afterInsert && relatedContactId != null) {                        
                        contactIds.add(cm.ContactId);
                        reciprocalIds.add(relatedContactId);
                        types.add(rac.Relationship_Type__c);
                    } else if (triggerAction == TDTM_Runnable.Action.afterUpdate && relatedContactId != null 
                            && relatedContactId != oldMap.get(cm.id).get(rac.Field__c)){
                        contactIds.add(cm.ContactId);
                        reciprocalIds.add(relatedContactId);
                        types.add(rac.Relationship_Type__c);
                    }
                }              
            }         
        }   

        if (!contactIds.isEmpty()) {
            DmlWrapper w = REL_Relationships_Con_TDTM.createNewRelationships(contactIds, reciprocalIds, types);
            dmlWrapper.objectsToInsert.addAll(w.objectsToInsert);
        }

        TDTM_ProcessControl.setRecursionFlag(TDTM_ProcessControl.registeredTrigger.REL_Relationships_Cm_TDTM, true);
        TDTM_TriggerHandler.processDML(dmlWrapper, true);
        dmlWrapper = null;
        TDTM_ProcessControl.setRecursionFlag(TDTM_ProcessControl.registeredTrigger.REL_Relationships_Cm_TDTM, false);

        return dmlWrapper;
    }
}
public class REL_Relationships_Con_TDTM extends TDTM_Runnable {

    @testVisible
    private static Boolean reentrancyPrevented;
	
	/*******************************************************************************************************
    * @description Trigger Handler on Contact that handles relationship autocreation and gender change.
    * @param newList the list of Contacts from trigger new. 
    * @param oldList the list of Contacts from trigger old. 
    * @param triggerAction which trigger event (BeforeInsert, AfterInsert, etc.). 
    * @param objResult the describe for Contacts 
    * @return dmlWrapper Any relationships that need DML.
    ********************************************************************************************************/
	public override DmlWrapper run(List<SObject> newList, List<SObject> oldList, 
    TDTM_Runnable.Action triggerAction, Schema.DescribeSObjectResult objResult) {

        DmlWrapper dmlWrapper = new DmlWrapper();

        if (newList == null || newList.isEmpty() == true){
            return dmlWrapper;
        }

        UTIL_Describe.cacheDescribeSObjectResult(Contact.SObjectType.getDescribe());

        if (triggerAction == TDTM_Runnable.Action.AfterInsert){
            return this.handleAfterInsert(newList);
        }

        /******************************************************************************************************************** */
         //Casting them to contacts, since this class should be run only for contacts
         List<Contact> newListCasted = (newList == null ? new List<Contact>(): (List<Contact>)newList);
         List<Contact> oldListCasted = (oldList == null ? new List<Contact>(): (List<Contact>)oldList);
         Map<Id, Contact> oldMap = new Map<Id, Contact>(oldListCasted);
                      
         if (TDTM_ProcessControl.getRecursionFlag(TDTM_ProcessControl.registeredTrigger.REL_Relationships_Con_TDTM)) {
             reentrancyPrevented = true;
             return dmlWrapper;
          }
         
         List<Id> contactIds = new List<Id>();
         List<Id> reciprocalIds = new List<Id>();
         List<String> types = new List<String>();
         
         Set<Id> changedGender = new Set<Id>();        
         
         if(newlist != null && newlist.size() > 0) {
             for (Contact c : newListCasted){
                 for(String s : REL_Utils.getAutoCreateMap().keySet()){
                     Relationship_Auto_Create__c rac = REL_Utils.getAutoCreateMap().get(s);
                     if (rac.Object__c != 'Contact') {
                         continue;
                     }
                     
                     Id relatedContactId;
                     try{
                         //get the id from the field                        
                         relatedContactId = (Id)c.get(rac.Field__c);
                     }catch(Exception e){
                         c.addError(system.Label.AutoCreateFieldError);
                     }    
                     
                     if(triggerAction == TDTM_Runnable.Action.afterInsert && relatedContactId != null) {                        
                         contactIds.add(c.Id);
                         reciprocalIds.add(relatedContactId);
                         types.add(rac.Relationship_Type__c);
                     } else if (triggerAction == TDTM_Runnable.Action.afterUpdate && relatedContactId != null 
                             && relatedContactId != oldMap.get(c.id).get(rac.Field__c)){
                         contactIds.add(c.Id);
                         reciprocalIds.add(relatedContactId);
                         types.add(rac.Relationship_Type__c);
                     }         
                 }
                 
                 //handle updates to the gender field
                 if (triggerAction == TDTM_Runnable.Action.afterUpdate && oldMap.get(c.id) != null) {
                     if (c.Gender__c != oldMap.get(c.id).Gender__c) {
                         changedGender.add(c.id);
                     }
                 }           
             }
         }
         
         if(triggerAction == TDTM_Runnable.Action.AfterDelete) {
             DmlWrapper w = deleteEmptyRelationships(oldMap);
             dmlWrapper.objectsToDelete.addAll(w.objectsToDelete);
         }
         
         if (!contactIds.isEmpty()){
             DmlWrapper w = createNewRelationships(contactIds, reciprocalIds, types);
             dmlWrapper.objectsToInsert.addAll(w.objectsToInsert);
         }
         
         if (!changedGender.isEmpty()) {
             //query for a map of all relationships where where contact or related contact has changed gender
             map<id,Relationship__c> mapRelationship = new map<Id,Relationship__c>(
                 [SELECT Id, Contact__c, RelatedContact__c, ReciprocalRelationship__c, Type__c 
                 FROM Relationship__c WHERE Contact__c IN :changedGender OR RelatedContact__c IN :changedGender]
             );
             //make a list of "Related Contact" lookup relationships in our set, these we want to update
             list<Relationship__c> listRelsForUpdate = new list<Relationship__c>();
             //make a list of mirror relationships for our first list, we need these for the addType method
             list<Relationship__c> listMirrorRels = new list<Relationship__c>();
 
             //get the relationships that the gender change affects
             for (Relationship__c rel : mapRelationship.values()) {
                 //add the changed gender's relationship and reciprocal
                 if (changedGender.contains(rel.RelatedContact__c)) {
                     listRelsForUpdate.add(rel);
                     listMirrorRels.add(mapRelationship.get(rel.ReciprocalRelationship__c));
                 }
             }
 
             //update type info
             REL_Relationships_TDTM.addType(listMirrorRels, listRelsForUpdate);
             dmlWrapper.objectsToUpdate.addAll((list<sObject>)listRelsForUpdate);
         }
 
        TDTM_ProcessControl.setRecursionFlag(TDTM_ProcessControl.registeredTrigger.REL_Relationships_Con_TDTM, true);
        TDTM_TriggerHandler.processDML(dmlWrapper, true);
        dmlWrapper = null;
        TDTM_ProcessControl.setRecursionFlag(TDTM_ProcessControl.registeredTrigger.REL_Relationships_Con_TDTM, false);
        /********************************************************************************************************/


        return dmlWrapper;
    }


    /********************************************************************************************************
    * @description Handles processing of logic necessary for an After Insert trigger action.
    * @param newList The list of inserted objects.
    * @return A DmlWrapper
    ********************************************************************************************************/ 
    @TestVisible
    private DmlWrapper handleAfterInsert(List<SObject> newList){        
        if (this.isInsertRecursion() == true){
            return null;
        }

        this.setInsertRecursion();

        List<Contact> newContactsList = (List<Contact>)newList;
        List<ContactRelAutoCreateMappingModel> contactRelAutoCreateModelsList = this.locateRelationshipAutoCreateMapper().getContactMappingModelsFromSettings();     

        ContactsRelationshipsModel contactsRelationshipsMdl = this.locateRelationshipAutoCreateService().getRelationshipsToCreateForContacts(newContactsList, contactRelAutoCreateModelsList);

        if (contactsRelationshipsMdl != null){
            List<Relationship__c> contactRelationshipsToCreate = contactsRelationshipsMdl.relationshipList;

            if (contactRelationshipsToCreate != null && contactRelationshipsToCreate.isEmpty() == false){
                DmlWrapper dmlWrapper = new DmlWrapper();
                
                dmlWrapper.objectsToInsert.addAll((List<SObject>)contactRelationshipsToCreate);
                TDTM_TriggerHandler.processDML(dmlWrapper, true);
            }
        }
        
        this.unsetInsertRecursion();

        return null;
    }

    /*******************************************************************************************************
    * @description Retrieves an instance of the RelAutoCreateSettingsMapper mapper class.
    * @return An instance of RelAutoCreateSettingsMapper.
    *******************************************************************************************************/ 
    @TestVisible
    private RelAutoCreateSettingsMapper locateRelationshipAutoCreateMapper(){
        return RelAutoCreateSettingsMapper.getInstance();
    }

    /*******************************************************************************************************
    * @description Retrieves an instance of the ContactRelAutoCreateService service class.
    * @return An instance of ContactRelAutoCreateService.
    *******************************************************************************************************/ 
    @TestVisible
    private ContactRelAutoCreateService locateRelationshipAutoCreateService(){
        return ContactRelAutoCreateService.getInstance();
    }

    /*******************************************************************************************************
    * @description Determines whether current context is associated with an insert recursion.
    * @return True if After Insert recursion flag for REL_Relationships_Con_TDTM is set, False otherwise.
    *******************************************************************************************************/ 
    @TestVisible
    private Boolean isInsertRecursion(){
        return TDTM_ProcessControl.getRecursionFlag(TDTM_ProcessControl.registeredTrigger.REL_Relationships_Con_TDTM);
    }
    
    /*******************************************************************************************************
    * @description Sets the After Insert recursion flag for REL_Relationships_Con_TDTM.
    *******************************************************************************************************/    
    @TestVisible
    private void setInsertRecursion(){
        TDTM_ProcessControl.setRecursionFlag(TDTM_ProcessControl.registeredTrigger.REL_Relationships_Con_TDTM, true);
    }

    /*******************************************************************************************************
    * @description Clears the After Insert recursion flag for REL_Relationships_Con_TDTM.
    *******************************************************************************************************/ 
    @TestVisible
    private void unsetInsertRecursion(){
        TDTM_ProcessControl.setRecursionFlag(TDTM_ProcessControl.registeredTrigger.REL_Relationships_Con_TDTM, false);
    }


    /*******************************************************************************************************
    * @description Deletes Relationships when a Contact is deleted
    * @param contacts the Map of Contacts from trigger oldMap. 
    * @return dmlWrapper Relationships to delete.
    ********************************************************************************************************/
    public static DmlWrapper deleteEmptyRelationships(Map<Id, Contact> contacts) {
        DmlWrapper dmlWrapper = new DmlWrapper();
        List<SObject> relationshipsToDelete = new List<SObject>();

        // The Contacts primary Relationships have already been cascade deleted in Contact After Delete context
        // Using ALL ROWS returns them in the query used to gather the mirror Relationships to be deleted 
        for (Relationship__c r : [SELECT Id, ReciprocalRelationship__c FROM Relationship__c 
                WHERE Contact__c IN :contacts.keySet() ALL ROWS]){
            if (r.ReciprocalRelationship__c != null) {
                relationshipsToDelete.add(new Relationship__c(Id = r.ReciprocalRelationship__c));
            }
        }
        if ( relationshipsToDelete.size() > 0 ) {
            dmlWrapper.objectsToDelete.addAll(relationshipsToDelete);
        }
        return dmlWrapper;
    }
    
    public static DmlWrapper createNewRelationships(List<Id> contactIds, List<Id> relatedContactIds, List<String> types) {
        
        DmlWrapper dmlWrapper = new DmlWrapper();
        Integer i = 0;
        List<SObject> relationshipsForInsert = new List<SObject>();
        
        //used to hold existing relationships for the group of contacts and check for dupes
        List<Relationship__c> existingRelationships = new List<Relationship__c>();
        Map<Id, List<Relationship__c>> relationshipsByContact = new Map<Id, List<Relationship__c>>();
        
        if (!UTIL_CustomSettingsFacade.getSettings().Allow_AutoCreated_Duplicates__c) {
            
            existingRelationships = [SELECT Id, Contact__c, RelatedContact__c, Type__c 
                FROM Relationship__c WHERE Contact__c IN :contactIds LIMIT 2000];
            
            //sort by Contact__c so we can pull relationships based on the inserted Contact
            for(Relationship__c r : existingRelationships){
                if(relationshipsByContact.containsKey(r.Contact__c)){
                    List<Relationship__c> rList = relationshipsByContact.get(r.Contact__c);
                    rList.add(r);
                    relationshipsByContact.put(r.Contact__c, rList);
                }
                else{
                    relationshipsByContact.put(r.Contact__c, new List<Relationship__c>{r});
                }               
            }        
        }        
            
        for (Id conId : contactIds){
            boolean doNotCreate = false;
            
            //prevent duplicates from being created if they exist and setting is enabled
            if (relationshipsByContact.containsKey(conId)){
                for (Relationship__c r : relationshipsByContact.get(conId)){
                    if (r.Type__c == types[i] && r.RelatedContact__c == relatedContactIds[i]){
                        doNotCreate = true;                     
                        break;
                    }                   
                }    
            }
            
            if (!doNotCreate){
                UTIL_Debug.debug('****Creating relationship in createNewRelationships method');
                Relationship__c r = new Relationship__c(
                    Contact__c = conId, 
                    RelatedContact__c = relatedContactIds[i],
                    Type__c = types[i],           
                    Status__c = 'Current'                 
                );
                relationshipsForInsert.add(r);
            }
            i++;
        }       
        
        if (!relationshipsForInsert.isEmpty()){
            dmlWrapper.objectsToInsert.addAll(relationshipsForInsert);
        }
        
        return dmlWrapper;
    }
}
@isTest
private with sharing class REL_Relationships_Con_TEST {
    /*********************************************************************************************************
     ****************************** RELATIONSHIP AUTO CREATION FUNCTIONAL TESTS *******************************
     *********************************************************************************************************/

    /*********************************************************************************************************
     * @description Test to verify that inserting a Contact record without an Auto Creation mapping does not
     * generate a relationship or reciprocal relationship record.
     *********************************************************************************************************/
    @isTest
    private static void insertContactWithoutRelationshipAutoCreate() {
        List<Contact> contactsList = UTIL_UnitTestData_TEST.getMultipleTestContacts(5);

        Test.startTest();
        insert contactsList;
        Test.stopTest();

        List<Relationship__c> relationshipResultsList = [
            SELECT Id, Contact__c, RelatedContact__c, Status__c, Type__c
            FROM Relationship__c
            WHERE Contact__c IN :contactsList OR RelatedContact__c IN :contactsList
        ];

        System.assertEquals(
            true,
            relationshipResultsList.isEmpty(),
            'There should be no auto created relationship records.'
        );
    }

    /*********************************************************************************************************
     * @description Test to verify that inserting a Contact record with invalid Auto Creation
     * mappings results in an error when Contact is created and all fields associated with invalid mappings are populated.
     *********************************************************************************************************/
    @isTest
    private static void insertContactWithInvalidRelationshipsAutoCreate() {
        List<Relationship_Auto_Create__c> relAutoCreateList = new List<Relationship_Auto_Create__c>();

        Relationship_Auto_Create__c relAutoCreateInValid1 = new Relationship_Auto_Create__c(
            Name = 'ConReportToAutoCreateInvalid1',
            Object__c = 'Contact',
            Field__c = 'FirstName',
            Relationship_Type__c = 'Testee',
            Campaign_Types__c = ''
        );

        Relationship_Auto_Create__c relAutoCreateInValid2 = new Relationship_Auto_Create__c(
            Name = 'ConReportToAutoCreateInvalid2',
            Object__c = 'Contact',
            Field__c = 'LastName',
            Relationship_Type__c = 'Tester',
            Campaign_Types__c = ''
        );

        relAutoCreateList.add(relAutoCreateInValid1);
        relAutoCreateList.add(relAutoCreateInValid2);
        insert relAutoCreateList;

        List<Relationship_Lookup__c> relationshipLookupsList = new List<Relationship_Lookup__c>();
        Relationship_Lookup__c testerRelationshipLookup = new Relationship_Lookup__c(
            Name = 'Tester',
            Male__c = 'Testee-Male',
            Female__c = 'Testee-Female',
            Neutral__c = 'Testee'
        );

        Relationship_Lookup__c testeeRelationshipLookup = new Relationship_Lookup__c(
            Name = 'Testee',
            Male__c = 'Tester-Male',
            Female__c = 'Tester-Female',
            Neutral__c = 'Tester'
        );

        relationshipLookupsList.add(TesterRelationshipLookup);
        relationshipLookupsList.add(TesteeRelationshipLookup);
        insert relationshipLookupsList;

        List<Contact> contactsList = UTIL_UnitTestData_TEST.getMultipleTestContacts(5);
        for (Integer i = 0; i < contactsList.size(); i++) {
            contactsList[i].FirstName = 'Test';
            contactsList[i].LastName = 'Contact ' + i;
        }

        Test.startTest();
        try {
            insert contactsList;
        } catch (DmlException e) {
            System.assertEquals(
                true,
                e.getMessage().contains(Label.AutoCreateFieldError),
                'Inserting a Contact with invalid Auto Create mappings should display an error.'
            );
        }
        Test.stopTest();

        List<Relationship__c> relationshipResultsList = [
            SELECT Id, Contact__c, RelatedContact__c, Status__c, Type__c
            FROM Relationship__c
            WHERE Contact__c IN :contactsList
        ];

        System.assertEquals(
            true,
            relationshipResultsList.isEmpty(),
            'No Contact records should be inserted when invalid Auto Create mappings.'
        );
    }

    /*********************************************************************************************************
     * @description Test to verify that inserting a Contact record with a valid Auto Creation
     * mappings and relationship lookup results in a reciprocal relationship record.
     * Test Scenario: T-4314976
     *********************************************************************************************************/
    @isTest
    private static void insertContactWithValidRelationshipsAutoCreate() {
        List<Relationship_Lookup__c> lookups = new List<Relationship_Lookup__c>();

        lookups.add(
            new Relationship_Lookup__c(
                Name = 'Employee',
                Male__c = 'Employer',
                Female__c = 'Employer',
                Neutral__c = 'Employer',
                Active__c = true
            )
        );
        lookups.add(
            new Relationship_Lookup__c(
                Name = 'Employer',
                Male__c = 'Employee',
                Female__c = 'Employee',
                Neutral__c = 'Employee',
                Active__c = true
            )
        );
        insert lookups;

        insert new Relationship_Auto_Create__c(
            Name = 'ConReportToAutoCreate',
            Object__c = 'Contact',
            Field__c = 'ReportsToId',
            Relationship_Type__c = 'Employer',
            Campaign_Types__c = ''
        );

        Contact employer = UTIL_UnitTestData_TEST.getUniqueContact(0);
        insert employer;

        Contact employee = UTIL_UnitTestData_TEST.getUniqueContact(1);
        employee.ReportsToId = employer.Id;

        Test.startTest();
        insert employee;
        Test.stopTest();

        List<Relationship__c> employeeRelationship = [
            SELECT Id, Contact__c, RelatedContact__c, Status__c, Type__c
            FROM Relationship__c
            WHERE RelatedContact__c = :employee.Id
        ];

        List<Relationship__c> employerRelationship = [
            SELECT Id, Contact__c, RelatedContact__c, Status__c, Type__c
            FROM Relationship__c
            WHERE RelatedContact__c = :employer.Id
        ];

        System.assertEquals(1, employeeRelationship.size());
        System.assertEquals(1, employerRelationship.size());

        System.assertEquals('Current', employerRelationship[0].Status__c);
        System.assertEquals('Employer', employerRelationship[0].Type__c);

        System.assertEquals('Current', employeeRelationship[0].Status__c);
        System.assertEquals('Employee', employeeRelationship[0].Type__c);
    }

    /*********************************************************************************************************
     * @description Test to verify that relationships are marked for insertion upon multiple relationships
     * being configured and inserting of a given Contact record.
     * Test Scenario: T-4315028
     *********************************************************************************************************/
    @isTest
    private static void ensureRelationshipServiceInsertsContactsWithValidRelationshipsAutoCreate() {
        List<Relationship_Lookup__c> lookups = new List<Relationship_Lookup__c>();

        lookups.add(
            new Relationship_Lookup__c(
                Name = 'Employee',
                Male__c = 'Employer',
                Female__c = 'Employer',
                Neutral__c = 'Employer',
                Active__c = true
            )
        );
        lookups.add(
            new Relationship_Lookup__c(
                Name = 'Employer',
                Male__c = 'Employee',
                Female__c = 'Employee',
                Neutral__c = 'Employee',
                Active__c = true
            )
        );
        lookups.add(
            new Relationship_Lookup__c(
                Name = 'Supervised',
                Male__c = 'Superviser',
                Female__c = 'Superviser',
                Neutral__c = 'Superviser',
                Active__c = true
            )
        );
        lookups.add(
            new Relationship_Lookup__c(
                Name = 'Superviser',
                Male__c = 'Supervised',
                Female__c = 'Supervised',
                Neutral__c = 'Supervised',
                Active__c = true
            )
        );
        insert lookups;

        insert new Relationship_Auto_Create__c(
            Name = 'ConReportToAutoCreate1',
            Object__c = 'Contact',
            Field__c = 'ReportsToId',
            Relationship_Type__c = 'Employer',
            Campaign_Types__c = ''
        );

        /*insert new Relationship_Auto_Create__c(
            Name = 'ConReportToAutoCreate2',
            Object__c = 'Contact',
            Field__c = 'IndividualId',
            Relationship_Type__c = 'Superviser',
            Campaign_Types__c = ''
        );*/

        Contact employer = UTIL_UnitTestData_TEST.getUniqueContact(0);
        insert employer;

        Contact superviser = UTIL_UnitTestData_TEST.getUniqueContact(1);
        insert superviser;

        Contact employee = UTIL_UnitTestData_TEST.getUniqueContact(2);
        employee.ReportsToId = employer.Id;
        //employee.IndividualId = superviser.Id;

        Test.startTest();
        REL_Relationships_Con_TDTM instance = new REL_Relationships_Con_TDTM();
        List<ContactRelAutoCreateMappingModel> contactRelAutoCreateModelsList = instance.locateRelationshipAutoCreateMapper()
            .getContactMappingModelsFromSettings();

        ContactsRelationshipsModel contactsRelationshipsMdl = instance.locateRelationshipAutoCreateService()
            .getRelationshipsToCreateForContacts(new List<Contact>{ employee }, contactRelAutoCreateModelsList);
        Test.stopTest();

        System.assertEquals(1, contactsRelationshipsMdl.relationshipList.size());
        System.assertEquals('Employer', contactsRelationshipsMdl.relationshipList[0].Type__c);
        //System.assertEquals('Superviser', contactsRelationshipsMdl.relationshipList[1].Type__c);
    }

    /*********************************************************************************************************
     * @description Test to verify that inserting a Contact record with invalid Auto Creation
     * mappings results in an error even when Contact is created and all fields associated with invalid mappings are not populated.
     * Test Scenario: T-4316897
     *********************************************************************************************************/
    @isTest
    private static void insertContactWithInvalidRelationshipsAutoCreateUnpopulated() {
        List<Relationship_Auto_Create__c> relAutoCreateList = new List<Relationship_Auto_Create__c>();

        Relationship_Auto_Create__c relAutoCreateInValid1 = new Relationship_Auto_Create__c(
            Name = 'ConReportToAutoCreateInvalid1',
            Object__c = 'Contact',
            Field__c = 'FirstName',
            Relationship_Type__c = 'Testee',
            Campaign_Types__c = ''
        );

        Relationship_Auto_Create__c relAutoCreateInValid2 = new Relationship_Auto_Create__c(
            Name = 'ConReportToAutoCreateInvalid2',
            Object__c = 'Contact',
            Field__c = 'Birthdate',
            Relationship_Type__c = 'Tester',
            Campaign_Types__c = ''
        );

        relAutoCreateList.add(relAutoCreateInValid1);
        relAutoCreateList.add(relAutoCreateInValid2);
        insert relAutoCreateList;

        List<Relationship_Lookup__c> relationshipLookupsList = new List<Relationship_Lookup__c>();
        Relationship_Lookup__c testerRelationshipLookup = new Relationship_Lookup__c(
            Name = 'Tester',
            Male__c = 'Testee-Male',
            Female__c = 'Testee-Female',
            Neutral__c = 'Testee'
        );

        Relationship_Lookup__c testeeRelationshipLookup = new Relationship_Lookup__c(
            Name = 'Testee',
            Male__c = 'Tester-Male',
            Female__c = 'Tester-Female',
            Neutral__c = 'Tester'
        );

        relationshipLookupsList.add(TesterRelationshipLookup);
        relationshipLookupsList.add(TesteeRelationshipLookup);
        insert relationshipLookupsList;

        List<Contact> contactsList = UTIL_UnitTestData_TEST.getMultipleTestContacts(5);
        for (Integer i = 0; i < contactsList.size(); i++) {
            contactsList[i].LastName = 'Contact ' + i;
        }

        Test.startTest();
        try {
            insert contactsList;
        } catch (DmlException e) {
            System.assertEquals(
                true,
                e.getMessage().contains(Label.AutoCreateFieldError),
                'Inserting a Contact with invalid Auto Create mappings should display an error even when mapped fields are not populated.'
            );
        }
        Test.stopTest();

        List<Relationship__c> relationshipResultsList = [
            SELECT Id, Contact__c, RelatedContact__c, Status__c, Type__c
            FROM Relationship__c
            WHERE Contact__c IN :contactsList
        ];

        System.assertEquals(
            true,
            relationshipResultsList.isEmpty(),
            'No Contact records should be inserted when invalid Auto Create mappings.'
        );
    }

    /*********************************************************************************************************
     * @description Test to verify that inserting a Contact record with both valid and invalid Auto Creation
     * mappings results in an error when Contact is created and field associated with invalid mapping is populated.
     *********************************************************************************************************/
    @isTest
    private static void insertContactWithValidAndInvalidRelationshipsAutoCreateInvalidPopulated() {
        List<Relationship_Auto_Create__c> relAutoCreateList = new List<Relationship_Auto_Create__c>();

        Relationship_Auto_Create__c relAutoCreateInvalid = new Relationship_Auto_Create__c(
            Name = 'ConReportToAutoCreateInvalid',
            Object__c = 'Contact',
            Field__c = 'LastName',
            Relationship_Type__c = 'Testee',
            Campaign_Types__c = ''
        );

        Relationship_Auto_Create__c relAutoCreateValid = new Relationship_Auto_Create__c(
            Name = 'ConReportToAutoCreateValid',
            Object__c = 'Contact',
            Field__c = 'ReportsToId',
            Relationship_Type__c = 'Tester',
            Campaign_Types__c = ''
        );

        relAutoCreateList.add(relAutoCreateInvalid);
        relAutoCreateList.add(relAutoCreateValid);
        insert relAutoCreateList;

        List<Relationship_Lookup__c> relationshipLookupsList = new List<Relationship_Lookup__c>();
        Relationship_Lookup__c testerRelationshipLookup = new Relationship_Lookup__c(
            Name = 'Tester',
            Male__c = 'Testee-Male',
            Female__c = 'Testee-Female',
            Neutral__c = 'Testee'
        );

        Relationship_Lookup__c testeeRelationshipLookup = new Relationship_Lookup__c(
            Name = 'Testee',
            Male__c = 'Tester-Male',
            Female__c = 'Tester-Female',
            Neutral__c = 'Tester'
        );

        relationshipLookupsList.add(TesterRelationshipLookup);
        relationshipLookupsList.add(TesteeRelationshipLookup);
        insert relationshipLookupsList;

        List<Contact> contactsList = UTIL_UnitTestData_TEST.getMultipleTestContacts(5);
        for (Integer i = 0; i < contactsList.size(); i++) {
            contactsList[i].FirstName = 'Test';
            contactsList[i].LastName = 'Contact ' + i;
        }

        Test.startTest();
        try {
            insert contactsList;
        } catch (DmlException e) {
            System.assertEquals(
                true,
                e.getMessage().contains(Label.AutoCreateFieldError),
                'Inserting a Contact with invalid Auto Create mappings should display an error.'
            );
        }
        Test.stopTest();

        List<Relationship__c> relationshipResultsList = [
            SELECT Id, Contact__c, RelatedContact__c, Status__c, Type__c
            FROM Relationship__c
            WHERE Contact__c IN :contactsList
        ];

        System.assertEquals(
            true,
            relationshipResultsList.isEmpty(),
            'No Contact records should be inserted when invalid Auto Create mappings.'
        );
    }

    /*********************************************************************************************************
     * @description Test to verify that inserting a Contact record with both valid and invalid Auto Creation
     * mappings results in an error even when Contact is created and field associated with invalid mapping is not populated.
     *********************************************************************************************************/
    @isTest
    private static void insertContactWithValidAndInvalidRelationshipsAutoCreateInvalidUnpopulated() {
        Contact reportContact = UTIL_UnitTestData_TEST.getMultipleTestContacts(1)[0];
        insert reportContact;

        List<Relationship_Auto_Create__c> relAutoCreateList = new List<Relationship_Auto_Create__c>();

        Relationship_Auto_Create__c relAutoCreateInvalid = new Relationship_Auto_Create__c(
            Name = 'ConReportToAutoCreateInvalid',
            Object__c = 'Contact',
            Field__c = 'FirstName',
            Relationship_Type__c = 'Testee',
            Campaign_Types__c = ''
        );

        Relationship_Auto_Create__c relAutoCreateValid = new Relationship_Auto_Create__c(
            Name = 'ConReportToAutoCreateValid',
            Object__c = 'Contact',
            Field__c = 'ReportsToId',
            Relationship_Type__c = 'Tester',
            Campaign_Types__c = ''
        );

        relAutoCreateList.add(relAutoCreateInvalid);
        relAutoCreateList.add(relAutoCreateValid);
        insert relAutoCreateList;

        List<Relationship_Lookup__c> relationshipLookupsList = new List<Relationship_Lookup__c>();
        Relationship_Lookup__c testerRelationshipLookup = new Relationship_Lookup__c(
            Name = 'Tester',
            Male__c = 'Testee-Male',
            Female__c = 'Testee-Female',
            Neutral__c = 'Testee'
        );

        Relationship_Lookup__c testeeRelationshipLookup = new Relationship_Lookup__c(
            Name = 'Testee',
            Male__c = 'Tester-Male',
            Female__c = 'Tester-Female',
            Neutral__c = 'Tester'
        );

        relationshipLookupsList.add(TesterRelationshipLookup);
        relationshipLookupsList.add(TesteeRelationshipLookup);
        insert relationshipLookupsList;

        List<Contact> contactsList = UTIL_UnitTestData_TEST.getMultipleTestContacts(5);
        for (Integer i = 0; i < contactsList.size(); i++) {
            contactsList[i].LastName = 'Contact ' + i;
            contactsList[i].ReportsToId = reportContact.Id;
        }

        Test.startTest();
        try {
            insert contactsList;
        } catch (DmlException e) {
            System.assertEquals(
                true,
                e.getMessage().contains(Label.AutoCreateFieldError),
                'Inserting a Contact with invalid Auto Create mappings should display an error.'
            );
        }
        Test.stopTest();

        List<Relationship__c> relationshipResultsList = [
            SELECT Id, Contact__c, RelatedContact__c, Status__c, Type__c
            FROM Relationship__c
            WHERE Contact__c IN :contactsList
        ];

        System.assertEquals(
            true,
            relationshipResultsList.isEmpty(),
            'No Contact records should be inserted when invalid Auto Create mappings.'
        );
    }

    /*********************************************************************************************************
    * @description Test to verify that when Relationship Auto Creation is enabled, inserting a Contact record 
    * with an Auto Creation mapped field populated generates the expected relationship  and reciprocal 
    * reciprocal relationship records.
    *********************************************************************************************************/
    @isTest
    private static void insertContactWithRelationshipAutoCreateFieldPopulated() {
        Relationship_Auto_Create__c contactReportToRelAutoCreate = new Relationship_Auto_Create__c(Name = 'ConReportToAutoCreate', 
                                                                                                   Object__c = 'Contact',
                                                                                                   Field__c = 'ReportsToId', 
                                                                                                   Relationship_Type__c = 'Tester',
                                                                                                   Campaign_Types__c = '');

        insert contactReportToRelAutoCreate;

        List<Relationship_Lookup__c> relationshipLookupsList = new List<Relationship_Lookup__c>();
        Relationship_Lookup__c testerRelationshipLookup = new Relationship_Lookup__c(Name = 'Tester', 
                                                                                   Male__c = 'Testee-Male',
                                                                                   Female__c = 'Testee-Female', 
                                                                                   Neutral__c = 'Testee');

        Relationship_Lookup__c testeeRelationshipLookup = new Relationship_Lookup__c(Name = 'Testee', 
                                                                                   Male__c = 'Tester-Male',
                                                                                   Female__c = 'Tester-Female', 
                                                                                   Neutral__c = 'Tester');

        relationshipLookupsList.add(TesterRelationshipLookup);
        relationshipLookupsList.add(TesteeRelationshipLookup);
        insert relationshipLookupsList;

        List<Contact> relatedContactsList = UTIL_UnitTestData_TEST.getMultipleTestContacts(5);
        for (Integer i = 0; i < relatedContactsList.size(); i++){
            relatedContactsList[i].FirstName = 'Test';
            relatedContactsList[i].LastName = 'Related ' + i; 
        }
        insert relatedContactsList;
        
        Map<Id, Contact> relatedContactsById = new Map<Id, Contact>();
        for (Contact con : relatedContactsList){
            relatedContactsById.put(con.Id, con);
        }

        List<Contact> contactsList = UTIL_UnitTestData_TEST.getMultipleTestContacts(5);
        for (Integer i = 0; i < contactsList.size(); i++){
            contactsList[i].FirstName = 'Test';
            contactsList[i].LastName = 'Contact ' + i;
            contactsList[i].ReportsToId = relatedContactsList[i].Id;
        }

        Test.startTest();
        insert contactsList;
        Test.stopTest();

        Map<Id, Contact> contactsById = new Map<Id, Contact>();
        for (Contact con : contactsList){
            contactsById.put(con.Id, con);
        }

        List<Relationship__c> relationshipResultsList = [SELECT Id, 
                                                                Contact__c,
                                                                RelatedContact__c,
                                                                Status__c,
                                                                Type__c
                                                        FROM Relationship__c
                                                        WHERE Contact__c IN :contactsList
                                                        OR Contact__c IN :relatedContactsList];

        Map<Id, Relationship__c> relationshipsByContactId = new Map<Id, Relationship__c>();
        for (Relationship__c rel : relationshipResultsList){
            relationshipsByContactId.put(rel.Contact__c, rel);
        }

        Map<Id, List<Relationship__c>> relationshipsListByContactId = new Map<Id, List<Relationship__c>>();
        for (Relationship__c rel : relationshipResultsList){
            List<Relationship__c> associatedRelationshipsList;

            if (contactsById.containsKey(rel.Contact__c)){
                associatedRelationshipsList = relationshipsListByContactId.get(rel.Contact__c);
            } else {
                associatedRelationshipsList = relationshipsListByContactId.get(rel.relatedContact__c);
            }
            
            if (associatedRelationshipsList == null){
                associatedRelationshipsList = new List<Relationship__c>();
            }

            associatedRelationshipsList.add(rel);
            relationshipsListByContactId.put(rel.Contact__c, associatedRelationshipsList);
        }

        System.assertEquals(10, relationshipResultsList.size(), 'There should be 10 auto created relationship records.');

        for (Id contactId : relationshipsListByContactId.keySet()){
            System.assertEquals(2, relationshipsListByContactId.get(contactId).size(), 'Each contact should be associated with 1 relationship and 1 reciprocal relationship.');
        }

        for (Relationship__c rel : relationshipsByContactId.values()){
            System.assertEquals(true, relationshipsByContactId.containsKey(rel.RelatedContact__c), 'Each relationship has a corresponding reciprocal relationship record.');
            System.assertEquals(rel.Contact__c, relationshipsByContactId.get(rel.RelatedContact__c).RelatedContact__c, 'The related contact on the reciprocal relationships should match the contact on the current relationship.');
            System.assertEquals('Current', rel.Status__c, 'Relationship status should be Current.');

            if (rel.Type__c.contains('Tester')){
                System.assertEquals(true, contactsById.containsKey(rel.Contact__c), 'Relationship contact should correspond with an inserted contact.');
                System.assertEquals(true, relatedContactsById.containsKey(rel.RelatedContact__c), 'Relationship should be associated with a related contact.');
            } else {
                System.assertEquals(true, relatedContactsById.containsKey(rel.Contact__c), 'Relationship contact should correspond with a related contact.');
                System.assertEquals(true, contactsById.containsKey(rel.RelatedContact__c), 'Relationship should be associated with an inserted contact.');
            }
        }
    }

    /*********************************************************************************************************
     * @description Test to verify that when Relationship Auto Creation is enabled, inserting a Contact record
     * with an Auto Creation mapping, but leaving the corresponding field unpopulated on the contact inserted
     * does not generate any relationships.
     *********************************************************************************************************/
    @isTest
    private static void insertContactWithRelationshipAutoCreateFieldUnpopulated() {
        Relationship_Auto_Create__c contactReportToRelAutoCreate = new Relationship_Auto_Create__c(
            Name = 'ConReportToAutoCreate',
            Object__c = 'Contact',
            Field__c = 'ReportsToId',
            Relationship_Type__c = 'Tester',
            Campaign_Types__c = ''
        );

        insert contactReportToRelAutoCreate;

        List<Relationship_Lookup__c> relationshipLookupsList = new List<Relationship_Lookup__c>();
        Relationship_Lookup__c testerRelationshipLookup = new Relationship_Lookup__c(
            Name = 'Tester',
            Male__c = 'Testee-Male',
            Female__c = 'Testee-Female',
            Neutral__c = 'Testee'
        );

        Relationship_Lookup__c testeeRelationshipLookup = new Relationship_Lookup__c(
            Name = 'Testee',
            Male__c = 'Tester-Male',
            Female__c = 'Tester-Female',
            Neutral__c = 'Tester'
        );

        relationshipLookupsList.add(TesterRelationshipLookup);
        relationshipLookupsList.add(TesteeRelationshipLookup);
        insert relationshipLookupsList;

        List<Contact> contactsList = UTIL_UnitTestData_TEST.getMultipleTestContacts(5);
        for (Integer i = 0; i < contactsList.size(); i++) {
            contactsList[i].FirstName = 'Test';
            contactsList[i].LastName = 'Contact ' + i;
        }

        Test.startTest();
        insert contactsList;
        Test.stopTest();

        Map<Id, Contact> contactsById = new Map<Id, Contact>();
        for (Contact con : contactsList) {
            contactsById.put(con.Id, con);
        }

        List<Relationship__c> relationshipResultsList = [
            SELECT Id, Contact__c, RelatedContact__c, Status__c, Type__c
            FROM Relationship__c
            WHERE Contact__c IN :contactsList OR RelatedContact__c IN :contactsList
        ];

        System.assertEquals(
            true,
            relationshipResultsList.isEmpty(),
            'No relationships should be created when mapped field is not populated.'
        );
    }

    /*********************************************************************************************************
     * @description Test to verify that when Relationship Auto Creation is enabled, inserting a Contact record
     * without populating a mapped Auto Creation field will not generate any relationship records.
     *********************************************************************************************************/
    @isTest
    private static void insertContactWithoutRelationshipAutoCreateFieldPopulated() {
        Relationship_Auto_Create__c contactReportToRelAutoCreate = new Relationship_Auto_Create__c(
            Name = 'ConReportToAutoCreate',
            Object__c = 'Contact',
            Field__c = 'ReportsToId',
            Relationship_Type__c = 'Tester',
            Campaign_Types__c = ''
        );

        insert contactReportToRelAutoCreate;

        List<Relationship_Lookup__c> relationshipLookupsList = new List<Relationship_Lookup__c>();
        Relationship_Lookup__c testerRelationshipLookup = new Relationship_Lookup__c(
            Name = 'Tester',
            Male__c = 'Testee-Male',
            Female__c = 'Testee-Female',
            Neutral__c = 'Testee'
        );

        Relationship_Lookup__c testeeRelationshipLookup = new Relationship_Lookup__c(
            Name = 'Testee',
            Male__c = 'Tester-Male',
            Female__c = 'Tester-Female',
            Neutral__c = 'Tester'
        );

        relationshipLookupsList.add(TesterRelationshipLookup);
        relationshipLookupsList.add(TesteeRelationshipLookup);
        insert relationshipLookupsList;

        List<Contact> contactsList = UTIL_UnitTestData_TEST.getMultipleTestContacts(5);
        for (Integer i = 0; i < contactsList.size(); i++) {
            contactsList[i].FirstName = 'Test';
            contactsList[i].LastName = 'Contact ' + i;
            contactsList[i].ReportsToId = null;
        }

        Test.startTest();
        insert contactsList;
        Test.stopTest();

        Map<Id, Contact> contactsById = new Map<Id, Contact>();
        for (Contact con : contactsList) {
            contactsById.put(con.Id, con);
        }

        List<Relationship__c> relationshipResultsList = [
            SELECT Id, Contact__c, RelatedContact__c, Status__c, Type__c
            FROM Relationship__c
            WHERE Contact__c IN :contactsList OR RelatedContact__c IN :contactsList
        ];

        System.assertEquals(
            true,
            relationshipResultsList.isEmpty(),
            'There should be no auto created relationship records when the auto create mapped field is null.'
        );
    }

    /*********************************************************************************************************
     * @description Test to verify that with Auto-Created Duplicate Relations and Relationship Auto Create
     * enabled, populating an Auto Create mapped field on Contact with the same value multiple times will
     * generate duplicate relationship and reciprocal relationship records.
     * Test Scenario: T-4316903
     *********************************************************************************************************/
    @isTest
    private static void updateContactWithRelationshipAutoCreateDuplicatesAllowed() {
        UTIL_CustomSettings_API.getSettingsForTests(new Hierarchy_Settings__c(Allow_AutoCreated_Duplicates__c = true));

        Relationship_Auto_Create__c contactReportToRelAutoCreate = new Relationship_Auto_Create__c(
            Name = 'ConReportToAutoCreate',
            Object__c = 'Contact',
            Field__c = 'ReportsToId',
            Relationship_Type__c = 'Tester',
            Campaign_Types__c = ''
        );

        insert contactReportToRelAutoCreate;

        List<Relationship_Lookup__c> relationshipLookupsList = new List<Relationship_Lookup__c>();
        Relationship_Lookup__c testerRelationshipLookup = new Relationship_Lookup__c(
            Name = 'Tester',
            Male__c = 'Testee-Male',
            Female__c = 'Testee-Female',
            Neutral__c = 'Testee'
        );

        Relationship_Lookup__c testeeRelationshipLookup = new Relationship_Lookup__c(
            Name = 'Testee',
            Male__c = 'Tester-Male',
            Female__c = 'Tester-Female',
            Neutral__c = 'Tester'
        );

        relationshipLookupsList.add(TesterRelationshipLookup);
        relationshipLookupsList.add(TesteeRelationshipLookup);
        insert relationshipLookupsList;

        List<Contact> relatedContactsList = UTIL_UnitTestData_TEST.getMultipleTestContacts(5);
        for (Integer i = 0; i < relatedContactsList.size(); i++) {
            relatedContactsList[i].FirstName = 'Test';
            relatedContactsList[i].LastName = 'Related ' + i;
        }
        insert relatedContactsList;

        List<Contact> contactsList = UTIL_UnitTestData_TEST.getMultipleTestContacts(5);
        for (Integer i = 0; i < contactsList.size(); i++) {
            contactsList[i].FirstName = 'Test';
            contactsList[i].LastName = 'Contact ' + i;
            contactsList[i].ReportsToId = relatedContactsList[i].Id;
        }

        insert contactsList;

        for (Integer i = 0; i < contactsList.size(); i++) {
            contactsList[i].FirstName = 'Test';
            contactsList[i].LastName = 'Contact ' + i;
            contactsList[i].ReportsToId = null;
        }

        update contactsList;

        for (Integer i = 0; i < contactsList.size(); i++) {
            contactsList[i].FirstName = 'Test';
            contactsList[i].LastName = 'Contact ' + i;
            contactsList[i].ReportsToId = relatedContactsList[i].Id;
        }

        Test.startTest();
        update contactsList;
        Test.stopTest();

        Map<Id, Contact> contactsById = new Map<Id, Contact>();
        for (Contact con : contactsList) {
            contactsById.put(con.Id, con);
        }

        List<Relationship__c> relationshipResultsList = [
            SELECT Id, Contact__c, RelatedContact__c, Status__c, Type__c
            FROM Relationship__c
            WHERE Contact__c IN :contactsList OR Contact__c IN :relatedContactsList
        ];

        Map<Id, TestRelationshipMapper> testRelationshipMapperByContactId = REL_Relationships_Con_TEST.mapRelationshipListsToContact(
            contactsById,
            relationshipResultsList
        );

        for (Id contactId : testRelationshipMapperByContactId.keySet()) {
            List<Relationship__c> testerRelList = testRelationshipMapperByContactId.get(contactId)
                .testerRelationshipsList;
            List<Relationship__c> testeeRelList = testRelationshipMapperByContactId.get(contactId)
                .testeeRelationshipsList;

            Boolean testerRecordsDuplicated =
                (testerRelList[0].Contact__c == testerRelList[1].Contact__c) &&
                (testerRelList[0].RelatedContact__c == testerRelList[1].RelatedContact__c);

            Boolean testeeRecordsDuplicated =
                (testeeRelList[0].Contact__c == testeeRelList[1].Contact__c) &&
                (testeeRelList[0].RelatedContact__c == testeeRelList[1].RelatedContact__c);

            System.assertEquals(
                2,
                testerRelList.size(),
                'Each contact should be associated with 2 Tester relationship records.'
            );
            System.assertEquals(
                2,
                testeeRelList.size(),
                'Each contact should be associated with 2 Testee relationship records.'
            );
            System.assertEquals(true, testerRecordsDuplicated, 'Tester relationship records should be duplicated.');
            System.assertEquals(true, testeeRecordsDuplicated, 'Testee relationship records should be duplicated.');
        }
    }

    /*********************************************************************************************************
     * @description Test to verify that when Relationship Auto Creation is enabled and Auto-Created Duplicate
     * Relations is not, associating a Contact multiple times with the same value for an Auto Creation mapped
     * field only results in a single relationship and reciprocal relationship record.
     * Test Scenario: T-4316901
     *********************************************************************************************************/
    @isTest
    private static void updateContactWithRelationshipAutoCreateDuplicatesNotAllowed() {
        UTIL_CustomSettings_API.getSettingsForTests(new Hierarchy_Settings__c(Allow_AutoCreated_Duplicates__c = false));

        Relationship_Auto_Create__c contactReportToRelAutoCreate = new Relationship_Auto_Create__c(
            Name = 'ConReportToAutoCreate',
            Object__c = 'Contact',
            Field__c = 'ReportsToId',
            Relationship_Type__c = 'Tester',
            Campaign_Types__c = ''
        );

        insert contactReportToRelAutoCreate;

        List<Relationship_Lookup__c> relationshipLookupsList = new List<Relationship_Lookup__c>();
        Relationship_Lookup__c testerRelationshipLookup = new Relationship_Lookup__c(
            Name = 'Tester',
            Male__c = 'Testee-Male',
            Female__c = 'Testee-Female',
            Neutral__c = 'Testee'
        );

        Relationship_Lookup__c testeeRelationshipLookup = new Relationship_Lookup__c(
            Name = 'Testee',
            Male__c = 'Tester-Male',
            Female__c = 'Tester-Female',
            Neutral__c = 'Tester'
        );

        relationshipLookupsList.add(TesterRelationshipLookup);
        relationshipLookupsList.add(TesteeRelationshipLookup);
        insert relationshipLookupsList;

        List<Contact> relatedContactsList = UTIL_UnitTestData_TEST.getMultipleTestContacts(5);
        for (Integer i = 0; i < relatedContactsList.size(); i++) {
            relatedContactsList[i].FirstName = 'Test';
            relatedContactsList[i].LastName = 'Related ' + i;
        }
        insert relatedContactsList;

        List<Contact> contactsList = UTIL_UnitTestData_TEST.getMultipleTestContacts(5);
        for (Integer i = 0; i < contactsList.size(); i++) {
            contactsList[i].FirstName = 'Test';
            contactsList[i].LastName = 'Contact ' + i;
            contactsList[i].ReportsToId = relatedContactsList[i].Id;
        }

        insert contactsList;

        for (Integer i = 0; i < contactsList.size(); i++) {
            contactsList[i].FirstName = 'Test';
            contactsList[i].LastName = 'Contact ' + i;
            contactsList[i].ReportsToId = null;
        }

        update contactsList;

        for (Integer i = 0; i < contactsList.size(); i++) {
            contactsList[i].FirstName = 'Test';
            contactsList[i].LastName = 'Contact ' + i;
            contactsList[i].ReportsToId = relatedContactsList[i].Id;
        }

        Test.startTest();
        update contactsList;
        Test.stopTest();

        Map<Id, Contact> contactsById = new Map<Id, Contact>();
        for (Contact con : contactsList) {
            contactsById.put(con.Id, con);
        }

        List<Relationship__c> relationshipResultsList = [
            SELECT Id, Contact__c, RelatedContact__c, Status__c, Type__c
            FROM Relationship__c
            WHERE Contact__c IN :contactsList OR Contact__c IN :relatedContactsList
        ];

        Map<Id, TestRelationshipMapper> testRelationshipMapperByContactId = REL_Relationships_Con_TEST.mapRelationshipListsToContact(
            contactsById,
            relationshipResultsList
        );

        for (Id contactId : testRelationshipMapperByContactId.keySet()) {
            System.assertEquals(
                1,
                testRelationshipMapperByContactId.get(contactId).testerRelationshipsList.size(),
                'Each contact should only have 1 Tester relationship record.'
            );
            System.assertEquals(
                1,
                testRelationshipMapperByContactId.get(contactId).testeeRelationshipsList.size(),
                'Each contact should only have 1 Testee relationship record.'
            );
        }
    }

    /*********************************************************************************************************
     ********************************************* UNIT TESTS *************************************************
     *********************************************************************************************************/

    /*********************************************************************************************************
     * @description Test method to validate that unsetInsertRecursion() updates the REL_Relationships_Con_TDTM
     * recursion trigger flag from true to false.
     *********************************************************************************************************/
    @isTest
    private static void unsetInsertRecursionTrue() {
        TDTM_ProcessControl.setRecursionFlag(TDTM_ProcessControl.registeredTrigger.REL_Relationships_Con_TDTM, true);

        REL_Relationships_Con_TDTM relConTdtm = new REL_Relationships_Con_TDTM();
        Test.startTest();
        relConTdtm.unsetInsertRecursion();
        Test.stopTest();

        System.assertEquals(
            false,
            TDTM_ProcessControl.getRecursionFlag(TDTM_ProcessControl.registeredTrigger.REL_Relationships_Con_TDTM),
            'Insert recursion trigger should be set to false.'
        );
    }

    /*********************************************************************************************************
     * @description Test method to validate that unsetInsertRecursion() does not change the
     * REL_Relationships_Con_TDTM recursion trigger flag if already set to false.
     *********************************************************************************************************/
    @isTest
    private static void unsetInsertRecursionFalse() {
        TDTM_ProcessControl.setRecursionFlag(TDTM_ProcessControl.registeredTrigger.REL_Relationships_Con_TDTM, false);

        REL_Relationships_Con_TDTM relConTdtm = new REL_Relationships_Con_TDTM();
        Test.startTest();
        relConTdtm.unsetInsertRecursion();
        Test.stopTest();

        System.assertEquals(
            false,
            TDTM_ProcessControl.getRecursionFlag(TDTM_ProcessControl.registeredTrigger.REL_Relationships_Con_TDTM),
            'Insert recursion trigger should remain set to false.'
        );
    }

    /*********************************************************************************************************
     * @description Test method to validate that setInsertRecursion() changes the
     * REL_Relationships_Con_TDTM recursion trigger flag from false to true.
     *********************************************************************************************************/
    @isTest
    private static void setInsertRecursionTrue() {
        TDTM_ProcessControl.setRecursionFlag(TDTM_ProcessControl.registeredTrigger.REL_Relationships_Con_TDTM, false);

        REL_Relationships_Con_TDTM relConTdtm = new REL_Relationships_Con_TDTM();
        Test.startTest();
        relConTdtm.setInsertRecursion();
        Test.stopTest();

        System.assertEquals(
            true,
            TDTM_ProcessControl.getRecursionFlag(TDTM_ProcessControl.registeredTrigger.REL_Relationships_Con_TDTM),
            'Insert recursion trigger should be set to true.'
        );
    }

    /*********************************************************************************************************
     * @description Test method to validate that setInsertRecursion() does not change the
     * REL_Relationships_Con_TDTM recursion trigger flag if already set to true.
     *********************************************************************************************************/
    @isTest
    private static void setInsertRecursionFalse() {
        TDTM_ProcessControl.setRecursionFlag(TDTM_ProcessControl.registeredTrigger.REL_Relationships_Con_TDTM, true);

        REL_Relationships_Con_TDTM relConTdtm = new REL_Relationships_Con_TDTM();
        Test.startTest();
        relConTdtm.setInsertRecursion();
        Test.stopTest();

        System.assertEquals(
            true,
            TDTM_ProcessControl.getRecursionFlag(TDTM_ProcessControl.registeredTrigger.REL_Relationships_Con_TDTM),
            'Insert recursion trigger should remain set to true.'
        );
    }

    /*********************************************************************************************************
     * @description Test method to validate that isInsertRecursion() returns true when the
     * REL_Relationships_Con_TDTM recursion trigger flag is set to true.
     *********************************************************************************************************/
    @isTest
    private static void isInsertRecursionTrue() {
        TDTM_ProcessControl.setRecursionFlag(TDTM_ProcessControl.registeredTrigger.REL_Relationships_Con_TDTM, true);

        REL_Relationships_Con_TDTM relConTdtm = new REL_Relationships_Con_TDTM();
        Test.startTest();
        System.assertEquals(true, relConTdtm.isInsertRecursion(), 'Insert recursion trigger should be true.');
        Test.stopTest();
    }

    /*********************************************************************************************************
     * @description Test method to validate that isInsertRecursion() returns false when the
     * REL_Relationships_Con_TDTM recursion trigger flag is set to false.
     *********************************************************************************************************/
    @isTest
    private static void isInsertRecursionFalse() {
        TDTM_ProcessControl.setRecursionFlag(TDTM_ProcessControl.registeredTrigger.REL_Relationships_Con_TDTM, false);

        REL_Relationships_Con_TDTM relConTdtm = new REL_Relationships_Con_TDTM();
        Test.startTest();
        System.assertEquals(false, relConTdtm.isInsertRecursion(), 'Insert recursion trigger should be false.');
        Test.stopTest();
    }

    /************************************************************************************************************
     * @description Test method to verify that the locateRelationshipAutoCreateService returns an instance of the
     * ContactRelAutoCreateService service class.
     *************************************************************************************************************/
    @isTest
    private static void getInstanceOfRelationshipAutoCreateService() {
        Test.startTest();
        REL_Relationships_Con_TDTM relConTdtm = new REL_Relationships_Con_TDTM();
        ContactRelAutoCreateService srvcConRelAutoCreateInstance = relConTdtm.locateRelationshipAutoCreateService();
        Test.stopTest();

        System.assertEquals(
            true,
            srvcConRelAutoCreateInstance != null,
            'Instance of service class should be retrieved.'
        );
    }

    /************************************************************************************************************
     * @description Test method to verify that the locateRelationshipAutoCreateMapper() returns an instance
     * of the RelAutoCreateSettingsMapper service class.
     *************************************************************************************************************/
    @isTest
    private static void getInstanceOfRelationshipAutoCreateMappingService() {
        Test.startTest();
        REL_Relationships_Con_TDTM relConTdtm = new REL_Relationships_Con_TDTM();
        RelAutoCreateSettingsMapper srvcRelAutoCreateSettingsMapperInstance = relConTdtm.locateRelationshipAutoCreateMapper();
        Test.stopTest();

        System.assertEquals(
            true,
            srvcRelAutoCreateSettingsMapperInstance != null,
            'Instance of service class should be retrieved.'
        );
    }

    /************************************************************************************************************
     * @description Test method to verify that the handleAfterInsert() returns null and does not perform an
     * insert when executed in an Insert Recursion context.
     ************************************************************************************************************/
    @isTest
    private static void handleAfterInsertWithRecursion() {
        TDTM_ProcessControl.setRecursionFlag(TDTM_ProcessControl.registeredTrigger.REL_Relationships_Con_TDTM, true);

        List<Contact> relatedContactsList = new List<Contact>();

        for (Integer i = 0; i < 5; i++) {
            Contact con = new Contact(
                Id = UTIL_UnitTestData_TEST.getFakeId(Contact.SObjectType),
                LastName = 'Testerson',
                ReportsToId = UTIL_UnitTestData_TEST.getFakeId(Contact.SObjectType)
            );
            relatedContactsList.add(con);
        }

        REL_Relationships_Con_TDTM relConTdtm = new REL_Relationships_Con_TDTM();
        Test.startTest();
        System.assertEquals(
            null,
            relConTdtm.handleAfterInsert((List<SObject>) relatedContactsList),
            'Insert logic in insert recursion context should not execute.'
        );
        Test.stopTest();
    }

    /************************************************************************************************************
     * @description Test method to verify that the handleAfterInsert() inserts contacts and does not create
     * relationships when Auto Create is not enabled.
     ************************************************************************************************************/
    @isTest
    private static void handleAfterInsertWithoutAutoCreate() {
        List<Contact> contactsList = UTIL_UnitTestData_TEST.getMultipleTestContacts(5);
        insert contactsList;

        REL_Relationships_Con_TDTM relConTdtm = new REL_Relationships_Con_TDTM();
        Test.startTest();
        relConTdtm.handleAfterInsert((List<SObject>) contactsList);
        Test.stopTest();

        List<Relationship__c> relationshipResultsList = [
            SELECT Id
            FROM Relationship__c
            WHERE Contact__c IN :contactsList OR RelatedContact__c IN :contactsList
        ];

        System.assertEquals(
            true,
            relationshipResultsList.isEmpty(),
            'There should be no relationship records auto created.'
        );
    }

    /************************************************************************************************************
     * @description Test method to verify that the handleAfterInsert() does not create a relationship and
     * reciprocal relationship when Auto Create is enabled, but the mapped field is not populated.
     ************************************************************************************************************/
    @isTest
    private static void handleAfterInsertWithAutoCreateNoFieldPopulated() {
        Relationship_Auto_Create__c contactReportToRelAutoCreate = new Relationship_Auto_Create__c(
            Name = 'ConReportToAutoCreate',
            Object__c = 'Contact',
            Field__c = 'ReportsToId',
            Relationship_Type__c = 'Tester',
            Campaign_Types__c = ''
        );

        insert contactReportToRelAutoCreate;

        List<Relationship_Lookup__c> relationshipLookupsList = new List<Relationship_Lookup__c>();
        Relationship_Lookup__c testerRelationshipLookup = new Relationship_Lookup__c(
            Name = 'Tester',
            Male__c = 'Testee-Male',
            Female__c = 'Testee-Female',
            Neutral__c = 'Testee'
        );

        Relationship_Lookup__c testeeRelationshipLookup = new Relationship_Lookup__c(
            Name = 'Testee',
            Male__c = 'Tester-Male',
            Female__c = 'Tester-Female',
            Neutral__c = 'Tester'
        );

        relationshipLookupsList.add(TesterRelationshipLookup);
        relationshipLookupsList.add(TesteeRelationshipLookup);
        insert relationshipLookupsList;

        Set<Id> fakeContactIdsSet = new Set<Id>();
        List<Contact> contactsList = UTIL_UnitTestData_TEST.getMultipleTestContacts(5);
        for (Contact con : contactsList) {
            Id fakeConId = UTIL_UnitTestData_TEST.getFakeId(Contact.SObjectType);
            fakeContactIdsSet.add(fakeConId);
            con.Id = fakeConId;
            con.ReportsToId = null;
        }

        REL_Relationships_Con_TDTM relConTdtm = new REL_Relationships_Con_TDTM();
        Test.startTest();
        relConTdtm.handleAfterInsert((List<SObject>) contactsList);
        Test.stopTest();

        List<Relationship__c> relationshipResultsList = [
            SELECT Id
            FROM Relationship__c
            WHERE Contact__c IN :fakeContactIdsSet OR RelatedContact__c IN :fakeContactIdsSet
        ];

        System.assertEquals(
            true,
            relationshipResultsList.isEmpty(),
            'There should be no relationship records auto created.'
        );
    }

    /************************************************************************************************************
     * @description Test method to verify that the handleAfterInsert() inserts contacts and creates a relationship
     * and reciprocal relationship when Auto Create is enabled and a mappe field is populated.
     ************************************************************************************************************/
    @isTest
    private static void handleAfterInsertWithAutoCreateFieldPopulated() {
        UTIL_CustomSettings_API.getSettingsForTests(new Hierarchy_Settings__c(Allow_AutoCreated_Duplicates__c = false));

        Relationship_Auto_Create__c contactReportToRelAutoCreate = new Relationship_Auto_Create__c(
            Name = 'ConReportToAutoCreate',
            Object__c = 'Contact',
            Field__c = 'ReportsToId',
            Relationship_Type__c = 'Tester',
            Campaign_Types__c = ''
        );

        insert contactReportToRelAutoCreate;

        List<Relationship_Lookup__c> relationshipLookupsList = new List<Relationship_Lookup__c>();
        Relationship_Lookup__c testerRelationshipLookup = new Relationship_Lookup__c(
            Name = 'Tester',
            Male__c = 'Testee-Male',
            Female__c = 'Testee-Female',
            Neutral__c = 'Testee'
        );

        Relationship_Lookup__c testeeRelationshipLookup = new Relationship_Lookup__c(
            Name = 'Testee',
            Male__c = 'Tester-Male',
            Female__c = 'Tester-Female',
            Neutral__c = 'Tester'
        );

        relationshipLookupsList.add(TesterRelationshipLookup);
        relationshipLookupsList.add(TesteeRelationshipLookup);
        insert relationshipLookupsList;

        List<Contact> relatedContactsList = UTIL_UnitTestData_TEST.getMultipleTestContacts(5);
        for (Integer i = 0; i < relatedContactsList.size(); i++) {
            relatedContactsList[i].FirstName = 'Test';
            relatedContactsList[i].LastName = 'Related ' + i;
        }
        insert relatedContactsList;

        Map<Id, Contact> relatedContactsById = new Map<Id, Contact>();
        for (Contact con : relatedContactsList) {
            relatedContactsById.put(con.Id, con);
        }

        List<Contact> contactsList = UTIL_UnitTestData_TEST.getMultipleTestContacts(5);
        for (Integer i = 0; i < contactsList.size(); i++) {
            contactsList[i].FirstName = 'Test';
            contactsList[i].LastName = 'Contact ' + i;
            contactsList[i].ReportsToId = relatedContactsList[i].Id;
        }

        insert contactsList; // inserts 10 additional relationship records

        Map<Id, Contact> contactsById = new Map<Id, Contact>();
        for (Contact con : contactsList) {
            contactsById.put(con.Id, con);
        }

        REL_Relationships_Con_TDTM relConTdtm = new REL_Relationships_Con_TDTM();
        Test.startTest();
        relConTdtm.handleAfterInsert((List<SObject>) contactsList);
        Test.stopTest();

        List<Relationship__c> relationshipResultsList = [
            SELECT Id, Contact__c, RelatedContact__c, Status__c, Type__c
            FROM Relationship__c
            WHERE Contact__c IN :contactsList OR Contact__c IN :relatedContactsList
        ];

        System.assertEquals(
            20,
            relationshipResultsList.size(),
            '10 Relationship records should be auto created (10 extra created due to test setup).'
        );

        Map<Id, TestRelationshipMapper> testRelationshipMapperByContactId = REL_Relationships_Con_TEST.mapRelationshipListsToContact(
            contactsById,
            relationshipResultsList
        );

        for (Id contactId : testRelationshipMapperByContactId.keySet()) {
            System.assertEquals(
                2,
                testRelationshipMapperByContactId.get(contactId).testerRelationshipsList.size(),
                'Each contact should only have 2 Tester relationship records (1 extra created due to test setup).'
            );
            System.assertEquals(
                2,
                testRelationshipMapperByContactId.get(contactId).testeeRelationshipsList.size(),
                'Each contact should only have 2 Testee relationship records (1 extra created due to test setup).'
            );
        }
    }

    /************************************************************************************************************
     * @description Test to verify that run() creates relationships for contacts inserted with Relationship Auto
     * Create enabled.
     ************************************************************************************************************/
    @isTest
    private static void runAfterInsertWithAutoCreate() {
        UTIL_CustomSettings_API.getSettingsForTests(new Hierarchy_Settings__c(Allow_AutoCreated_Duplicates__c = false));

        Relationship_Auto_Create__c contactReportToRelAutoCreate = new Relationship_Auto_Create__c(
            Name = 'ConReportToAutoCreate',
            Object__c = 'Contact',
            Field__c = 'ReportsToId',
            Relationship_Type__c = 'Tester',
            Campaign_Types__c = ''
        );

        insert contactReportToRelAutoCreate;

        List<Relationship_Lookup__c> relationshipLookupsList = new List<Relationship_Lookup__c>();
        Relationship_Lookup__c testerRelationshipLookup = new Relationship_Lookup__c(
            Name = 'Tester',
            Male__c = 'Testee-Male',
            Female__c = 'Testee-Female',
            Neutral__c = 'Testee'
        );

        Relationship_Lookup__c testeeRelationshipLookup = new Relationship_Lookup__c(
            Name = 'Testee',
            Male__c = 'Tester-Male',
            Female__c = 'Tester-Female',
            Neutral__c = 'Tester'
        );

        relationshipLookupsList.add(TesterRelationshipLookup);
        relationshipLookupsList.add(TesteeRelationshipLookup);
        insert relationshipLookupsList;

        List<Contact> relatedContactsList = UTIL_UnitTestData_TEST.getMultipleTestContacts(5);
        for (Integer i = 0; i < relatedContactsList.size(); i++) {
            relatedContactsList[i].FirstName = 'Test';
            relatedContactsList[i].LastName = 'Related ' + i;
        }
        insert relatedContactsList;

        Map<Id, Contact> relatedContactsById = new Map<Id, Contact>();
        for (Contact con : relatedContactsList) {
            relatedContactsById.put(con.Id, con);
        }

        List<Contact> contactsList = UTIL_UnitTestData_TEST.getMultipleTestContacts(5);
        for (Integer i = 0; i < contactsList.size(); i++) {
            contactsList[i].FirstName = 'Test';
            contactsList[i].LastName = 'Contact ' + i;
            contactsList[i].ReportsToId = relatedContactsList[i].Id;
        }

        insert contactsList; // inserts 10 additional relationship records

        Map<Id, Contact> contactsById = new Map<Id, Contact>();
        for (Contact con : contactsList) {
            contactsById.put(con.Id, con);
        }

        REL_Relationships_Con_TDTM relConTdtm = new REL_Relationships_Con_TDTM();
        TDTM_Runnable.Action triggerAction = TDTM_Runnable.Action.AfterInsert;
        Schema.DescribeSObjectResult objResult = Schema.SObjectType.Contact;

        Test.startTest();
        relConTdtm.run((List<SObject>) contactsList, null, triggerAction, objResult);
        Test.stopTest();

        List<Relationship__c> relationshipResultsList = [
            SELECT Id, Contact__c, RelatedContact__c, Status__c, Type__c
            FROM Relationship__c
            WHERE Contact__c IN :contactsList OR Contact__c IN :relatedContactsList
        ];

        System.assertEquals(
            20,
            relationshipResultsList.size(),
            '10 Relationship records should be auto created (10 extra created due to test setup).'
        );
    }

    /************************************************************************************************************
     * @description Test to verify that run() does not create relationships for contacts inserted with
     * Relationship Auto Create disabled.
     ************************************************************************************************************/
    @isTest
    private static void runAfterInsertWithoutAutoCreate() {
        UTIL_CustomSettings_API.getSettingsForTests(new Hierarchy_Settings__c(Allow_AutoCreated_Duplicates__c = false));

        List<Contact> contactsList = UTIL_UnitTestData_TEST.getMultipleTestContacts(5);
        insert contactsList;

        Map<Id, Contact> contactsById = new Map<Id, Contact>();
        for (Contact con : contactsList) {
            contactsById.put(con.Id, con);
        }

        REL_Relationships_Con_TDTM relConTdtm = new REL_Relationships_Con_TDTM();
        TDTM_Runnable.Action triggerAction = TDTM_Runnable.Action.AfterInsert;
        Schema.DescribeSObjectResult objResult = Schema.SObjectType.Contact;

        Test.startTest();
        relConTdtm.run((List<SObject>) contactsList, null, triggerAction, objResult);
        Test.stopTest();

        List<Relationship__c> relationshipResultsList = [
            SELECT Id, Contact__c, RelatedContact__c, Status__c, Type__c
            FROM Relationship__c
            WHERE Contact__c IN :contactsList OR RelatedContact__c IN :contactsList
        ];

        System.assertEquals(true, relationshipResultsList.isEmpty(), 'No Relationship records should be auto created.');
    }

    /*********************************************************************************************************
     * @description Helper method to generate a map relating a contact to all associated Tester and Testee relationship records.
     * @param  contactsById A map of inserted contacts by Id
     * @param  relationshipsList A list of relationship records to be mapped
     * @return A map of TestRelationshipMapper value objects by Contact Id.
     *********************************************************************************************************/
    private static Map<Id, TestRelationshipMapper> mapRelationshipListsToContact(
        Map<Id, Contact> contactsById,
        List<Relationship__c> relationshipsList
    ) {
        Map<Id, TestRelationshipMapper> testRelationshipMapperByContactId = new Map<Id, TestRelationshipMapper>();

        for (Relationship__c rel : relationshipsList) {
            TestRelationshipMapper testRelMapper;

            if (contactsById.containsKey(rel.Contact__c)) {
                testRelMapper = testRelationshipMapperByContactId.get(rel.Contact__c);

                if (testRelMapper == null) {
                    testRelMapper = new TestRelationshipMapper(rel.Contact__c);
                }
            } else {
                testRelMapper = testRelationshipMapperByContactId.get(rel.relatedContact__c);

                if (testRelMapper == null) {
                    testRelMapper = new TestRelationshipMapper(rel.relatedContact__c);
                }
            }

            testRelMapper.addRelationship(rel);
        }

        return testRelationshipMapperByContactId;
    }

    /*********************************************************************************************************
     * @describe Wrapper class to associate Tester and Testee relationships to a Contact.
     *********************************************************************************************************/
    private class TestRelationshipMapper {
        public Id contactId { get; set; }
        public List<Relationship__c> testerRelationshipsList { get; set; }
        public List<Relationship__c> testeeRelationshipsList { get; set; }

        public TestRelationshipMapper(Id contactId) {
            this.contactId = contactId;
            testerRelationshipsList = new List<Relationship__c>();
            testeeRelationshipsList = new List<Relationship__c>();
        }

        /*********************************************************************************************************
         * @description Adds a new relationship to the Tester or Testee relationship
         * list for a contact based on relationship type.
         * @param  rel A relationship to add.
         *********************************************************************************************************/
        public void addRelationship(Relationship__c rel) {
            if (rel.Type__c.contains('Tester')) {
                testerRelationshipsList.add(rel);
            }

            if (rel.Type__c.contains('Testee')) {
                testeeRelationshipsList.add(rel);
            }
        }
    }
}
public class REL_Relationships_TDTM extends TDTM_Runnable {
    
    @testVisible
    private static Boolean reentrancyPrevented;
    
    /*******************************************************************************************************
    * @description Handles Relationship management.
    * @param newList the list of Relationships from trigger new. 
    * @param oldList the list of Relationships from trigger old. 
    * @param triggerAction which trigger event (BeforeInsert, AfterInsert, etc.). 
    * @param objResult the describe for Relationship.
    * @return dmlWrapper.  
    ********************************************************************************************************/
    public override DmlWrapper run(List<SObject> newList, List<SObject> oldList, 
        TDTM_Runnable.Action triggerAction, Schema.DescribeSObjectResult objResult) {

        if (TDTM_ProcessControl.getRecursionFlag(TDTM_ProcessControl.registeredTrigger.REL_Relationships_TDTM_After_Update)) {
            reentrancyPrevented = true;
            return new DmlWrapper();
        }
    	
    	List<Relationship__c> newListCasted = (newList == null ? new List<Relationship__c>(): (List<Relationship__c>)newList);
        List<Relationship__c> oldListCasted = (oldList == null ? new List<Relationship__c>(): (List<Relationship__c>)oldList);
    	
    	if (triggerAction != TDTM_Runnable.Action.AfterDelete) {
    		return runForRelationships(newListCasted, oldListCasted, triggerAction);
        } else {
        	return runForRelationships(oldListCasted, null, triggerAction);
        }
    }
    
    /*******************************************************************************************************
    * @description Handles Relationship management.
    * @param newList the list of Relationships from trigger new. 
    * @param oldList the list of Relationships from trigger old. 
    * @param triggerAction which trigger event (BeforeInsert, AfterInsert, etc.). 
    * @return dmlWrapper.  
    ********************************************************************************************************/
    private DmlWrapper runForRelationships(List<Relationship__c> newList, List<Relationship__c> oldList, 
        TDTM_Runnable.Action triggerAction) {
    	    
    	DmlWrapper mainWrapper = new DmlWrapper();
    	
        // Relationship List for termination updates
        List<Relationship__c> origrelationships = new List<Relationship__c>();
        List<Relationship__c> relationshipsToCreate = new List<Relationship__c>();
        List<Relationship__c> relationshipsToUpdate = new List<Relationship__c>();
        List<Relationship__c> relationshipsToDelete = new List<Relationship__c>();
        List<Relationship__c> reciprocalsToUpdate = new List<Relationship__c>();

        //Keeps track of relationships that have already been deleted to prevent Entity is Deleted error
        Set<Id> hasBeenDeleted = new Set<Id>();

        if (triggerAction == TDTM_Runnable.Action.AfterDelete) {
            hasBeenDeleted.addAll((new Map<Id, Relationship__c>(newList)).keySet());
        }
        
        Integer i = 0;          // processing counter            
        for (Relationship__c r : newList) {
            // AFTER INSERT
            if (triggerAction == TDTM_Runnable.Action.AfterInsert) {
                if (r.ReciprocalRelationship__c == null) {
                    relationshipsToCreate.add(r);
                } else {
                    reciprocalsToUpdate.add(r);
                }
            }
            
            // AFTER UPDATE
            if (triggerAction == TDTM_Runnable.Action.AfterUpdate) {   
                if (r.ReciprocalRelationship__c == oldList[i].ReciprocalRelationship__c && 
                        r.RelatedContact__c != null) {
                    relationshipsToUpdate.add(r);
                    origRelationships.add(oldList[i]);
                }
                
                if (r.RelatedContact__c == null) {
                    relationshipsToDelete.add(r);
                }
            }

            // AFTER DELETE
            if (triggerAction == TDTM_Runnable.Action.AfterDelete) {
                if (r.ReciprocalRelationship__c != null && !hasBeenDeleted.contains(r.ReciprocalRelationship__c)) {
                    relationshipsToDelete.add(r);
                }
            }

            i++;
        }

        if (relationshipsToCreate.size() > 0) {
        	DmlWrapper wrapper = createRelationship(relationshipsToCreate);
            mainWrapper.objectsToInsert.addAll(wrapper.objectsToInsert);
            mainWrapper.objectsToUpdate.addAll(wrapper.objectsToUpdate);
        }

        if (relationshipsToUpdate.size() > 0) {
            // relationshipsToUpdate is only populated in the AfterUpdate sequence.
            // In this sequence, we're updating reciprocal relationships after the other relationship has been updated.
            // So, let's prevent reentrancy here so that the code doesn't run through for a second time.
            DmlWrapper wrapper = updateRelationship(relationshipsToUpdate, origRelationships);
            TDTM_ProcessControl.setRecursionFlag(TDTM_ProcessControl.registeredTrigger.REL_Relationships_TDTM_After_Update, true);
            TDTM_TriggerHandler.processDML(wrapper, true);
            TDTM_ProcessControl.setRecursionFlag(TDTM_ProcessControl.registeredTrigger.REL_Relationships_TDTM_After_Update, false);
        }
        
        if (reciprocalsToUpdate.size() > 0) {
            DmlWrapper wrapper = reciprocate(reciprocalsToUpdate);
            mainWrapper.objectsToUpdate.addAll(wrapper.objectsToUpdate);
        }
        
        if (relationshipsToDelete.size() > 0) {
            DmlWrapper wrapper = deleteRelationships(relationshipsToDelete);
            mainWrapper.objectsToDelete.addAll(wrapper.objectsToDelete);
        }

        return mainWrapper;
    }

    /*******************************************************************************************************
    * @description Deletes Reciprocal Relationships when a Relationship is deleted
    * @param relationships the list of Relationships that are being deleted
    * @return dmlWrapper 
    ********************************************************************************************************/
    private static DmlWrapper deleteRelationships(List<Relationship__c> relationships) {
    	UTIL_Debug.debug('****Deleting relationships: ' + relationships);
    	DmlWrapper dmlWrapper = new DmlWrapper();
        List<SObject> relationshipsToDelete = new List<SObject>();
        
        for (Relationship__c r : relationships) {
        	Relationship__c relationshipToDelete;
            if (r.ReciprocalRelationship__c != null) {
            	relationshipToDelete = new Relationship__c(Id = r.ReciprocalRelationship__c);
            } else if (r.RelatedContact__c == null) {
            	relationshipToDelete = new Relationship__c(Id = r.Id);
	        }

	        relationshipsToDelete.add(relationshipToDelete);
        }
        
        dmlWrapper.objectsToDelete.addAll(relationshipsToDelete);
        return dmlWrapper;
    }
    
    /*******************************************************************************************************
    * @description Updates the existing Reciprocal Relationships for new Relationship records
    * @param relationships the list of new Relationships
    * @return dmlWrapper 
    ********************************************************************************************************/
    private static DmlWrapper reciprocate(List<Relationship__c> relationships) {
    	DmlWrapper dmlWrapper = new DmlWrapper();
        List<SObject> relationshipsToUpdate = new List<SObject>();
        
        for (Relationship__c r : relationships) {
        	UTIL_Debug.debug('****Updating reciprocal relationship');
            Relationship__c copy = new Relationship__c(Id = r.ReciprocalRelationship__c, 
                                                        ReciprocalRelationship__c = r.Id);
            relationshipsToUpdate.add(copy);
        }
        
        dmlWrapper.objectsToUpdate.addAll(relationshipsToUpdate);
        return dmlWrapper;
    }
    
    /*******************************************************************************************************
    * @description Creates the new Reciprocal Relationships for new Relationship records
    * @param relationships the list of new Relationships
    * @return dmlWrapper 
    ********************************************************************************************************/
    private static DmlWrapper createRelationship(List<Relationship__c> relationships) {
    	
    	DmlWrapper dmlWrapper = new DmlWrapper();
    	
        List<SObject> relationshipsToCreate = new List<SObject>();
                
        for (Relationship__c r : relationships) {
        	UTIL_Debug.debug('****Creating relationship in createRelationship method');
            Relationship__c copy = new Relationship__c();              
            copy.Contact__c = r.RelatedContact__c;
            copy.RelatedContact__c = r.Contact__c;
            copy.Status__c = r.Status__c;
            copy.ReciprocalRelationship__c = r.Id;
            copy.Description__c = r.Description__c;
            copy.SYSTEM_SystemCreated__c = true;
            relationshipsToCreate.add(copy);
        }
        
        //evaluate and add the type
        addType(relationships, relationshipsToCreate);      
        dmlWrapper.objectsToInsert.addAll(relationshipsToCreate);
        
        return dmlWrapper;
    }

    /*******************************************************************************************************
    * @description Updates the Status and/or Type of a Relationship after its reciprocal has been updated
    * @param relationships the list of Reciprocal Relationships that were updated
    * @param oldRelationships the old list of Reciprocal Relationships prior to the update
    * @return dmlWrapper 
    ********************************************************************************************************/
    private static DmlWrapper updateRelationship(List<Relationship__c> relationships, 
            List<Relationship__c> oldRelationships) {
    	
    	DmlWrapper dmlWrapper = new DmlWrapper();
    	
        List<Relationship__c> originalRelationships = new List<Relationship__c>();
        List<SObject> relationshipsTypesToUpdate = new List<SObject>();
        List<SObject> reciprocalsToUpdate = new List<SObject>();
        Integer counter = 0;                                            // processing counter       

        for (Relationship__c r : relationships) {
        	
            //SWA 2009-05-13 removed a duplicate check for change to Status__c from this OR statement
            if ((r.Status__c != oldRelationships[counter].Status__c 
                    || r.Type__c != oldRelationships[counter].Type__c 
                    || r.Description__c != oldRelationships[counter].Description__c) 
                    && r.ReciprocalRelationship__c != null) {
            	
                UTIL_Debug.debug('****Updating relationship in updateRelationship method');
                Relationship__c copy = new Relationship__c(Id = r.ReciprocalRelationship__c);
                
                //SWA 2009-05-13 - only attempt to modify the Contact field if the Related Contact  has changed
                if (oldRelationships[counter].RelatedContact__c != r.RelatedContact__c) {
                    copy.Contact__c = r.RelatedContact__c;
                }

                copy.Status__c = r.Status__c;
                copy.Description__c = r.Description__c;
                
                //only recalculate type on reciprocal if the original type has changed
                if (r.Type__c != oldRelationships[counter].Type__c) {
                    relationshipsTypesToUpdate.add(copy);
                    originalRelationships.add(r);
                } else {
                    reciprocalsToUpdate.add(copy);
                }

            }
            counter++;
        }

        //add type info as needed and update
        if (!originalRelationships.isEmpty() && !relationshipsTypesToUpdate.isEmpty()) {
            addType(originalRelationships, relationshipsTypesToUpdate);
            dmlWrapper.objectsToUpdate.addAll(relationshipsTypesToUpdate);
        }
        
        //update reciprocals without type change
        dmlWrapper.objectsToUpdate.addAll(reciprocalsToUpdate);
        
        return dmlWrapper;
    }
    
    /*******************************************************************************************************
    * @description Updates the Type of a list of Relationships based on the defined settings in the org.
    * @param rList the original list of new or updated Relationships
    * @param rCopy the reciprocals of the original list of new or updated Relationships
    ********************************************************************************************************/
    public static void addType(List<Relationship__c> rList, List<SObject> rCopy) {
        
        Hierarchy_Settings__c rs = UTIL_CustomSettingsFacade.getSettings();
        
        //used for tracking place in array
        Integer counter = 0;            
        
        if (rs.Reciprocal_Method__c == 'List Setting') { 
            List<Relationship_Lookup__c> settings = UTIL_CustomSettingsFacade.getReciprocalSettings().clone();           
            Map<String, Relationship_Lookup__c> rlMap = new Map<String, Relationship_Lookup__c>();
            for (Relationship_Lookup__c setting : settings) {
                rlMap.put(setting.Name, setting);
            }
        
            //remove inactive values
            for (String s : rlMap.keySet()) {
                Relationship_Lookup__c thisRl = rlMap.get(s);
                if (thisRl.Active__c != true) {
                    rlMap.remove(s);
                }
            }
        
            List<Id> rIDs = new List<Id>();
            for (Relationship__c r : rList) {
                rIDs.add(r.Contact__c);
            }            
            
            String queryString = 'SELECT Id, Salutation, Gender__c FROM Contact WHERE Id IN :rIDs';                         
            
            Map<Id, Contact> cMap = new Map<Id, Contact>((List<Contact>)Database.query(queryString));
            
            for (Relationship__c r : rList) {
                
                Relationship__c copy = (Relationship__c)rCopy[counter];

                Contact relatedContact = cMap.get(r.Contact__c);
            
                if (rlMap.containsKey(r.Type__c)) {
                    List<String> maleList = system.label.Male.split(',');                                                                                                        
                    List<String> femaleList = system.label.Female.split(',');
                    
                    Set<String> maleSet = new Set<String>();
                    Set<String> femaleSet = new Set<String>();
                    maleSet.addAll(maleList);
                    femaleSet.addAll(femaleList);                    
                                        
                    //was a gender field defined? 
                    if (relatedContact.Gender__c != null) {
                        String match_type = '';                        
                        
                        //try male
                        for (String s : maleList) {
                            if (relatedContact.Gender__c.toLowerCase() == s.toLowerCase().trim()) {
                                match_type = 'male';
                                break;
                            }
                        }

                        //if we haven't found it, try female
                        if (match_type == '') {
                            for (String s : femaleList) {
                                if (relatedContact.Gender__c.toLowerCase() == s.toLowerCase().trim()) {
                                    match_type = 'female';
                                    break;
                                }
                            }
                        }     
                        
                        if (match_type == 'male' && rlMap.get(r.Type__c).Male__c != null) {
                            copy.Type__c = rlMap.get(r.Type__c).Male__c;
                        } else if (match_type == 'female' && rlMap.get(r.Type__c).Female__c != null) {
                            copy.Type__c = rlMap.get(r.Type__c).Female__c;
                        } else {
                            copy.Type__c = rlMap.get(r.Type__c).Neutral__c;
                        }
                    } else if ((relatedContact.Salutation == 'Mr.' || maleSet.contains(relatedContact.Salutation))  
                            && rlMap.get(r.Type__c).Male__c != null) {
                        copy.Type__c = rlMap.get(r.Type__c).Male__c;
                    } else if (((relatedContact.Salutation == 'Ms.' || relatedContact.Salutation == 'Mrs.') 
                            || femaleSet.contains(relatedContact.Salutation)) && rlMap.get(r.Type__c).Female__c != null) {
                        copy.Type__c = rlMap.get(r.Type__c).Female__c;
                    
                    //can't match up gender, bad field or otherwise
                    } else {
                        copy.Type__c = rlMap.get(r.Type__c).Neutral__c;                     
                    }                                     
                //no matching custom List setting, use provided type
                } else {
                    copy.Type__c = r.Type__c;
                }                
                counter++;
            }            
        } else if (rs.Reciprocal_Method__c == 'Value Inversion') {
            
            for (Relationship__c r : rList) {                           
                //instead lets split the type
                List<String> splitrelationship = r.Type__c.split(system.label.Relationship_Split);
                String newString = '';
                if (splitrelationship.size() > 1)
                    newString = splitrelationship[1] + system.label.Relationship_Split + splitrelationship[0];
                else
                    newString = r.Type__c;
            
                Relationship__c castedObject = (Relationship__c)rCopy[counter];
                castedObject.Type__c = newString;
                counter++;
            }
        } else {
            for (Relationship__c r : rList) {
            	Relationship__c castedObject = (Relationship__c)rCopy[counter];
                castedObject.Type__c = r.Type__c;
                counter++; 
            }   
        }
    }
}
@isTest
private class REL_Relationships_TEST {

    private static Contact c1;//male
    private static Contact c2;//female
    private static Contact c3;//unknown

    /*********************************************************************************************************
    * @description Helper for test methods, creates a Auto Create Relationship settings and Relationship
    * Lookup settings.
    */
    private static void setupRelationshipTestData(Hierarchy_Settings__c rs) {

        //set running user to avoid dml issue
        System.runAs(new User(Id = UserInfo.getUserId())) {

            if (rs != null) {
                UTIL_CustomSettingsFacade.getSettingsForTests(rs);
            } else {
                UTIL_CustomSettingsFacade.getSettingsForTests(new Hierarchy_Settings__c(Reciprocal_Method__c = 'List Setting',
                												                        Store_Errors_On__c = true));
            }

            //add autocreate settings for CMs
            delete [SELECT Id FROM Relationship_Auto_Create__c];
            insert new Relationship_Auto_Create__c(Name = 'AutoCreate', Object__c = 'CampaignMember',
                                                    Field__c = 'ContactId', Relationship_Type__c = 'TestType',
                                                    Campaign_Types__c = 'Other;');

            Relationship_Auto_Create__c contactRelationshipAutoCreate = new Relationship_Auto_Create__c(Name = 'AutoCreate2', 
                                                                                                        Object__c = 'Contact',
                                                                                                        Field__c = 'ReportsToId', 
                                                                                                        Relationship_Type__c = 'TestType');
            insert contactRelationshipAutoCreate;
            
            //add Reciprocal Relationship
            delete [SELECT Id FROM Relationship_Lookup__c];
            insert new Relationship_Lookup__c(Name = 'TestLookupType', Male__c = 'TestMaleType',
                                                Female__c = 'TestFemaleType', Neutral__c = 'TestNeutralType');
            insert new Relationship_Lookup__c(Name = 'TestLookupType2', Male__c = 'TestMaleType2',
                                                Female__c = 'TestFemaleType2', Neutral__c = 'TestNeutralType2',
                                                Active__c = false);

            c1 = new Contact(Salutation = 'Mr.', FirstName = 'Walter_Test', LastName = 'Roosevelt_Test');
            c2 = new Contact(Salutation = 'Mrs.', FirstName = 'Jane_Test', LastName = 'Nixon_Test');
            c3 = new Contact(Salutation = 'Dr.', FirstName = 'Pat_Test', LastName = 'Cleveland_Test');
            insert new List<Contact> {c1, c2, c3};
        }
    }

    /*********************************************************************************************************
    * @description Tests relationships and mirroring
    */
    @isTest
    public static void testContactRel() {
        setupRelationshipTestData(null);

        Relationship__c rel = new Relationship__c(
              Contact__c = c1.Id,
              RelatedContact__c = c2.Id,
              Type__c = 'Friend',
              Status__c = 'Active',
              Description__c = 'notes');
        insert rel;

        System.assert(REL_Relationships_TDTM.reentrancyPrevented != true, 
            'Did not expect the reentrancy check to have prevented the REL_Relationships_TDTM trigger from processing again after an insert.');

        // check that rel gets created
        List<Relationship__c> relList = [SELECT Id, Contact__c, RelatedContact__c, Status__c,
                                          Type__c, ReciprocalRelationship__c
                                          FROM Relationship__c WHERE Id = :rel.Id LIMIT 1];
        // check for mirror rel
        List<Relationship__c> mirrorList = [SELECT Id, Contact__c, RelatedContact__c, Status__c,
                                              Type__c, ReciprocalRelationship__c
                                              FROM Relationship__c WHERE ReciprocalRelationship__c = :relList[0].Id LIMIT 1];


        //reference eachother
        System.assertEquals(relList[0].ReciprocalRelationship__c, mirrorList[0].Id);
        System.assertEquals(mirrorList[0].ReciprocalRelationship__c, relList[0].Id);

        //same types
        System.assertEquals(mirrorList[0].Type__c, 'Friend');
        System.assertEquals(relList[0].Type__c, 'Friend');

        // test changing the relationship
        relList[0].Type__c = 'Colleague';
        relList[0].Description__c = 'test desc';

        Test.startTest();
        update relList[0];
        Test.stopTest();

        System.assert(REL_Relationships_TDTM.reentrancyPrevented == true, 
            'Expected the reentrancy check to have prevented the REL_Relationships_TDTM trigger from processing again after an update.');

        // test change to the rel
        Relationship__c updated_original = [SELECT Id, Description__c, Type__c, ReciprocalRelationship__c
                                              FROM Relationship__c WHERE Id = :relList[0].Id LIMIT 1];

        //original should have updated relationship
        System.assertEquals('Colleague', updated_original.Type__c);
        //original should have updated notes
        System.assertEquals('test desc', updated_original.Description__c);

        Relationship__c updated_mirror = [SELECT Id, Type__c, Description__c, ReciprocalRelationship__c
                                              FROM Relationship__c WHERE ReciprocalRelationship__c = :relList[0].Id LIMIT 1];
        //mirror should have relationship set right
        System.assertEquals('Colleague', updated_mirror.Type__c);
        //mirror should have updated notes
        System.assertEquals('test desc', updated_mirror.Description__c);

        // test deleting the rel
        delete updated_original;
        List<Relationship__c> mirror_after_original_deleted = [SELECT Id
                                                           FROM Relationship__c
                                                           WHERE ReciprocalRelationship__c = :rel.Id];
        //mirror should be deleted as well
        System.assertEquals(0, mirror_after_original_deleted.size());
    }

    /*********************************************************************************************************
    * @description Test method for relationships and deleting the mirror record
    */
    @isTest
    public static void testOrphanedRelDelete() {
        setupRelationshipTestData(null);

        Relationship__c crel = new Relationship__c(Contact__c = c1.Id, RelatedContact__c = c2.Id, Type__c = 'Buddies');
        insert crel;

        // check that rel gets created
        Relationship__c crel_original = [SELECT Id, Description__c, Type__c, ReciprocalRelationship__c
                                        FROM Relationship__c WHERE Id = :crel.Id];
        //relationship should be set right
        System.assertEquals(crel_original.Type__c, 'Buddies');

        // check for mirror rel
        Relationship__c crel_mirror = [SELECT Id, Description__c, ReciprocalRelationship__c, Type__c
                                        FROM Relationship__c WHERE ReciprocalRelationship__c = :crel_original.Id];
        //mirror should reference the original
        System.assertEquals(crel_mirror.ReciprocalRelationship__c, crel_original.Id);
        Test.startTest();
        delete crel_mirror;
        Test.stopTest();

        //original relationship should have been automatically deleted
        List<Relationship__c> orphanedCrel = [SELECT Id FROM Relationship__c WHERE Id = :crel_original.Id];
        System.assertEquals(0, orphanedCrel.size());
    }

    /*********************************************************************************************************
    * @description Test method for deleting the original, should delete the reciprocal
    */
    @isTest
    public static void testRelationshipDelete() {
        setupRelationshipTestData(null);
        Relationship__c crel_original = new Relationship__c(Contact__c = c1.Id, RelatedContact__c = c2.Id,
                                                                Type__c = 'Buddies');
        insert crel_original;

        crel_original = [SELECT Id, Description__c, ReciprocalRelationship__c, Type__c
                                            FROM Relationship__c WHERE Id = :crel_original.Id];
        UTIL_Debug.debug('****Original relationship: ' + crel_original);

        // check mirror rel got created
        Relationship__c crel_mirror = [SELECT Id, Description__c, ReciprocalRelationship__c, Type__c
                                            FROM Relationship__c WHERE ReciprocalRelationship__c = :crel_original.Id];

        UTIL_Debug.debug('****Mirror relationship: ' + crel_mirror);

        //mirror should reference the original
        System.assertEquals(crel_original.Id, crel_mirror.ReciprocalRelationship__c);

        //original should reference mirror
        System.assertEquals(crel_mirror.Id, crel_original.ReciprocalRelationship__c);
        UTIL_Debug.debug('***Original successfully references mirror');

        Test.startTest();
        delete crel_original;
        Test.stopTest();
        system.assertEquals(0, [SELECT count() FROM Relationship__c WHERE Id = :crel_mirror.Id]);
    }

    /*********************************************************************************************************
    * @description Test method for campaign member auto create relationships - reentrancy is prevented
    */
    @isTest
    public static void testCampaignMemberReentrancyCheck() {
        setupRelationshipTestData(null);

        // Install Default HEDA TDTM Configuration
        List<TDTM_Global_API.TdtmToken> defaultTokens = TDTM_Global_API.getDefaultTdtmConfig();
        TDTM_Global_API.setTdtmConfig(defaultTokens, 'hed');

        // Add the Test TDTM for the Relationship object. This Test TDTM will simply update the campaign member that caused the relationship to be inserted.
        // So the flow would be: campaign member updated -> relationship updated -> campaign member updated again
        Trigger_Handler__c newTDTM = new Trigger_Handler__c(Active__c = true, Asynchronous__c = false,
            Class__c = 'UTIL_UnitTestData_TEST.Test_TDTM', Load_Order__c = 1, Object__c = 'Relationship__c',
            Owned_by_Namespace__c = 'hed', Trigger_Action__c = 'AfterInsert;AfterUpdate');
        insert newTDTM;

        //Insert a campaign
        Campaign campaign = new Campaign(Name = 'TestCampaign', IsActive = true, Type = 'Other');
        insert campaign;

        //Insert a campaign member
        CampaignMember cm = new CampaignMember(ContactId = c2.Id, CampaignId = campaign.Id);
        insert cm;

        // Ensure that the campaign member gets updated recursively
        UTIL_UnitTestData_TEST.sObjectsToUpdate = new List<SObject>{ cm };

        Test.startTest();
        // Turn the reentrancy flag on since the class won't actually insert any relationships, so the flag would remain off otherwise.
        TDTM_ProcessControl.setRecursionFlag(TDTM_ProcessControl.registeredTrigger.REL_Relationships_Cm_TDTM, true);
        cm.Status = 'SomethingDifferentForUpdate';
        update cm;
        Test.stopTest();

        System.assert(REL_Relationships_Cm_TDTM.reentrancyPrevented == true, 
            'Expected the reentrancy check to have prevented the REL_Relationships_Cm_TDTM trigger from processing again.');
    }

    /*********************************************************************************************************
    * @description Test method for campaign member auto create relationships on update.
    * We can't do a true test as ContactId is not updatable, but we'll hit the update for coverage.
    */
    @isTest
    public static void testAutoCreateCampaignMemberUpdate() {
        setupRelationshipTestData(null);
        //insert a campaignmember
        Campaign c = new Campaign(Name = 'TestCampaign', IsActive = true);
        insert c;
        CampaignMember cm = new CampaignMember(ContactId = c2.Id, CampaignId = c.Id);
        insert cm;
        //do an update and check that a second relationship set is created for the new Contact
        cm.Status = 'SomethingDifferentForUpdate';
        Test.startTest();
        update cm;
        Test.stopTest();

        System.assertNotEquals('We got here', 'Exception thrown on update');
    }

    /*********************************************************************************************************
    * @description Test method for auto creating relationships based on contact fields on contact insert.
    */
    @isTest
    public static void testAutoCreateContactInsert() {
        setupRelationshipTestData(null);

        //insert a new Contact
        Contact c = new Contact(LastName='ReportingIn', ReportsToId = c1.Id);

        Test.startTest();
        insert c;
        Test.stopTest();

        Relationship__c rel = [SELECT Id, Type__c, RelatedContact__c FROM Relationship__c WHERE Contact__c = :c.Id LIMIT 1];
        system.assertEquals('TestType', rel.Type__c);
        system.assertEquals(c1.Id, rel.RelatedContact__c);

        Relationship__c recRel = [SELECT Id, Type__c, RelatedContact__c, Contact__c FROM Relationship__c WHERE ReciprocalRelationship__c = :rel.Id];
        system.assertEquals('TestType', recRel.Type__c);
        system.assertEquals(c.Id, recRel.RelatedContact__c);
    }

    /*********************************************************************************************************
    * @description Test method for auto creating relationships based on contact fields on contact insert - synchronous.
    */
    @isTest
    public static void testAutoCreateContactInsertSynch() {
        setupRelationshipTestData(new Hierarchy_Settings__c(Reciprocal_Method__c = 'List Setting'));

        //insert a new Contact
        Contact c = new Contact(LastName = 'ReportingIn', ReportsToId = c1.Id);

        Test.startTest();
        insert c;
        Test.stopTest();

        Relationship__c rel = [SELECT Id, Type__c, RelatedContact__c FROM Relationship__c WHERE Contact__c = :c.Id LIMIT 1];
        system.assertEquals('TestType', rel.Type__c);
        system.assertEquals(c1.Id, rel.RelatedContact__c);

        Relationship__c recRel = [SELECT Id, Type__c, RelatedContact__c, Contact__c FROM Relationship__c WHERE ReciprocalRelationship__c = :rel.Id];
        system.assertEquals('TestType', recRel.Type__c);
        system.assertEquals(c.Id, recRel.RelatedContact__c);
    }

    /*********************************************************************************************************
    * @description Test method for auto creating relationships based on contact fields on contact update.
    */
    @isTest
    public static void testAutoCreateContactUpdate() {
        setupRelationshipTestData(null);

        //insert a new Contact
        Contact c = new Contact(LastName = 'ReportingIn', ReportsToId = c1.Id);
        insert c;
        c.ReportsToId = c2.Id;

        Test.startTest();
        update c;
        Test.stopTest();

        Relationship__c rel = [SELECT Id, Type__c, RelatedContact__c FROM Relationship__c WHERE Contact__c = :c.Id and RelatedContact__c = :c2.Id LIMIT 1];
        system.assertEquals('TestType', rel.Type__c);
        system.assertEquals(c2.Id, rel.RelatedContact__c);
    }

    /*********************************************************************************************************
    * @description Test method for auto creating relationships based on contact fields on contact update - reentrancy is prevented.
    */
    @isTest
    public static void testContactUpdateReentrancyPrevented() {
        setupRelationshipTestData(null);

        // Install Default HEDA TDTM Configuration
        List<TDTM_Global_API.TdtmToken> defaultTokens = TDTM_Global_API.getDefaultTdtmConfig();
        TDTM_Global_API.setTdtmConfig(defaultTokens, 'hed');

        // Add the Test TDTM for the Relationship object. This Test TDTM will simply update the contact that caused the relationship to be inserted.
        // So the flow would be: contact updated -> relationship updated -> contact updated again
        Trigger_Handler__c newTDTM = new Trigger_Handler__c(Active__c = true, Asynchronous__c = false,
            Class__c = 'UTIL_UnitTestData_TEST.Test_TDTM', Load_Order__c = 1, Object__c = 'Relationship__c',
            Owned_by_Namespace__c = 'hed', Trigger_Action__c = 'AfterInsert;AfterUpdate');
        insert newTDTM;

        //insert a new Contact
        Contact c = new Contact(LastName = 'ReportingIn', ReportsToId = c1.Id);
        insert c;
        c.ReportsToId = c2.Id;

        // Ensure that the contact gets updated recursively
        UTIL_UnitTestData_TEST.sObjectsToUpdate = new List<SObject>{ c };

        Test.startTest();
        update c;
        Test.stopTest();

        Relationship__c rel = [SELECT Id, Type__c, RelatedContact__c FROM Relationship__c WHERE Contact__c = :c.Id AND RelatedContact__c = :c2.Id LIMIT 1];
        system.assertEquals('TestType', rel.Type__c);
        system.assertEquals(c2.Id, rel.RelatedContact__c);

        System.assert(REL_Relationships_Con_TDTM.reentrancyPrevented == true, 
            'Expected the reentrancy check to have prevented the REL_Relationships_Con_TDTM trigger from processing again.');
    }

    /*********************************************************************************************************
    * @description Test value inversion reciprocal method, verify type.
    */
    @isTest
    public static void testInversionSettingsHaveType() {
        setupRelationshipTestData(new Hierarchy_Settings__c(Reciprocal_Method__c = 'Value Inversion'));

        List<Relationship__c> crel = new List<Relationship__c>{
            new Relationship__c(Contact__c = c1.Id, RelatedContact__c = c2.Id, Type__c = 'Buddies-Friends')
        };

        Test.startTest();
        insert crel;
        Test.stopTest();

        // check that rel gets created
        Relationship__c crel_original = [SELECT Id, Description__c, Type__c, ReciprocalRelationship__c FROM Relationship__c WHERE Id = :crel[0].Id];
        //relationship should be set right
        system.assertEquals(crel_original.Type__c, 'Buddies-Friends');

        // check for mirror rel
        Relationship__c crel_mirror = [SELECT Id, Description__c, ReciprocalRelationship__c, Type__c FROM Relationship__c WHERE ReciprocalRelationship__c = :crel_original.Id];
        //mirror should reference the original
        system.assertEquals(crel_mirror.ReciprocalRelationship__c, crel_original.Id);
        system.assertEquals('Friends-Buddies', crel_mirror.Type__c);
    }

    /*********************************************************************************************************
    * @description Test value inversion reciprocal method, verify type.
    */
    @isTest
    public static void testInversionSettingsNoType() {
        setupRelationshipTestData(new Hierarchy_Settings__c(Reciprocal_Method__c = 'Value Inversion'));

        List<Relationship__c> crel = new List<Relationship__c>{
            new Relationship__c(Contact__c = c1.Id, RelatedContact__c = c2.Id, Type__c = 'BuddiesFriends')
        };

        Test.startTest();
        insert crel;
        Test.stopTest();

        // check that rel gets created
        Relationship__c crel_original = [SELECT Id, Description__c, Type__c, ReciprocalRelationship__c FROM Relationship__c WHERE Id = :crel[0].Id];
        //relationship should be set right
        system.assertEquals(crel_original.Type__c, 'BuddiesFriends');

        // check for mirror rel
        Relationship__c crel_mirror = [SELECT Id, Description__c, ReciprocalRelationship__c, Type__c FROM Relationship__c WHERE ReciprocalRelationship__c = :crel_original.Id];
        //mirror should reference the original
        system.assertEquals(crel_mirror.ReciprocalRelationship__c, crel_original.Id);
        system.assertEquals('BuddiesFriends', crel_mirror.Type__c);
    }

    /*********************************************************************************************************
    * @description Test invalid settings config, verify mirror relationship works correctly
    */
    @isTest
    public static void testNoValidSettingsConfig() {
        setupRelationshipTestData(new Hierarchy_Settings__c(Reciprocal_Method__c = 'BAD_VALUE'));

        List<Relationship__c> crel = new List<Relationship__c>{
            new Relationship__c(Contact__c = c1.Id, RelatedContact__c = c2.Id, Type__c = 'BuddiesFriends')
        };

        Test.startTest();
        insert crel;
        Test.stopTest();

        // check that rel gets created
        Relationship__c crel_original = [SELECT Id, Description__c, Type__c, ReciprocalRelationship__c FROM Relationship__c WHERE Id = :crel[0].Id];
        //relationship should be set right
        system.assertEquals(crel_original.Type__c, 'BuddiesFriends');

        // check for mirror rel
        Relationship__c crel_mirror = [SELECT Id, Description__c, ReciprocalRelationship__c, Type__c FROM Relationship__c WHERE ReciprocalRelationship__c = :crel_original.Id];
        //mirror should reference the original
        system.assertEquals(crel_mirror.ReciprocalRelationship__c, crel_original.Id);
        system.assertEquals('BuddiesFriends', crel_mirror.Type__c);
    }

    /*********************************************************************************************************
    * @description Test male contact (by salutation) gets male relationship type
    */
    @isTest
    public static void testMaleSalutationReciprocal() {
        setupRelationshipTestData(null);
        List<Relationship__c> crel = new List<Relationship__c>{
            new Relationship__c(Contact__c = c1.Id, RelatedContact__c = c2.Id, Type__c = 'TestLookupType')
        };

        Test.startTest();
        insert crel;
        Test.stopTest();

        Relationship__c recRel = [SELECT Id, Type__c FROM Relationship__c WHERE ReciprocalRelationship__c = :crel[0].Id];
        system.assertEquals('TestMaleType', recRel.Type__c);
    }

    /*********************************************************************************************************
    * @description Test female contact (by salutation) gets female relationship type
    */
    @isTest
    public static void testFemaleSalutationReciprocal() {
        setupRelationshipTestData(null);
        List<Relationship__c> crel = new List<Relationship__c>{
            new Relationship__c(Contact__c = c2.Id, RelatedContact__c = c1.Id, Type__c = 'TestLookupType')
        };

        Test.startTest();
        insert crel;
        Test.stopTest();

        Relationship__c recRel = [SELECT Id, Type__c FROM Relationship__c WHERE ReciprocalRelationship__c = :crel[0].Id];
        system.assertEquals('TestFemaleType', recRel.Type__c);
    }

    /*********************************************************************************************************
    * @description Test neutral contact (by salutation) gets neutral relationship type
    */
    @isTest
    public static void testNeutralSalutationReciprocal() {
        setupRelationshipTestData(null);
        List<Relationship__c> crel = new List<Relationship__c>{
            new Relationship__c(Contact__c = c3.Id, RelatedContact__c = c2.Id, Type__c = 'TestLookupType')
        };

        Test.startTest();
        insert crel;
        Test.stopTest();

        Relationship__c recRel = [SELECT Id, Type__c FROM Relationship__c WHERE ReciprocalRelationship__c = :crel[0].Id];
        system.assertEquals('TestNeutralType', recRel.Type__c);
    }

    /*********************************************************************************************************
    * @description Test neutral contact (by gender field) gets neutral relationship type
    */
    @isTest
    public static void testNeutralGenderFieldReciprocal() {
        setupRelationshipTestData(new Hierarchy_Settings__c(Reciprocal_Method__c = 'List Setting'));
        List<Relationship__c> crel = new List<Relationship__c>{
            new Relationship__c(Contact__c = c3.Id, RelatedContact__c = c2.Id, Type__c = 'TestLookupType')
        };
        c3.Gender__c = 'Neutral';
        update c3;

        Test.startTest();
        insert crel;
        Test.stopTest();

        Relationship__c recRel = [SELECT Id, Type__c FROM Relationship__c WHERE ReciprocalRelationship__c = :crel[0].Id];
        system.assertEquals('TestNeutralType', recRel.Type__c);
    }

    /*********************************************************************************************************
    * @description Test male contact (by gender field) gets male relationship type
    */
    @isTest
    public static void testMaleGenderFieldReciprocal() {
        setupRelationshipTestData(new Hierarchy_Settings__c(Reciprocal_Method__c = 'List Setting'));
        c1.Gender__c = 'Male';
        update c1;
        List<Relationship__c> crel = new List<Relationship__c>{
            new Relationship__c(Contact__c = c1.Id, RelatedContact__c = c2.Id, Type__c = 'TestLookupType')
        };

        Test.startTest();
        insert crel;
        Test.stopTest();

        Relationship__c recRel = [SELECT Id, Type__c FROM Relationship__c WHERE ReciprocalRelationship__c = :crel[0].Id];
        system.assertEquals('TestMaleType', recRel.Type__c);
    }

    /*********************************************************************************************************
    * @description Test female contact (by gender field) gets female relationship type
    */
    @isTest
    public static void testFemaleGenderFieldReciprocal() {
        setupRelationshipTestData(new Hierarchy_Settings__c(Reciprocal_Method__c = 'List Setting'));
        c2.Gender__c = 'Female';
        update c2;

        List<Relationship__c> crel = new List<Relationship__c>{
            new Relationship__c(Contact__c = c2.Id, RelatedContact__c = c2.Id, Type__c = 'TestLookupType')
        };

        Test.startTest();
        insert crel;
        Test.stopTest();

        Relationship__c recRel = [SELECT Id, Type__c FROM Relationship__c WHERE ReciprocalRelationship__c = :crel[0].Id];
        system.assertEquals('TestFemaleType', recRel.Type__c);
    }

    /*********************************************************************************************************
    * @description For two contacts with no gender, manually set a gendered relationship. Verify that it stays
    * and that the reciprocal gets the neutral type by default.
    */
    static testMethod void testNoGenderManualRel() {
        setupRelationshipTestData(new Hierarchy_Settings__c(Reciprocal_Method__c = 'List Setting'));

        list<Contact> conList = new list<Contact>{
            new Contact(LastName = 'foo'),
            new Contact(LastName = 'foo2')
        };
        insert conList;

        List<Relationship__c> crel = new List<Relationship__c>{
            new Relationship__c(Contact__c = conList[0].Id, RelatedContact__c = conList[1].Id, Type__c = 'TestLookupType')
        };

        Test.startTest();
        insert crel;
        Test.stopTest();

        Relationship__c recRel = [SELECT Id, Type__c FROM Relationship__c WHERE ReciprocalRelationship__c = :crel[0].Id];
        system.assertEquals('TestNeutralType', recRel.Type__c);

        recRel = [SELECT Id, Type__c FROM Relationship__c WHERE Id = :crel[0].Id];
        system.assertEquals('TestLookupType', recRel.Type__c);
    }

    /*********************************************************************************************************
    * @description For two contacts with no gender, manually set a gendered relationship. Change the status,
    * verify gendered relationship type hasn't changed, but that the status has changed.
    */
    static testMethod void testNoGenderManualRelStatusChange() {
        setupRelationshipTestData(new Hierarchy_Settings__c(Reciprocal_Method__c = 'List Setting'));

        list<Contact> conList = new list<Contact>{
            new Contact(LastName = 'foo'),
            new Contact(LastName = 'foo2')
        };
        insert conList;

        List<Relationship__c> crel = new List<Relationship__c>{
            new Relationship__c(Contact__c = conList[0].Id, RelatedContact__c = conList[1].Id, Type__c = 'TestMaleType')
        };

        Test.startTest();
        insert crel;
        Test.stopTest();

        Relationship__c recRel = [SELECT Id, Type__c FROM Relationship__c WHERE Id = :crel[0].Id];
        system.assertEquals('TestMaleType', recRel.Type__c);

        crel[0].Status__c = 'Former';
        update crel;

        recRel = [SELECT Id, Type__c FROM Relationship__c WHERE Id = :crel[0].Id];
        system.assertEquals('TestMaleType', recRel.Type__c);

        recRel = [SELECT Id, Status__c FROM Relationship__c WHERE ReciprocalRelationship__c = :crel[0].Id];
        system.assertEquals('Former', recRel.Status__c);

        crel[0].Status__c = 'Current';
        update crel;

        recRel = [SELECT Id, Type__c FROM Relationship__c WHERE Id = :crel[0].Id];
        system.assertEquals('TestMaleType', recRel.Type__c);

        recRel = [SELECT Id, Status__c FROM Relationship__c WHERE ReciprocalRelationship__c = :crel[0].Id];
        system.assertEquals('Current', recRel.Status__c);
    }

    /*********************************************************************************************************
    * @description For two contacts with an established relationship, change the gender field of one of the
    * contacts. Verify the relationship's type has changed per the changed gender, and that the reciprocal
    * hasn't changed.
    */
    static testMethod void testGenderChange() {
        setupRelationshipTestData(new Hierarchy_Settings__c(Reciprocal_Method__c = 'List Setting'));

        list<Contact> conList = new list<Contact>{
            new Contact(LastName = 'foo', Gender__c = 'Female'),
            new Contact(LastName = 'foo2', Gender__c = 'Male')
        };
        insert conList;

        List<Relationship__c> crel = new List<Relationship__c>{
            new Relationship__c(Contact__c = conList[0].Id, RelatedContact__c = conList[1].Id, Type__c = 'TestLookupType')
        };

        insert crel;

        Relationship__c recRel = [SELECT Id, Type__c FROM Relationship__c WHERE Id = :crel[0].Id];
        system.assertEquals('TestLookupType', recRel.Type__c);

        recRel = [SELECT Id, Type__c FROM Relationship__c WHERE ReciprocalRelationship__c = :crel[0].Id];
        system.assertEquals('TestFemaleType', recRel.Type__c);

        conList[1].Gender__c='Female';

        Test.startTest();
        update conList[1];
        Test.stopTest();

        recRel = [SELECT Id, Type__c FROM Relationship__c WHERE Id = :crel[0].Id];
        system.assertEquals('TestFemaleType', recRel.Type__c);

        recRel = [SELECT Id, Type__c FROM Relationship__c WHERE ReciprocalRelationship__c = :crel[0].Id];
        system.assertEquals('TestFemaleType', recRel.Type__c);
    }

    /*********************************************************************************************************
    * @description Test error record creation when inserting a relationship with a required field missing.
    */
    @isTest
    public static void testErrorRecordCreation() {
        setupRelationshipTestData(null);

        List<Relationship__c> relationships = new List<Relationship__c>{
            new Relationship__c(Contact__c = c2.Id, Type__c = 'TestLookupType')
        };

        Test.startTest();
        Database.SaveResult[] insertResults = Database.insert(relationships, false);
        Test.stopTest();

        // We catch errors here because TDTM_TriggerHandler no loger processes errors.
        ERR_Handler.Errors errors = ERR_Handler.getErrors(insertResults,relationships);
        ERR_Handler.processErrors(errors.errorRecords, ERR_Handler.Context.REL.name());

        //assert an error - Required fields are missing: [Contact__c]
        //Contact__c is missing from the reciprocal relationship that gets automatically created.
        system.assertEquals(1, [SELECT count() from Error__c]);

        //update relationship - this will create the missing Contact__c field
        relationships[0].RelatedContact__c = c1.Id;
        Database.SaveResult[] updateResults = Database.update(relationships, false);
        system.assertNotEquals(null, relationships[0].Contact__c);

        //get errors
        errors = ERR_Handler.getErrors(updateResults, (List<SObject>)relationships);
        //we still get an error, because of the Related_Contact_Do_Not_Change validation rule on Relationship
        system.assertEquals(true, errors.errorsExist);
        system.assertEquals(1, errors.errorRecords.size());

        //assert no additional error record was created on update
        system.assertEquals(1, [SELECT count() FROM Error__c]);
    }

    /*********************************************************************************************************
    * @description Test method throws an exception for relationships and verifies an error is logged.
    */
    @isTest
    public static void testExceptionRecordCreation() {
        setupRelationshipTestData(null);

        ERR_Handler.processError(new MyException('TestException'), ERR_Handler.Context.REL);
        List<Error__c> errors = [SELECT Full_Message__c FROM Error__c];
        System.assertEquals(1, errors.size());
        System.assertEquals('TestException', errors[0].Full_Message__c);
    }

    /*********************************************************************************************************
    * @description Method to test the UTIL_CustomSettingsFacade class as a different user
    */
    @isTest
    public static void testRelationshipUTILS() {
        //to test the Relationship_Utils class
        System.runAs(new User(Id = UserInfo.getUserId())) {
           Boolean cAuto = REL_Utils.hasContactAutoCreate;
           Boolean cmAuto = REL_Utils.hasCMAutoCreate;
           System.assertEquals(false, cAuto);
           System.assertEquals(false, cmAuto);
        }
    }

    /*********************************************************************************************************
    * @description Test method for inserting two relationships in a single transaction.
    */
    @isTest
    public static void test2Rels1Transaction_v2() {
         // Create three contacts
        Contact mainClient = new Contact(FirstName = 'Main', LastName = 'AAAClient');
        Contact friend = new Contact(FirstName = 'Test', LastName = 'AAAFriend');
        Contact coworker = new Contact(FirstName = 'Test', LastName = 'AAACoworker');
        insert new List<Contact> {mainClient, friend, coworker};

        // Create two relationships
        Relationship__c r1 = new Relationship__c(Contact__c = mainClient.Id, RelatedContact__c = friend.Id, Type__c = 'Friend');
        Relationship__c r2 = new Relationship__c(Contact__c = mainClient.Id, RelatedContact__c = coworker.Id, Type__c = 'Coworker');

        Test.startTest();
        insert new List<Relationship__c> {r1, r2};
        Test.stopTest();

        Relationship__c nr = [SELECT Id, ReciprocalRelationship__c FROM Relationship__c WHERE Id = :r1.Id];
        system.assert(nr.ReciprocalRelationship__c != null);

        Relationship__c nr2 = [SELECT Id, ReciprocalRelationship__c FROM Relationship__c WHERE Id = :r2.Id];
        system.assert(nr2.ReciprocalRelationship__c != null);

        list<Relationship__c> rels = new list<Relationship__c>();
        rels.add(new Relationship__c(Contact__c = mainClient.Id, RelatedContact__c = friend.Id, Type__c = 'Friend2'));
        rels.add(new Relationship__c(Contact__c = mainClient.Id, RelatedContact__c = coworker.Id, Type__c = 'Coworker2'));
        insert rels;
        list<Relationship__c> rels2 = [SELECT Id, ReciprocalRelationship__c FROM Relationship__c WHERE Id = :rels[0].Id OR Id = :rels[1].Id];
        system.assertEquals(2, rels2.size());
        system.assert(rels2[0].ReciprocalRelationship__c != null);
        system.assert(rels2[1].ReciprocalRelationship__c != null);

    }

    /*********************************************************************************************************
    * @description Test method for deleting relationship and reciprocal relationship in a single transaction.
    */
    @isTest
    public static void deleteRelationshipAndReciRelationship() {
        setupRelationshipTestData(null);

        Relationship__c rel = new Relationship__c(Contact__c = c1.Id, relatedContact__c = c2.Id, Type__c = 'Friend');
        insert rel;

        //After insert the relationship, system should create the reciprocal relationship. So, we should have two relationships in the system.
        List<Relationship__c> relList = [SELECT Id FROM Relationship__c];
        system.assertEquals(2, relList.size());

        //now we delete the relationships, this will include relationship we inserted and the corresponding reciprocal relationship
        Test.startTest();
        delete relList;
        Test.stopTest();

        //We should be able to delete all relationship without error
        List<Relationship__c> relRemaining = [SELECT Id FROM Relationship__c];
        system.assertEquals(0, relRemaining.size());
    }

    /*********************************************************************************************************
    * @description Exception
    */
    public class MyException extends Exception{}


    /*********************************************************************************************************
    * @description Test method for campaign member auto create relationships
    */
    @isTest
    public static void testAutoCreateCampaignMemberInsert() {
        setupRelationshipTestData(null);

        //Insert a campaign
        Campaign campaign = new Campaign(Name = 'TestCampaign', IsActive = true, Type = 'Other');
        insert campaign;

        //Insert a campaign member
        CampaignMember cm = new CampaignMember(ContactId = c2.Id, CampaignId = campaign.Id);
        Test.startTest();
        insert cm;
        Test.stopTest();

        //Verify a relationship was automatically created when the campaign member was created
        List<Relationship__c> relationships = [SELECT Id, Type__c FROM Relationship__c
                                        WHERE Contact__c = :c2.Id];
        UTIL_Debug.debug('****Number of relationships after creating campaign member: ' + relationships.size());
        system.assertEquals(2, relationships.size());
        system.assertEquals('TestType', relationships[0].Type__c);

        //Verify a reciprocal relationship was also automatically created when the campaign member was created
        List<Relationship__c> reciprocalRelationships = [SELECT Id, Type__c FROM Relationship__c
                                        WHERE ReciprocalRelationship__c = :relationships[0].Id];
        UTIL_Debug.debug('****Number of reciprocal relationships: ' + reciprocalRelationships);
        system.assertEquals(1, reciprocalRelationships.size());
        system.assertEquals('TestType', reciprocalRelationships[0].Type__c);
    }

    /*********************************************************************************************************
    * @description Test method for campaign member auto create relationships - synchronous
    */
    @isTest
    public static void testAutoCreateCampaignMemberInsertSynch() {
        setupRelationshipTestData(new Hierarchy_Settings__c(Reciprocal_Method__c = 'List Setting'));

        //insert a campaignmember
        Campaign c = new Campaign(Name = 'TestCampaign', IsActive = true, Type = 'Other');
        insert c;
        CampaignMember cm = new CampaignMember(ContactId = c2.Id, CampaignId = c.Id);

        Test.startTest();
        insert cm;
        Test.stopTest();

        Relationship__c rel = [SELECT Id, Type__c FROM Relationship__c WHERE Contact__c = :c2.Id LIMIT 1];
        system.assertEquals('TestType', rel.Type__c);
        Relationship__c recRel = [SELECT Id, Type__c FROM Relationship__c WHERE ReciprocalRelationship__c = :rel.Id];
        system.assertEquals('TestType', recRel.Type__c);
    }

    /*********************************************************************************************************
    * @description Test method for verifying automatic relationship creation won't create a duplicate.
    */
    @isTest
    public static void testAutoCreateDupePrevention() {
        setupRelationshipTestData(null);

        List<Relationship__c> crel = new List<Relationship__c>{
            new Relationship__c(Contact__c = c1.Id, RelatedContact__c = c2.Id, Type__c = 'TestType')
        };
        crel.add(new Relationship__c(Contact__c = c1.Id, RelatedContact__c = c2.Id, Type__c = 'TestType2'));
        insert crel;

        //update the ReportsToId to trigger autocreation
        c1.ReportsToId = c2.Id;

        Test.startTest();
        update c1;
        Test.stopTest();

        //assert we only have one relationship since we've deduped the auto-created one
        List<Relationship__c> rel = [SELECT Id, Type__c, RelatedContact__c FROM Relationship__c WHERE Contact__c = :c1.Id AND Type__c = 'TestType'];
        system.assertEquals('TestType', rel[0].Type__c);
        system.assertEquals(rel.size(), 1);
    }

    /*********************************************************************************************************
    * @description Test method for REL_Utils class when auto create settings exist
    */
    @isTest
    public static void testRelationshipUTILSAutoCreate() {
        System.runAs(new User(Id = UserInfo.getUserId())) {
            insert new Relationship_Auto_Create__c(Name = 'contacttest'+ system.now(),
                                                    Object__c = 'Contact', Field__c = 'coworker__c',
                                                    Relationship_Type__c = 'coworker',
                                                    Campaign_Types__c = 'fun event');
            insert new Relationship_Auto_Create__c(Name = 'membertest'+ system.now(),
                                                    Object__c = 'CampaignMember', Field__c = 'member__c',
                                                    Relationship_Type__c = 'member',
                                                    Campaign_Types__c = 'fun event');

            Boolean cAuto = REL_Utils.hasContactAutoCreate;
            Boolean cmAuto = REL_Utils.hasCMAutoCreate;
            System.assertEquals(true, cAuto);
            System.assertEquals(true, cmAuto);
        }
    }

}
public virtual with sharing class ReciprocalRelHealthCheckVMapper {

    /***************************************************************************
    * @description Instance for Singleton Pattern
    ******************************************************************************/
    @TestVisible
    private static ReciprocalRelHealthCheckVMapper instance;

    /***************************************************************************
    * @description Empty constructor is not public for Singleton Pattern
    ***************************************************************************/
    protected ReciprocalRelHealthCheckVMapper() {}

    /***************************************************************************
    * @description Static method to get the current instance for Singleton
    * pattern
    * @return The instance of ReciprocalRelHealthCheckVMapper.
    ***************************************************************************/
    public static ReciprocalRelHealthCheckVMapper getInstance() {

        if (instance == null) {
            instance = new ReciprocalRelHealthCheckVMapper();
        }

        return instance;
    }

    /***************************************************************************
    * @description Provides comprehensive Health Check Group View Model for
    * Reciprocal Relationship Settings
    * @return The Health Check Group View Model for Reciprocal Relationship
    * Settings
    ***************************************************************************/
    public virtual HealthCheckGroupVModel getHealthCheckGroup() {
        HealthCheckGroupVModel healthCheckGroupVModel = new HealthCheckGroupVModel(
            Label.stgHealthCheckReciprocalRelTitle,
            Label.stgHealthCheckStatusPassed,
            0,
            0,
            new List<String>(),
            new List<HealthCheckItemVModel>()
        );

        List<RelationshipLookupModel> relationshipLookupModelList =
            this.locateRelationshipLookupSettingsService(
            ).getRelationshipLookupModels();

        Map<String,PicklistEntryModel> picklistEntryModelByName =
            this.locatePicklistEntryService(
            ).getModelsByNameForSObjectField(
                Relationship__c.SObjectType,
                Relationship__c.Type__c
            );

        Set<String> duplicateMappingKeys = this.locateRelationshipLookupSettingsService(
            ).getDuplicateRelationshipModelNamesFromList(relationshipLookupModelList);

        for(RelationshipLookupModel relationshipLookupModel : relationshipLookupModelList) {
            HealthCheckGroupVModel relationshipLookupCheckResult =
                this.getRelationshipLookupHealthCheckGroup(
                    relationshipLookupModel,
                    picklistEntryModelByName,
                    duplicateMappingKeys
                );

            healthCheckGroupVModel.passedChecks += 
                relationshipLookupCheckResult.passedChecks;
            healthCheckGroupVModel.totalChecks += 
                relationshipLookupCheckResult.totalChecks;
            
            healthCheckGroupVModel.expandedRowsList.addAll(
                relationshipLookupCheckResult.expandedRowsList
            );
            healthCheckGroupVModel.healthCheckItemList.addAll(
                relationshipLookupCheckResult.healthCheckItemList
            );
        }

        if(healthCheckGroupVModel.passedChecks < healthCheckGroupVModel.totalChecks) {
            healthCheckGroupVModel.status = Label.stgHealthCheckStatusFailed;
        }

        healthCheckGroupVModel.healthCheckItemList.sort();

        return healthCheckGroupVModel;
    }

    /***************************************************************************
    * @description Retrieves the health check for an individual Relationship
    * Lookup Model 
    * @param relationshipLookupModel The relationship lookup model to perform
    * the health check on.
    * @param picklistEntryModelByName The picklist entry model map by value for
    * Relationship__c.Type__c
    * @param duplicateMappingKeys The set of duplicate relationship mapping key
    * values
    * @return The health check for an individual Relationship Lookup Model 
    ***************************************************************************/
    @TestVisible
    protected virtual HealthCheckGroupVModel getRelationshipLookupHealthCheckGroup(
        RelationshipLookupModel relationshipLookupModel,
        Map<String,PicklistEntryModel> picklistEntryModelByName,
        Set<String> duplicateMappingKeys
    ) {
        HealthCheckGroupVModel healthCheckGroupVModel = new HealthCheckGroupVModel(
            '',
            '',
            0,
            0,
            new List<String>(),
            new List<HealthCheckItemVModel>()
        );

        PicklistEntryModel picklistEntryModel =
            picklistEntryModelByName.get(relationshipLookupModel.name);

        HealthCheckItemVModel healthCheckItemVModel =
            this.getHealthCheckItemVModelForRelationshipLookupModel(
                relationshipLookupModel,
                picklistEntryModel
            );

        List<HealthCheckGroupVModel> healthCheckGroupVModelList =
            new List<HealthCheckGroupVModel>();

        healthCheckGroupVModelList.add(
            this.getNameHealthCheckGroup(
                relationshipLookupModel,
                picklistEntryModel
            )
        );
        healthCheckGroupVModelList.add(
            this.getFemaleHealthCheckGroup(
                relationshipLookupModel,
                picklistEntryModelByName
            )
        );
        healthCheckGroupVModelList.add(
            this.getMaleHealthCheckGroup(
                relationshipLookupModel,
                picklistEntryModelByName
            )
        );
        healthCheckGroupVModelList.add(
            this.getNeutralHealthCheckGroup(
                relationshipLookupModel,
                picklistEntryModelByName
            )
        );

        healthCheckGroupVModelList.add(
            this.getUniquenessHealthCheckGroup(
                relationshipLookupModel,
                picklistEntryModel,
                duplicateMappingKeys
            )
        );

        for(HealthCheckGroupVModel healthCheckGroupVModelItem : healthCheckGroupVModelList) {
            healthCheckGroupVModel.passedChecks += healthCheckGroupVModelItem.passedChecks;
            healthCheckGroupVModel.totalChecks += healthCheckGroupVModelItem.totalChecks;
            healthCheckGroupVModel.expandedRowsList.addAll(healthCheckGroupVModelItem.expandedRowsList);
            healthCheckItemVModel.healthCheckItemList.addAll(healthCheckGroupVModelItem.healthCheckItemList);
        }

        if(healthCheckGroupVModel.passedChecks < healthCheckGroupVModel.totalChecks) {
            healthCheckItemVModel.status = 'Fail';
            healthCheckItemVModel.statusLabel = Label.stgHealthCheckStatusFailed;
            healthCheckGroupVModel.expandedRowsList.add(relationshipLookupModel.name);
        }

        healthCheckItemVModel.healthCheckItemList.sort();

        healthCheckGroupVModel.healthCheckItemList.add(healthCheckItemVModel);

        return healthCheckGroupVModel;
    }

    /***************************************************************************
    * @description Retrieves the health check for the Relationship Lookup Model
    * Name
    * @param relationshipLookupModel The relationship lookup model to perform
    * the health check on.
    * @param picklistEntryModel The picklist entry model for the Relationship
    * Lookup Model Name
    * @return The health check for the Relationship Lookup Model Name
    ***************************************************************************/
    @TestVisible
    protected virtual HealthCheckGroupVModel getNameHealthCheckGroup(
        RelationshipLookupModel relationshipLookupModel,
        PicklistEntryModel picklistEntryModel
    ) {
        return this.getHealthCheckGroupForPicklistSetting(
            picklistEntryModel,
            relationshipLookupModel.name,
            '01',
            Label.stgHCReciprocalRelNameTitle,
            Label.stgHCReciprocalRelNameNotFoundFix,
            Label.stgHCReciprocalRelNameInactiveFix
        );
    }

    /***************************************************************************
    * @description Retrieves the health check for the Relationship Lookup Model
    * Female Value
    * @param relationshipLookupModel The relationship lookup model to perform
    * the health check on.
    * @param picklistEntryModelByName The picklist entry model map by value for
    * Relationship__c.Type__c
    * @return The health check for the Relationship Lookup Model Female Value
    ***************************************************************************/
    @TestVisible
    protected virtual HealthCheckGroupVModel getFemaleHealthCheckGroup(
        RelationshipLookupModel relationshipLookupModel,
        Map<String,PicklistEntryModel> picklistEntryModelByName
    ) {

        PicklistEntryModel picklistEntryModel =
            picklistEntryModelByName.get(relationshipLookupModel.femaleValue);

        return this.getHealthCheckGroupForPicklistSetting(
            picklistEntryModel,
            relationshipLookupModel.femaleValue,
            '02',
            Label.stgHCReciprocalRelFemaleTitle,
            Label.stgHCReciprocalRelFemaleNotFoundFix,
            Label.stgHCReciprocalRelFemaleInactiveFix
        );
    }

    /***************************************************************************
    * @description Retrieves the health check for the Relationship Lookup Model
    * Male Value
    * @param relationshipLookupModel The relationship lookup model to perform
    * the health check on.
    * @param picklistEntryModelByName The picklist entry model map by value for
    * Relationship__c.Type__c
    * @return The health check for the Relationship Lookup Model Male Value
    ***************************************************************************/
    @TestVisible
    protected virtual HealthCheckGroupVModel getMaleHealthCheckGroup(
        RelationshipLookupModel relationshipLookupModel,
        Map<String,PicklistEntryModel> picklistEntryModelByName
    ) {
        PicklistEntryModel picklistEntryModel =
            picklistEntryModelByName.get(relationshipLookupModel.maleValue);

        return this.getHealthCheckGroupForPicklistSetting(
            picklistEntryModel,
            relationshipLookupModel.maleValue,
            '03',
            Label.stgHCReciprocalRelMaleTitle,
            Label.stgHCReciprocalRelMaleNotFoundFix,
            Label.stgHCReciprocalRelMaleInactiveFix
        );
    }

    /***************************************************************************
    * @description Retrieves the health check for the Relationship Lookup Model
    * Neutral Value
    * @param relationshipLookupModel The relationship lookup model to perform
    * the health check on.
    * @param picklistEntryModelByName The picklist entry model map by value for
    * Relationship__c.Type__c
    * @return The health check for the Relationship Lookup Model Neutral Value
    ***************************************************************************/
    @TestVisible
    protected virtual HealthCheckGroupVModel getNeutralHealthCheckGroup(
        RelationshipLookupModel relationshipLookupModel,
        Map<String,PicklistEntryModel> picklistEntryModelByName
    ) {
        PicklistEntryModel picklistEntryModel =
            picklistEntryModelByName.get(relationshipLookupModel.neutralValue);

        return this.getHealthCheckGroupForPicklistSetting(
            picklistEntryModel,
            relationshipLookupModel.neutralValue,
            '04',
            Label.stgHCReciprocalRelNeutralTitle,
            Label.stgHCReciprocalRelNeutralNotFoundFix,
            Label.stgHCReciprocalRelNeutralInactiveFix
        );
    }

    /***************************************************************************
    * @description Retrieves the health check for an arbitrary picklist entry
    * model
    * @param picklistEntryModel The picklist entry model to perform the check
    * against
    * @param relationshipLookupModelFieldValue The value from the relationship
    * lookup model to use for the key and label formatting
    * @param indexString The index to use for the key
    * @param settingsLabel The label for the setting of the Health Check
    * @param notFoundFix The fix label for when a picklist entry model is
    * unfound
    * @param inactiveFix The fix label for when a picklist entry model is
    * inactive
    * @return The health check for the picklist entry model
    ***************************************************************************/
    @TestVisible
    protected virtual HealthCheckGroupVModel getHealthCheckGroupForPicklistSetting(
        PicklistEntryModel picklistEntryModel,
        String relationshipLookupModelFieldValue,
        String indexString,
        String settingsLabel,
        String notFoundFix,
        String inactiveFix
    ) {
        HealthCheckGroupVModel healthCheckGroupVModel = new HealthCheckGroupVModel(
            '',
            '',
            0,
            0,
            new List<String>(),
            new List<HealthCheckItemVModel>()
        );
    
        List<String> modelNameListForFormat =
            new List<String>{relationshipLookupModelFieldValue};
    
        String key = relationshipLookupModelFieldValue + indexString;
    
        HealthCheckItemVModel healthCheckItemVModel =
            new healthCheckItemVModel(
                key,
                settingsLabel,
                'Fail',
                Label.stgHealthCheckStatusFailed,
                this.locateStringHandlingService().formatStringWithApostrophesAndParameters(
                    Label.stgHCPicklistValueNotFound,
                    modelNameListForFormat
                ),
                this.locateStringHandlingService().formatStringWithApostrophesAndParameters(
                    notFoundFix,
                    modelNameListForFormat
                ),
                new List<HealthCheckItemVModel>()
            );
    
        healthCheckGroupVModel.totalChecks++;
        healthCheckGroupVModel.healthCheckItemList.add(healthCheckItemVModel);
    
        if(picklistEntryModel == null) {
            return healthCheckGroupVModel;
        }
    
        List<String> picklistLabelAndNameForFormat =
            new List<String>{picklistEntryModel.label,picklistEntryModel.name};
    
        if(picklistEntryModel.isActive == false) {
            healthCheckItemVModel.description =
                this.locateStringHandlingService().formatStringWithApostrophesAndParameters(
                    Label.stgHCPicklistValueInactive, 
                    picklistLabelAndNameForFormat
                );
            healthCheckItemVModel.recommendedFix = 
                this.locateStringHandlingService().formatStringWithApostrophesAndParameters(
                    inactiveFix, 
                    picklistLabelAndNameForFormat
                );
            return healthCheckGroupVModel;
        }
    
        healthCheckItemVModel.status = 'Pass';
        healthCheckItemVModel.statusLabel = Label.stgHealthCheckStatusPassed;
        healthCheckItemVModel.description = this.locateStringHandlingService().formatStringWithApostrophesAndParameters(
                Label.stgHCPicklistValueValid,
                picklistLabelAndNameForFormat
            );
        healthCheckItemVModel.recommendedFix = Label.stgHealthCheckFixNotApplicable;
    
        healthCheckGroupVModel.passedChecks++;
    
        return healthCheckGroupVModel;
    }

    /***************************************************************************
    * @description Retrieves the health check for the Relationship Lookup Model
    * Name Uniqueness
    * @param relationshipLookupModel The relationship lookup model to perform
    * the health check on.
    * @param picklistEntryModelByName The picklist entry model map by value for
    * Relationship__c.Type__c
    * @param duplicateMappingKeys The set of duplicate relationship mapping key
    * values
    * @return The health check for the Relationship Lookup Model Name Uniqueness
    ***************************************************************************/
    @TestVisible
    protected virtual HealthCheckGroupVModel getUniquenessHealthCheckGroup(
        RelationshipLookupModel relationshipLookupModel,
        PicklistEntryModel picklistEntryModel,
        Set<String> duplicateNameSet
    ) {
        HealthCheckGroupVModel healthCheckGroupVModel = new HealthCheckGroupVModel(
            '',
            '',
            0,
            0,
            new List<String>(),
            new List<HealthCheckItemVModel>()
        );
    
        List<String> modelNameListForFormat =
            new List<String>{relationshipLookupModel.name,relationshipLookupModel.name};

        if(picklistEntryModel != null) {
            modelNameListForFormat =
                new List<String>{picklistEntryModel.label,picklistEntryModel.name};
        }
    
        String key = relationshipLookupModel.name + '05';
    
        HealthCheckItemVModel healthCheckItemVModel =
            new healthCheckItemVModel(
                key,
                Label.stgHCReciprocalRelNameUniqueTitle,
                'Fail',
                Label.stgHealthCheckStatusFailed,
                this.locateStringHandlingService().formatStringWithApostrophesAndParameters(
                    Label.stgHCReciprocalRelNameNotUniqueDesc,
                    modelNameListForFormat
                ),
                this.locateStringHandlingService().formatStringWithApostrophesAndParameters(
                    Label.stgHCReciprocalRelNameNotUniqueFix,
                    modelNameListForFormat
                ),
                new List<HealthCheckItemVModel>()
            );
    
        healthCheckGroupVModel.totalChecks++;
        healthCheckGroupVModel.healthCheckItemList.add(healthCheckItemVModel);
    
        if(duplicateNameSet.contains(relationshipLookupModel.name)) {
            return healthCheckGroupVModel;
        }
    
        healthCheckItemVModel.status = 'Pass';
        healthCheckItemVModel.statusLabel = Label.stgHealthCheckStatusPassed;
        healthCheckItemVModel.description = this.locateStringHandlingService().formatStringWithApostrophesAndParameters(
                Label.stgHCReciprocalRelNameUniqueDesc,
                modelNameListForFormat
            );
        healthCheckItemVModel.recommendedFix = Label.stgHealthCheckFixNotApplicable;
    
        healthCheckGroupVModel.passedChecks++;
    
        return healthCheckGroupVModel;
    }

    /***************************************************************************
    * @description Retrieves a formatted HealthCheckItemVModel. 
    * @return A formatted HealthCheckItemVModel.
    ***************************************************************************/
    @TestVisible
    protected virtual HealthCheckItemVModel getHealthCheckItemVModelForRelationshipLookupModel(
        RelationshipLookupModel relationshipLookupModel,
        PicklistEntryModel picklistEntryModel
    ){
        String picklistEntryModelName = relationshipLookupModel.name;

        if(picklistEntryModel != null) {
            picklistEntryModelName = picklistentryModel.name;
        }

        List<String> listForSettingsLabel =
            new List<String>{relationshipLookupModel.name};
        List<String> listForDescriptionLabel =
            new List<String>{relationshipLookupModel.name,picklistEntryModelName};

        return new HealthCheckItemVModel(
            relationshipLookupModel.name,
            this.locateStringHandlingService().formatStringWithApostrophesAndParameters(Label.stgHCReciprocalRelSetting,listForSettingsLabel),
            'Pass',
            Label.stgHealthCheckStatusPassed,
            '',
            '',
            new List<HealthCheckItemVModel>()
        );
    }

    /***************************************************************************
    * @description Retrieves an instance of PicklistEntryService. 
    * @return An instance of PicklistEntryService.
    ***************************************************************************/
    @TestVisible
    private PicklistEntryService locatePicklistEntryService(){
        return PicklistEntryService.getInstance();
    }

    /***************************************************************************
    * @description Retrieves an instance of RelationshipLookupSettingsService. 
    * @return An instance of RelationshipLookupSettingsService.
    ***************************************************************************/
    @TestVisible
    private RelationshipLookupSettingsService locateRelationshipLookupSettingsService(){
        return RelationshipLookupSettingsService.getInstance();
    }

    /***************************************************************************
    * @description Retrieves an instance of StringHandlingService. 
    * @return An instance of StringHandlingService.
    ***************************************************************************/
    @TestVisible
    private StringHandlingService locateStringHandlingService(){
        return StringHandlingService.getInstance();
    }
}
@isTest
private class ReciprocalRelHealthCheckVMapper_TEST {

    /***************************************************************************
    *******************************INSTANCE*************************************
    ***************************************************************************/

    /***************************************************************************
    * @description Test method to verify that the getInstance method returns a
    * new instance of the ReciprocalRelHealthCheckVMapper class when one does
    * not already exist.
    ***************************************************************************/
    @isTest
    private static void getInstanceNew() {

        Test.startTest();
        ReciprocalRelHealthCheckVMapper reciprocalRelHealthCheckVMapperInstance =
            ReciprocalRelHealthCheckVMapper.getInstance();
        Test.stopTest();

        System.assertNotEquals(
            null,
            reciprocalRelHealthCheckVMapperInstance,
            'Instance of view model mapper class should not be null.'
        );

        System.assertEquals(
            ReciprocalRelHealthCheckVMapper.instance,
            reciprocalRelHealthCheckVMapperInstance,
            'Instance of view model mapper class returned should match static instance variable.'
        );
    }

    /***************************************************************************
    * @description Test method to verify that the getInstance method returns the
    * existing instance of the ReciprocalRelHealthCheckVMapper class when one
    * already exists.
    ***************************************************************************/
    @isTest
    private static void getInstanceExisting() {
        ReciprocalRelHealthCheckVMapper expectedReciprocalRelHealthCheckVMapperInstance =
            ReciprocalRelHealthCheckVMapper.getInstance();

        Test.startTest();
            ReciprocalRelHealthCheckVMapper reciprocalRelHealthCheckVMapperInstance =
                ReciprocalRelHealthCheckVMapper.getInstance();
        Test.stopTest();

        System.assertEquals(
            expectedReciprocalRelHealthCheckVMapperInstance,
            reciprocalRelHealthCheckVMapperInstance,
            'Instance of mapper class returned should match cached value.'
        );
    }

    /***************************************************************************
    *************************HEALTH CHECK GROUP/ITEM****************************
    ***************************************************************************/

    /***************************************************************************
    * @description Test method to verify that getHealthCheckGroup handles all
    * passed health checks
    ***************************************************************************/
    @isTest
    private static void getHealthCheckGroupAllPassed() {
        RelationshipLookupSettingsService.instance = 
            new STUB_RelationshipLookupSettingsService();
        PicklistEntryService.instance =
            new STUB_PicklistEntryService();

        STUB_ReciprocalRelHealthCheckVMapper reciprocalRelHealthCheckVMapperStub =
            new STUB_ReciprocalRelHealthCheckVMapper();
        ReciprocalRelHealthCheckVMapper.instance = reciprocalRelHealthCheckVMapperStub;  

        ReciprocalRelHealthCheckVMapper reciprocalRelHealthCheckVMapper =
            ReciprocalRelHealthCheckVMapper.getInstance();

        Integer numberOfHealthChecks = 1;

        Test.startTest();
            HealthCheckGroupVModel healthCheckGroupVModel =
                reciprocalRelHealthCheckVMapperStub.getHealthCheckGroup();
        Test.stopTest();

        System.assertEquals(
            Label.stgHealthCheckReciprocalRelTitle,
            healthCheckGroupVModel.label,
            'Label of returned health check should match expected custom label.'
        );
        System.assertEquals(
            Label.stgHealthCheckStatusPassed,
            healthCheckGroupVModel.status,
            'Status of returned health check should match expected custom label.'
        );
        System.assertEquals(
            numberOfHealthChecks,
            healthCheckGroupVModel.passedChecks,
            'Number of passed checks of returned health check should match expected custom label.'
        );
        System.assertEquals(
            numberOfHealthChecks,
            healthCheckGroupVModel.totalChecks,
            'Number of total checks of returned health check should match expected custom label.'
        );
        System.assertEquals(
            0,
            healthCheckGroupVModel.expandedRowsList.size(),
            'No health checks should fail, making expanded rows list size 0.'
        );
        System.assertEquals(
            1,
            healthCheckGroupVModel.healthCheckItemList.size(),
            'Number of health check items of returned health check should be 1.'
        );
    }

    /***************************************************************************
    * @description Test method to verify that getHealthCheckGroup handles all
    * passed health checks
    ***************************************************************************/
    @isTest
    private static void getHealthCheckGroupAllFail() {
        RelationshipLookupSettingsService.instance = 
            new STUB_RelationshipLookupSettingsUnfound();
        PicklistEntryService.instance =
            new STUB_PicklistEntryService();

        STUB_ReciprocalRelHealthCheckVMapper reciprocalRelHealthCheckVMapperStub =
            new STUB_ReciprocalRelHealthCheckVMapper();
        ReciprocalRelHealthCheckVMapper.instance = reciprocalRelHealthCheckVMapperStub;  

        ReciprocalRelHealthCheckVMapper reciprocalRelHealthCheckVMapper =
            ReciprocalRelHealthCheckVMapper.getInstance();

        Integer numberOfHealthChecks = 1;

        Test.startTest();
            HealthCheckGroupVModel healthCheckGroupVModel =
            reciprocalRelHealthCheckVMapper.getHealthCheckGroup();
        Test.stopTest();

        System.assertEquals(
            Label.stgHealthCheckReciprocalRelTitle,
            healthCheckGroupVModel.label,
            'Label of returned health check should match expected custom label.'
        );
        System.assertEquals(
            Label.stgHealthCheckStatusFailed,
            healthCheckGroupVModel.status,
            'Status of returned health check should match expected custom label.'
        );
        System.assertEquals(
            0,
            healthCheckGroupVModel.passedChecks,
            'Number of passed checks should be 0.'
        );
        System.assertEquals(
            numberOfHealthChecks,
            healthCheckGroupVModel.totalChecks,
            'Number of total checks of returned health check should match expected custom label.'
        );
        System.assertEquals(
            1,
            healthCheckGroupVModel.expandedRowsList.size(),
            'All health checks should fail, making expanded rows list size 1.'
        );
        System.assertEquals(
            1,
            healthCheckGroupVModel.healthCheckItemList.size(),
            'Number of health check items of returned health check should be 1.'
        );
    }

    /***************************************************************************
    * @description Test method to verify that
    * getRelationshipLookupHealthCheckGroup returns the expected passed health
    * check
    ***************************************************************************/
    @isTest
    private static void getRelationshipLookupHealthCheckGroupPass() {
        STUB_RelationshipLookupSettingsService relationshipLookupSettingsServiceStub =
            new STUB_RelationshipLookupSettingsService();
        STUB_PicklistEntryService picklistEntryServiceStub =
            new STUB_PicklistEntryService();

        ReciprocalRelHealthCheckVMapper.instance =
            new STUB_ReciprocalRelHealthCheckVMapperSub();

        ReciprocalRelHealthCheckVMapper reciprocalRelHealthCheckVMapper =
            ReciprocalRelHealthCheckVMapper.getInstance();
 
        List<RelationshipLookupModel> relationshipLookupModelList =
            relationshipLookupSettingsServiceStub.getRelationshipLookupModels();

        Map<String,PicklistEntryModel> picklistEntryModelByName =
            picklistEntryServiceStub.getModelsByNameForSObjectField(
                Relationship__c.SObjectType,
                Relationship__c.Type__c
            );

        Set<String> duplicateMappingKeys = new Set<String>();

        Integer numberOfHealthChecks = 5;

        Test.startTest();
            HealthCheckGroupVModel healthCheckGroupVModel =
                reciprocalRelHealthCheckVMapper.getRelationshipLookupHealthCheckGroup(
                    relationshipLookupModelList[0],
                    picklistEntryModelByName,
                    duplicateMappingKeys
                );
        Test.stopTest();

        System.assertEquals(
            '',
            healthCheckGroupVModel.label,
            'Label should equal expected value of blank'
        );
        System.assertEquals(
            '',
            healthCheckGroupVModel.status,
            'Status should equal expected value of blank'
        );
        System.assertEquals(
            numberOfHealthChecks,
            healthCheckGroupVModel.passedChecks,
            'Passed checks should equal expected value of ' + numberOfHealthChecks
        );
        System.assertEquals(
            numberOfHealthChecks,
            healthCheckGroupVModel.totalChecks,
            'Total checks should equal expected value of ' + numberOfHealthChecks
        );
        System.assertEquals(
            0,
            healthCheckGroupVModel.expandedRowsList.size(),
            'Expanded rows list should have a size of 0'
        );
        System.assertEquals(
            1,
            healthCheckGroupVModel.healthCheckItemList.size(),
            'Health Check Item list should have a size of 1'
        );
    }

    /***************************************************************************
    * @description Test method to verify that
    * getRelationshipLookupHealthCheckGroup returns the expected failed health
    * check
    ***************************************************************************/
    @isTest
    private static void getRelationshipLookupHealthCheckGroupFail() {
        RelationshipLookupSettingsService.instance = 
            new STUB_RelationshipLookupSettingsService();
        PicklistEntryService.instance =
            new STUB_PicklistEntryService();

        ReciprocalRelHealthCheckVMapper.instance =
            new STUB_ReciprocalRelHealthCheckVMapperSub();  
        ReciprocalRelHealthCheckVMapper reciprocalRelHealthCheckVMapper =
            ReciprocalRelHealthCheckVMapper.getInstance();
 
        List<RelationshipLookupModel> relationshipLookupModelList =
            reciprocalRelHealthCheckVMapper.locateRelationshipLookupSettingsService(
            ).getRelationshipLookupModels();

        Map<String,PicklistEntryModel> picklistEntryModelByName =
            new Map<String,PicklistEntryModel>();

        Set<String> duplicateMappingKeys = new Set<String>();

        Integer numberOfHealthChecks = 5;

        Test.startTest();
            HealthCheckGroupVModel healthCheckGroupVModel =
                reciprocalRelHealthCheckVMapper.getRelationshipLookupHealthCheckGroup(
                    relationshipLookupModelList[0],
                    picklistEntryModelByName,
                    duplicateMappingKeys
                );
        Test.stopTest();

        System.assertEquals(
            '',
            healthCheckGroupVModel.label,
            'Label should equal expected value of blank'
        );
        System.assertEquals(
            '',
            healthCheckGroupVModel.status,
            'Status should equal expected value of blank'
        );
        System.assertEquals(
            0,
            healthCheckGroupVModel.passedChecks,
            'Passed checks should equal expected value of 0'
        );
        System.assertEquals(
            numberOfHealthChecks,
            healthCheckGroupVModel.totalChecks,
            'Total checks should equal expected value of ' + numberOfHealthChecks
        );
        System.assertEquals(
            1,
            healthCheckGroupVModel.expandedRowsList.size(),
            'Expanded rows list should have a size of 1'
        );
        System.assertEquals(
            1,
            healthCheckGroupVModel.healthCheckItemList.size(),
            'Health Check Item list should have a size of 1'
        );
    }

    /***************************************************************************
    **********************************NAME**************************************
    ***************************************************************************/

    /***************************************************************************
    * @description Test method to verify that getNameHealthCheckGroup
    * passes with an active picklist entry model for its relationship model's
    * name
    ***************************************************************************/
    @isTest
    private static void getNameHealthCheckGroupPass() {
        ReciprocalRelHealthCheckVMapper reciprocalRelHealthCheckVMapper =
            ReciprocalRelHealthCheckVMapper.getInstance();

        RelationshipLookupModel relationshipLookupModel = 
            new RelationshipLookupModel(
                'testvalue',
                true,
                'testfemalevalue',
                'testmalevalue',
                'testneutralvalue'
            );

        PicklistEntryModel picklistEntryModel = new PicklistEntryModel(
            'testvalue',
            'testlabel',
            true
        );

        Test.startTest();
            HealthCheckGroupVModel healthCheckGroupVModel =
                reciprocalRelHealthCheckVMapper.getNameHealthCheckGroup(
                    relationshipLookupModel,
                    picklistEntryModel
                );
        Test.stopTest();

        ReciprocalRelHealthCheckVMapper_TEST.healthCheckAssertionHelper(
            picklistEntryModel,
            healthCheckGroupVModel,
            1,
            relationshipLookupModel.name,
            '01',
            Label.stgHCReciprocalRelNameTitle,
            'Pass',
            Label.stgHealthCheckStatusPassed,
            Label.stgHCPicklistValueValid,
            Label.stgHealthCheckFixNotApplicable
        );
    }

    /***************************************************************************
    * @description Test method to verify that getNameHealthCheckGroupPass fails
    * with an inactive picklist entry model for its relationship model's name
    ***************************************************************************/
    @isTest
    private static void getNameHealthCheckGroupInactive() {
        ReciprocalRelHealthCheckVMapper reciprocalRelHealthCheckVMapper =
            ReciprocalRelHealthCheckVMapper.getInstance();

        RelationshipLookupModel relationshipLookupModel = 
            new RelationshipLookupModel(
                'testvalue',
                true,
                'testfemalevalue',
                'testmalevalue',
                'testneutralvalue'
            );

        PicklistEntryModel picklistEntryModel = new PicklistEntryModel(
            'testvalue',
            'testlabel',
            false
        );

        Test.startTest();
            HealthCheckGroupVModel healthCheckGroupVModel =
                reciprocalRelHealthCheckVMapper.getNameHealthCheckGroup(
                    relationshipLookupModel,
                    picklistEntryModel
                );
        Test.stopTest();

        ReciprocalRelHealthCheckVMapper_TEST.healthCheckAssertionHelper(
            picklistEntryModel,
            healthCheckGroupVModel,
            0,
            relationshipLookupModel.name,
            '01',
            Label.stgHCReciprocalRelNameTitle,
            'Fail',
            Label.stgHealthCheckStatusFailed,
            Label.stgHCPicklistValueInactive,
            Label.stgHCReciprocalRelNameInactiveFix
        );               
    }

    /***************************************************************************
    * @description Test method to verify that getNameHealthCheckGroupPass fails
    * with an unfound picklist entry model for its relationship model's name
    ***************************************************************************/
    @isTest
    private static void getNameHealthCheckGroupNotFound() {
        ReciprocalRelHealthCheckVMapper reciprocalRelHealthCheckVMapper =
            ReciprocalRelHealthCheckVMapper.getInstance();

        RelationshipLookupModel relationshipLookupModel = 
            new RelationshipLookupModel(
                'testvalue',
                true,
                'testfemalevalue',
                'testmalevalue',
                'testneutralvalue'
            );

        Test.startTest();
            HealthCheckGroupVModel healthCheckGroupVModel =
                reciprocalRelHealthCheckVMapper.getNameHealthCheckGroup(
                    relationshipLookupModel,
                    null
                );
        Test.stopTest();

        ReciprocalRelHealthCheckVMapper_TEST.healthCheckAssertionHelper(
            null,
            healthCheckGroupVModel,
            0,
            relationshipLookupModel.name,
            '01',
            Label.stgHCReciprocalRelNameTitle,
            'Fail',
            Label.stgHealthCheckStatusFailed,
            Label.stgHCPicklistValueNotFound,
            Label.stgHCReciprocalRelNameNotFoundFix
        );
    }

    /***************************************************************************
    *********************************FEMALE*************************************
    ***************************************************************************/

    /***************************************************************************
    * @description Test method to verify that getFemaleHealthCheckGroup
    * passes with an active picklist entry model for its relationship model's
    * female value
    ***************************************************************************/
    @isTest
    private static void getFemaleHealthCheckGroupPass() {
        STUB_PicklistEntryService picklistEntryServiceStub =
            new STUB_PicklistEntryService();

        ReciprocalRelHealthCheckVMapper reciprocalRelHealthCheckVMapper =
            ReciprocalRelHealthCheckVMapper.getInstance();

        Map<String,PicklistEntryModel> picklistEntryModelByName =
            picklistEntryServiceStub.getModelsByNameForSObjectField(
                Relationship__c.SObjectType,
                Relationship__c.Type__c
            );

        RelationshipLookupModel relationshipLookupModel = 
            new RelationshipLookupModel(
                'testvalue',
                true,
                'testfemalevalue',
                'testmalevalue',
                'testneutralvalue'
            );

        Test.startTest();
            HealthCheckGroupVModel healthCheckGroupVModel =
                reciprocalRelHealthCheckVMapper.getFemaleHealthCheckGroup(
                    relationshipLookupModel,
                    picklistEntryModelByName
                );
        Test.stopTest();

        ReciprocalRelHealthCheckVMapper_TEST.healthCheckAssertionHelper(
            picklistEntryModelByName.get('testfemalevalue'),
            healthCheckGroupVModel,
            1,
            relationshipLookupModel.femaleValue,
            '02',
            Label.stgHCReciprocalRelFemaleTitle,
            'Pass',
            Label.stgHealthCheckStatusPassed,
            Label.stgHCPicklistValueValid,
            Label.stgHealthCheckFixNotApplicable
        );
    }

    /***************************************************************************
    * @description Test method to verify that getFemaleHealthCheckGroupPass
    * fails with an inactive picklist entry model for its relationship model's
    * female value
    ***************************************************************************/
    @isTest
    private static void getFemaleHealthCheckGroupInactive() {
        STUB_PicklistEntryServiceInactive picklistEntryServiceStub =
            new STUB_PicklistEntryServiceInactive();

        ReciprocalRelHealthCheckVMapper reciprocalRelHealthCheckVMapper =
            ReciprocalRelHealthCheckVMapper.getInstance();

        Map<String,PicklistEntryModel> picklistEntryModelByName =
            picklistEntryServiceStub.getModelsByNameForSObjectField(
                Relationship__c.SObjectType,
                Relationship__c.Type__c
            );

        RelationshipLookupModel relationshipLookupModel = 
            new RelationshipLookupModel(
                'testvalue',
                true,
                'testfemalevalue',
                'testmalevalue',
                'testneutralvalue'
            );

        Test.startTest();
            HealthCheckGroupVModel healthCheckGroupVModel =
                reciprocalRelHealthCheckVMapper.getFemaleHealthCheckGroup(
                    relationshipLookupModel,
                    picklistEntryModelByName
                );
        Test.stopTest();

        ReciprocalRelHealthCheckVMapper_TEST.healthCheckAssertionHelper(
            picklistEntryModelByName.get('testfemalevalue'),
            healthCheckGroupVModel,
            0,
            relationshipLookupModel.femaleValue,
            '02',
            Label.stgHCReciprocalRelFemaleTitle,
            'Fail',
            Label.stgHealthCheckStatusFailed,
            Label.stgHCPicklistValueInactive,
            Label.stgHCReciprocalRelFemaleInactiveFix
        );               
    }

    /***************************************************************************
    * @description Test method to verify that getFemaleHealthCheckGroupPass
    * fails with an unfound picklist entry model for its relationship model's
    * female value
    ***************************************************************************/
    @isTest
    private static void getFemaleHealthCheckGroupNotFound() {
        ReciprocalRelHealthCheckVMapper reciprocalRelHealthCheckVMapper =
            ReciprocalRelHealthCheckVMapper.getInstance();

        RelationshipLookupModel relationshipLookupModel = 
            new RelationshipLookupModel(
                'testvalue',
                true,
                'testfemalevalue',
                'testmalevalue',
                'testneutralvalue'
            );

        Test.startTest();
            HealthCheckGroupVModel healthCheckGroupVModel =
                reciprocalRelHealthCheckVMapper.getFemaleHealthCheckGroup(
                    relationshipLookupModel,
                    new Map<String,PicklistEntryModel>()
                );
        Test.stopTest();

        ReciprocalRelHealthCheckVMapper_TEST.healthCheckAssertionHelper(
            null,
            healthCheckGroupVModel,
            0,
            relationshipLookupModel.femaleValue,
            '02',
            Label.stgHCReciprocalRelFemaleTitle,
            'Fail',
            Label.stgHealthCheckStatusFailed,
            Label.stgHCPicklistValueNotFound,
            Label.stgHCReciprocalRelFemaleNotFoundFix
        );
    }

    /***************************************************************************
    **********************************MALE**************************************
    ***************************************************************************/

    /***************************************************************************
    * @description Test method to verify that getMaleHealthCheckGroup
    * passes with an active picklist entry model for its relationship model's
    * male value
    ***************************************************************************/
    @isTest
    private static void getMaleHealthCheckGroupPass() {
        STUB_PicklistEntryService picklistEntryServiceStub =
            new STUB_PicklistEntryService();

        ReciprocalRelHealthCheckVMapper reciprocalRelHealthCheckVMapper =
            ReciprocalRelHealthCheckVMapper.getInstance();

        Map<String,PicklistEntryModel> picklistEntryModelByName =
            picklistEntryServiceStub.getModelsByNameForSObjectField(
                Relationship__c.SObjectType,
                Relationship__c.Type__c
            );

        RelationshipLookupModel relationshipLookupModel = 
            new RelationshipLookupModel(
                'testvalue',
                true,
                'testmalevalue',
                'testmalevalue',
                'testneutralvalue'
            );

        Test.startTest();
            HealthCheckGroupVModel healthCheckGroupVModel =
                reciprocalRelHealthCheckVMapper.getMaleHealthCheckGroup(
                    relationshipLookupModel,
                    picklistEntryModelByName
                );
        Test.stopTest();

        ReciprocalRelHealthCheckVMapper_TEST.healthCheckAssertionHelper(
            picklistEntryModelByName.get('testmalevalue'),
            healthCheckGroupVModel,
            1,
            relationshipLookupModel.maleValue,
            '03',
            Label.stgHCReciprocalRelMaleTitle,
            'Pass',
            Label.stgHealthCheckStatusPassed,
            Label.stgHCPicklistValueValid,
            Label.stgHealthCheckFixNotApplicable
        );
    }

    /***************************************************************************
    * @description Test method to verify that getMaleHealthCheckGroupPass
    * fails with an inactive picklist entry model for its relationship model's
    * male value
    ***************************************************************************/
    @isTest
    private static void getMaleHealthCheckGroupInactive() {
        STUB_PicklistEntryServiceInactive picklistEntryServiceStub =
            new STUB_PicklistEntryServiceInactive();

        ReciprocalRelHealthCheckVMapper reciprocalRelHealthCheckVMapper =
            ReciprocalRelHealthCheckVMapper.getInstance();

        Map<String,PicklistEntryModel> picklistEntryModelByName =
            picklistEntryServiceStub.getModelsByNameForSObjectField(
                Relationship__c.SObjectType,
                Relationship__c.Type__c
            );

        RelationshipLookupModel relationshipLookupModel = 
            new RelationshipLookupModel(
                'testvalue',
                true,
                'testmalevalue',
                'testmalevalue',
                'testneutralvalue'
            );

        Test.startTest();
            HealthCheckGroupVModel healthCheckGroupVModel =
                reciprocalRelHealthCheckVMapper.getMaleHealthCheckGroup(
                    relationshipLookupModel,
                    picklistEntryModelByName
                );
        Test.stopTest();

        ReciprocalRelHealthCheckVMapper_TEST.healthCheckAssertionHelper(
            picklistEntryModelByName.get('testmalevalue'),
            healthCheckGroupVModel,
            0,
            relationshipLookupModel.maleValue,
            '03',
            Label.stgHCReciprocalRelMaleTitle,
            'Fail',
            Label.stgHealthCheckStatusFailed,
            Label.stgHCPicklistValueInactive,
            Label.stgHCReciprocalRelMaleInactiveFix
        );               
    }

    /***************************************************************************
    * @description Test method to verify that getMaleHealthCheckGroupPass
    * fails with an unfound picklist entry model for its relationship model's
    * male value
    ***************************************************************************/
    @isTest
    private static void getMaleHealthCheckGroupNotFound() {
        ReciprocalRelHealthCheckVMapper reciprocalRelHealthCheckVMapper =
            ReciprocalRelHealthCheckVMapper.getInstance();

        RelationshipLookupModel relationshipLookupModel = 
            new RelationshipLookupModel(
                'testvalue',
                true,
                'testmalevalue',
                'testmalevalue',
                'testneutralvalue'
            );

        Test.startTest();
            HealthCheckGroupVModel healthCheckGroupVModel =
                reciprocalRelHealthCheckVMapper.getMaleHealthCheckGroup(
                    relationshipLookupModel,
                    new Map<String,PicklistEntryModel>()
                );
        Test.stopTest();

        ReciprocalRelHealthCheckVMapper_TEST.healthCheckAssertionHelper(
            null,
            healthCheckGroupVModel,
            0,
            relationshipLookupModel.maleValue,
            '03',
            Label.stgHCReciprocalRelMaleTitle,
            'Fail',
            Label.stgHealthCheckStatusFailed,
            Label.stgHCPicklistValueNotFound,
            Label.stgHCReciprocalRelMaleNotFoundFix
        );
    }

    /***************************************************************************
    ********************************NEUTRAL*************************************
    ***************************************************************************/

    /***************************************************************************
    * @description Test method to verify that getNeutralHealthCheckGroup
    * passes with an active picklist entry model for its relationship model's
    * neutral value
    ***************************************************************************/
    @isTest
    private static void getNeutralHealthCheckGroupPass() {
        STUB_PicklistEntryService picklistEntryServiceStub =
            new STUB_PicklistEntryService();

        ReciprocalRelHealthCheckVMapper reciprocalRelHealthCheckVMapper =
            ReciprocalRelHealthCheckVMapper.getInstance();

        Map<String,PicklistEntryModel> picklistEntryModelByName =
            picklistEntryServiceStub.getModelsByNameForSObjectField(
                Relationship__c.SObjectType,
                Relationship__c.Type__c
            );

        RelationshipLookupModel relationshipLookupModel = 
            new RelationshipLookupModel(
                'testvalue',
                true,
                'testneutralvalue',
                'testmalevalue',
                'testneutralvalue'
            );

        Test.startTest();
            HealthCheckGroupVModel healthCheckGroupVModel =
                reciprocalRelHealthCheckVMapper.getNeutralHealthCheckGroup(
                    relationshipLookupModel,
                    picklistEntryModelByName
                );
        Test.stopTest();

        ReciprocalRelHealthCheckVMapper_TEST.healthCheckAssertionHelper(
            picklistEntryModelByName.get('testneutralvalue'),
            healthCheckGroupVModel,
            1,
            relationshipLookupModel.neutralValue,
            '04',
            Label.stgHCReciprocalRelNeutralTitle,
            'Pass',
            Label.stgHealthCheckStatusPassed,
            Label.stgHCPicklistValueValid,
            Label.stgHealthCheckFixNotApplicable
        );
    }

    /***************************************************************************
    * @description Test method to verify that getNeutralHealthCheckGroupPass
    * fails with an inactive picklist entry model for its relationship model's
    * neutral value
    ***************************************************************************/
    @isTest
    private static void getNeutralHealthCheckGroupInactive() {
        STUB_PicklistEntryServiceInactive picklistEntryServiceStub =
            new STUB_PicklistEntryServiceInactive();

        ReciprocalRelHealthCheckVMapper reciprocalRelHealthCheckVMapper =
            ReciprocalRelHealthCheckVMapper.getInstance();

        Map<String,PicklistEntryModel> picklistEntryModelByName =
            picklistEntryServiceStub.getModelsByNameForSObjectField(
                Relationship__c.SObjectType,
                Relationship__c.Type__c
            );

        RelationshipLookupModel relationshipLookupModel = 
            new RelationshipLookupModel(
                'testvalue',
                true,
                'testneutralvalue',
                'testmalevalue',
                'testneutralvalue'
            );

        Test.startTest();
            HealthCheckGroupVModel healthCheckGroupVModel =
                reciprocalRelHealthCheckVMapper.getNeutralHealthCheckGroup(
                    relationshipLookupModel,
                    picklistEntryModelByName
                );
        Test.stopTest();

        ReciprocalRelHealthCheckVMapper_TEST.healthCheckAssertionHelper(
            picklistEntryModelByName.get('testneutralvalue'),
            healthCheckGroupVModel,
            0,
            relationshipLookupModel.neutralValue,
            '04',
            Label.stgHCReciprocalRelNeutralTitle,
            'Fail',
            Label.stgHealthCheckStatusFailed,
            Label.stgHCPicklistValueInactive,
            Label.stgHCReciprocalRelNeutralInactiveFix
        );               
    }

    /***************************************************************************
    * @description Test method to verify that getNeutralHealthCheckGroupPass
    * fails with an unfound picklist entry model for its relationship model's
    * neutral value
    ***************************************************************************/
    @isTest
    private static void getNeutralHealthCheckGroupNotFound() {
        ReciprocalRelHealthCheckVMapper reciprocalRelHealthCheckVMapper =
            ReciprocalRelHealthCheckVMapper.getInstance();

        RelationshipLookupModel relationshipLookupModel = 
            new RelationshipLookupModel(
                'testvalue',
                true,
                'testneutralvalue',
                'testmalevalue',
                'testneutralvalue'
            );

        Test.startTest();
            HealthCheckGroupVModel healthCheckGroupVModel =
                reciprocalRelHealthCheckVMapper.getNeutralHealthCheckGroup(
                    relationshipLookupModel,
                    new Map<String,PicklistEntryModel>()
                );
        Test.stopTest();

        ReciprocalRelHealthCheckVMapper_TEST.healthCheckAssertionHelper(
            null,
            healthCheckGroupVModel,
            0,
            relationshipLookupModel.neutralValue,
            '04',
            Label.stgHCReciprocalRelNeutralTitle,
            'Fail',
            Label.stgHealthCheckStatusFailed,
            Label.stgHCPicklistValueNotFound,
            Label.stgHCReciprocalRelNeutralNotFoundFix
        );
    }

    /***************************************************************************
    ******************************PICKLIST HELPER*******************************
    ***************************************************************************/

    /***************************************************************************
    * @description Test method to verify that
    * getHealthCheckGroupForPicklistSetting passes with an active picklist entry
    * model
    ***************************************************************************/
    @isTest
    private static void getHealthCheckGroupForPicklistSettingPass() {
        ReciprocalRelHealthCheckVMapper reciprocalRelHealthCheckVMapper =
            ReciprocalRelHealthCheckVMapper.getInstance();

        PicklistEntryModel picklistEntryModel = new PicklistEntryModel(
            'testvalue',
            'testlabel',
            true
        );

        Test.startTest();
            HealthCheckGroupVModel healthCheckGroupVModel =
                reciprocalRelHealthCheckVMapper.getHealthCheckGroupForPicklistSetting(
                    picklistEntryModel,
                    'value',
                    '01',
                    'settingsLabel',
                    'notFoundFix {0}',
                    'inactiveFix {0} {1}'
                );
        Test.stopTest();

        ReciprocalRelHealthCheckVMapper_TEST.healthCheckAssertionHelper(
            picklistEntryModel,
            healthCheckGroupVModel,
            1,
            'value',
            '01',
            'settingsLabel',
            'Pass',
            Label.stgHealthCheckStatusPassed,
            Label.stgHCPicklistValueValid,
            Label.stgHealthCheckFixNotApplicable
        );
    }

    /***************************************************************************
    * @description Test method to verify that
    * getHealthCheckGroupForPicklistSetting fails with an inactive picklist
    * entry model
    ***************************************************************************/
    @isTest
    private static void getHealthCheckGroupForPicklistSettingInactive() {
        ReciprocalRelHealthCheckVMapper reciprocalRelHealthCheckVMapper =
            ReciprocalRelHealthCheckVMapper.getInstance();

        PicklistEntryModel picklistEntryModel = new PicklistEntryModel(
            'testvalue',
            'testlabel',
            false
        );

        Test.startTest();
            HealthCheckGroupVModel healthCheckGroupVModel =
                reciprocalRelHealthCheckVMapper.getHealthCheckGroupForPicklistSetting(
                    picklistEntryModel,
                    'value',
                    '01',
                    'settingsLabel',
                    'notFoundFix {0}',
                    'inactiveFix {0} {1}'
                );
        Test.stopTest();

        ReciprocalRelHealthCheckVMapper_TEST.healthCheckAssertionHelper(
            picklistEntryModel,
            healthCheckGroupVModel,
            0,
            'value',
            '01',
            'settingsLabel',
            'Fail',
            Label.stgHealthCheckStatusFailed,
            Label.stgHCPicklistValueInactive,
            'inactiveFix {0} {1}'
        );               
    }

    /***************************************************************************
    * @description Test method to verify that
    * getHealthCheckGroupForPicklistSetting fails with an unfound picklist
    * entry model
    ***************************************************************************/
    @isTest
    private static void getHealthCheckGroupForPicklistSettingNotFound() {
        ReciprocalRelHealthCheckVMapper reciprocalRelHealthCheckVMapper =
            ReciprocalRelHealthCheckVMapper.getInstance();

        Test.startTest();
            HealthCheckGroupVModel healthCheckGroupVModel =
                reciprocalRelHealthCheckVMapper.getHealthCheckGroupForPicklistSetting(
                    null,
                    'value',
                    '01',
                    'settingsLabel',
                    'notFoundFix {0}',
                    'inactiveFix {0} {1}'
                );
        Test.stopTest();

        ReciprocalRelHealthCheckVMapper_TEST.healthCheckAssertionHelper(
            null,
            healthCheckGroupVModel,
            0,
            'value',
            '01',
            'settingsLabel',
            'Fail',
            Label.stgHealthCheckStatusFailed,
            Label.stgHCPicklistValueNotFound,
            'notFoundFix {0}'
        );
    }

    /***************************************************************************
    ********************************UNIQUENESS**********************************
    ***************************************************************************/

    /***************************************************************************
    * @description Test method to verify that getUniquenessHealthCheckGroup
    * passes with a unique name
    ***************************************************************************/
    @isTest
    private static void getUniquenessHealthCheckGroupUnique() {
        ReciprocalRelHealthCheckVMapper reciprocalRelHealthCheckVMapper =
            ReciprocalRelHealthCheckVMapper.getInstance();

        RelationshipLookupModel relationshipLookupModel = 
            new RelationshipLookupModel(
                'testvalue',
                true,
                'testfemalevalue',
                'testmalevalue',
                'testneutralvalue'
            );

        PicklistEntryModel picklistEntryModel = new PicklistEntryModel(
            'testvalue',
            'testlabel',
            true
        );

        Set<String> duplicateNameSet = new Set<String>();

        Test.startTest();
            HealthCheckGroupVModel healthCheckGroupVModel =
                reciprocalRelHealthCheckVMapper.getUniquenessHealthCheckGroup(
                    relationshipLookupModel,
                    picklistEntryModel,
                    duplicateNameSet
                );
        Test.stopTest();

        ReciprocalRelHealthCheckVMapper_TEST.healthCheckAssertionHelper(
            picklistEntryModel,
            healthCheckGroupVModel,
            1,
            relationshipLookupModel.name,
            '05',
            Label.stgHCReciprocalRelNameUniqueTitle,
            'Pass',
            Label.stgHealthCheckStatusPassed,
            Label.stgHCReciprocalRelNameUniqueDesc,
            Label.stgHealthCheckFixNotApplicable
        );
    }

    /***************************************************************************
    * @description Test method to verify that getUniquenessHealthCheckGroup
    * passes with a unique name and unfound picklist entry model
    ***************************************************************************/
    @isTest
    private static void getUniquenessHealthCheckGroupUniqueUnfoundPicklist() {
        ReciprocalRelHealthCheckVMapper reciprocalRelHealthCheckVMapper =
            ReciprocalRelHealthCheckVMapper.getInstance();

        RelationshipLookupModel relationshipLookupModel = 
            new RelationshipLookupModel(
                'testvalue',
                true,
                'testfemalevalue',
                'testmalevalue',
                'testneutralvalue'
            );

        Set<String> duplicateNameSet = new Set<String>();

        Test.startTest();
            HealthCheckGroupVModel healthCheckGroupVModel =
                reciprocalRelHealthCheckVMapper.getUniquenessHealthCheckGroup(
                    relationshipLookupModel,
                    null,
                    duplicateNameSet
                );
        Test.stopTest();

        ReciprocalRelHealthCheckVMapper_TEST.healthCheckAssertionHelper(
            null,
            healthCheckGroupVModel,
            1,
            relationshipLookupModel.name,
            '05',
            Label.stgHCReciprocalRelNameUniqueTitle,
            'Pass',
            Label.stgHealthCheckStatusPassed,
            Label.stgHCReciprocalRelNameUniqueDesc,
            Label.stgHealthCheckFixNotApplicable
        );
    }

    /***************************************************************************
    * @description Test method to verify that getUniquenessHealthCheckGroup
    * fails with a duplicate name
    ***************************************************************************/
    @isTest
    private static void getUniquenessHealthCheckGroupDuplicate() {
        ReciprocalRelHealthCheckVMapper reciprocalRelHealthCheckVMapper =
            ReciprocalRelHealthCheckVMapper.getInstance();

        RelationshipLookupModel relationshipLookupModel = 
            new RelationshipLookupModel(
                'testvalue',
                true,
                'testfemalevalue',
                'testmalevalue',
                'testneutralvalue'
            );

        PicklistEntryModel picklistEntryModel = new PicklistEntryModel(
            'testvalue',
            'testlabel',
            true
        );

        Set<String> duplicateNameSet = new Set<String>{'testvalue'};

        Test.startTest();
            HealthCheckGroupVModel healthCheckGroupVModel =
                reciprocalRelHealthCheckVMapper.getUniquenessHealthCheckGroup(
                    relationshipLookupModel,
                    picklistEntryModel,
                    duplicateNameSet
                );
        Test.stopTest();

        ReciprocalRelHealthCheckVMapper_TEST.healthCheckAssertionHelper(
            picklistEntryModel,
            healthCheckGroupVModel,
            0,
            relationshipLookupModel.name,
            '05',
            Label.stgHCReciprocalRelNameUniqueTitle,
            'Fail',
            Label.stgHealthCheckStatusFailed,
            Label.stgHCReciprocalRelNameNotUniqueDesc,
            Label.stgHCReciprocalRelNameNotUniqueFix
        );
    }

    /***************************************************************************
    * @description Test method to verify that getUniquenessHealthCheckGroup
    * fails with a duplicate name and unfound picklist entry model
    ***************************************************************************/
    @isTest
    private static void getUniquenessHealthCheckGroupDuplicateUnfoundPicklist() {
        ReciprocalRelHealthCheckVMapper reciprocalRelHealthCheckVMapper =
            ReciprocalRelHealthCheckVMapper.getInstance();

        RelationshipLookupModel relationshipLookupModel = 
            new RelationshipLookupModel(
                'testvalue',
                true,
                'testfemalevalue',
                'testmalevalue',
                'testneutralvalue'
            );

        Set<String> duplicateNameSet = new Set<String>{'testvalue'};

        Test.startTest();
            HealthCheckGroupVModel healthCheckGroupVModel =
                reciprocalRelHealthCheckVMapper.getUniquenessHealthCheckGroup(
                    relationshipLookupModel,
                    null,
                    duplicateNameSet
                );
        Test.stopTest();

        ReciprocalRelHealthCheckVMapper_TEST.healthCheckAssertionHelper(
            null,
            healthCheckGroupVModel,
            0,
            relationshipLookupModel.name,
            '05',
            Label.stgHCReciprocalRelNameUniqueTitle,
            'Fail',
            Label.stgHealthCheckStatusFailed,
            Label.stgHCReciprocalRelNameNotUniqueDesc,
            Label.stgHCReciprocalRelNameNotUniqueFix
        );
    }

    /***************************************************************************
    ****************************LOCATORS AND HELPERS***************************
    ***************************************************************************/

    /***************************************************************************
    * @description Test method to verify that a formatted HealthCheckItemVModel
    * is returned
    ***************************************************************************/
    @isTest 
    private static void getHealthCheckItemVModelForRelationshipLookupModel(){
        ReciprocalRelHealthCheckVMapper reciprocalRelHealthCheckVMapper =
            ReciprocalRelHealthCheckVMapper.getInstance();

        RelationshipLookupModel relationshipLookupModel = 
            new RelationshipLookupModel(
                'testvalue',
                true,
                'testfemalevalue',
                'testmalevalue',
                'testneutralvalue'
            );

        PicklistEntryModel picklistEntryModel = new PicklistEntryModel(
            'testvalue',
            'testlabel',
            false
        );

        Test.startTest();
            HealthCheckItemVModel healthCheckItemVModel =
                reciprocalRelHealthCheckVMapper.getHealthCheckItemVModelForRelationshipLookupModel(
                    relationshipLookupModel,
                    picklistEntryModel
                );
        Test.stopTest();

        List<String> listForSettingsLabel =
            new List<String>{relationshipLookupModel.name,relationshipLookupModel.name};
        List<String> listForDescriptionLabel =
            new List<String>{relationshipLookupModel.name,picklistEntryModel.name};

        System.assertEquals(
            relationshipLookupModel.name,
            healthCheckItemVModel.key,
            'Health Check Item View Model key should equal the relationship lookup model name.'
        );
        System.assertEquals(
            String.format(Label.stgHCReciprocalRelSetting,listForSettingsLabel),
            healthCheckItemVModel.setting,
            'Health Check Item View Model setting should equal the formatted expected label.'
            );
        System.assertEquals(
            'Pass',
            healthCheckItemVModel.status,
            'The Health Check Item\'s status should status should be Pass.'
        );
        System.assertEquals(
            Label.stgHealthCheckStatusPassed,
            healthCheckItemVModel.statusLabel,
            'Health Check Item View Model status should equal the expected label.'
        );
        System.assertEquals(
            '',
            healthCheckItemVModel.description,
            'Health Check Item View Model description should equal the expected formatted label.'
        );
        System.assertEquals(
            '',
            healthCheckItemVModel.recommendedFix,
            'Health Check Item View Model recommended fix should be blank.'
        );
        System.assertEquals(
            true,
            healthCheckItemVModel.healthCheckItemList.isEmpty(),
            'Health Check Item View Model health check item list should be empty.'
        );
    }

    /***************************************************************************
    * @description Test method to verify that a PicklistEntryService is
    * retrieved by the locator method.
    ***************************************************************************/
    @isTest 
    private static void locatePicklistEntryService(){
        PicklistEntryService expectedPicklistEntryService
            = PicklistEntryService.getInstance();

        ReciprocalRelHealthCheckVMapper reciprocalRelHealthCheckVMapper =
            ReciprocalRelHealthCheckVMapper.getInstance();

        Test.startTest();
            PicklistEntryService picklistEntryService
                = reciprocalRelHealthCheckVMapper.locatePicklistEntryService();
        Test.stopTest();

        System.assertNotEquals(
            null,
            picklistEntryService,
            'Instance of service class should not be null.'
        );

        System.assertEquals(
            expectedPicklistEntryService,
            picklistEntryService,
            'Instance of service class from view model mapper should match the singleton instance.'
        );
    }

    /***************************************************************************
    * @description Test method to verify that a
    * RelationshipLookupSettingsService is retrieved by the locator method.
    ***************************************************************************/
    @isTest 
    private static void locateRelationshipLookupSettingsService(){
        RelationshipLookupSettingsService expectedRelationshipLookupSettingsService
            = RelationshipLookupSettingsService.getInstance();

        ReciprocalRelHealthCheckVMapper reciprocalRelHealthCheckVMapper =
            ReciprocalRelHealthCheckVMapper.getInstance();

        Test.startTest();
            RelationshipLookupSettingsService relationshipLookupSettingsService
                = reciprocalRelHealthCheckVMapper.locateRelationshipLookupSettingsService();
        Test.stopTest();

        System.assertNotEquals(
            null,
            relationshipLookupSettingsService,
            'Instance of service class should not be null.'
        );

        System.assertEquals(
            expectedRelationshipLookupSettingsService,
            relationshipLookupSettingsService,
            'Instance of service class from view model mapper should match the singleton instance.'
        );
    }

    /***************************************************************************
    * @description Test method to verify that a
    * StringHandlingService is retrieved by the locator method.
    ***************************************************************************/
    @isTest 
    private static void locateStringHandlingService(){
        StringHandlingService expectedStringHandlingService
            = StringHandlingService.getInstance();

        ReciprocalRelHealthCheckVMapper reciprocalRelHealthCheckVMapper =
            ReciprocalRelHealthCheckVMapper.getInstance();

        Test.startTest();
            StringHandlingService StringHandlingService
                = reciprocalRelHealthCheckVMapper.locateStringHandlingService();
        Test.stopTest();

        System.assertNotEquals(
            null,
            StringHandlingService,
            'Instance of service class should not be null.'
        );

        System.assertEquals(
            expectedStringHandlingService,
            StringHandlingService,
            'Instance of service class from view model mapper should match the singleton instance.'
        );
    }

    /***************************************************************************
    *******************************TEST HELPERS*********************************
    ***************************************************************************/

    /***************************************************************************
    * @description A helper method to steamline standardized picklist value
    * assertions and reduce eye strain.
    ***************************************************************************/
    private static void healthCheckAssertionHelper(
        PicklistEntryModel picklistEntryModel,
        HealthCheckGroupVModel healthCheckGroupVModel,
        Integer passedChecks,
        String picklistName,
        String picklistIndex,
        String setting,
        String status,
        String statusLabel,
        String description,
        String recommendedFix
    ) {
        System.assertEquals(
            passedChecks,
            healthCheckGroupVModel.passedChecks,
            'The Health Check Group View Model should have ' + passedChecks + ' passed check(s).'
        );
        System.assertEquals(
            1,
            healthCheckGroupVModel.totalChecks,
            'The Health Check Group View Model should have 1 total check.'
        );
        System.assertEquals(
            0,
            healthCheckGroupVModel.expandedRowsList.size(),
            'The Health Check Group View Model should have 0 expanded rows.'
        );
        System.assertEquals(
            1,
            healthCheckGroupVModel.healthCheckItemList.size(),
            'The Health Check Group View Model should have 1 health check item.'
        );

        HealthCheckItemVModel healthCheckItemVModel =
            healthCheckGroupVModel.healthCheckItemList[0];
        List<String> labelAndNameForFormat = new List<String>{picklistName,picklistName};

        if(picklistEntryModel != null) {
            labelAndNameForFormat = new List<String>{picklistEntryModel.label,picklistEntryModel.name};
        }

        System.assertEquals(
            picklistName + picklistIndex,
            healthCheckItemVModel.key,
            'The Health Check Item\'s key should match the relationship lookup model\'s name.'
        );
        System.assertEquals(
            setting,
            healthCheckItemVModel.setting,
            'The Health Check Item\'s setting should match the specified label.'
            );
        System.assertEquals(
            status,
            healthCheckItemVModel.status,
            'The Health Check Item\'s status should status should be ' + status + '.'
        );
        System.assertEquals(
            statusLabel,
            healthCheckItemVModel.statusLabel,
            'The Health Check Item\'s status label should match the specified label.'
        );
        System.assertEquals(
            StringHandlingService.getInstance().formatStringWithApostrophesAndParameters(
                description,
                labelAndNameForFormat
            ),
            healthCheckItemVModel.description,
            'The Health Check Item\'s description should match the specified label.'
        );
        System.assertEquals(
            StringHandlingService.getInstance().formatStringWithApostrophesAndParameters(
                recommendedFix,
                labelAndNameForFormat
            ),
            healthCheckItemVModel.recommendedFix,
            'The Health Check Item\'s recommended fix should match the specified label.'
        );
    }

    /***************************************************************************
    *********************************STUBS**************************************
    ***************************************************************************/

    /***************************************************************************
    * @description Stub class to simulate the response from
    * ReciprocalRelHealthCheckVMapper to control
    * getRelationshipLookupHealthCheckGroup
    ***************************************************************************/
    private class STUB_ReciprocalRelHealthCheckVMapper extends ReciprocalRelHealthCheckVMapper {
        protected override HealthCheckGroupVModel getRelationshipLookupHealthCheckGroup(
            RelationshipLookupModel relationshipLookupModel,
            Map<String,PicklistEntryModel> picklistEntryModelByName,
            Set<String> duplicateMappingKeys
        ) {
            HealthCheckGroupVModel healthCheckGroupVModel = new HealthCheckGroupVModel(
                '',
                '',
                0,
                0,
                new List<String>(),
                new List<HealthCheckItemVModel>()
            );

            PicklistEntryModel picklistEntryModel =
                picklistEntryModelByName.get(relationshipLookupModel.name);
    
            HealthCheckItemVModel healthCheckItemVModel = 
                this.getHealthCheckItemVModelForRelationshipLookupModel(
                    relationshipLookupModel,
                    picklistEntryModel
                );

            healthCheckGroupVModel.totalChecks += 1;

            if(picklistEntryModel != null) {
                healthCheckGroupVModel.passedChecks += 1;
            }

            if(healthCheckGroupVModel.passedChecks < healthCheckGroupVModel.totalChecks) {
                healthCheckItemVModel.status = 'Fail';
                healthCheckItemVModel.statusLabel = Label.stgHealthCheckStatusFailed;
                healthCheckGroupVModel.expandedRowsList.add(relationshipLookupModel.name);
            }
    
            healthCheckItemVModel.healthCheckItemList.sort();
    
            healthCheckGroupVModel.healthCheckItemList.add(healthCheckItemVModel);

            return healthCheckGroupVModel;
        }
    }

    /***************************************************************************
    * @description Stub class to simulate the response from
    * ReciprocalRelHealthCheckVMapper to control individual health check methods
    * for success or failure
    ***************************************************************************/
    private class STUB_ReciprocalRelHealthCheckVMapperSub extends ReciprocalRelHealthCheckVMapper {
        protected override HealthCheckGroupVModel getHealthCheckGroupForPicklistSetting(
            PicklistEntryModel picklistEntryModel,
            String relationshipLookupModelFieldValue,
            String indexString,
            String settingsLabel,
            String notFoundFix,
            String inactiveFix
        ) {
            return this.mockCheck(picklistEntryModel);
        }

        protected override HealthCheckGroupVModel getUniquenessHealthCheckGroup(
            RelationshipLookupModel relationshipLookupModel,
            PicklistEntryModel picklistEntryModel,
            Set<String> duplicateNameSet
        ) {
            return this.mockCheck(picklistEntryModel);
        }

        private HealthCheckGroupVModel mockCheck(PicklistEntryModel picklistEntryModel) {
            HealthCheckGroupVModel healthCheckGroupVModel = new HealthCheckGroupVModel(
                '',
                '',
                0,
                0,
                new List<String>(),
                new List<HealthCheckItemVModel>()
            );
    
            HealthCheckItemVModel healthCheckItemVModel =
                new healthCheckItemVModel(
                    'Mock',
                    'MockSetting',
                    'Pass',
                    'MockStatusLabel',
                    'MockDescription',
                    'MockRecommendedFix',
                    new List<HealthCheckItemVModel>()
                );

            healthCheckGroupVModel.totalChecks += 1;

            if(picklistEntryModel != null) {
                healthCheckGroupVModel.passedChecks += 1;
            }

            if(healthCheckGroupVModel.passedChecks < healthCheckGroupVModel.totalChecks) {
                healthCheckItemVModel.status = 'Fail';
                healthCheckItemVModel.statusLabel = Label.stgHealthCheckStatusFailed;
            }
    
            healthCheckGroupVModel.healthCheckItemList.add(healthCheckItemVModel);
            return healthCheckGroupVModel;
        }
    }
    
    /***************************************************************************
    * @description Stub class to simulate the response from
    * RelationshipLookupSettingsService to return a predetermined set of models.
    ***************************************************************************/
    private class STUB_RelationshipLookupSettingsService extends RelationshipLookupSettingsService {

        public override List<RelationshipLookupModel> getRelationshipLookupModels() {
            List<RelationshipLookupModel> relationshipLookupModelList =
                new List<RelationshipLookupModel>();
            
            RelationshipLookupModel relationshipLookupModel = 
                new RelationshipLookupModel(
                    'testvalue',
                    true,
                    'testfemalevalue',
                    'testmalevalue',
                    'testneutralvalue'
                );

            relationshipLookupModelList.add(relationshipLookupModel);

            return relationshipLookupModelList;
        }
    }

    /***************************************************************************
    * @description Stub class to simulate the response from
    * RelationshipLookupSettingsService to return a predetermined set of unfound
    * models.
    ***************************************************************************/
    private class STUB_RelationshipLookupSettingsUnfound extends RelationshipLookupSettingsService {

        public override List<RelationshipLookupModel> getRelationshipLookupModels() {
            List<RelationshipLookupModel> relationshipLookupModelList =
                new List<RelationshipLookupModel>();
            
            RelationshipLookupModel relationshipLookupModel = 
                new RelationshipLookupModel(
                    'unfoundvalue',
                    true,
                    'unfoundfemalevalue',
                    'unfoundmalevalue',
                    'unfoundneutralvalue'
                );

            relationshipLookupModelList.add(relationshipLookupModel);

            return relationshipLookupModelList;
        }
    }



    /***************************************************************************
    * @description Stub class to simulate the response from
    * PicklistEntryService to return a predetermined set of active models.
    ***************************************************************************/
    private class STUB_PicklistEntryService extends PicklistEntryService {
        public override Map<String,PicklistEntryModel> getModelsByNameForSObjectField(
            SObjectType sObjectTypeName,
            SObjectField SObjectFieldName
        ) {
            Map<String,PicklistEntryModel> picklistEntryModelByName =
                new Map<String,PicklistEntryModel>();
            
            picklistEntryModelByName.put('testvalue',new PicklistEntryModel(
                'testvalue',
                'testlabel',
                true
            ));            
            picklistEntryModelByName.put('testfemalevalue',new PicklistEntryModel(
                'testfemalevalue',
                'testfemalelabel',
                true
            ));            
            picklistEntryModelByName.put('testmalevalue',new PicklistEntryModel(
                'testmalevalue',
                'testmalelabel',
                true
            ));            
            picklistEntryModelByName.put('testneutralvalue',new PicklistEntryModel(
                'testneutralvalue',
                'testneutrallabel',
                true
            ));

            return picklistEntryModelByName;
        }
    }

    /***************************************************************************
    * @description Stub class to simulate the response from
    * PicklistEntryService to return a predetermined set of inactive models.
    ***************************************************************************/
    private class STUB_PicklistEntryServiceInactive extends PicklistEntryService {
        public override Map<String,PicklistEntryModel> getModelsByNameForSObjectField(
            SObjectType sObjectTypeName,
            SObjectField SObjectFieldName
        ) {
            Map<String,PicklistEntryModel> picklistEntryModelByName =
                new Map<String,PicklistEntryModel>();
            
            picklistEntryModelByName.put('testvalue',new PicklistEntryModel(
                'testvalue',
                'testlabel',
                false
            ));            
            picklistEntryModelByName.put('testfemalevalue',new PicklistEntryModel(
                'testfemalevalue',
                'testfemalelabel',
                false
            ));            
            picklistEntryModelByName.put('testmalevalue',new PicklistEntryModel(
                'testmalevalue',
                'testmalelabel',
                false
            ));            
            picklistEntryModelByName.put('testneutralvalue',new PicklistEntryModel(
                'testneutralvalue',
                'testneutrallabel',
                false
            ));

            return picklistEntryModelByName;
        }
    }
}
@isTest
private class RecordTypeMapper_TEST {
    /**************************************************************************************************************************
    * @description Test method to verify that the getInstance method returns a new instance of the 
    * RecordTypeMapper class when one does not already exist.
    ***************************************************************************************************************************/
    @isTest
    private static void getInstanceNew() {
        Test.startTest();
        RecordTypeMapper recordTypeMapperInstance = RecordTypeMapper.getInstance();
        Test.stopTest();

        System.assertEquals(RecordTypeMapper.instance, recordTypeMapperInstance, 'Instance of service class returned should match static instance variable.');
        System.assertEquals(true, recordTypeMapperInstance != null, 'Instance of service class should not be null.');
    }

    /**************************************************************************************************************************
    * @description Test method to verify that the getInstance method returns the existing instance of the 
    * RecordTypeMapper class when one already exists.
    ***************************************************************************************************************************/
    @isTest
    private static void getInstanceExisting() {
        RecordTypeMapper recordTypeMapperInstance1 = RecordTypeMapper.getInstance();

        Test.startTest();
            RecordTypeMapper recordTypeMapperInstance2 = RecordTypeMapper.getInstance();
        Test.stopTest();

        System.assertEquals(RecordTypeMapper.instance, recordTypeMapperInstance1, 'Instance of service class returned should match static instance variable.');
        System.assertEquals(recordTypeMapperInstance1, recordTypeMapperInstance2, 'Subsequent retrievals of service class instance should return existing instance.');
        System.assertEquals(true, recordTypeMapperInstance1 != null, 'Instance of service class should not be null.');
    }

    /**************************************************************************************************************************
    * @description Test method to verify that the getModelByIdMapForSObjectType returns correct record type model by id map.
    * Since unit tests have access to record types in the org, we will only check if admin record type exists.
    ***************************************************************************************************************************/
    @isTest
    private static void getModelByIdMapForSObjectTypeAccountTest() {
        UTIL_Describe.populateRecordTypeInfoForSObject('Account');

        Map<String, Schema.RecordTypeInfo> accountDeveloperNameMap =
            UTIL_Describe.recordTypeInfoByDeveloperName.get('Account');

        Test.startTest();
            Map<Id, RecordTypeModel> recordTypeModelById = RecordTypeMapper.getInstance().getModelByIdMapForSObjectType(Account.getSobjectType());
        Test.stopTest();

        System.assertEquals(
            accountDeveloperNameMap.size(),
            recordTypeModelById.size(),
            'The number of record types for an object and the number of record type models for an object should be the same.'
        );

        for(Schema.RecordTypeInfo recordTypeInfo : accountDeveloperNameMap.values()) {
            RecordTypeModel recordTypeModel = recordTypeModelById.get(recordTypeInfo.getRecordTypeId());

            System.assertNotEquals(null,recordTypeModel,'All record types for an object should have a corresponding record type model.');
            System.assertEquals(recordTypeInfo.getRecordTypeId(),recordTypeModel.id,'The record type model for a record type should have the same Id.');
            System.assertEquals(recordTypeInfo.getName(),recordTypeModel.name,'The record type model for a record type should have the same name.');
            System.assertEquals(recordTypeInfo.getDeveloperName(),recordTypeModel.developerName,'The record type model for a record type should have the same developer name.');
            System.assertEquals(recordTypeInfo.isActive(),recordTypeModel.isActive,'The record type model for a record type should have the same is active flag.');
        }
    }

    /**************************************************************************************************************************
    * @description Test method to verify that the getRecordTypeModelFromRecTypeDevName returns a recordtype model for a valid
    * object and its record type.
    ***************************************************************************************************************************/
    @isTest
    private static void getRecordTypeModelFromRecTypeDevNamePositiveTest() {
        UTIL_Describe.populateRecordTypeInfoForSObject('Account');
        Test.startTest();
            RecordTypeModel accRecTypeMdl = RecordTypeMapper.getInstance().getRecordTypeModelFromRecTypeDevName('Account', 'Academic_Program');
        Test.stopTest();
        
        System.assert(accRecTypeMdl.Id != null, 'The id of the account recordtype in the model should have a value');
        System.assertEquals('Academic Program', accRecTypeMdl.name, 'The name of the account recordtype in the model should have a value');
        System.assertEquals('Academic_Program', accRecTypeMdl.developerName, 'The developer name of the account recordtype in the model should have a value');
        System.assertEquals(true, accRecTypeMdl.isActive, 'The account record type should be active.');

    } 

    /**************************************************************************************************************************
    * @description Test method to verify that the getRecordTypeModelFromRecTypeDevName returns null for an invalid
    * object or record type.
    ***************************************************************************************************************************/
    @isTest
    private static void getRecordTypeModelFromRecTypeDevNameNegativeTest() {
        UTIL_Describe.populateRecordTypeInfoForSObject('Account');
        Test.startTest();
            RecordTypeModel accRecTypeMdl = RecordTypeMapper.getInstance().getRecordTypeModelFromRecTypeDevName('Account', 'test only rec type');
        Test.stopTest();
        
        System.assertEquals(null, accRecTypeMdl, 'A model should not be retireved for invalid recordtype');

        
    }
}
public virtual with sharing class RecordTypeService {
    /*********************************************
     * @description Instance for Singleton Pattern
     **********************************************/
    @TestVisible
    private static RecordTypeService instance;

    /*********************************************************************
     * @description Empty constructor is not public for Singleton Pattern
     **********************************************************************/
    protected RecordTypeService() {
    }

    /******************************************************************************
     * @description Static method to get the current instance for Singleton pattern
     * @return The instance of RecordTypeService.
     ******************************************************************************/
    public static RecordTypeService getInstance() {
        if (instance == null) {
            instance = new RecordTypeService();
        }

        return instance;
    }

    /******************************************************************************
     * @description Get a map of Record Type Model By Id for specified SObjectType
     * @param SObjectype An SObject from which to retrieve associated record types
     * @return A map of Record Type Models By Id
     ******************************************************************************/
    public virtual Map<Id, RecordTypeModel> getModelByIdMapForSObjectType(Schema.SObjectType sObjectType) {
        return this.locateRecordTypeMapper().getModelByIdMapForSObjectType(sObjectType);
    }

    /******************************************************************************
     * @description Returns a recordtype model for an Object and it's recordtype
     * @param objectAPI The API name for object to get the record type model for
     * @param recTypeDevName The record type dev name to get the record typpe model for
     * for the given object
     * @return A recordtype model
     ******************************************************************************/
    public virtual RecordTypeModel getRecordTypeModelFromRecTypeDevName(String objectAPI, String recTypeDevName) {
        return this.locateRecordTypeMapper().getRecordTypeModelFromRecTypeDevName(objectAPI, recTypeDevName);
    }

    /***********************************************************************************************************************
     * @description Retrieve a map of active record types by Id from a list of all record types associated with an SObject.
     * @param allRecordTypeModelsList A list containing all record type models in an org.
     * @return A map of Active Record Type Models By Id.
     ***********************************************************************************************************************/
    public virtual Map<Id, RecordTypeModel> getActiveRecordTypeModelsById(
        List<RecordTypeModel> allRecordTypeModelsList
    ) {
        Map<Id, RecordTypeModel> activeRecordTypeModelsById = new Map<Id, RecordTypeModel>();

        for (RecordTypeModel recordTypeModel : allRecordTypeModelsList) {
            if (recordTypeModel.isActive == false) {
                continue;
            }

            activeRecordTypeModelsById.put(recordTypeModel.id, recordTypeModel);
        }

        return activeRecordTypeModelsById;
    }

    /***********************************************************************************************************************
     * @description Filter through a map of valid Record Type models to retrieve a list of Ids corresponding to values in a specified list.
     * @param  idsToFindList A list of Id strings corresponding to Record Types
     * @param  validRecordTypeIdsSet A set of Ids associated with valid Record Types
     * @return A List<Id> containing Ids that correspond to valid Record Types and match a value in the specified list of Ids to find.
     ***********************************************************************************************************************/
    public virtual List<Id> filterListForValidIds(List<String> idsToFindList, Set<Id> validRecordTypeIdsSet) {
        List<String> validIdsList = new List<String>();

        for (String idToFind : idsToFindList) {
            if ((idToFind instanceof Id) == false) {
                // Id to find is not a valid Id string => omit
                continue;
            }
            if (validRecordTypeIdsSet.contains((Id) idToFind) == false) {
                // Id to find has no match to a valid record type model => omit
                continue;
            }

            validIdsList.add(idToFind);
        }

        return validIdsList;
    }

    /******************************************************************************
     * @description Get the Record Type Model from the map of record type model by id
     * @param recordTypeId string of Record Type Id
     * @param recordTypeModelById map of Record Type Model By Id
     * @return An instance of Record Type Model
     ******************************************************************************/
    public virtual RecordTypeModel getRecordTypeModelFromMap(
        String recordTypeId,
        Map<Id, RecordTypeModel> recordTypeModelById
    ) {
        try {
            return recordTypeModelById.get(Id.valueOf(recordTypeId));
        } catch (System.StringException ex) {
            return null;
        }
    }

    /******************************************************************************
     * @description Retrieve a record type model for a specified record type name or label.
     * @param recordTypeNameOrLabel A string representing the name or label for a record type
     * @param recordTypeModelByName A map of record type models by name
     * @param recordTypeModelByLabel A map of record type models by label
     * @return A Record Type Model corresponding to the specified record type label or name
     ******************************************************************************/
    public virtual RecordTypeModel getRecordTypeModelFromNameAndLabelMaps(
        String recordTypeNameOrLabel,
        Map<String, RecordTypeModel> recordTypeModelByName,
        Map<String, RecordTypeModel> recordTypeModelByLabel
    ) {
        RecordTypeModel recordTypeModel = recordTypeModelByName.get(recordTypeNameOrLabel);

        if (recordTypeModel == null) {
            recordTypeModel = recordTypeModelByLabel.get(recordTypeNameOrLabel);
        }

        return recordTypeModel;
    }

    /******************************************************************************
     * @description Generate a map of Record Type Models By developer name.
     * @param recordTypeModelById A map of recordTypeModels by Id
     * @return A map of Record Type Model By Name
     ******************************************************************************/
    public Map<String, RecordTypeModel> getRecordTypeModelMapByName(Map<Id, RecordTypeModel> recordTypeModelById) {
        Map<String, RecordTypeModel> recordTypeModelsByName = new Map<String, RecordTypeModel>();

        for (RecordTypeModel recordTypeModel : recordTypeModelById.values()) {
            recordTypeModelsByName.put(recordTypeModel.developerName, recordTypeModel);
        }

        return recordTypeModelsByName;
    }

    /******************************************************************************
     * @description Generate a map of Record Type Models By developer label.
     * @param recordTypeModelById A map of recordTypeModels by Id
     * @return A map of Record Type Model By Label
     ******************************************************************************/
    public Map<String, RecordTypeModel> getRecordTypeModelMapByLabel(Map<Id, RecordTypeModel> recordTypeModelById) {
        Map<String, RecordTypeModel> recordTypeModelsByLabel = new Map<String, RecordTypeModel>();

        for (RecordTypeModel recordTypeModel : recordTypeModelById.values()) {
            recordTypeModelsByLabel.put(recordTypeModel.name, recordTypeModel);
        }

        return recordTypeModelsByLabel;
    }

    /******************************************************************************
     * @description Retrieves an instance of the RecordTypeMapper class.
     * @return An instance of RecordTypeMapper.
     ******************************************************************************/
    @TestVisible
    private RecordTypeMapper locateRecordTypeMapper() {
        return RecordTypeMapper.getInstance();
    }
}
@isTest
private class RecordTypeService_TEST {
    /**************************************************************************************************************************
     * @description Test method to verify that the getInstance method returns a new instance of the
     * RecordTypeService class when one does not already exist.
     ***************************************************************************************************************************/
    @isTest
    private static void getInstanceNew() {
        Test.startTest();
        RecordTypeService recordTypeServiceInstance = RecordTypeService.getInstance();
        Test.stopTest();

        System.assertEquals(
            RecordTypeService.instance,
            recordTypeServiceInstance,
            'Instance of service class returned should match static instance variable.'
        );
        System.assertEquals(true, recordTypeServiceInstance != null, 'Instance of service class should not be null.');
    }

    /**************************************************************************************************************************
     * @description Test method to verify that the getInstance method returns the existing instance of the
     * RecordTypeService class when one already exists.
     ***************************************************************************************************************************/
    @isTest
    private static void getInstanceExisting() {
        RecordTypeService recordTypeServiceInstance1 = RecordTypeService.getInstance();

        Test.startTest();
        RecordTypeService recordTypeServiceInstance2 = RecordTypeService.getInstance();
        Test.stopTest();

        System.assertEquals(
            RecordTypeService.instance,
            recordTypeServiceInstance1,
            'Instance of service class returned should match static instance variable.'
        );
        System.assertEquals(
            recordTypeServiceInstance1,
            recordTypeServiceInstance2,
            'Subsequent retrievals of service class instance should return existing instance.'
        );
        System.assertNotEquals(null, recordTypeServiceInstance1, 'Instance of service class should not be null.');
    }

    /**************************************************************************************************************************
     * @description Test method to verify that a map of Record Type model by Id is returned by getModelByIdMapForSObjectType correctly
     ***************************************************************************************************************************/
    @isTest
    private static void getModelByIdMapForSObjectTypeTest() {
        RecordTypeMapper.instance = new STUB_RecordTypeMapper();

        Test.startTest();
        Map<Id, RecordTypeModel> recordTypeModelById = RecordTypeService.getInstance()
            .getModelByIdMapForSObjectType(Account.getSobjectType());
        Test.stopTest();

        RecordTypeModel recordTypeModel = recordTypeModelById.get('000000000000000000');

        System.assertNotEquals(
            null,
            recordTypeModel,
            'A record type model should be retrieved for a valid record type Id.'
        );
        System.assertEquals(
            Id.valueOf('000000000000000000'),
            recordTypeModel.id,
            'The record type model for a record type should have the specified Id.'
        );
        System.assertEquals(
            'Household',
            recordTypeModel.name,
            'The record type model for a record type should have the specified name.'
        );
        System.assertEquals(
            'Household Account',
            recordTypeModel.developerName,
            'The record type model for a record type should have the specified developer name.'
        );
        System.assertEquals(
            true,
            recordTypeModelById.get('000000000000000000').isActive,
            'The record type model for a record type should have the specified is active flag.'
        );
    }

    /**************************************************************************************************************************
     * @description Test method to verify that null is returned for valid id not in the map
     ***************************************************************************************************************************/
    @isTest
    private static void getRecordTypeModelFromMapValidIdNotInMapTest() {
        RecordTypeMapper.instance = new STUB_RecordTypeMapper();
        Map<Id, RecordTypeModel> recordTypeModelById = RecordTypeService.getInstance()
            .getModelByIdMapForSObjectType(Account.getSobjectType());

        Test.startTest();
        RecordTypeModel recordTypeModel = RecordTypeService.getInstance()
            .getRecordTypeModelFromMap('000000000000000001', recordTypeModelById);
        Test.stopTest();

        System.assertEquals(
            null,
            recordTypeModel,
            'A record type model should not be returned for a record type that does not exist.'
        );
    }

    /**************************************************************************************************************************
     * @description Test method to verify that null is returned for invalid id
     ***************************************************************************************************************************/
    @isTest
    private static void getRecordTypeModelFromMapInvalidIdTest() {
        RecordTypeMapper.instance = new STUB_RecordTypeMapper();
        Map<Id, RecordTypeModel> recordTypeModelById = RecordTypeService.getInstance()
            .getModelByIdMapForSObjectType(Account.getSobjectType());

        Test.startTest();
        RecordTypeModel recordTypeModel = RecordTypeService.getInstance()
            .getRecordTypeModelFromMap('invalid', recordTypeModelById);
        Test.stopTest();

        System.assertEquals(
            null,
            recordTypeModel,
            'A record type model should not be returned for a non-id string value.'
        );
    }

    /**************************************************************************************************************************
     * @description Test method to verify that a valid record type model is returned.
     ***************************************************************************************************************************/
    @isTest
    private static void getRecordTypeModelFromMapValidIdInMapTest() {
        RecordTypeMapper.instance = new STUB_RecordTypeMapper();

        Map<Id, RecordTypeModel> recordTypeModelById = RecordTypeService.getInstance()
            .getModelByIdMapForSObjectType(Account.getSobjectType());

        Test.startTest();
        RecordTypeModel recordTypeModel = RecordTypeService.getInstance()
            .getRecordTypeModelFromMap('000000000000000000', recordTypeModelById);
        Test.stopTest();

        System.assertNotEquals(
            null,
            recordTypeModel,
            'A record type model should be retrieved for a valid record type Id.'
        );
        System.assertEquals(
            Id.valueOf('000000000000000000'),
            recordTypeModel.id,
            'The record type model for a record type should have the specified Id.'
        );
        System.assertEquals(
            'Household',
            recordTypeModel.name,
            'The record type model for a record type should have the specified name.'
        );
        System.assertEquals(
            'Household Account',
            recordTypeModel.developerName,
            'The record type model for a record type should have the specified developer name.'
        );
        System.assertEquals(
            true,
            recordTypeModelById.get('000000000000000000').isActive,
            'The record type model for a record type should have the specified is active flag.'
        );
    }

    /**************************************************************************************************************************
     * @description Test method to verify that getRecordTypeModelFromNameAndLabelMaps returns a valid record type model when a match is found
     * for a specified developer name.
     ***************************************************************************************************************************/
    @isTest
    private static void getRecordTypeModelFromNameAndLabelMapsByName() {
        Map<String, RecordTypeModel> recordTypeModelsByName = new Map<String, RecordTypeModel>{
            'Record_Type_1' => new RecordTypeModel('000000000000000001', 'Record Type 1', 'Record_Type_1', true)
        };

        Map<String, RecordTypeModel> recordTypeModelsByLabel = new Map<String, RecordTypeModel>{
            'Record Type Label' => new RecordTypeModel(
                '000000000000000001',
                'Record Type Label',
                'Record_Type_Label',
                false
            )
        };

        RecordTypeService recordTypeServiceInstance = RecordTypeService.getInstance();

        Test.startTest();
        RecordTypeModel recordTypeModelResult = recordTypeServiceInstance.getRecordTypeModelFromNameAndLabelMaps(
            'Record_Type_1',
            recordTypeModelsByName,
            recordTypeModelsByLabel
        );
        Test.stopTest();

        System.assertEquals(
            '000000000000000001',
            recordTypeModelResult.id,
            'Record type model name should be \'000000000000000001\'.'
        );
        System.assertEquals(
            'Record Type 1',
            recordTypeModelResult.name,
            'Record type model name should be \'Record Type 1\'.'
        );
        System.assertEquals(
            'Record_Type_1',
            recordTypeModelResult.developerName,
            'Record type model name should be \'Record_Type_1\'.'
        );
        System.assertEquals(true, recordTypeModelResult.isActive, 'Record type model name should be \'true\'.');
    }

    /**************************************************************************************************************************
     * @description Test method to verify that getRecordTypeModelFromNameAndLabelMaps returns a valid record type model when a match is found
     * for a specified label name.
     ***************************************************************************************************************************/
    @isTest
    private static void getRecordTypeModelFromNameAndLabelMapsByLabel() {
        Map<String, RecordTypeModel> recordTypeModelsByName = new Map<String, RecordTypeModel>{
            'Record_Type_1' => new RecordTypeModel('000000000000000001', 'Record Type 1', 'Record_Type_1', true)
        };

        Map<String, RecordTypeModel> recordTypeModelsByLabel = new Map<String, RecordTypeModel>{
            'Record Type Label' => new RecordTypeModel(
                '123000000000000000',
                'Record Type Label',
                'Record_Type_Label',
                false
            )
        };

        RecordTypeService recordTypeServiceInstance = RecordTypeService.getInstance();

        Test.startTest();
        RecordTypeModel recordTypeModelResult = recordTypeServiceInstance.getRecordTypeModelFromNameAndLabelMaps(
            'Record Type Label',
            recordTypeModelsByName,
            recordTypeModelsByLabel
        );
        Test.stopTest();

        System.assertEquals(
            '123000000000000000',
            recordTypeModelResult.id,
            'Record type model name should be \'123000000000000000\'.'
        );
        System.assertEquals(
            'Record Type Label',
            recordTypeModelResult.name,
            'Record type model name should be \'Record Type Label\'.'
        );
        System.assertEquals(
            'Record_Type_Label',
            recordTypeModelResult.developerName,
            'Record type model name should be \'Record_Type_Label\'.'
        );
        System.assertEquals(false, recordTypeModelResult.isActive, 'Record type model name should be \'false\'.');
    }

    /**************************************************************************************************************************
     * @description Test method to verify that getRecordTypeModelFromNameAndLabelMaps returns a null record type model when no match is found
     * for a specified developer or label name.
     ***************************************************************************************************************************/
    @isTest
    private static void getRecordTypeModelFromNameAndLabelMapsNull() {
        Map<String, RecordTypeModel> recordTypeModelsByName = new Map<String, RecordTypeModel>{
            'Record_Type_1' => new RecordTypeModel('000000000000000001', 'Record Type 1', 'Record_Type_1', true)
        };

        Map<String, RecordTypeModel> recordTypeModelsByLabel = new Map<String, RecordTypeModel>{
            'Record Type Label' => new RecordTypeModel(
                '123000000000000000',
                'Record Type Label',
                'Record_Type_Label',
                false
            )
        };

        RecordTypeService recordTypeServiceInstance = RecordTypeService.getInstance();

        Test.startTest();
        RecordTypeModel recordTypeModelResult = recordTypeServiceInstance.getRecordTypeModelFromNameAndLabelMaps(
            'Non Existent Record Type Name',
            recordTypeModelsByName,
            recordTypeModelsByLabel
        );
        Test.stopTest();

        System.assertEquals(null, recordTypeModelResult, 'Record type model should be null.');
    }

    /**************************************************************************************************************************
     * @description Test method to verify that getRecordTypeModelMapByLabelPositive returns a map of record type models by label.
     ***************************************************************************************************************************/
    @isTest
    private static void getRecordTypeModelMapByLabelPositive() {
        Map<Id, RecordTypeModel> recordTypeModelsById = new Map<Id, RecordTypeModel>{
            '000000000000000001' => new RecordTypeModel('000000000000000001', 'Record Type 1', 'Record_Type_1', true),
            '000000000000000002' => new RecordTypeModel('000000000000000002', 'Record Type 2', 'Record_Type_2', false)
        };

        RecordTypeService recordTypeServiceInstance = RecordTypeService.getInstance();

        Test.startTest();
        Map<String, RecordTypeModel> recordTypeModelsByLabelResult = recordTypeServiceInstance.getRecordTypeModelMapByLabel(
            recordTypeModelsById
        );
        Test.stopTest();

        System.assertEquals(
            true,
            recordTypeModelsByLabelResult.keySet().contains('Record Type 1'),
            'Record type should be mapped by label name.'
        );
        System.assertEquals(
            true,
            recordTypeModelsByLabelResult.keySet().contains('Record Type 2'),
            'Record type should be mapped by label name.'
        );
    }

    /**************************************************************************************************************************
     * @description Test method to verify that getRecordTypeModelMapByLabelPositive returns a map of record type models by name.
     ***************************************************************************************************************************/
    @isTest
    private static void getRecordTypeModelMapByNamePositive() {
        Map<Id, RecordTypeModel> recordTypeModelsById = new Map<Id, RecordTypeModel>{
            '000000000000000001' => new RecordTypeModel('000000000000000001', 'Record Type 1', 'Record_Type_1', true),
            '000000000000000002' => new RecordTypeModel('000000000000000002', 'Record Type 2', 'Record_Type_2', false)
        };

        RecordTypeService recordTypeServiceInstance = RecordTypeService.getInstance();

        Test.startTest();
        Map<String, RecordTypeModel> recordTypeModelsByNameResult = recordTypeServiceInstance.getRecordTypeModelMapByName(
            recordTypeModelsById
        );
        Test.stopTest();

        System.assertEquals(
            true,
            recordTypeModelsByNameResult.keySet().contains('Record_Type_1'),
            'Record type should be mapped by developer name.'
        );
        System.assertEquals(
            true,
            recordTypeModelsByNameResult.keySet().contains('Record_Type_2'),
            'Record type should be mapped by developer name.'
        );
    }

    /***********************************************************************************************************************************
     * @description Test method to verify that the getActiveRecordTypeModelsById returns a list containing only active Account Record Types.
     ***********************************************************************************************************************************/
    @isTest
    private static void getActiveRecordTypeModelsByIdValid() {
        // active and inactive RTs exist
        List<RecordTypeModel> recordTypeModelsList = new List<RecordTypeModel>();

        recordTypeModelsList.add(
            new RecordTypeModel('000000000000000000', 'Active RecordType 1', 'Active_RecordType_1', true)
        );
        recordTypeModelsList.add(
            new RecordTypeModel('000000000000000001', 'Active RecordType 2', 'Active_RecordType_2', true)
        );
        recordTypeModelsList.add(
            new RecordTypeModel('000000000000000002', 'Inactive RecordType 1', 'Inactive_RecordType_1', false)
        );

        RecordTypeService recordTypeServiceInstance = RecordTypeService.getInstance();
        Test.startTest();
        Map<Id, RecordTypeModel> activeRecordTypeModelsById = recordTypeServiceInstance.getActiveRecordTypeModelsById(
            recordTypeModelsList
        );
        Test.stopTest();

        System.assertEquals(
            2,
            activeRecordTypeModelsById.values().size(),
            'Should contain 2 active record type models.'
        );

        for (RecordTypeModel recordTypeModel : activeRecordTypeModelsById.values()) {
            System.assertEquals(true, recordTypeModel.isActive, 'Record Type Model should be active.');
        }
    }

    /***********************************************************************************************************************************
     * @description Test method to verify that the getActiveRecordTypeModelsById returns an empty list when no active Account Record Types exist.
     ***********************************************************************************************************************************/
    @isTest
    private static void getActiveRecordTypeModelsByIdWithoutActive() {
        // only inactive RTs exist
        List<RecordTypeModel> recordTypeModelsList = new List<RecordTypeModel>();

        recordTypeModelsList.add(
            new RecordTypeModel('000000000000000000', 'Inactive RecordType 1', 'Inactive_RecordType_1', false)
        );
        recordTypeModelsList.add(
            new RecordTypeModel('000000000000000001', 'Inactive RecordType 2', 'Inactive_RecordType_2', false)
        );
        recordTypeModelsList.add(
            new RecordTypeModel('000000000000000002', 'Inactive RecordType 1', 'Inactive_RecordType_1', false)
        );

        RecordTypeService recordTypeServiceInstance = RecordTypeService.getInstance();
        Test.startTest();
        Map<Id, RecordTypeModel> activeRecordTypeModelsById = recordTypeServiceInstance.getActiveRecordTypeModelsById(
            recordTypeModelsList
        );
        Test.stopTest();

        System.assertEquals(
            0,
            activeRecordTypeModelsById.values().size(),
            'Should contain 0 active record type models.'
        );
    }

    /***********************************************************************************************************************************
     * @description Test method to verify that the filterListForValidIds correctly removes values from the specified list of Ids to find
     * that do not match a value in the set of valid Ids.
     ***********************************************************************************************************************************/
    @isTest
    private static void filterListForValidIdsValid() {
        List<String> idsToFindList = new List<String>{
            '000000000000000001',
            '000000000000000002',
            '000000000000000003',
            'Not an Id String'
        };
        Set<Id> validRecordTypeIdsSet = new Set<Id>{ '000000000000000001', '000000000000000003' };

        RecordTypeService recordTypeServiceInstance = RecordTypeService.getInstance();
        Test.startTest();
        List<Id> validIdsList = recordTypeServiceInstance.filterListForValidIds(idsToFindList, validRecordTypeIdsSet);
        Test.stopTest();

        System.assertEquals(2, validIdsList.size(), 'Should only contain ids matching valid record type Ids.');
        System.assertEquals(
            '000000000000000001',
            validIdsList[0],
            'Should contain valid Ids specified in list of Ids to find.'
        );
        System.assertEquals(
            '000000000000000003',
            validIdsList[1],
            'Should contain valid Ids specified in list of Ids to find.'
        );
    }

    /***********************************************************************************************************************************
     * @description Test method to verify that the filterListForValidIds returns an empty list of when no Ids are included in list of
     * Ids to find.
     ***********************************************************************************************************************************/
    @isTest
    private static void filterListForValidIdsNoIdsToFind() {
        List<String> idsToFindList = new List<String>();
        Set<Id> validRecordTypeIdsSet = new Set<Id>{ '000000000000000001', '000000000000000003' };

        RecordTypeService recordTypeServiceInstance = RecordTypeService.getInstance();

        Test.startTest();
        List<Id> validIdsList = recordTypeServiceInstance.filterListForValidIds(idsToFindList, validRecordTypeIdsSet);
        Test.stopTest();

        System.assertEquals(
            0,
            validIdsList.size(),
            'No Ids to find should return an empty list of matching valid Ids.'
        );
    }

    /***********************************************************************************************************************************
     * @description Test method to verify that the filterListForValidIds returns an empty list of when no valid record type Ids are
     * specified.
     ***********************************************************************************************************************************/
    @isTest
    private static void filterListForValidIdsNoValidIds() {
        List<String> idsToFindList = new List<String>{
            '000000000000000001',
            '000000000000000002',
            '000000000000000003'
        };
        Set<Id> validRecordTypeIdsSet = new Set<Id>();

        RecordTypeService recordTypeServiceInstance = RecordTypeService.getInstance();

        Test.startTest();
        List<Id> validIdsList = recordTypeServiceInstance.filterListForValidIds(idsToFindList, validRecordTypeIdsSet);
        Test.stopTest();

        System.assertEquals(
            0,
            validIdsList.size(),
            'No valid Ids in map should return an empty list of matching valid Ids.'
        );
    }

    /***********************************************************************************************************************************
     * @description Test method to verify getRecordTypeModelFromRecTypeDevName retrieves a recordtype model for given object and a record
     * type
     ***********************************************************************************************************************************/
    @isTest
    private static void getRecordTypeModelFromRecTypeDevName() {
        RecordTypeMapper.instance = new STUB_RecordTypeMapperModel();
        Test.startTest();
        RecordTypeModel recTypeMdl = RecordTypeService.getInstance()
            .getRecordTypeModelFromRecTypeDevName('Account', 'Household_Account');
        Test.stopTest();

        System.assert(recTypeMdl.Id != null, 'The id of the account recordtype in the model should have a value');
        System.assertEquals(
            'Household',
            recTypeMdl.name,
            'The name of the account recordtype in the model should have a value'
        );
        System.assertEquals(
            'Household Account',
            recTypeMdl.developerName,
            'The developer name of the account recordtype in the model should have a value'
        );
        System.assertEquals(true, recTypeMdl.isActive, 'The account record type should be active.');
    }

    /**************************************************************************************************************************
     ****************************************************** STUB CLASS *********************************************************
     **************************************************************************************************************************/

    /*************************************************************************************************************
     * @description Stub class to simulate the response from RecordTypeMapper to return a map of Record Type model by Id
     */
    private class STUB_RecordTypeMapper extends RecordTypeMapper {
        public override Map<Id, RecordTypeModel> getModelByIdMapForSObjectType(Schema.SObjectType sObjectType) {
            Map<Id, RecordTypeModel> stubRecordTypeModelById = new Map<Id, RecordTypeModel>();

            RecordTypeModel recordTypeModel = new RecordTypeModel(
                '000000000000000000',
                'Household',
                'Household Account',
                true
            );

            stubRecordTypeModelById.put('000000000000000000', recordTypeModel);

            return stubRecordTypeModelById;
        }
    }

    /*************************************************************************************************************
     * @description Stub class to simulate the response from RecordTypeMapper to return a recordtype model
     */
    private class STUB_RecordTypeMapperModel extends RecordTypeMapper {
        public override RecordTypeModel getRecordTypeModelFromRecTypeDevName(String objectAPI, String recTypeDevName) {
            RecordTypeModel recordTypeModel = new RecordTypeModel(
                '000000000000000000',
                'Household',
                'Household Account',
                true
            );

            return recordTypeModel;
        }
    }
}
@isTest
public with sharing class RelAutoCreateSettingsMapperService_TEST {
    
    /**************************************************************************************************************************
    * @description Test method to verify that the getInstance method returns a new instance of the 
    * RelAutoCreateSettingsMapperService class when one does not already exist.
    ***************************************************************************************************************************/
    @isTest
    private static void getInstanceNew() {
        RelAutoCreateSettingsMapperService srvcRelAutoCreateSettingMapper = RelAutoCreateSettingsMapperService.getInstance();
        System.assertEquals(RelAutoCreateSettingsMapperService.instance, srvcRelAutoCreateSettingMapper, 'Instance of service class returned should match static instance variable.');
        System.assertEquals(true, srvcRelAutoCreateSettingMapper != null, 'Instance of service class should not be null.');
    }

    /**************************************************************************************************************************
    * @description Test method to verify that the getInstance method returns the existing instance of the 
    * RelAutoCreateSettingsMapperService class when one already exists.
    ***************************************************************************************************************************/
    @isTest
    private static void getInstanceExisting() {
        RelAutoCreateSettingsMapperService srvcRelAutoCreateSettingsMapperInstance1 = RelAutoCreateSettingsMapperService.getInstance();
        RelAutoCreateSettingsMapperService srvcRelAutoCreateSettingsMapperInstance2 = RelAutoCreateSettingsMapperService.getInstance();
 
        System.assertEquals(RelAutoCreateSettingsMapperService.instance, srvcRelAutoCreateSettingsMapperInstance1, 'Instance of service class returned should match static instance variable.');
        System.assertEquals(srvcRelAutoCreateSettingsMapperInstance1, srvcRelAutoCreateSettingsMapperInstance2, 'Subsequent retrievals of service class instance should return existing instance.');
        System.assertEquals(true, srvcRelAutoCreateSettingsMapperInstance1 != null, 'Instance of service class should not be null.');
    }

    /***************************************************************************************************************************
    * @description Test method to verify that getContactMappingModelsFromSettings() returns only the models for Relationship 
    * Auto Create mappings associated with the Contact object.
    ***************************************************************************************************************************/ 
    @isTest 
    private static void getContactMappingModelsFromSettingsTrue(){
        List<Relationship_Auto_Create__c> relAutoCreateList = new List<Relationship_Auto_Create__c>();
        Relationship_Auto_Create__c contactRelAutoCreate;
        Relationship_Auto_Create__c accountRelAutoCreate;

        for (Integer i = 0; i < 5; i++){
            contactRelAutoCreate = new Relationship_Auto_Create__c(Name = 'ConReportToAutoCreate' + i, 
                                                                                               Object__c = 'Contact',
                                                                                               Field__c = 'ReportsToId', 
                                                                                               Relationship_Type__c = 'ContactTester' + i,
                                                                                               Campaign_Types__c = '');

            accountRelAutoCreate = new Relationship_Auto_Create__c(Name = 'AccountReportToAutoCreate' + i, 
                                                                                               Object__c = 'Account',
                                                                                               Field__c = 'Name', 
                                                                                               Relationship_Type__c = 'AccountTester' + i,
                                                                                               Campaign_Types__c = '');
            relAutoCreateList.add(contactRelAutoCreate);
            relAutoCreateList.add(accountRelAutoCreate);
        }

        insert relAutoCreateList;

        Test.startTest();
        List<ContactRelAutoCreateMappingModel> conRelAutoCreateMappingList = RelAutoCreateSettingsMapperService.getInstance().getContactMappingModelsFromSettings();
        Test.stopTest();

        System.assertEquals(5, conRelAutoCreateMappingList.size(), 'There should be 5 Relationship Auto Create Mapping models for Contact.');

        for (Integer i = 0; i < conRelAutoCreateMappingList.size(); i++){
            System.assertEquals('ReportsToId', conRelAutoCreateMappingList[i].contactFieldApiName, 'The contact field name set on model should correspond to the Relationship_Type__c for the Contact Relationship Auto Create mapping.');
            System.assertEquals('Reports To ID', conRelAutoCreateMappingList[i].contactFieldLabel, 'The contact field label set on model should correspond to the Relationship_Type__c for the Contact Relationship Auto Create mapping.');
            System.assertEquals('ContactTester' + i, conRelAutoCreateMappingList[i].relationshipType, 'The relationship type set on model should correspond to the Relationship_Type__c for the Contact Relationship Auto Create mapping.');
        }
    }

    /***************************************************************************************************************************
    * @description Test method to verify that getContactMappingModelsFromSettings() returns an empty list
    * when there are no Relationship Auto Create mappings for the Contact object set.
    ***************************************************************************************************************************/ 
    @isTest 
    private static void getContactMappingModelsFromSettingsFalse(){
        List<Relationship_Auto_Create__c> relAutoCreateList = [SELECT Id 
                                                               FROM Relationship_Auto_Create__c];

        delete relAutoCreateList;

        Test.startTest();
        System.assertEquals(true, RelAutoCreateSettingsMapperService.getInstance().getContactMappingModelsFromSettings().isEmpty(), 'There should be no Relationship Auto Create Mapping models for Contact.');
        Test.stopTest();
    }

    /***************************************************************************************************************************
    * @description Test method to verify that getContactMappingModelsFromMappings() returns a list of models representing
    * the Relationship Auto Create mappings provided as input (regardless of Object).
    ***************************************************************************************************************************/ 
    @isTest 
    private static void getContactMappingModelsFromMappingsTrue(){
        List<Relationship_Auto_Create__c> relAutoCreateList = new List<Relationship_Auto_Create__c>();

        for (Integer i = 0; i < 5; i++){
            Relationship_Auto_Create__c contactRelAutoCreate = new Relationship_Auto_Create__c(Id = UTIL_UnitTestData_TEST.getFakeId(Relationship_Auto_Create__c.SObjectType),
                                                                                               Name = 'ConReportToAutoCreate' + i, 
                                                                                               Object__c = 'Contact',
                                                                                               Field__c = 'reportsToId', 
                                                                                               Relationship_Type__c = 'ContactTester' + i,
                                                                                               Campaign_Types__c = '');

            Relationship_Auto_Create__c accountRelAutoCreate = new Relationship_Auto_Create__c(Id = UTIL_UnitTestData_TEST.getFakeId(Relationship_Auto_Create__c.SObjectType),
                                                                                               Name = 'AccountReportToAutoCreate' + i, 
                                                                                               Object__c = 'Account',
                                                                                               Field__c = 'Name', 
                                                                                               Relationship_Type__c = 'AccountTester' + i,
                                                                                               Campaign_Types__c = '');
            relAutoCreateList.add(contactRelAutoCreate);
            relAutoCreateList.add(accountRelAutoCreate);
        }

        Test.startTest();
        List<ContactRelAutoCreateMappingModel> conRelAutoCreateMappingsList = RelAutoCreateSettingsMapperService.getInstance().getContactMappingModelsFromMappings(relAutoCreateList);
        Test.stopTest();

        System.assertEquals(10, conRelAutoCreateMappingsList.size(), 'There should be 10 ContactRelAutoCreateMappingModel returned.');
    }

    /***************************************************************************************************************************
    * @description Test method to verify that getContactMappingModelsFromMappings() returns an empty list of when no 
    * Relationships Auto Create mappings are provided as input.
    ***************************************************************************************************************************/ 
    @isTest 
    private static void getContactMappingModelsFromMappingsFalse(){
        List<Relationship_Auto_Create__c> relAutoCreateList = new List<Relationship_Auto_Create__c>();

        Test.startTest();
        List<ContactRelAutoCreateMappingModel> conRelAutoCreateMappingsList = RelAutoCreateSettingsMapperService.getInstance().getContactMappingModelsFromMappings(relAutoCreateList);
        Test.stopTest();

        System.assertEquals(true, conRelAutoCreateMappingsList.isEmpty(), 'There should be no ContactRelAutoCreateMappingModel returned.');
    }

    /***************************************************************************************************************************
    * @description Test method to verify that getModelFromMapping() returns a model representing the Relationship Auto Create 
    * mapping provided as input (regardless of Object).
    ***************************************************************************************************************************/ 
    @isTest 
    private static void getModelFromMappingTrue(){
        List<Relationship_Auto_Create__c> relAutoCreateList = new List<Relationship_Auto_Create__c>();

        for (Integer i = 0; i < 5; i++){
            Relationship_Auto_Create__c contactRelAutoCreate = new Relationship_Auto_Create__c(Id = UTIL_UnitTestData_TEST.getFakeId(Relationship_Auto_Create__c.SObjectType),
                                                                                               Name = 'ConReportToAutoCreate' + i, 
                                                                                               Object__c = 'Contact',
                                                                                               Field__c = 'ReportsToId', 
                                                                                               Relationship_Type__c = 'ContactTester' + i,
                                                                                               Campaign_Types__c = '');

            Relationship_Auto_Create__c accountRelAutoCreate = new Relationship_Auto_Create__c(Id = UTIL_UnitTestData_TEST.getFakeId(Relationship_Auto_Create__c.SObjectType),
                                                                                               Name = 'AccountReportToAutoCreate' + i, 
                                                                                               Object__c = 'Account',
                                                                                               Field__c = 'Name', 
                                                                                               Relationship_Type__c = 'AccountTester' + i,
                                                                                               Campaign_Types__c = '');
            relAutoCreateList.add(contactRelAutoCreate);
            relAutoCreateList.add(accountRelAutoCreate);
        }

        Test.startTest();
        for (Relationship_Auto_Create__c relAutoCreate : relAutoCreateList){
            ContactRelAutoCreateMappingModel conRelAutoCreateMapping = RelAutoCreateSettingsMapperService.getInstance().getModelFromMapping(relAutoCreate);
            if (conRelAutoCreateMapping.relationshipType.contains('ContactTester')){
                System.assertEquals(true, conRelAutoCreateMapping.contactFieldApiName.contains('ReportsToId'));
                System.assertEquals(true, conRelAutoCreateMapping.contactFieldLabel.contains('Reports To ID'));
            } else {
                System.assertEquals(true, conRelAutoCreateMapping.settingsContactFieldValue.contains('Name'));
                System.assertEquals(true, conRelAutoCreateMapping.relationshipType.contains('AccountTester'));
            }
        }
        Test.stopTest();
    }

    /***************************************************************************************************************************
    * @description Test method to verify that getModelFromMapping() returns a model with default settings applied when an empty 
    * Relationship Auto Create mapping is provided as input.
    ***************************************************************************************************************************/ 
    @isTest 
    private static void getModelFromMappingFalse(){
        RelAutoCreateSettingsMapperService.instance = new STUB_NoRelAutoCreateMappingModel();

        Test.startTest();
        System.assertEquals(null, RelAutoCreateSettingsMapperService.getInstance().getModelFromMapping(new Relationship_Auto_Create__c()), 'Empty Relationship Auto Create record should return null');
        Test.stopTest();
    }

    /**************************************************************************************************************************
    ****************************************************** STUBS **************************************************************
    **************************************************************************************************************************/

    /************************************************************************************************************
    * @description Stub class to simulate a null response from the getModelFromMapping method in the
    * RelAutoCreateSettingsMapperService.
    *************************************************************************************************************/ 
    private class STUB_NoRelAutoCreateMappingModel extends RelAutoCreateSettingsMapperService {
        @TestVisible
        public override ContactRelAutoCreateMappingModel getModelFromMapping(Relationship_Auto_Create__c relAutoCreate){
            return null;
        }
    }
}
@isTest
private with sharing class RelAutoCreateSettingsMapper_TEST {
    
    /**************************************************************************************************************************
    * @description Test method to verify that the getInstance method returns a new instance of the 
    * RelAutoCreateSettingsMapper class when one does not already exist.
    ***************************************************************************************************************************/
    @isTest
    private static void getInstanceNew() {
        RelAutoCreateSettingsMapper srvcRelAutoCreateSettingMapper = RelAutoCreateSettingsMapper.getInstance();
        System.assertEquals(RelAutoCreateSettingsMapper.instance, srvcRelAutoCreateSettingMapper, 'Instance of service class returned should match static instance variable.');
        System.assertEquals(true, srvcRelAutoCreateSettingMapper != null, 'Instance of service class should not be null.');
    }

    /**************************************************************************************************************************
    * @description Test method to verify that the getInstance method returns the existing instance of the 
    * RelAutoCreateSettingsMapper class when one already exists.
    ***************************************************************************************************************************/
    @isTest
    private static void getInstanceExisting() {
        RelAutoCreateSettingsMapper srvcRelAutoCreateSettingsMapperInstance1 = RelAutoCreateSettingsMapper.getInstance();
        RelAutoCreateSettingsMapper srvcRelAutoCreateSettingsMapperInstance2 = RelAutoCreateSettingsMapper.getInstance();
 
        System.assertEquals(RelAutoCreateSettingsMapper.instance, srvcRelAutoCreateSettingsMapperInstance1, 'Instance of service class returned should match static instance variable.');
        System.assertEquals(srvcRelAutoCreateSettingsMapperInstance1, srvcRelAutoCreateSettingsMapperInstance2, 'Subsequent retrievals of service class instance should return existing instance.');
        System.assertEquals(true, srvcRelAutoCreateSettingsMapperInstance1 != null, 'Instance of service class should not be null.');
    }

    /***************************************************************************************************************************
    * @description Test method to verify that getContactMappingModelsFromSettings() returns only the models for Relationship 
    * Auto Create mappings associated with the Contact object.
    ***************************************************************************************************************************/ 
    @isTest 
    private static void getContactMappingModelsFromSettingsTrue(){
        List<Relationship_Auto_Create__c> relAutoCreateList = new List<Relationship_Auto_Create__c>();
        Relationship_Auto_Create__c contactRelAutoCreate;
        Relationship_Auto_Create__c accountRelAutoCreate;

        for (Integer i = 0; i < 5; i++){
            contactRelAutoCreate = new Relationship_Auto_Create__c(Name = 'ConReportToAutoCreate' + i, 
                                                                                               Object__c = 'Contact',
                                                                                               Field__c = 'ReportsToId', 
                                                                                               Relationship_Type__c = 'ContactTester' + i,
                                                                                               Campaign_Types__c = '');

            accountRelAutoCreate = new Relationship_Auto_Create__c(Name = 'AccountReportToAutoCreate' + i, 
                                                                                               Object__c = 'Account',
                                                                                               Field__c = 'Name', 
                                                                                               Relationship_Type__c = 'AccountTester' + i,
                                                                                               Campaign_Types__c = '');
            relAutoCreateList.add(contactRelAutoCreate);
            relAutoCreateList.add(accountRelAutoCreate);
        }

        insert relAutoCreateList;

        Test.startTest();
        List<ContactRelAutoCreateMappingModel> conRelAutoCreateMappingList = RelAutoCreateSettingsMapper.getInstance().getContactMappingModelsFromSettings();
        Test.stopTest();

        System.assertEquals(5, conRelAutoCreateMappingList.size(), 'There should be 5 Relationship Auto Create Mapping models for Contact.');

        for (Integer i = 0; i < conRelAutoCreateMappingList.size(); i++){
            System.assertEquals('ReportsToId', conRelAutoCreateMappingList[i].contactFieldApiName, 'The contact field name set on model should correspond to the Relationship_Type__c for the Contact Relationship Auto Create mapping.');
            System.assertEquals('Reports To ID', conRelAutoCreateMappingList[i].contactFieldLabel, 'The contact field label set on model should correspond to the Relationship_Type__c for the Contact Relationship Auto Create mapping.');
            System.assertEquals('ContactTester' + i, conRelAutoCreateMappingList[i].relationshipType, 'The relationship type set on model should correspond to the Relationship_Type__c for the Contact Relationship Auto Create mapping.');
        }
    }

    /***************************************************************************************************************************
    * @description Test method to verify that getContactMappingModelsFromSettings() returns its cached value
    ***************************************************************************************************************************/ 
    @isTest 
    private static void getContactMappingModelsFromSettingsCached(){
        List<Relationship_Auto_Create__c> relAutoCreateList = new List<Relationship_Auto_Create__c>();
        Relationship_Auto_Create__c contactRelAutoCreate;
        Relationship_Auto_Create__c accountRelAutoCreate;

        for (Integer i = 0; i < 5; i++){
            contactRelAutoCreate = new Relationship_Auto_Create__c(Name = 'ConReportToAutoCreate' + i, 
                                                                                               Object__c = 'Contact',
                                                                                               Field__c = 'ReportsToId', 
                                                                                               Relationship_Type__c = 'ContactTester' + i,
                                                                                               Campaign_Types__c = '');

            accountRelAutoCreate = new Relationship_Auto_Create__c(Name = 'AccountReportToAutoCreate' + i, 
                                                                                               Object__c = 'Account',
                                                                                               Field__c = 'Name', 
                                                                                               Relationship_Type__c = 'AccountTester' + i,
                                                                                               Campaign_Types__c = '');
            relAutoCreateList.add(contactRelAutoCreate);
            relAutoCreateList.add(accountRelAutoCreate);
        }

        insert relAutoCreateList;

        List<ContactRelAutoCreateMappingModel> conRelAutoCreateMappingList = RelAutoCreateSettingsMapper.getInstance().getContactMappingModelsFromSettings();

        Test.startTest();
        List<ContactRelAutoCreateMappingModel> conRelAutoCreateMappingList2 = RelAutoCreateSettingsMapper.getInstance().getContactMappingModelsFromSettings();
        Test.stopTest();

        System.assertEquals(conRelAutoCreateMappingList, conRelAutoCreateMappingList2, 'The relationship autocreate mapping models should be cached.');
    }

    /***************************************************************************************************************************
    * @description Test method to verify that getContactMappingModelsFromSettings() returns an empty list
    * when there are no Relationship Auto Create mappings for the Contact object set.
    ***************************************************************************************************************************/ 
    @isTest 
    private static void getContactMappingModelsFromSettingsFalse(){
        List<Relationship_Auto_Create__c> relAutoCreateList = [SELECT Id 
                                                               FROM Relationship_Auto_Create__c];

        delete relAutoCreateList;

        Test.startTest();
        System.assertEquals(true, RelAutoCreateSettingsMapper.getInstance().getContactMappingModelsFromSettings().isEmpty(), 'There should be no Relationship Auto Create Mapping models for Contact.');
        Test.stopTest();
    }

    /***************************************************************************************************************************
    * @description Test method to verify that getContactMappingModelsFromMappings() returns a list of models representing
    * the Relationship Auto Create mappings provided as input (regardless of Object).
    ***************************************************************************************************************************/ 
    @isTest 
    private static void getContactMappingModelsFromMappingsTrue(){
        List<Relationship_Auto_Create__c> relAutoCreateList = new List<Relationship_Auto_Create__c>();

        for (Integer i = 0; i < 5; i++){
            Relationship_Auto_Create__c contactRelAutoCreate = new Relationship_Auto_Create__c(Id = UTIL_UnitTestData_TEST.getFakeId(Relationship_Auto_Create__c.SObjectType),
                                                                                               Name = 'ConReportToAutoCreate' + i, 
                                                                                               Object__c = 'Contact',
                                                                                               Field__c = 'reportsToId', 
                                                                                               Relationship_Type__c = 'ContactTester' + i,
                                                                                               Campaign_Types__c = '');

            Relationship_Auto_Create__c accountRelAutoCreate = new Relationship_Auto_Create__c(Id = UTIL_UnitTestData_TEST.getFakeId(Relationship_Auto_Create__c.SObjectType),
                                                                                               Name = 'AccountReportToAutoCreate' + i, 
                                                                                               Object__c = 'Account',
                                                                                               Field__c = 'Name', 
                                                                                               Relationship_Type__c = 'AccountTester' + i,
                                                                                               Campaign_Types__c = '');
            relAutoCreateList.add(contactRelAutoCreate);
            relAutoCreateList.add(accountRelAutoCreate);
        }

        Test.startTest();
        List<ContactRelAutoCreateMappingModel> conRelAutoCreateMappingsList = RelAutoCreateSettingsMapper.getInstance().getContactMappingModelsFromMappings(relAutoCreateList);
        Test.stopTest();

        System.assertEquals(10, conRelAutoCreateMappingsList.size(), 'There should be 10 ContactRelAutoCreateMappingModel returned.');
    }

    /***************************************************************************************************************************
    * @description Test method to verify that getContactMappingModelsFromMappings() returns an empty list of when no 
    * Relationships Auto Create mappings are provided as input.
    ***************************************************************************************************************************/ 
    @isTest 
    private static void getContactMappingModelsFromMappingsFalse(){
        List<Relationship_Auto_Create__c> relAutoCreateList = new List<Relationship_Auto_Create__c>();

        Test.startTest();
        List<ContactRelAutoCreateMappingModel> conRelAutoCreateMappingsList = RelAutoCreateSettingsMapper.getInstance().getContactMappingModelsFromMappings(relAutoCreateList);
        Test.stopTest();

        System.assertEquals(true, conRelAutoCreateMappingsList.isEmpty(), 'There should be no ContactRelAutoCreateMappingModel returned.');
    }

    /***************************************************************************************************************************
    * @description Test method to verify that getModelFromMapping() returns a model representing the Relationship Auto Create 
    * mapping provided as input (regardless of Object).
    ***************************************************************************************************************************/ 
    @isTest 
    private static void getModelFromMappingTrue(){
        List<Relationship_Auto_Create__c> relAutoCreateList = new List<Relationship_Auto_Create__c>();

        for (Integer i = 0; i < 5; i++){
            Relationship_Auto_Create__c contactRelAutoCreate = new Relationship_Auto_Create__c(Id = UTIL_UnitTestData_TEST.getFakeId(Relationship_Auto_Create__c.SObjectType),
                                                                                               Name = 'ConReportToAutoCreate' + i, 
                                                                                               Object__c = 'Contact',
                                                                                               Field__c = 'ReportsToId', 
                                                                                               Relationship_Type__c = 'ContactTester' + i,
                                                                                               Campaign_Types__c = '');

            Relationship_Auto_Create__c accountRelAutoCreate = new Relationship_Auto_Create__c(Id = UTIL_UnitTestData_TEST.getFakeId(Relationship_Auto_Create__c.SObjectType),
                                                                                               Name = 'AccountReportToAutoCreate' + i, 
                                                                                               Object__c = 'Account',
                                                                                               Field__c = 'Name', 
                                                                                               Relationship_Type__c = 'AccountTester' + i,
                                                                                               Campaign_Types__c = '');
            relAutoCreateList.add(contactRelAutoCreate);
            relAutoCreateList.add(accountRelAutoCreate);
        }

        Test.startTest();
        for (Relationship_Auto_Create__c relAutoCreate : relAutoCreateList){
            ContactRelAutoCreateMappingModel conRelAutoCreateMapping = RelAutoCreateSettingsMapper.getInstance().getModelFromMapping(relAutoCreate);
            if (conRelAutoCreateMapping.relationshipType.contains('ContactTester')){
                System.assertEquals(true, conRelAutoCreateMapping.contactFieldApiName.contains('ReportsToId'));
                System.assertEquals(true, conRelAutoCreateMapping.contactFieldLabel.contains('Reports To ID'));
            } else {
                System.assertEquals(true, conRelAutoCreateMapping.settingsContactFieldValue.contains('Name'));
                System.assertEquals(true, conRelAutoCreateMapping.relationshipType.contains('AccountTester'));
            }
        }
        Test.stopTest();
    }

    /***************************************************************************************************************************
    * @description Test method to verify that getModelFromMapping() returns a model with default settings applied when an empty 
    * Relationship Auto Create mapping is provided as input.
    ***************************************************************************************************************************/ 
    @isTest 
    private static void getModelFromMappingFalse(){
        RelAutoCreateSettingsMapper.instance = new STUB_NoRelAutoCreateMappingModel();

        Test.startTest();
        System.assertEquals(null, RelAutoCreateSettingsMapper.getInstance().getModelFromMapping(new Relationship_Auto_Create__c()), 'Empty Relationship Auto Create record should return null');
        Test.stopTest();
    }

    /**************************************************************************************************************************
    ****************************************************** STUBS **************************************************************
    **************************************************************************************************************************/

    /************************************************************************************************************
    * @description Stub class to simulate a null response from the getModelFromMapping method in the
    * RelAutoCreateSettingsMapper.
    *************************************************************************************************************/ 
    private class STUB_NoRelAutoCreateMappingModel extends RelAutoCreateSettingsMapper {
        @TestVisible
        public override ContactRelAutoCreateMappingModel getModelFromMapping(Relationship_Auto_Create__c relAutoCreate){
            return null;
        }
    }
}
@isTest
private class RelationshipLookupMapper_TEST {
    /**************************************************************************************************************************
     * @description Test method to verify that the getInstance method returns a new instance of the
     * RelationshipLookupMapper class when one does not already exist.
     ***************************************************************************************************************************/
    @isTest
    private static void getInstanceNew() {
        Test.startTest();
        RelationshipLookupMapper relationshipLookupMapperInstance = RelationshipLookupMapper.getInstance();
        Test.stopTest();

        System.assertEquals(
            RelationshipLookupMapper.instance,
            relationshipLookupMapperInstance,
            'Instance of mapper class returned should match static instance variable.'
        );
        System.assertEquals(
            true,
            relationshipLookupMapperInstance != null,
            'Instance of mapper class should not be null.'
        );
    }

    /**************************************************************************************************************************
     * @description Test method to verify that the getInstance method returns the existing instance of the
     * RelationshipLookupMapper class when one already exists.
     ***************************************************************************************************************************/
    @isTest
    private static void getInstanceExisting() {
        Test.startTest();
        RelationshipLookupMapper relationshipLookupMapperInstance1 = RelationshipLookupMapper.getInstance();
        RelationshipLookupMapper relationshipLookupMapperInstance2 = RelationshipLookupMapper.getInstance();
        Test.stopTest();

        System.assertEquals(
            RelationshipLookupMapper.instance,
            relationshipLookupMapperInstance1,
            'Instance of mapper class returned should match static instance variable.'
        );
        System.assertEquals(
            relationshipLookupMapperInstance1,
            relationshipLookupMapperInstance2,
            'Subsequent retrievals of mapper class instance should return existing instance.'
        );
        System.assertEquals(
            true,
            relationshipLookupMapperInstance1 != null,
            'Instance of mapper class should not be null.'
        );
    }

    /****************************************************************************************************************************
     * @description Test method to verify that the getRelationshipLookupModels method returns a list of relationship lookup models
     *****************************************************************************************************************************/
    @isTest
    private static void getRelationshipLookupModels() {
        RelationshipLookupMapper relationshipLookupMapperInstance = RelationshipLookupMapper.getInstance();

        insert new Relationship_Lookup__c(
            Name = 'test' + system.now(),
            Active__c = true,
            Female__c = 'wife',
            Male__c = 'husband',
            Neutral__c = 'spouse'
        );

        Test.startTest();
        List<RelationshipLookupModel> relationshipLookupModelsList = relationshipLookupMapperInstance.getRelationshipLookupModels();
        Test.stopTest();

        List<Relationship_Lookup__c> relationshipLookupList = UTIL_CustomSettingsFacade.getReciprocalSettings();

        System.assertEquals(1, relationshipLookupList.size(), 'Only one item should be available in the list');
        System.assertEquals(
            relationshipLookupList[0].Name,
            relationshipLookupModelsList[0].name,
            'Retrieved model\'s name should be same as Name from settings'
        );
        System.assertEquals(
            relationshipLookupList[0].Active__c,
            relationshipLookupModelsList[0].isActive,
            'Retrieved model\'s isActive should be same as isActive__c from settings'
        );
        System.assertEquals(
            relationshipLookupList[0].Female__c,
            relationshipLookupModelsList[0].femaleValue,
            'Retrieved model\'s femaleValue should be same as Female__c from settings'
        );
        System.assertEquals(
            relationshipLookupList[0].Male__c,
            relationshipLookupModelsList[0].maleValue,
            'Retrieved model\'s maleValue should be same as Male__c from settings'
        );
        System.assertEquals(
            relationshipLookupList[0].Neutral__c,
            relationshipLookupModelsList[0].neutralValue,
            'Retrieved model\'s neutralValue should be same as Neutral__c from settings'
        );
    }

    /****************************************************************************************************************************
     * @description Test method to verify that the insertRelationshipLookupModel inserts a record into Relationship_Lookup__c
     *****************************************************************************************************************************/
    @isTest
    private static void insertRelationshipLookupModel() {
        String relationshipLookupName = 'Father';
        String femaleValue = 'Daughter';
        String maleValue = 'Son';
        String neutralValue = 'Child';
        Boolean isActive = false;
        RelationshipLookupMapper relationshipLookupMapperInstance = RelationshipLookupMapper.getInstance();

        Test.startTest();
        relationshipLookupMapperInstance.insertRelationshipLookupModel(
            new RelationshipLookupModel(relationshipLookupName, isActive, femaleValue, maleValue, neutralValue)
        );
        Test.stopTest();

        Relationship_Lookup__c insertedRelationshipLookup = Relationship_Lookup__c.getInstance(relationshipLookupName);
        System.assertEquals(
            relationshipLookupName,
            insertedRelationshipLookup.Name,
            'Inserted record\'s name should be ' + relationshipLookupName
        );
        System.assertEquals(
            isActive,
            insertedRelationshipLookup.Active__c,
            'Inserted record\'s isActive__c should be ' + isActive
        );
        System.assertEquals(
            femaleValue,
            insertedRelationshipLookup.Female__c,
            'Inserted record\'s Female__c should be ' + femaleValue
        );
        System.assertEquals(
            maleValue,
            insertedRelationshipLookup.Male__c,
            'Inserted record\'s Male__c should be ' + maleValue
        );
        System.assertEquals(
            neutralValue,
            insertedRelationshipLookup.Neutral__c,
            'Inserted record\'s Neutral__c should be ' + neutralValue
        );
    }

    /****************************************************************************************************************************
     * @description Test method to verify that the updateRelationshipLookupModel updates a record in Relationship_Lookup__c
     *****************************************************************************************************************************/
    @isTest
    private static void updateRelationshipLookupModel() {
        String oldRelationshipLookupName = 'Test';
        String newRelationshipLookupName = 'Father';
        String femaleValue = 'Daughter';
        String maleValue = 'Son';
        String neutralValue = 'Child';
        Boolean isActive = true;
        RelationshipLookupMapper relationshipLookupMapperInstance = RelationshipLookupMapper.getInstance();

        insert new Relationship_Lookup__c(
            Name = oldRelationshipLookupName,
            Active__c = false,
            Female__c = 'wife',
            Male__c = 'husband',
            Neutral__c = 'spouse'
        );

        Test.startTest();
        relationshipLookupMapperInstance.updateRelationshipLookupModel(
            oldRelationshipLookupName,
            new RelationshipLookupModel(newRelationshipLookupName, isActive, femaleValue, maleValue, neutralValue)
        );
        Test.stopTest();

        Relationship_Lookup__c updatedOldRelationshipLookup = Relationship_Lookup__c.getInstance(
            oldRelationshipLookupName
        );
        Relationship_Lookup__c updatedRelationshipLookup = Relationship_Lookup__c.getInstance(
            newRelationshipLookupName
        );

        System.assertEquals(
            null,
            updatedOldRelationshipLookup,
            'A relationship record with old name should not exist: ' + oldRelationshipLookupName
        );
        System.assertEquals(
            newRelationshipLookupName,
            updatedRelationshipLookup.Name,
            'Inserted record\'s name should be ' + newRelationshipLookupName
        );
        System.assertEquals(
            isActive,
            updatedRelationshipLookup.Active__c,
            'Inserted record\'s isActive__c should be ' + isActive
        );
        System.assertEquals(
            femaleValue,
            updatedRelationshipLookup.Female__c,
            'Inserted record\'s Female__c should be ' + femaleValue
        );
        System.assertEquals(
            maleValue,
            updatedRelationshipLookup.Male__c,
            'Inserted record\'s Male__c should be ' + maleValue
        );
        System.assertEquals(
            neutralValue,
            updatedRelationshipLookup.Neutral__c,
            'Inserted record\'s Neutral__c should be ' + neutralValue
        );
    }

    /****************************************************************************************************************************
     * @description Test method to verify that the deleteRelationshipLookupModel deletes a record in Relationship_Lookup__c
     *****************************************************************************************************************************/
    @isTest
    private static void deleteRelationshipLookupModel() {
        String relationshipLookupName = 'Father';
        String femaleValue = 'Daughter';
        String maleValue = 'Son';
        String neutralValue = 'Child';
        Boolean isActive = true;
        RelationshipLookupMapper relationshipLookupMapperInstance = RelationshipLookupMapper.getInstance();

        insert new Relationship_Lookup__c(
            Name = relationshipLookupName,
            Active__c = isActive,
            Female__c = femaleValue,
            Male__c = maleValue,
            Neutral__c = neutralValue
        );
        Relationship_Lookup__c existingRelationshipLookup = Relationship_Lookup__c.getInstance(relationshipLookupName);

        Test.startTest();
        relationshipLookupMapperInstance.deleteRelationshipLookupModel(
            new RelationshipLookupModel(relationshipLookupName, isActive, femaleValue, maleValue, neutralValue)
        );
        Test.stopTest();

        Relationship_Lookup__c deletedRelationshipLookup = Relationship_Lookup__c.getInstance(relationshipLookupName);

        System.assertNotEquals(
            null,
            existingRelationshipLookup,
            'Inserted relationship record with name \'' +
            relationshipLookupName +
            '\' should exist prior to delete'
        );
        System.assertEquals(
            relationshipLookupName,
            existingRelationshipLookup.Name,
            'Inserted record\'s name should be ' + relationshipLookupName
        );
        System.assertEquals(
            null,
            deletedRelationshipLookup,
            'A relationship record with name \'' +
            relationshipLookupName +
            '\' should not exist'
        );
    }
}
@isTest
private class RelationshipLookupSettingsService_TEST {
    /**************************************************************************************************************************
     * @description Test method to verify that the getInstance method returns a new instance of the
     * RelationshipLookupSettingsService class when one does not already exist.
     ***************************************************************************************************************************/
    @isTest
    private static void getInstanceNew() {
        Test.startTest();
        RelationshipLookupSettingsService relationshipLookupSettingsServiceInstance = RelationshipLookupSettingsService.getInstance();
        Test.stopTest();

        System.assertEquals(
            RelationshipLookupSettingsService.instance,
            relationshipLookupSettingsServiceInstance,
            'Instance of service class returned should match static instance variable.'
        );
        System.assertEquals(
            true,
            relationshipLookupSettingsServiceInstance != null,
            'Instance of service class should not be null.'
        );
    }

    /**************************************************************************************************************************
     * @description Test method to verify that the getInstance method returns the existing instance of the
     * RelationshipLookupSettingsService class when one already exists.
     ***************************************************************************************************************************/
    @isTest
    private static void getInstanceExisting() {
        Test.startTest();
        RelationshipLookupSettingsService relationshipLookupSettingsServiceInstance1 = RelationshipLookupSettingsService.getInstance();
        RelationshipLookupSettingsService relationshipLookupSettingsServiceInstance2 = RelationshipLookupSettingsService.getInstance();
        Test.stopTest();

        System.assertEquals(
            RelationshipLookupSettingsService.instance,
            relationshipLookupSettingsServiceInstance1,
            'Instance of service class returned should match static instance variable.'
        );
        System.assertEquals(
            relationshipLookupSettingsServiceInstance1,
            relationshipLookupSettingsServiceInstance2,
            'Subsequent retrievals of service class instance should return existing instance.'
        );
        System.assertEquals(
            true,
            relationshipLookupSettingsServiceInstance1 != null,
            'Instance of service class should not be null.'
        );
    }

    /***********************************************************************************************************************************
     * @description Test method to verify that the locateRelationshipLookupMapper method returns instance of RelationshipLookupMapper
     ***********************************************************************************************************************************/
    @isTest
    private static void locateRelationshipLookupMapper() {
        Test.startTest();
        RelationshipLookupMapper relLookupMapper = RelationshipLookupSettingsService.getInstance()
            .locateRelationshipLookupMapper();
        Test.stopTest();

        System.assertEquals(
            RelationshipLookupMapper.getInstance(),
            relLookupMapper,
            'Should return the instance of RelationshipLookupMapper'
        );
    }

    /***********************************************************************************************************************************
     * @description Test method to verify that the getRelationshipLookupModels method returns instance of getRelationshipLookup Models
     ***********************************************************************************************************************************/
    @isTest
    private static void getRelationshipLookupModels() {
        RelationshipLookupMapper.instance = new STUB_RelationshipLookupMapper();

        Test.startTest();
        List<RelationshipLookupModel> relationshipLookupModelList = RelationshipLookupSettingsService.getInstance()
            .getRelationshipLookupModels();
        Test.stopTest();

        System.assertEquals(
            1,
            relationshipLookupModelList.size(),
            'Only 1 record should be availabel in the list as we are adding only one settings to the model'
        );
        System.assertEquals(
            'Father',
            relationshipLookupModelList[0].Name,
            'Retrieved model\'s name should be same as Name from settings'
        );
        System.assertEquals(
            true,
            relationshipLookupModelList[0].isActive,
            'Retrieved model\'s isActive should be same as isActive__c from settings'
        );
        System.assertEquals(
            'Daughter',
            relationshipLookupModelList[0].femaleValue,
            'Retrieved model\'s femaleValue should be same as Female__c from settings'
        );
        System.assertEquals(
            'Son',
            relationshipLookupModelList[0].maleValue,
            'Retrieved model\'s maleValue should be same as Male__c from settings'
        );
        System.assertEquals(
            'Child',
            relationshipLookupModelList[0].neutralValue,
            'Retrieved model\'s neutralValue should be same as Neutral__c from settings'
        );
    }

    /***************************************************************************
     * @description Test Method to verify that duplicate relationship model names
     * are retrieved.
     ***************************************************************************/
    @isTest
    private static void getDuplicateRelationshipModelNamesFromList() {
        RelationshipLookupModel uniqueRelationshipLookupModel = new RelationshipLookupModel(
            'unique',
            true,
            'uniquefemale',
            'uniquemale',
            'uniqueneutral'
        );

        RelationshipLookupModel duplicateRelationshipLookupModel1 = new RelationshipLookupModel(
            'duplicate',
            true,
            'duplicatefemale1',
            'duplicatemale1',
            'duplicateneutral1'
        );
        RelationshipLookupModel duplicateRelationshipLookupModel2 = new RelationshipLookupModel(
            'duplicate',
            true,
            'duplicatefemale2',
            'duplicatemale2',
            'duplicateneutral2'
        );

        List<RelationshipLookupModel> relationshipLookupModelList = new List<RelationshipLookupModel>{
            uniqueRelationshipLookupModel,
            duplicateRelationshipLookupModel1,
            duplicateRelationshipLookupModel2
        };

        RelationshipLookupSettingsService relationshipLookupSettingsService = RelationshipLookupSettingsService.getInstance();

        Test.startTest();
        Set<String> duplicateNameSet = relationshipLookupSettingsService.getDuplicateRelationshipModelNamesFromList(
            relationshipLookupModelList
        );
        Test.stopTest();

        System.assertEquals(1, duplicateNameSet.size(), 'Duplicate name set size should equal 1');
        System.assertEquals(
            true,
            duplicateNameSet.contains('duplicate'),
            'Duplicate name set should contain name for duplicate'
        );
        System.assertNotEquals(
            true,
            duplicateNameSet.contains('unique'),
            'Duplicate name set should not contain name for unique.'
        );
    }

    /***************************************************************************
     * @description Test Method to verify that insertRelationshipLookup returns
     * a valid RelationshipLookupModel model
     ***************************************************************************/
    @isTest
    private static void insertRelationshipLookup() {
        UserPermissionService.instance = new STUB_UserPermissionServiceTrue();
        RelationshipLookupMapper.instance = new STUB_RelationshipLookupMapper();
        String relationshipLookupName = 'TestRelationshipLookupName';
        String femaleValue = 'TestFemaleValue';
        String maleValue = 'TestMaleValue';
        String neutralValue = 'TestNeutralValue';
        Boolean isActive = false;

        Test.startTest();
        RelationshipLookupModel insertRelationshipLookupModel = RelationshipLookupSettingsService.getInstance()
            .insertRelationshipLookup(relationshipLookupName, femaleValue, maleValue, neutralValue, isActive);
        Test.stopTest();

        System.assertNotEquals(null, insertRelationshipLookupModel, 'Should return a RelationshipLookupModel instance');
        System.assertEquals(
            relationshipLookupName,
            insertRelationshipLookupModel.name,
            'Inserted model\'s name should be ' + relationshipLookupName
        );
        System.assertEquals(
            isActive,
            insertRelationshipLookupModel.isActive,
            'Inserted model\'s isActive should be ' + isActive
        );
        System.assertEquals(
            femaleValue,
            insertRelationshipLookupModel.femaleValue,
            'Inserted model\'s femaleValue should ' + femaleValue
        );
        System.assertEquals(
            maleValue,
            insertRelationshipLookupModel.maleValue,
            'Inserted model\'s maleValue should be ' + maleValue
        );
        System.assertEquals(
            neutralValue,
            insertRelationshipLookupModel.neutralValue,
            'Inserted model\'s neutralValue should be ' + neutralValue
        );
    }

    /***************************************************************************
     * @description Test Method to verify that updateRelationshipLookup returns
     * a valid RelationshipLookupModel model
     ***************************************************************************/
    @isTest
    private static void updateRelationshipLookup() {
        UserPermissionService.instance = new STUB_UserPermissionServiceTrue();
        RelationshipLookupMapper.instance = new STUB_RelationshipLookupMapper();
        String newRelationshipLookupName = 'TestNewRelationshipLookupName';
        String oldRelationshipLookupName = 'TestOldRelationshipLookupName';
        String femaleValue = 'TestFemaleValue';
        String maleValue = 'TestMaleValue';
        String neutralValue = 'TestNeutralValue';
        Boolean isActive = false;

        Test.startTest();
        RelationshipLookupModel updateRelationshipLookupModel = RelationshipLookupSettingsService.getInstance()
            .updateRelationshipLookup(
                oldRelationshipLookupName,
                newRelationshipLookupName,
                femaleValue,
                maleValue,
                neutralValue,
                isActive
            );
        Test.stopTest();

        System.assertNotEquals(null, updateRelationshipLookupModel, 'Should return a RelationshipLookupModel instance');
        System.assertEquals(
            newRelationshipLookupName,
            updateRelationshipLookupModel.name,
            'Updated model\'s name should be ' + newRelationshipLookupName
        );
        System.assertEquals(
            isActive,
            updateRelationshipLookupModel.isActive,
            'Updated model\'s isActive should be ' + isActive
        );
        System.assertEquals(
            femaleValue,
            updateRelationshipLookupModel.femaleValue,
            'Updated model\'s femaleValue should ' + femaleValue
        );
        System.assertEquals(
            maleValue,
            updateRelationshipLookupModel.maleValue,
            'Updated model\'s maleValue should be ' + maleValue
        );
        System.assertEquals(
            neutralValue,
            updateRelationshipLookupModel.neutralValue,
            'Updated model\'s neutralValue should be ' + neutralValue
        );
    }

    /***************************************************************************
     * @description Test Method to verify that deleteRelationshipLookup returns
     * a valid RelationshipLookupModel model
     ***************************************************************************/
    @isTest
    private static void deleteRelationshipLookup() {
        UserPermissionService.instance = new STUB_UserPermissionServiceTrue();
        RelationshipLookupMapper.instance = new STUB_RelationshipLookupMapper();
        String relationshipLookupName = 'Father';
        String femaleValue = 'Daughter';
        String maleValue = 'Son';
        String neutralValue = 'Child';
        Boolean isActive = false;

        Test.startTest();
        Relationship_Lookup__c relLookupRecord = new Relationship_Lookup__c(
            Name = relationshipLookupName,
            Female__c = femaleValue,
            Male__c = maleValue,
            Neutral__c = neutralValue,
            Active__c = isActive
        );

        insert relLookupRecord;

        RelationshipLookupModel deleteRelationshipLookupModel = RelationshipLookupSettingsService.getInstance()
            .deleteRelationshipLookup(relationshipLookupName);
        Test.stopTest();

        System.assertNotEquals(null, deleteRelationshipLookupModel, 'Should return a RelationshipLookupModel instance');
        System.assertEquals(
            relationshipLookupName,
            deleteRelationshipLookupModel.name,
            'Deleted model\'s name should be ' + relationshipLookupName
        );
        System.assertEquals(
            isActive,
            deleteRelationshipLookupModel.isActive,
            'Deleted model\'s isActive should be ' + isActive
        );
        System.assertEquals(
            femaleValue,
            deleteRelationshipLookupModel.femaleValue,
            'Deleted model\'s femaleValue should ' + femaleValue
        );
        System.assertEquals(
            maleValue,
            deleteRelationshipLookupModel.maleValue,
            'Deleted model\'s maleValue should be ' + maleValue
        );
        System.assertEquals(
            neutralValue,
            deleteRelationshipLookupModel.neutralValue,
            'Deleted model\'s neutralValue should be ' + neutralValue
        );
    }

    /***************************************************************************
     * @description Test Method to verify that deleteRelationshipLookup returns
     * null if relationship lookup record doesn't exist
     ***************************************************************************/
    @isTest
    private static void deleteRelationshipLookupNonExistent() {
        UserPermissionService.instance = new STUB_UserPermissionServiceTrue();
        RelationshipLookupMapper.instance = new STUB_RelationshipLookupMapper();
        String relationshipLookupName = 'Father';

        Test.startTest();
        RelationshipLookupModel deleteRelationshipLookupModel = RelationshipLookupSettingsService.getInstance()
            .deleteRelationshipLookup(relationshipLookupName);
        Test.stopTest();

        System.assertEquals(
            null,
            deleteRelationshipLookupModel,
            'Should return null for non existent relationship lookup'
        );
    }

    /**************************************************************************************************************************
     * @description Test method to verify deleteRelationshipLookup does not delete a reltionship lookup without sufficient
     * user permissions.
     **************************************************************************************************************************/
    @isTest
    private static void deleteRelationshipLookupNoPermission() {
        UserPermissionService.instance = new STUB_UserPermissionServiceFalse();
        RelationshipLookupMapper.instance = new STUB_RelationshipLookupMapper();
        String relationshipLookupName = 'Father';
        String femaleValue = 'Daughter';
        String maleValue = 'Son';
        String neutralValue = 'Child';
        Boolean isActive = false;

        Test.startTest();
        Relationship_Lookup__c relLookupRecord = new Relationship_Lookup__c(
            Name = relationshipLookupName,
            Female__c = femaleValue,
            Male__c = maleValue,
            Neutral__c = neutralValue,
            Active__c = isActive
        );
        insert relLookupRecord;

        RelationshipLookupModel deleteRelationshipLookupModel = RelationshipLookupSettingsService.getInstance()
            .deleteRelationshipLookup(relationshipLookupName);
        Test.stopTest();

        List<Relationship_Lookup__c> relationshipLookupResultsList = [
            SELECT Name
            FROM Relationship_Lookup__c
            WHERE Name = :relationshipLookupName
        ];

        System.assertEquals(
            1,
            relationshipLookupResultsList.size(),
            'Relationship lookup should not be deleted due to insufficient user permissions.'
        );

        System.assertEquals(
            null,
            deleteRelationshipLookupModel,
            'Deleting relationship lookup without appropriate permissions should return null value.'
        );
    }

    /***********************************************************************************************************************************
     ****************************************************** STUBS ***********************************************************************
     ***********************************************************************************************************************************/

    /**************************************************************************************************************************************
     * @description Stub class to simulate the response from RelationshipLookupMapper to return a RelationshipLookup model
     **************************************************************************************************************************************/
    private class STUB_RelationshipLookupMapper extends RelationshipLookupMapper {
        public override List<RelationshipLookupModel> getRelationshipLookupModels() {
            List<RelationshipLookupModel> RelationshipLookupModelList = new List<RelationshipLookupModel>();

            RelationshipLookupModel accModelSettingsModel = new RelationshipLookupModel(
                'Father',
                true,
                'Daughter',
                'Son',
                'Child'
            );
            RelationshipLookupModelList.add(accModelSettingsModel);

            return RelationshipLookupModelList;
        }

        public override void insertRelationshipLookupModel(RelationshipLookupModel relLookupModel) {
            System.assertEquals(
                'TestRelationshipLookupName',
                relLookupModel.name,
                'Inserted model\'s name should be \'TestRelationshipLookupName\''
            );
        }

        public override void updateRelationshipLookupModel(
            String relationshipLookupName,
            RelationshipLookupModel relLookupModel
        ) {
            System.assertEquals(
                'TestOldRelationshipLookupName',
                relationshipLookupName,
                'Updated model\'s old name should be \'TestOldRelationshipLookupName\''
            );
            System.assertEquals(
                'TestNewRelationshipLookupName',
                relLookupModel.name,
                'Updated model\'s new name should be \'TestNewRelationshipLookupName\''
            );
        }

        public override void deleteRelationshipLookupModel(RelationshipLookupModel relLookupModel) {
            System.assertEquals('Father', relLookupModel.name, 'Deleted model\'s name should be Father');
        }
    }

    /**************************************************************************************************************************************
     * @description Stub class to simulate the response from UserPermissionService to return true
     **************************************************************************************************************************************/
    private class STUB_UserPermissionServiceTrue extends UserPermissionService {
        public override Boolean checkCustomizeApplicationForCurrentUser() {
            return true;
        }
    }

    /**************************************************************************************************************************************
     * @description Stub class to simulate the response from UserPermissionService to return false
     **************************************************************************************************************************************/
    private class STUB_UserPermissionServiceFalse extends UserPermissionService {
        public override Boolean checkCustomizeApplicationForCurrentUser() {
            return false;
        }
    }
}
public virtual with sharing class RelationshipLookupsVMapper {
    /*********************************************
     * @description Instance for Singleton Pattern
     **********************************************/
    @TestVisible
    private static RelationshipLookupsVMapper instance;

    /*********************************************************************
     * @description Empty constructor is not public for Singleton Pattern
     **********************************************************************/
    protected RelationshipLookupsVMapper() {
    }

    /*****************************************************************************
     * @description Static method to get the current instance for Singleton pattern
     * @return The instance of RelationshipLookupsVMapper.
     ******************************************************************************/
    public static RelationshipLookupsVMapper getInstance() {
        if (instance == null) {
            instance = new RelationshipLookupsVMapper();
        }

        return instance;
    }

    /**
     * @description Retrieve a RelationshipLookupsVModel represeting the current values specified for Reciprocal Relationship mappings.
     * @return   A RelationshipLookupsVModel instance
     */
    public virtual RelationshipLookupsVModel getRelationshipLookupsVModel() {
        List<RelationshipLookupModel> relationshipLookupModelList = this.locateRelationshipLookupSettingsService()
            .getRelationshipLookupModels();
        List<RelationshipLookupVModel> relationshipLookupVModelList = new List<RelationshipLookupVModel>();
        for (RelationshipLookupModel relLookupModel : relationshipLookupModelList) {
            relationshipLookupVModelList.add(
                new RelationshipLookupVModel(
                    relLookupModel.name,
                    relLookupModel.femaleValue,
                    relLookupModel.maleValue,
                    relLookupModel.neutralValue,
                    relLookupModel.isActive
                )
            );
        }
        return new RelationshipLookupsVModel(relationshipLookupVModelList);
    }

    /**
     * @description Gets Relationship Type picklist values for FemaleValue, MaleValue and NeutralValue
     * @param  relationshipLookupName Specifies an existing relationship lookup name.
     * @return                        A ComboBoxVModel
     */
    public virtual ComboBoxVModel getRelationshipLookupComboboxVModel(String relationshipLookupName) {
        return this.getActiveRelationshipTypesComboboxVModel(relationshipLookupName);
    }

    /**
     * @description gets all active Relationship Type picklist values
     * @param  relationshipLookupName Specifies an existing relationship lookup name.
     * @return                        A ComboBoxVModel
     */
    public virtual ComboBoxVModel getActiveRelationshipTypesComboboxVModel(String relationshipLookupName) {
        Map<String, PicklistEntryModel> picklistEntryModelsByName = this.locatePicklistEntryService()
            .getModelsByNameForSObjectField(Relationship__c.SObjectType, Relationship__c.Type__c);
        Map<String, PicklistEntryModel> activePicklistEntryModelsByName = new Map<String, PicklistEntryModel>();
        Boolean nameExists = false;
        for (PicklistEntryModel picklistEntryModel : picklistEntryModelsByName.values()) {
            if (picklistEntryModel.isActive == true || picklistEntryModel.name == relationshipLookupName) {
                nameExists |= picklistEntryModel.name == relationshipLookupName;
                activePicklistEntryModelsByName.put(picklistEntryModel.name, picklistEntryModel);
            }
        }
        List<ComboboxValueVModel> activePicklistEntryModelList = this.getComboboxValueVModelListFromPicklist(
            activePicklistEntryModelsByName
        );
        if (!nameExists && String.isNotBlank(relationshipLookupName)) {
            //if relationshipLookupName doesn't exist in picklistEntryModelsByName (for example if it is inactive or missing)
            //insert it explicitly so the dropdown control could show the current value
            activePicklistEntryModelList.add(
                0,
                new ComboboxValueVModel(relationshipLookupName, relationshipLookupName)
            );
        }
        return new ComboboxVModel(relationshipLookupName, activePicklistEntryModelList);
    }

    /**
     * @description Gets Relationship Type picklist values for the name field
     * @param  relationshipLookupName Specifies an existing relationship lookup name. Should be an empty string for a new record
     * @return                        A ComboBoxVModel model with populated active unmapped picklist items
     */
    public virtual ComboBoxVModel getRelationshipLookupNameComboboxVModel(String relationshipLookupName) {
        //For relationship lookup name field we return the active unmapped values
        return this.getActiveUnmappedRelationshipTypesComboboxVModel(relationshipLookupName);
    }

    /**
     * @description gets all active unmapped Relationship Type picklist values
     * @return   A ComboBoxVModel
     */
    public virtual ComboBoxVModel getActiveUnmappedRelationshipTypesComboboxVModel(String relationshipLookupName) {
        PicklistEntryService picklistEntryServiceInstance = this.locatePicklistEntryService();

        Map<String, PicklistEntryModel> picklistEntryModelByName = picklistEntryServiceInstance.getActivePicklistEntryModelsByName(
            picklistEntryServiceInstance.getModelsByNameForSObjectField(
                Relationship__c.SObjectType,
                Relationship__c.Type__c
            )
        );

        //filtering out mapped values
        List<RelationshipLookupModel> relationshipLookupModelList = this.locateRelationshipLookupSettingsService()
            .getRelationshipLookupModels();
        for (RelationshipLookupModel relLookupModel : relationshipLookupModelList) {
            if (relLookupModel.name != relationshipLookupName) {
                picklistEntryModelByName.remove(relLookupModel.name);
            }
        }

        List<ComboboxValueVModel> comboboxValues = this.getComboboxValueVModelListFromPicklist(
            picklistEntryModelByName
        );
        if (
            String.isNotBlank(relationshipLookupName) && !picklistEntryModelByName.containsKey(relationshipLookupName)
        ) {
            //if relationshipLookupName doesn't exist in picklistEntryModelsByName (for example if it is inactive or missing)
            //insert it explicitly so the dropdown control could show the current value
            comboboxValues.add(0, new ComboboxValueVModel(relationshipLookupName, relationshipLookupName));
        }

        return new ComboboxVModel(relationshipLookupName, comboboxValues);
    }

    /**
     * @description Maps PicklistEntryModel map to ComboboxValueVModel list
     * @param  picklistEntryModelByName a map of PicklistEntryModel items
     * @return                          a list of ComboboxValueVModel view models
     */
    @TestVisible
    private List<ComboboxValueVModel> getComboboxValueVModelListFromPicklist(
        Map<String, PicklistEntryModel> picklistEntryModelByName
    ) {
        List<ComboboxValueVModel> comboBoxValueVModelList = new List<ComboboxValueVModel>();
        for (PicklistEntryModel pickListEntry : picklistEntryModelByName.values()) {
            comboBoxValueVModelList.add(new ComboboxValueVModel(pickListEntry.label, pickListEntry.name));
        }

        return comboBoxValueVModelList;
    }

    /***************************************************************************
     * @description Retrieves an instance of PicklistEntryService.
     * @return An instance of PicklistEntryService.
     ***************************************************************************/
    @TestVisible
    private PicklistEntryService locatePicklistEntryService() {
        return PicklistEntryService.getInstance();
    }

    /*****************************************************************************
     * @description Retrieve an instance of the RelationshipLookupSettingsService class.
     * @return An instance of RelationshipLookupSettingsService.
     *****************************************************************************/
    @TestVisible
    private RelationshipLookupSettingsService locateRelationshipLookupSettingsService() {
        return RelationshipLookupSettingsService.getInstance();
    }
}
@isTest
private with sharing class RelationshipLookupsVMapper_TEST {
    /**************************************************************************************************
     * @description Test method to verify that the getInstance method returns a new instance of the
     * RelationshipLookupsVMapper class when one does not already exist.
     **************************************************************************************************/
    @isTest
    private static void getInstanceNew() {
        Test.startTest();
        RelationshipLookupsVMapper relationshipLookupsVMapperInstance = RelationshipLookupsVMapper.getInstance();
        Test.stopTest();

        System.assertEquals(
            RelationshipLookupsVMapper.instance,
            relationshipLookupsVMapperInstance,
            'Instance of mapper class returned should match static instance variable.'
        );
        System.assertEquals(
            true,
            relationshipLookupsVMapperInstance != null,
            'Instance of mapper class should not be null.'
        );
    }

    /**************************************************************************************************
     * @description Test method to verify that the getInstance method returns the existing instance of the
     * RelationshipLookupsVMapper class when one already exists.
     **************************************************************************************************/
    @isTest
    private static void getInstanceExisting() {
        Test.startTest();
        RelationshipLookupsVMapper relationshipLookupsVMapperInstance1 = RelationshipLookupsVMapper.getInstance();
        RelationshipLookupsVMapper relationshipLookupsVMapperInstance2 = RelationshipLookupsVMapper.getInstance();
        Test.stopTest();

        System.assertEquals(
            RelationshipLookupsVMapper.instance,
            relationshipLookupsVMapperInstance1,
            'Instance of mapper class returned should match static instance variable.'
        );
        System.assertEquals(
            relationshipLookupsVMapperInstance1,
            relationshipLookupsVMapperInstance2,
            'Subsequent retrievals of mapper class instance should return existing instance.'
        );
        System.assertEquals(
            true,
            relationshipLookupsVMapperInstance1 != null,
            'Instance of mapper class should not be null.'
        );
    }

    /****************************************************************************************
     * @description Test method to verify locateRelationshipLookupSettingsService() returns an instance of
     * the RelationshipLookupSettingsService class.
     ****************************************************************************************/
    @isTest
    private static void locatePicklistEntryServiceValid() {
        RelationshipLookupsVMapper relationshipLookupsVMapperInstance = RelationshipLookupsVMapper.getInstance();

        Test.startTest();
        PicklistEntryService picklistEntryServiceInstance = relationshipLookupsVMapperInstance.locatePicklistEntryService();
        Test.stopTest();

        System.assertEquals(
            PicklistEntryService.getInstance(),
            picklistEntryServiceInstance,
            'Should return instance of PicklistEntryService class.'
        );
    }

    /****************************************************************************************
     * @description Test method to verify locateRelationshipLookupSettingsService() returns an instance of
     * the RelationshipLookupSettingsService class.
     ****************************************************************************************/
    @isTest
    private static void locateRelationshipLookupSettingsServiceValid() {
        RelationshipLookupsVMapper relationshipLookupsVMapperInstance = RelationshipLookupsVMapper.getInstance();

        Test.startTest();
        RelationshipLookupSettingsService relationshipLookupSettingsServiceInstance = relationshipLookupsVMapperInstance.locateRelationshipLookupSettingsService();
        Test.stopTest();

        System.assertEquals(
            RelationshipLookupSettingsService.getInstance(),
            relationshipLookupSettingsServiceInstance,
            'Should return instance of RelationshipLookupSettingsService class.'
        );
    }

    /****************************************************************************************
     * @description Test method to verify getComboboxValueVModelListFromPicklist()
     * returns a list of ComboboxValueVModels representing the relationship lookup picklist values
     ****************************************************************************************/
    @isTest
    private static void getComboboxValueVModelListFromPicklistValid() {
        STUB_PicklistEntryService picklistEntryServiceStub = new STUB_PicklistEntryService();

        RelationshipLookupsVMapper relationshipLookupsVMapperInstance = RelationshipLookupsVMapper.getInstance();

        Test.startTest();
        List<ComboboxValueVModel> lookupComboboxValueVModelsList = relationshipLookupsVMapperInstance.getComboboxValueVModelListFromPicklist(
            picklistEntryServiceStub.getModelsByNameForSObjectField(null, null)
        );
        Test.stopTest();

        System.assertEquals(7, lookupComboboxValueVModelsList.size(), 'Should return 7 ComboboxValueVModels.');

        for (Integer i = 0; i < lookupComboboxValueVModelsList.size(); i++) {
            System.assertEquals(
                'TestRelationshipName' + String.valueOf(i + 1),
                lookupComboboxValueVModelsList[i].value,
                'ComoboboxValueVModel value should match lookup field model name.'
            );

            System.assertEquals(
                'TestRelationshipLabel' + String.valueOf(i + 1),
                lookupComboboxValueVModelsList[i].label,
                'ComoboboxValueVModel label should match lookup field model label.'
            );
        }
    }

    /****************************************************************************************
     * @description Test method to verify getRelationshipLookupsVModel()
     * returns a RelationshipLookupsVModel representing existing relationship lookups
     ****************************************************************************************/
    @isTest
    private static void getRelationshipLookupsVModelValid() {
        PicklistEntryService.instance = new STUB_PicklistEntryService();
        RelationshipLookupSettingsService.instance = new STUB_RelationshipLookupSettingsService();

        RelationshipLookupsVMapper relationshipLookupsVMapperInstance = RelationshipLookupsVMapper.getInstance();

        Test.startTest();
        RelationshipLookupsVModel relLookupVModel = relationshipLookupsVMapperInstance.getRelationshipLookupsVModel();
        Test.stopTest();

        System.assertEquals(
            5,
            relLookupVModel.relationshipLookups.size(),
            'Should return 5 RelationshipLookupVModel items'
        );

        System.assertEquals(
            'TestRelationshipName1',
            relLookupVModel.relationshipLookups[0].name,
            'Relationship lookup name should be \'TestRelationshipName1\''
        );
        System.assertEquals(
            'TestFemaleValue1',
            relLookupVModel.relationshipLookups[0].femaleValue,
            'Female value should be \'TestFemaleValue1\''
        );
        System.assertEquals(
            'TestMaleValue1',
            relLookupVModel.relationshipLookups[0].maleValue,
            'Male value should be \'TestMaleValue1\''
        );
        System.assertEquals(
            'TestNeutralValue1',
            relLookupVModel.relationshipLookups[0].neutralValue,
            'Neutral value should be \'TestNeutralValue1\''
        );
        System.assertEquals(true, relLookupVModel.relationshipLookups[0].isActive, 'isActive should be \'true\'');
    }

    /****************************************************************************************
     * @description Test method to verify getRelationshipLookupComboboxVModel()
     * returns a ComboboxVModel representing active picklist items
     ****************************************************************************************/
    @isTest
    private static void getRelationshipLookupComboboxVModelValid() {
        PicklistEntryService.instance = new STUB_PicklistEntryService();
        RelationshipLookupSettingsService.instance = new STUB_RelationshipLookupSettingsService();

        RelationshipLookupsVMapper relationshipLookupsVMapperInstance = RelationshipLookupsVMapper.getInstance();

        Test.startTest();
        ComboBoxVModel relationshipLookupComboBoxVModel = relationshipLookupsVMapperInstance.getRelationshipLookupComboboxVModel(
            ''
        );
        ComboBoxVModel missingRelationshipLookupComboBoxVModel = relationshipLookupsVMapperInstance.getRelationshipLookupComboboxVModel(
            'MissingValue'
        );
        Test.stopTest();

        System.assertEquals(
            5,
            relationshipLookupComboBoxVModel.options.size(),
            'Should return 5 active relationship types'
        );

        System.assertEquals(
            'TestRelationshipName1',
            relationshipLookupComboBoxVModel.options[0].value,
            'Relationship type value should be \'TestRelationshipName1\''
        );
        System.assertEquals(
            'TestRelationshipLabel1',
            relationshipLookupComboBoxVModel.options[0].label,
            'Relationship type label should be \'TestRelationshipLabel1\''
        );
        System.assertEquals(
            'TestRelationshipName7',
            relationshipLookupComboBoxVModel.options[4].value,
            'Relationship type value should be \'TestRelationshipName7\''
        );
        System.assertEquals(
            'TestRelationshipLabel7',
            relationshipLookupComboBoxVModel.options[4].label,
            'Relationship type label should be \'TestRelationshipLabel7\''
        );

        System.assertEquals(
            6,
            missingRelationshipLookupComboBoxVModel.options.size(),
            'Should return 6 relationship types (5 active, 1 missing)'
        );
        System.assertEquals(
            'MissingValue',
            missingRelationshipLookupComboBoxVModel.options[0].value,
            'Relationship type value should be \'TestRelationshipName1\''
        );
        System.assertEquals(
            'MissingValue',
            missingRelationshipLookupComboBoxVModel.options[0].label,
            'Relationship type label should be \'TestRelationshipLabel1\''
        );
    }

    /****************************************************************************************
     * @description Test method to verify getRelationshipLookupsVModel()
     * returns a ComboboxVModel representing active unmapped picklist items
     ****************************************************************************************/
    @isTest
    private static void getActiveUnmappedRelationshipTypesComboboxVModelValid() {
        PicklistEntryService.instance = new STUB_PicklistEntryService();
        RelationshipLookupSettingsService.instance = new STUB_RelationshipLookupSettingsService();

        RelationshipLookupsVMapper relationshipLookupsVMapperInstance = RelationshipLookupsVMapper.getInstance();

        Test.startTest();
        ComboBoxVModel activeUnmappedRelTypesComboBoxVModel = relationshipLookupsVMapperInstance.getActiveUnmappedRelationshipTypesComboboxVModel(
            ''
        );
        Test.stopTest();

        System.assertEquals(
            2,
            activeUnmappedRelTypesComboBoxVModel.options.size(),
            'Should return 2 active unmapped relationship types'
        );

        System.assertEquals(
            'TestRelationshipName6',
            activeUnmappedRelTypesComboBoxVModel.options[0].value,
            'Relationship type value should be \'TestRelationshipName6\''
        );
        System.assertEquals(
            'TestRelationshipLabel6',
            activeUnmappedRelTypesComboBoxVModel.options[0].label,
            'Relationship type label should be \'TestRelationshipLabel6\''
        );

        System.assertEquals(
            'TestRelationshipName7',
            activeUnmappedRelTypesComboBoxVModel.options[1].value,
            'Relationship type value should be \'TestRelationshipName7\''
        );
        System.assertEquals(
            'TestRelationshipLabel7',
            activeUnmappedRelTypesComboBoxVModel.options[1].label,
            'Relationship type label should be \'TestRelationshipLabel7\''
        );
    }

    /****************************************************************************************
     * @description Test method to verify getRelationshipLookupNameComboboxVModel()
     * returns a ComboboxVModel representing active unmapped picklist items for a new record
     ****************************************************************************************/
    @isTest
    private static void getRelationshipLookupNameComboboxVModelValidNew() {
        PicklistEntryService.instance = new STUB_PicklistEntryService();
        RelationshipLookupSettingsService.instance = new STUB_RelationshipLookupSettingsService();

        RelationshipLookupsVMapper relationshipLookupsVMapperInstance = RelationshipLookupsVMapper.getInstance();

        Test.startTest();
        ComboBoxVModel activeUnmappedRelTypesComboBoxVModel = relationshipLookupsVMapperInstance.getRelationshipLookupNameComboboxVModel(
            ''
        );
        Test.stopTest();

        System.assertEquals(
            2,
            activeUnmappedRelTypesComboBoxVModel.options.size(),
            'Should return 2 active unmapped relationship types'
        );

        System.assertEquals(
            'TestRelationshipName6',
            activeUnmappedRelTypesComboBoxVModel.options[0].value,
            'Relationship type value should be \'TestRelationshipName6\''
        );
        System.assertEquals(
            'TestRelationshipLabel6',
            activeUnmappedRelTypesComboBoxVModel.options[0].label,
            'Relationship type label should be \'TestRelationshipLabel6\''
        );

        System.assertEquals(
            'TestRelationshipName7',
            activeUnmappedRelTypesComboBoxVModel.options[1].value,
            'Relationship type value should be \'TestRelationshipName7\''
        );
        System.assertEquals(
            'TestRelationshipLabel7',
            activeUnmappedRelTypesComboBoxVModel.options[1].label,
            'Relationship type label should be \'TestRelationshipLabel7\''
        );
    }

    /****************************************************************************************
     * @description Test method to verify getRelationshipLookupNameComboboxVModel()
     * returns a ComboboxVModel representing active picklist items
     * for an existing record (edit mode)
     ****************************************************************************************/
    @isTest
    private static void getRelationshipLookupNameComboboxVModelValidEdit() {
        PicklistEntryService.instance = new STUB_PicklistEntryService();
        RelationshipLookupSettingsService.instance = new STUB_RelationshipLookupSettingsService();

        RelationshipLookupsVMapper relationshipLookupsVMapperInstance = RelationshipLookupsVMapper.getInstance();

        Test.startTest();
        ComboBoxVModel activeItemRelTypesComboBoxVModel = relationshipLookupsVMapperInstance.getRelationshipLookupNameComboboxVModel(
            'TestRelationshipName1'
        );
        ComboBoxVModel inactiveItemRelTypesComboBoxVModel = relationshipLookupsVMapperInstance.getRelationshipLookupNameComboboxVModel(
            'TestRelationshipName6'
        );
        ComboBoxVModel missingItemRelTypesComboBoxVModel = relationshipLookupsVMapperInstance.getRelationshipLookupNameComboboxVModel(
            'TestRelationshipName8'
        );

        Test.stopTest();

        System.assertEquals(
            3,
            activeItemRelTypesComboBoxVModel.options.size(),
            'Should return 3 active unmapped relationship types (2 active unmapped + 1 current)'
        );

        System.assertEquals(
            2,
            inactiveItemRelTypesComboBoxVModel.options.size(),
            'Should return 2 active unmapped relationship types'
        );

        System.assertEquals(
            'TestRelationshipName1',
            activeItemRelTypesComboBoxVModel.options[0].value,
            'Relationship type value should be \'TestRelationshipName1\''
        );
        System.assertEquals(
            'TestRelationshipLabel1',
            activeItemRelTypesComboBoxVModel.options[0].label,
            'Relationship type label should be \'TestRelationshipLabel1\''
        );

        System.assertEquals(
            3,
            missingItemRelTypesComboBoxVModel.options.size(),
            'Should return 3 active unmapped relationship types'
        );

        //Checking if the mapper returns inactive item because this is the current record's value
        Boolean hasInactiveItemValue = false;
        for (ComboboxValueVModel inactiveItemVModel : inactiveItemRelTypesComboBoxVModel.options) {
            if (inactiveItemVModel.value == 'TestRelationshipName6') {
                hasInactiveItemValue = true;
                break;
            }
        }
        System.assertEquals(
            true,
            hasInactiveItemValue,
            'getRelationshipLookupNameComboboxVModel should return \'TestRelationshipName6\''
        );

        //Checking if the mapper returns missing item because this is the current record's value
        Boolean hasMissingItemValue = false;
        for (ComboboxValueVModel missingItemVModel : missingItemRelTypesComboBoxVModel.options) {
            if (missingItemVModel.value == 'TestRelationshipName8') {
                hasMissingItemValue = true;
                break;
            }
        }
        System.assertEquals(
            true,
            hasMissingItemValue,
            'getRelationshipLookupNameComboboxVModel should return \'TestRelationshipName8\''
        );
    }

    /***********************************************************************************************************************************
     ****************************************************** STUBS ***********************************************************************
     ***********************************************************************************************************************************/

    /**************************************************************************************************************************************
     * @description Stub class to simulate valid responses from RelationshipLookupSettingsService
     **************************************************************************************************************************************/
    private class STUB_RelationshipLookupSettingsService extends RelationshipLookupSettingsService {
        public override List<RelationshipLookupModel> getRelationshipLookupModels() {
            List<RelationshipLookupModel> relLookupModelList = new List<RelationshipLookupModel>();
            relLookupModelList.add(
                new RelationshipLookupModel(
                    'TestRelationshipName1',
                    true,
                    'TestFemaleValue1',
                    'TestMaleValue1',
                    'TestNeutralValue1'
                )
            );
            relLookupModelList.add(
                new RelationshipLookupModel(
                    'TestRelationshipName2',
                    false,
                    'TestFemaleValue2',
                    'TestMaleValue2',
                    'TestNeutralValue2'
                )
            );
            relLookupModelList.add(
                new RelationshipLookupModel(
                    'TestRelationshipName3',
                    true,
                    'TestFemaleValue3',
                    'TestMaleValue3',
                    'TestNeutralValue3'
                )
            );
            relLookupModelList.add(
                new RelationshipLookupModel(
                    'TestRelationshipName4',
                    true,
                    'TestFemaleValue4',
                    'TestMaleValue4',
                    'TestNeutralValue4'
                )
            );
            relLookupModelList.add(
                new RelationshipLookupModel(
                    'TestRelationshipName5',
                    false,
                    'TestFemaleValue5',
                    'TestMaleValue5',
                    'TestNeutralValue5'
                )
            );
            return relLookupModelList;
        }
    }

    /**************************************************************************************************************************************
     * @description Stub class to simulate valid responses from PicklistEntryService
     **************************************************************************************************************************************/
    private class STUB_PicklistEntryService extends PicklistEntryService {
        public override Map<String, PicklistEntryModel> getModelsByNameForSObjectField(
            SObjectType sObjectTypeName,
            SObjectField SObjectFieldName
        ) {
            Map<String, PicklistEntryModel> picklistModelsMap = new Map<String, PicklistEntryModel>();
            picklistModelsMap.put(
                'TestRelationshipName1',
                new PicklistEntryModel('TestRelationshipName1', 'TestRelationshipLabel1', true)
            );
            picklistModelsMap.put(
                'TestRelationshipName2',
                new PicklistEntryModel('TestRelationshipName2', 'TestRelationshipLabel2', true)
            );
            picklistModelsMap.put(
                'TestRelationshipName3',
                new PicklistEntryModel('TestRelationshipName3', 'TestRelationshipLabel3', true)
            );
            picklistModelsMap.put(
                'TestRelationshipName4',
                new PicklistEntryModel('TestRelationshipName4', 'TestRelationshipLabel4', false)
            );
            picklistModelsMap.put(
                'TestRelationshipName5',
                new PicklistEntryModel('TestRelationshipName5', 'TestRelationshipLabel5', false)
            );
            picklistModelsMap.put(
                'TestRelationshipName6',
                new PicklistEntryModel('TestRelationshipName6', 'TestRelationshipLabel6', true)
            );
            picklistModelsMap.put(
                'TestRelationshipName7',
                new PicklistEntryModel('TestRelationshipName7', 'TestRelationshipLabel7', true)
            );
            return picklistModelsMap;
        }
    }
}
public with sharing class RelationshipSettingsController {
    /************************************************************************************
     * @description Retrieve an RelationshipSettingsVModel represeting the current values
     * specified for Relationship Settings fields in Hierarchy Settings.
     * @return An RelationshipSettingsVModel
     ************************************************************************************/
    @AuraEnabled(cacheable=true)
    public static RelationshipSettingsVModel getRelationshipSettingsVModel() {
        try {
            return RelationshipSettingsController.locateRelationshipSettingsVMapper().getRelationshipSettingsVModel();
        } catch (Exception e) {
            throw new AuraHandledException(e.getMessage());
        }
    }

    /************************************************************************************
     * @description Retrieve an RelationshipLookupsVModel represeting the current values
     * specified for Reciprocal Relationship mappings.
     * @return An RelationshipLookupsVModel
     ************************************************************************************/
    @AuraEnabled(cacheable=true)
    public static RelationshipLookupsVModel getRelationshipLookupsVModel() {
        try {
            return RelationshipSettingsController.locateRelationshipLookupsVMapper().getRelationshipLookupsVModel();
        } catch (Exception e) {
            throw new AuraHandledException(e.getMessage());
        }
    }

    /**
     * @description gets all active Relationship Type picklist values for FemaleValue, MaleValue and NeutralValue
     * @param  relationshipLookupName Specifies and existing relationship lookup value. Should be an empty string for a new record
     * @return                        A ComboBoxVModel
     */
    @AuraEnabled(cacheable=true)
    public static ComboBoxVModel getRelationshipLookupComboboxVModel(String relationshipLookupName) {
        try {
            return RelationshipSettingsController.locateRelationshipLookupsVMapper()
                .getRelationshipLookupComboboxVModel(relationshipLookupName);
        } catch (Exception e) {
            throw new AuraHandledException(e.getMessage());
        }
    }

    /**
     * @description Gets picklist values for a relationship name lookup.
     * For a new record returns all active unmapped Relationship Type picklist values
     * For an existing record returns all active Relationship Type picklist values plus the existing one if it is not active
     * @param  relationshipLookupName Specifies and existing relationship lookup name. Should be an empty string for a new record
     * @return                        A ComboBoxVModel
     */
    @AuraEnabled
    public static ComboBoxVModel getRelationshipLookupNameComboboxVModel(String relationshipLookupName) {
        try {
            return RelationshipSettingsController.locateRelationshipLookupsVMapper()
                .getRelationshipLookupNameComboboxVModel(relationshipLookupName);
        } catch (Exception e) {
            throw new AuraHandledException(e.getMessage());
        }
    }

    /**
     * @description inserts a relationship lookup
     * @param  relationshipLookupName relationship lookup name
     * @param  femaleValue            female relationship type value
     * @param  maleValue              male relationship type value
     * @param  neutralValue           neutral relationship type value
     * @param  isActive               specifies if the lookup is active
     * @return                        inserted relationship lookup name
     */
    @AuraEnabled
    public static String createRelationshipLookup(
        String relationshipLookupName,
        String femaleValue,
        String maleValue,
        String neutralValue,
        Boolean isActive
    ) {
        try {
            return RelationshipSettingsController.locateRelationshipLookupSettingsService()
                .insertRelationshipLookup(relationshipLookupName, femaleValue, maleValue, neutralValue, isActive)
                .name;
        } catch (Exception e) {
            throw new AuraHandledException(e.getMessage());
        }
    }

    /**
     * @description updates a relationship lookup
     * @param  oldRelationshipLookupName old relationship lookup name
     * @param  newRelationshipLookupName new relationship lookup name
     * @param  femaleValue               female relationship type value
     * @param  maleValue                 male relationship type value
     * @param  neutralValue              neutral relationship type value
     * @param  isActive                  specifies if the lookup is active
     * @return                           updated relationship lookup name
     */
    @AuraEnabled
    public static String updateRelationshipLookup(
        String oldRelationshipLookupName,
        String newRelationshipLookupName,
        String femaleValue,
        String maleValue,
        String neutralValue,
        Boolean isActive
    ) {
        try {
            return RelationshipSettingsController.locateRelationshipLookupSettingsService()
                .updateRelationshipLookup(
                    oldRelationshipLookupName,
                    newRelationshipLookupName,
                    femaleValue,
                    maleValue,
                    neutralValue,
                    isActive
                )
                .name;
        } catch (Exception e) {
            throw new AuraHandledException(e.getMessage());
        }
    }

    /**
     * @description deletes a relationship lookup
     * @param  relationshipLookupName relationship lookup name to delete
     * @return                        deleted relationship lookup name or null if the record was not found
     */
    @AuraEnabled
    public static String deleteRelationshipLookup(String relationshipLookupName) {
        try {
            RelationshipLookupModel deletedRelationshipLookupModel = RelationshipSettingsController.locateRelationshipLookupSettingsService()
                .deleteRelationshipLookup(relationshipLookupName);
            return deletedRelationshipLookupModel == null ? null : deletedRelationshipLookupModel.name;
        } catch (Exception e) {
            throw new AuraHandledException(e.getMessage());
        }
    }

    /**********************************************************************************
     * @description Locates and returns an instance of RelationshipSettingsVMapper.
     **********************************************************************************/
    @TestVisible
    private static RelationshipSettingsVMapper locateRelationshipSettingsVMapper() {
        return RelationshipSettingsVMapper.getInstance();
    }

    /**********************************************************************************
     * @description Locates and returns an instance of RelationshipLookupsVMapper.
     * @return An instance of RelationshipLookupsVMapper
     **********************************************************************************/
    @TestVisible
    private static RelationshipLookupsVMapper locateRelationshipLookupsVMapper() {
        return RelationshipLookupsVMapper.getInstance();
    }

    /*****************************************************************************
     * @description Retrieve an instance of the RelationshipLookupSettingsService class.
     * @return An instance of RelationshipLookupSettingsService.
     *****************************************************************************/
    @TestVisible
    private static RelationshipLookupSettingsService locateRelationshipLookupSettingsService() {
        return RelationshipLookupSettingsService.getInstance();
    }
}
@isTest
private with sharing class RelationshipSettingsController_TEST {
    /**************************************************************************************************************************************************
     * @description Test method to verify that the locateRelationshipSettingsVMapper method returns instance of locateRelationshipSettingsVMapper.
     *************************************************************************************************************************************************/
    @isTest
    private static void locateRelationshipSettingsVMapper() {
        Test.startTest();
        RelationshipSettingsVMapper relationshipSettingsVMapperInstance = RelationshipSettingsController.locateRelationshipSettingsVMapper();
        Test.stopTest();

        System.assertEquals(
            RelationshipSettingsVMapper.getInstance(),
            RelationshipSettingsVMapperInstance,
            'Should return the instance of locateRelationshipSettingsVMapper.'
        );
    }

    /****************************************************************************************************************************
     * @description Test method to verify that the getRelationshipSettingsVModel method returns a RelationshipSettingsVModel
     * representing Relationship Settings in Hierarchy Settings.
     ****************************************************************************************************************************/
    @isTest
    private static void getRelationshipSettingsVModelValid() {
        RelationshipSettingsVMapper.instance = new STUB_RelationshipSettingsVMapper();

        Test.startTest();
        RelationshipSettingsVModel relationshipSettingsVModel = RelationshipSettingsController.getRelationshipSettingsVModel();
        Test.stopTest();

        System.assertEquals(
            'List Setting',
            relationshipSettingsVModel.reciprocalMethodComboboxVModel.value,
            'Selected value should be retrieved'
        );

        System.assertEquals(
            Label.stgReciprocalMethodListSetting,
            relationshipSettingsVModel.reciprocalMethodComboboxVModel.options[0].label,
            'Selected value should be retrieved'
        );

        System.assertEquals(
            'List Setting',
            relationshipSettingsVModel.reciprocalMethodComboboxVModel.options[0].value,
            'Selected value should be retrieved'
        );

        System.assertEquals(
            Label.stgReciprocalMethodValueInversion,
            relationshipSettingsVModel.reciprocalMethodComboboxVModel.options[1].label,
            'Selected value should be retrieved'
        );

        System.assertEquals(
            'Value Inversion',
            relationshipSettingsVModel.reciprocalMethodComboboxVModel.options[1].value,
            'Selected value should be retrieved'
        );

        System.assertEquals(
            true,
            relationshipSettingsVModel.preventAutoCreatedDuplicates,
            'Selected value should be retrieved for allow auto created duplicates'
        );
    }

    /****************************************************************************************************************************
     * @description Test method to verify that the getRelationshipSettingsVModel method fails gracefully when an exception is
     * encountered.
     ****************************************************************************************************************************/
    @isTest
    private static void getRelationshipSettingsVModelException() {
        RelationshipSettingsVMapper.instance = new STUB_ExceptionRelationshipSettingsVMapper();

        try {
            Test.startTest();
            RelationshipSettingsVModel relationshipSettingsVModel = RelationshipSettingsController.getRelationshipSettingsVModel();
            Test.stopTest();
        } catch (AuraHandledException e) {
            System.assertEquals('Script-thrown exception', e.getMessage(), 'Should throw exception.');
        }
    }

    /****************************************************************************************************************************
     * @description Test method to verify that the getRelationshipLookupsVModel method returns a RelationshipLookupsVModel
     * representing Relationship Lookups.
     ****************************************************************************************************************************/
    @isTest
    private static void getRelationshipLookupsVModelValid() {
        RelationshipLookupsVMapper.instance = new STUB_RelationshipLookupsVMapper();

        Test.startTest();
        RelationshipLookupsVModel relLookupsVModel = RelationshipSettingsController.getRelationshipLookupsVModel();
        Test.stopTest();
        System.assertEquals(2, relLookupsVModel.relationshipLookups.size(), 'Should return 2 items');
        System.assertEquals(
            'RelationshipLookupName1',
            relLookupsVModel.relationshipLookups[0].name,
            'Relationship lookup name should be \'RelationshipLookupName1\''
        );
        System.assertEquals(
            'FemaleValue1',
            relLookupsVModel.relationshipLookups[0].femaleValue,
            'femaleValue should be \'FemaleValue1\''
        );
        System.assertEquals(
            'MaleValue1',
            relLookupsVModel.relationshipLookups[0].maleValue,
            'maleValue should be \'MaleValue1\''
        );
        System.assertEquals(
            'NeutralValue1',
            relLookupsVModel.relationshipLookups[0].neutralValue,
            'neutralValue should be \'NeutralValue1\''
        );
    }

    /****************************************************************************************************************************
     * @description Test method to verify that the getRelationshipLookupComboboxVModel method returns a ComboBoxVModel
     * representing active relationship types.
     ****************************************************************************************************************************/
    @isTest
    private static void getRelationshipLookupComboboxVModelValid() {
        RelationshipLookupsVMapper.instance = new STUB_RelationshipLookupsVMapper();

        Test.startTest();
        ComboBoxVModel activeRelTypesComboboxVModel = RelationshipSettingsController.getRelationshipLookupComboboxVModel(
            ''
        );
        Test.stopTest();
        System.assertEquals(2, activeRelTypesComboboxVModel.options.size(), 'Should return 2 items');
        System.assertEquals(
            'ActiveRelationshipName1',
            activeRelTypesComboboxVModel.options[0].value,
            'Active item value should be \'ActiveRelationshipName1\''
        );
        System.assertEquals(
            'ActiveRelationshipLabel1',
            activeRelTypesComboboxVModel.options[0].label,
            'Active item label should be \'ActiveRelationshipLabel1\''
        );
    }

    /****************************************************************************************************************************
     * @description Test method to verify that the getRelationshipLookupNameComboboxVModel method returns a ComboBoxVModel
     * representing unmapped relationship types.
     ****************************************************************************************************************************/
    @isTest
    private static void getRelationshipLookupNameComboboxVModelValid() {
        RelationshipLookupsVMapper.instance = new STUB_RelationshipLookupsVMapper();

        Test.startTest();
        ComboBoxVModel activeUnmappedRelTypesComboboxVModel = RelationshipSettingsController.getRelationshipLookupNameComboboxVModel(
            ''
        );
        Test.stopTest();
        System.assertEquals(2, activeUnmappedRelTypesComboboxVModel.options.size(), 'Should return 2 items');
        System.assertEquals(
            'UnmappedRelationshipName1',
            activeUnmappedRelTypesComboboxVModel.options[0].value,
            'Unmapped item value should be \'UnmappedRelationshipName1\''
        );
        System.assertEquals(
            'UnmappedRelationshipLabel1',
            activeUnmappedRelTypesComboboxVModel.options[0].label,
            'Unmapped item label should be \'UnmappedRelationshipLabel1\''
        );
    }

    /****************************************************************************************************************************
     * @description Test method to verify that the getRelationshipLookupsVModel method fails gracefully when an exception is
     * encountered.
     ****************************************************************************************************************************/
    @isTest
    private static void getRelationshipLookupsVModelException() {
        RelationshipLookupsVMapper.instance = new STUB_ExceptionRelationshipLookupsVMapper();

        try {
            Test.startTest();
            RelationshipLookupsVModel relLookupsVModel = RelationshipSettingsController.getRelationshipLookupsVModel();
            Test.stopTest();
            System.assert(false, 'should always throw an exception');
        } catch (AuraHandledException e) {
            System.assertEquals('Script-thrown exception', e.getMessage(), 'Should throw exception.');
        }
    }

    /****************************************************************************************************************************
     * @description Test method to verify that the getRelationshipLookupComboboxVModel method fails gracefully when an exception is
     * encountered.
     ****************************************************************************************************************************/
    @isTest
    private static void getRelationshipLookupComboboxVModelException() {
        RelationshipLookupsVMapper.instance = new STUB_ExceptionRelationshipLookupsVMapper();

        try {
            Test.startTest();
            ComboBoxVModel activeRelTypesComboboxVModel = RelationshipSettingsController.getRelationshipLookupComboboxVModel(
                ''
            );
            Test.stopTest();
            System.assert(false, 'should always throw an exception');
        } catch (AuraHandledException e) {
            System.assertEquals('Script-thrown exception', e.getMessage(), 'Should throw exception.');
        }
    }

    /****************************************************************************************************************************
     * @description Test method to verify that the getRelationshipLookupNameComboboxVModel method fails gracefully when an exception is
     * encountered.
     ****************************************************************************************************************************/
    @isTest
    private static void getRelationshipLookupNameComboboxVModelException() {
        RelationshipLookupsVMapper.instance = new STUB_ExceptionRelationshipLookupsVMapper();

        try {
            Test.startTest();
            ComboBoxVModel activeUnmappedRelTypesComboboxVModel = RelationshipSettingsController.getRelationshipLookupNameComboboxVModel(
                ''
            );
            Test.stopTest();
            System.assert(false, 'should always throw an exception');
        } catch (AuraHandledException e) {
            System.assertEquals('Script-thrown exception', e.getMessage(), 'Should throw exception.');
        }

        RelationshipLookupsVMapper.instance = new STUB_RelationshipLookupsVMapper();
    }

    /****************************************************************************************************************************
     * @description Test method to verify that the createRelationshipLookup method returns a valid relationship lookup name
     ****************************************************************************************************************************/
    @isTest
    private static void createRelationshipLookupSuccess() {
        RelationshipLookupSettingsService.instance = new STUB_RelationshipLookupSettingsService();
        String relationshipLookupName = 'TestInsertedLookupName';

        Test.startTest();
        String insertedRelationshipLookupName = RelationshipSettingsController.createRelationshipLookup(
            relationshipLookupName,
            'TestFemaleValue',
            'TestMaleValue',
            'TestNeutralValue',
            true
        );
        Test.stopTest();
        System.assertEquals(
            relationshipLookupName,
            insertedRelationshipLookupName,
            'Relationship lookup name should be ' + relationshipLookupName
        );
    }

    /****************************************************************************************************************************
     * @description Test method to verify that the updateRelationshipLookup method returns a valid relationship lookup name
     ****************************************************************************************************************************/
    @isTest
    private static void updateRelationshipLookupSuccess() {
        RelationshipLookupSettingsService.instance = new STUB_RelationshipLookupSettingsService();

        String relationshipLookupName = 'TestUpdatedLookupName';
        String oldRelationshipLookupName = 'TestOldLookupName';

        Test.startTest();
        String updatedRelationshipLookupName = RelationshipSettingsController.updateRelationshipLookup(
            oldRelationshipLookupName,
            relationshipLookupName,
            'TestFemaleValue',
            'TestMaleValue',
            'TestNeutralValue',
            true
        );
        Test.stopTest();
        System.assertEquals(
            relationshipLookupName,
            updatedRelationshipLookupName,
            'Relationship lookup name should be ' + relationshipLookupName
        );
    }

    /****************************************************************************************************************************
     * @description Test method to verify that the deleteRelationshipLookup method returns a valid relationship lookup name
     ****************************************************************************************************************************/
    @isTest
    private static void deleteRelationshipLookupSuccess() {
        RelationshipLookupSettingsService.instance = new STUB_RelationshipLookupSettingsService();

        String relationshipLookupName = 'TestDeletedLookupName';

        Test.startTest();
        String deletedRelationshipLookupName = RelationshipSettingsController.deleteRelationshipLookup(
            relationshipLookupName
        );
        Test.stopTest();
        System.assertEquals(
            relationshipLookupName,
            deletedRelationshipLookupName,
            'Relationship lookup name should be ' + relationshipLookupName
        );
    }

    /****************************************************************************************************************************
     * @description Test method to verify that the createRelationshipLookup method fails gracefully when an exception is
     * encountered.
     ****************************************************************************************************************************/
    @isTest
    private static void createRelationshipLookupException() {
        RelationshipLookupSettingsService.instance = new STUB_ExceptionRelationshipLookupSettingsService();

        try {
            Test.startTest();
            String insertedRelLookupName = RelationshipSettingsController.createRelationshipLookup(
                'TestRelationshipLookupName',
                'femaleValue',
                'maleValue',
                'neutralValue',
                false
            );
            Test.stopTest();
            System.assert(false, 'should always throw an exception');
        } catch (AuraHandledException e) {
            System.assertEquals('Script-thrown exception', e.getMessage(), 'Should throw exception.');
        }
    }

    /****************************************************************************************************************************
     * @description Test method to verify that the updateRelationshipLookup method fails gracefully when an exception is
     * encountered.
     ****************************************************************************************************************************/
    @isTest
    private static void updateRelationshipLookupException() {
        RelationshipLookupSettingsService.instance = new STUB_ExceptionRelationshipLookupSettingsService();

        try {
            Test.startTest();
            String updatedRelLookupName = RelationshipSettingsController.updateRelationshipLookup(
                'TestOldRelationshipLookupName',
                'TestRelationshipLookupName',
                'femaleValue',
                'maleValue',
                'neutralValue',
                false
            );
            Test.stopTest();
            System.assert(false, 'should always throw an exception');
        } catch (AuraHandledException e) {
            System.assertEquals('Script-thrown exception', e.getMessage(), 'Should throw exception.');
        }
    }

    /****************************************************************************************************************************
     * @description Test method to verify that the deleteRelationshipLookup method fails gracefully when an exception is
     * encountered.
     ****************************************************************************************************************************/
    @isTest
    private static void deleteRelationshipLookupException() {
        RelationshipLookupSettingsService.instance = new STUB_ExceptionRelationshipLookupSettingsService();

        try {
            Test.startTest();
            String deletedRelLookupName = RelationshipSettingsController.deleteRelationshipLookup(
                'TestRelationshipLookupName'
            );
            Test.stopTest();
            System.assert(false, 'should always throw an exception');
        } catch (AuraHandledException e) {
            System.assertEquals('Script-thrown exception', e.getMessage(), 'Should throw exception.');
        }
    }

    /**************************************************************************************************************************
     ****************************************************** STUBS **************************************************************
     **************************************************************************************************************************/

    /**************************************************************************************************************************************
     * @description Stub class to simulate the response from RelationshipSettingsVMapper to return a valid RelationshipSettingsVModel
     **************************************************************************************************************************************/
    private class STUB_RelationshipSettingsVMapper extends RelationshipSettingsVMapper {
        public override RelationshipSettingsVModel getRelationshipSettingsVModel() {
            ComboboxValueVModel listSettingComboboxValueVModel = new ComboboxValueVModel(
                Label.stgReciprocalMethodListSetting,
                'List Setting'
            );
            ComboboxValueVModel valueInversionComboboxValueVModel = new ComboboxValueVModel(
                Label.stgReciprocalMethodValueInversion,
                'Value Inversion'
            );
            List<ComboboxValueVModel> relationshipTypeComboboxValueVModelsList = new List<ComboboxValueVModel>();

            relationshipTypeComboboxValueVModelsList.add(listSettingComboboxValueVModel);
            relationshipTypeComboboxValueVModelsList.add(valueInversionComboboxValueVModel);

            return new RelationshipSettingsVModel(
                new comboboxvmodel('List Setting', relationshipTypeComboboxValueVModelsList),
                true
            );
        }
    }

    /**************************************************************************************************************************************
     * @description Stub class to simulate the response from RelationshipSettingsVMapper to throw an exception
     **************************************************************************************************************************************/
    private class STUB_ExceptionRelationshipSettingsVMapper extends RelationshipSettingsVMapper {
        public override RelationshipSettingsVModel getRelationshipSettingsVModel() {
            throw new TestException('Exception encountered!');
        }
    }

    /**************************************************************************************************************************************
     * @description Stub class to simulate the response from RelationshipLookupsVMapper to return a valid RelationshipSettingsVModel
     **************************************************************************************************************************************/
    private class STUB_RelationshipLookupsVMapper extends RelationshipLookupsVMapper {
        public override RelationshipLookupsVModel getRelationshipLookupsVModel() {
            List<RelationshipLookupVModel> relationshipLookupVModelList = new List<RelationshipLookupVModel>();
            relationshipLookupVModelList.add(
                new RelationshipLookupVModel(
                    'RelationshipLookupName1',
                    'FemaleValue1',
                    'MaleValue1',
                    'NeutralValue1',
                    true
                )
            );
            relationshipLookupVModelList.add(
                new RelationshipLookupVModel(
                    'RelationshipLookupName2',
                    'FemaleValue2',
                    'MaleValue2',
                    'NeutralValue2',
                    true
                )
            );
            return new RelationshipLookupsVModel(relationshipLookupVModelList);
        }

        public override ComboBoxVModel getRelationshipLookupComboboxVModel(String relationshipLookupName) {
            List<ComboboxValueVModel> relationshipLookupComboboxValueVModelsList = new List<ComboboxValueVModel>();
            relationshipLookupComboboxValueVModelsList.add(
                new ComboboxValueVModel('ActiveRelationshipLabel1', 'ActiveRelationshipName1')
            );
            relationshipLookupComboboxValueVModelsList.add(
                new ComboboxValueVModel('ActiveRelationshipLabel2', 'ActiveRelationshipName2')
            );

            return new ComboboxVModel('ActiveRelationshipName1', relationshipLookupComboboxValueVModelsList);
        }

        public override ComboBoxVModel getRelationshipLookupNameComboboxVModel(String relationshipLookupName) {
            List<ComboboxValueVModel> relationshipLookupComboboxValueVModelsList = new List<ComboboxValueVModel>();
            relationshipLookupComboboxValueVModelsList.add(
                new ComboboxValueVModel('UnmappedRelationshipLabel1', 'UnmappedRelationshipName1')
            );
            relationshipLookupComboboxValueVModelsList.add(
                new ComboboxValueVModel('UnmappedRelationshipLabel2', 'UnmappedRelationshipName2')
            );

            return new ComboboxVModel('UnmappedRelationshipName1', relationshipLookupComboboxValueVModelsList);
        }
    }

    /**************************************************************************************************************************************
     * @description Stub class to simulate the response from RelationshipSettingsVMapper to throw an exception
     **************************************************************************************************************************************/
    private class STUB_ExceptionRelationshipLookupsVMapper extends RelationshipLookupsVMapper {
        public override RelationshipLookupsVModel getRelationshipLookupsVModel() {
            throw new TestException('Exception encountered!');
        }

        public override ComboBoxVModel getRelationshipLookupComboboxVModel(String relationshipLookupName) {
            throw new TestException('Exception encountered!');
        }

        public override ComboBoxVModel getRelationshipLookupNameComboboxVModel(String relationshipLookupName) {
            throw new TestException('Exception encountered!');
        }
    }

    /**************************************************************************************************************************************
     * @description Stub class to simulate the response from RelationshipLookupSettingsService to return a valid RelationshipLookupSettingsService
     **************************************************************************************************************************************/
    private class STUB_RelationshipLookupSettingsService extends RelationshipLookupSettingsService {
        public override RelationshipLookupModel insertRelationshipLookup(
            String relationshipLookupName,
            String femaleValue,
            String maleValue,
            String neutralValue,
            Boolean isActive
        ) {
            return new RelationshipLookupModel(relationshipLookupName, isActive, femaleValue, maleValue, neutralValue);
        }

        public override RelationshipLookupModel updateRelationshipLookup(
            String oldRelationshipLookupName,
            String newRelationshipLookupName,
            String femaleValue,
            String maleValue,
            String neutralValue,
            Boolean isActive
        ) {
            return new RelationshipLookupModel(
                newRelationshipLookupName,
                isActive,
                femaleValue,
                maleValue,
                neutralValue
            );
        }

        public override RelationshipLookupModel deleteRelationshipLookup(String relationshipLookupName) {
            return new RelationshipLookupModel(
                relationshipLookupName,
                true,
                'TestDeletedFemaleValue',
                'TestDeletedMaleValue',
                'TestDeletedNeutralValue'
            );
        }
    }

    /**************************************************************************************************************************************
     * @description Stub class to simulate the response from RelationshipLookupSettingsService to throw an exception
     **************************************************************************************************************************************/
    private class STUB_ExceptionRelationshipLookupSettingsService extends RelationshipLookupSettingsService {
        public override RelationshipLookupModel insertRelationshipLookup(
            String relationshipLookupName,
            String femaleValue,
            String maleValue,
            String neutralValue,
            Boolean isActive
        ) {
            throw new TestException('Exception encountered!');
        }

        public override RelationshipLookupModel updateRelationshipLookup(
            String oldRelationshipLookupName,
            String newRelationshipLookupName,
            String femaleValue,
            String maleValue,
            String neutralValue,
            Boolean isActive
        ) {
            throw new TestException('Exception encountered!');
        }

        public override RelationshipLookupModel deleteRelationshipLookup(String relationshipLookupName) {
            throw new TestException('Exception encountered!');
        }
    }

    private class TestException extends Exception {
    }
}
@isTest
private class RenameLeadConvertedAccounts_TEST {
    private static Integer leadCount = 5; // used to determine number of test contact records to create
    /*********************************************************************************************************
     * @description Insert and convert a new Lead with no Lead Conversion record types selected
     * Make sure the Account's name is the Lead Company Name
     */
    @isTest
    private static void convertLeadNoRecordTypes() {
        Lead testLead = new Lead(FirstName = 'First', LastName = 'Last', company = 'Company');
        insert testLead;

        Test.startTest();
        Database.LeadConvert lc = new database.LeadConvert();
        lc.setLeadId(testLead.Id);
        LeadStatus convertStatus = [SELECT Id, MasterLabel FROM LeadStatus WHERE IsConverted = TRUE LIMIT 1];
        lc.setConvertedStatus(convertStatus.MasterLabel);
        Database.LeadConvertResult lcr = Database.convertLead(lc);

        Test.stopTest();

        System.assert(lcr.isSuccess());

        Account assertAccount = [SELECT Id, RecordType.Name, Name FROM Account LIMIT 1];

        System.assertEquals('Company', assertAccount.Name);
    }

    /*********************************************************************************************************
     * @description Insert and convert a new lead with the Administrative Record Type selected
     * Make sure the Account's name is set based on account administrative naming setting.
     */
    @isTest
    private static void convertLeadAdminRecordType() {
        UTIL_CustomSettingsFacade.getSettingsForTests(
            new Hierarchy_Settings__c(
                Account_Processor__c = UTIL_Describe_API.getAdminAccRecTypeID(),
                Automatic_Household_Naming__c = true,
                Lead_Converted_Account_RTypes__c = UTIL_Describe_API.getAdminAccRecTypeID()
            )
        );

        Lead testLead = new Lead(FirstName = 'First', LastName = 'Last', company = 'Company');
        insert testLead;

        Test.startTest();
        Database.LeadConvert lc = new database.LeadConvert();
        lc.setLeadId(testLead.Id);
        LeadStatus convertStatus = [SELECT Id, MasterLabel FROM LeadStatus WHERE IsConverted = TRUE LIMIT 1];
        lc.setConvertedStatus(convertStatus.MasterLabel);
        Database.LeadConvertResult lcr = Database.convertLead(lc);

        Test.stopTest();

        System.assert(lcr.isSuccess());

        Account assertAccount = [SELECT Id, RecordType.Name, Name FROM Account LIMIT 1];

        System.assertEquals(testLead.LastName + ' Administrative Account', assertAccount.Name);
    }

    /*********************************************************************************************************
     * @description Insert and convert a new lead with the Administrative Record Type selected
     * convert this lead to an existing Account
     * Make sure the Account's name is set based on account administrative naming setting.
     */
    @isTest
    private static void convertLeadAdminRecordTypeExistingAccount() {
        UTIL_CustomSettingsFacade.getSettingsForTests(
            new Hierarchy_Settings__c(
                Account_Processor__c = UTIL_Describe_API.getAdminAccRecTypeID(),
                Automatic_Household_Naming__c = true,
                Lead_Converted_Account_RTypes__c = UTIL_Describe_API.getAdminAccRecTypeID()
            )
        );

        Lead testLead = new Lead(FirstName = 'First', LastName = 'Last', company = 'Company');
        insert testLead;

        Account anAccount = new Account(Name = 'Demo Admin', RecordTypeId = UTIL_Describe_API.getAdminAccRecTypeID());
        insert anAccount;

        Test.setCreatedDate(anAccount.Id, DateTime.newInstance(2012, 12, 12));

        Test.startTest();
        Database.LeadConvert lc = new database.LeadConvert();
        lc.setLeadId(testLead.Id);
        LeadStatus convertStatus = [SELECT Id, MasterLabel FROM LeadStatus WHERE IsConverted = TRUE LIMIT 1];
        lc.setConvertedStatus(convertStatus.MasterLabel);

        Account theaccount = [SELECT CreatedDate FROM Account WHERE Id = :anAccount.Id];
        lc.setAccountId(anAccount.Id);
        Database.LeadConvertResult lcr = Database.convertLead(lc);

        Test.stopTest();

        System.assert(lcr.isSuccess());

        Account assertAccount = [SELECT Id, RecordType.Name, Name FROM Account LIMIT 1];

        System.assertEquals('Demo Admin', assertAccount.Name);
    }

    /*********************************************************************************************************
     * @description Insert and convert a new lead with the Household Record Type selected
     * Make sure the Account's name is set based on account default naming setting.
     */
    @isTest
    private static void convertLeadHHRecordType() {
        UTIL_CustomSettingsFacade.getSettingsForTests(
            new Hierarchy_Settings__c(
                Account_Processor__c = UTIL_Describe_API.getAdminAccRecTypeID(),
                Household_Account_Naming_Format__c = '{!LastName} Household Account',
                Automatic_Household_Naming__c = true,
                Lead_Converted_Account_RTypes__c = UTIL_Describe_API.getHhAccRecTypeID()
            )
        );

        Lead testLead = new Lead(FirstName = 'First', LastName = 'Last', company = 'Company');
        insert testLead;

        Account testAccount = new Account(
            Name = 'Test Account Name',
            RecordTypeId = UTIL_Describe_API.getHhAccRecTypeID()
        );
        insert testAccount;

        Test.startTest();
        Database.LeadConvert lc = new database.LeadConvert();
        lc.setLeadId(testLead.Id);
        lc.setAccountId(testAccount.Id);
        LeadStatus convertStatus = [SELECT Id, MasterLabel FROM LeadStatus WHERE IsConverted = TRUE LIMIT 1];
        lc.setConvertedStatus(convertStatus.MasterLabel);
        Database.LeadConvertResult lcr = Database.convertLead(lc);

        Test.stopTest();

        System.assert(lcr.isSuccess());

        Account assertAccount = [SELECT Id, RecordType.Name, Name FROM Account LIMIT 1];

        System.assertEquals(testLead.LastName + ' Household Account', assertAccount.Name);
    }

    /*********************************************************************************************************
     * @description Insert and convert a new lead with the Household Record Type selected
     * with an Existing Account
     * Make sure the Account's name includes the new Contact lastName
     */
    @isTest
    private static void convertLeadHHRecordTypeExistingAccount() {
        UTIL_CustomSettingsFacade.getSettingsForTests(
            new Hierarchy_Settings__c(
                Account_Processor__c = UTIL_Describe_API.getAdminAccRecTypeID(),
                Household_Account_Naming_Format__c = '{!LastName} Household Account',
                Automatic_Household_Naming__c = true,
                Lead_Converted_Account_RTypes__c = UTIL_Describe_API.getHhAccRecTypeID()
            )
        );

        Lead testLead = new Lead(FirstName = 'Mickey', LastName = 'Mouse', company = 'Company');
        insert testLead;

        Account anAccount = new Account(Name = 'Demo Admin', RecordTypeId = UTIL_Describe_API.getHhAccRecTypeID());
        insert anAccount;

        Contact firstContact = new Contact(LastName = 'Duck', FirstName = 'Daffy', AccountId = anAccount.Id);
        insert firstContact;

        Test.setCreatedDate(anAccount.Id, DateTime.newInstance(2012, 12, 12));

        Test.startTest();
        Database.LeadConvert lc = new database.LeadConvert();
        lc.setLeadId(testLead.Id);
        lc.setAccountId(anAccount.Id);
        LeadStatus convertStatus = [SELECT Id, MasterLabel FROM LeadStatus WHERE IsConverted = TRUE LIMIT 1];
        lc.setConvertedStatus(convertStatus.MasterLabel);

        Account theaccount = [SELECT CreatedDate FROM Account WHERE Id = :anAccount.Id];
        lc.setAccountId(anAccount.Id);
        Database.LeadConvertResult lcr = Database.convertLead(lc);

        Test.stopTest();

        System.assert(lcr.isSuccess());

        Account assertAccount = [SELECT Id, RecordType.Name, Name FROM Account LIMIT 1];

        System.assertEquals('Duck and Mouse Household Account', assertAccount.Name);
    }

    @isTest
    private static void convertLeadDefaultRecordType() {
        UTIL_CustomSettingsFacade.getSettingsForTests(
            new Hierarchy_Settings__c(
                Account_Processor__c = UTIL_Describe_API.getAdminAccRecTypeID(),
                Household_Account_Naming_Format__c = '{!LastName} Household Account',
                Automatic_Household_Naming__c = true,
                Lead_Converted_Account_RTypes__c = UTIL_Describe_API.getAcademicAccRecTypeID()
            )
        );

        Lead testLead = new Lead(FirstName = 'First', LastName = 'Last', company = 'Company');
        insert testLead;

        Account testAccount = new Account(
            Name = 'Test Account Name',
            RecordTypeId = UTIL_Describe_API.getAcademicAccRecTypeID()
        );
        insert testAccount;

        Test.startTest();
        Database.LeadConvert lc = new database.LeadConvert();
        lc.setLeadId(testLead.Id);
        lc.setAccountId(testAccount.Id);
        LeadStatus convertStatus = [SELECT Id, MasterLabel FROM LeadStatus WHERE IsConverted = TRUE LIMIT 1];
        lc.setConvertedStatus(convertStatus.MasterLabel);
        Database.LeadConvertResult lcr = Database.convertLead(lc);

        Test.stopTest();

        System.assert(lcr.isSuccess());

        Account assertAccount = [SELECT Id, RecordType.Name, Name FROM Account LIMIT 1];

        System.assertEquals(testLead.LastName + ' Account', assertAccount.Name);
    }

    /*********************************************************************************************************
     * @description Insert and convert a specified number of leads to test for bulk, the number
     * to insert can be overriden for unpackaged
     */
    @isTest
    private static void bulkConvertLeadAdminRecordType() {
        UTIL_CustomSettingsFacade.getSettingsForTests(
            new Hierarchy_Settings__c(
                Account_Processor__c = UTIL_Describe_API.getAdminAccRecTypeID(),
                Automatic_Household_Naming__c = true,
                Lead_Converted_Account_RTypes__c = UTIL_Describe_API.getAdminAccRecTypeID()
            )
        );

        List<Lead> leadsToInsert = new List<Lead>();
        for (integer i = 0; i < leadCount; i++) {
            leadsToInsert.add(new Lead(Company = 'Company' + i, lastname = 'Last' + i));
        }

        insert leadsToInsert;

        Test.startTest();
        LeadStatus convertStatus = [SELECT Id, MasterLabel FROM LeadStatus WHERE IsConverted = TRUE LIMIT 1];
        list<Database.LeadConvert> leadConverts = new List<Database.LeadConvert>();
        for (Lead theLead : leadsToInsert) {
            Database.LeadConvert lc = new database.LeadConvert();
            lc.setLeadId(theLead.Id);
            lc.convertedStatus = convertStatus.MasterLabel;
            leadConverts.add(lc);
        }

        Database.LeadConvertResult[] leadConvertResults = Database.convertLead(leadConverts);

        for (Database.LeadConvertResult lcr : leadConvertResults) {
            System.assert(lcr.isSuccess());
        }

        Test.stopTest();
    }
}
@isTest
private class SRVC_Account_PreventDeletion_TEST {
    /**************************************************************************************************************************
     * @description Helper method to create Account with child records
     */
    private static Account createAccountWithChildRecordsHelper() {
        UTIL_CustomSettingsFacade.getSettingsForTests(
            new Hierarchy_Settings__c(
                Account_Processor__c = UTIL_Describe_API.getBizAccRecTypeID(),
                Prevent_Account_Deletion__c = true
            )
        );

        return UTIL_UnitTestData_TEST.createTestAccountWithMultipleRelations();
    }

    /**************************************************************************************************************************
     * @description Tests getInstance() and constructor of SRVC_Account_PreventDeletion
     */
    @isTest
    static void testGetInstance() {
        UTIL_CustomSettingsFacade.getSettingsForTests(
            new Hierarchy_Settings__c(
                Account_Processor__c = UTIL_Describe_API.getBizAccRecTypeID(),
                Prevent_Account_Deletion__c = true
            )
        );

        SRVC_Account_PreventDeletion srvcAccountPreventDeleteInstance = SRVC_Account_PreventDeletion.getInstance();
        System.assertEquals(SRVC_Account_PreventDeletion.instance, srvcAccountPreventDeleteInstance);
        System.assertNotEquals(null, srvcAccountPreventDeleteInstance);

        srvcAccountPreventDeleteInstance = SRVC_Account_PreventDeletion.getInstance();
        System.assertEquals(SRVC_Account_PreventDeletion.instance, srvcAccountPreventDeleteInstance);
        System.assertEquals(true, srvcAccountPreventDeleteInstance.enabledPreventAccountDeletion);
    }

    /**************************************************************************************************************************
     * @description Tests that isAccountDeletionPreventionEnabled is returning true when prevent deletion is enabled
     */
    @isTest
    static void shouldDetectEnabledPreventDeletionSetting() {
        UTIL_CustomSettingsFacade.getSettingsForTests(
            new Hierarchy_Settings__c(
                Account_Processor__c = UTIL_Describe_API.getBizAccRecTypeID(),
                Prevent_Account_Deletion__c = true
            )
        );

        SRVC_Account_PreventDeletion srvcAccountPreventDeleteInstance = SRVC_Account_PreventDeletion.getInstance();
        System.assertEquals(true, srvcAccountPreventDeleteInstance.isAccountDeletionPreventionEnabled());
    }

    /**************************************************************************************************************************
     * @description Tests that isAccountDeletionPreventionEnabled is returning false when prevent deletion is disabled
     */
    @isTest
    static void shouldDetectDisabledPreventDeletionSetting() {
        UTIL_CustomSettingsFacade.getSettingsForTests(
            new Hierarchy_Settings__c(
                Account_Processor__c = UTIL_Describe_API.getBizAccRecTypeID(),
                Prevent_Account_Deletion__c = false
            )
        );

        SRVC_Account_PreventDeletion srvcAccountPreventDeleteInstance = SRVC_Account_PreventDeletion.getInstance();
        System.assertEquals(false, srvcAccountPreventDeleteInstance.isAccountDeletionPreventionEnabled());
    }

    /**************************************************************************************************************************
     * @description Tests Prevent Deletion for Accounts with STUB_AccountsWithChildRelationships
     */
    @isTest
    static void shouldPreventDeletionForAccountsWithChildrenUsingSTUB() {
        SRVC_Account_PreventDeletion.instance = new STUB_AccountsWithChildRelationships();

        List<Account> accounts = UTIL_UnitTestData_TEST.getMultipleTestAccounts(
            1,
            UTIL_Describe_API.getBizAccRecTypeID()
        );
        accounts[0].Id = UTIL_UnitTestData_TEST.getFakeId(Account.sObjectType);

        Map<Id, Account> accountsById = new Map<Id, Account>((List<Account>) accounts);

        Test.startTest();
        List<Account> accountsWithRelations = SRVC_Account_PreventDeletion.getInstance()
            .getAccountsAndChildRelationships(accountsById.keySet());
        List<Account> accountsWithErrorsList = SRVC_Account_PreventDeletion.getInstance()
            .preventDeletionForAccounts(accountsById, accountsWithRelations);
        Test.stopTest();

        System.assertEquals(accountsById.values().size(), accountsWithErrorsList.size());

        for (Account accountToCheck : accountsWithErrorsList) {
            System.assert(accountsById.get(accountToCheck.Id) != null);
        }
    }

    /**************************************************************************************************************************
     * @description Tests Prevent Deletion for Accounts with STUB_AccountsWithNoChildRelationships
     */
    @isTest
    static void shouldPreventDeletionForAccountsWithNoChildrenUsingSTUB() {
        SRVC_Account_PreventDeletion.instance = new STUB_AccountsWithNoChildRelationships();

        List<Account> accounts = UTIL_UnitTestData_TEST.getMultipleTestAccounts(
            1,
            UTIL_Describe_API.getBizAccRecTypeID()
        );
        accounts[0].Id = UTIL_UnitTestData_TEST.getFakeId(Account.sObjectType);

        Map<Id, Account> accountById = new Map<Id, Account>((List<Account>) accounts);

        Test.startTest();
        List<Account> accountsWithRelations = SRVC_Account_PreventDeletion.getInstance()
            .getAccountsAndChildRelationships(accountById.keySet());
        List<Account> accountsWithErrorsList = SRVC_Account_PreventDeletion.getInstance()
            .preventDeletionForAccounts(accountById, accountsWithRelations);
        Test.stopTest();

        // Ensure accountsWithErrorsList is empty
        System.assertEquals(0, accountsWithErrorsList.size());
    }

    /**************************************************************************************************************************
     * @description Positive tests for preventDeletionForAccounts method using Account with Child records
     */
    @isTest
    static void shouldPreventDeletionForAccountsWithRelations() {
        Account accountWithChildRecords = SRVC_Account_PreventDeletion_TEST.createAccountWithChildRecordsHelper();
        Map<Id, Account> accountById = new Map<Id, Account>();
        accountById.put(accountWithChildRecords.Id, accountWithChildRecords);

        Test.startTest();
        List<Account> accountsWithRelations = SRVC_Account_PreventDeletion.getInstance()
            .getAccountsAndChildRelationships(accountById.keySet());
        List<account> accountErroredList = SRVC_Account_PreventDeletion.getInstance()
            .preventDeletionForAccounts(accountById, accountsWithRelations);
        Test.stopTest();

        // Ensure accountsWithErrorsList is not empty
        System.assertEquals(1, accountErroredList.size());
    }

    /**************************************************************************************************************************
     * @description Negative tests for preventDeletionForAccounts method with No Child records
     */
    @isTest
    static void shouldNotPreventDeletionForAccountsWithNoRelations() {
        List<Account> accountWithNoChildRecord = UTIL_UnitTestData_TEST.getMultipleTestAccounts(
            1,
            UTIL_Describe_API.getBizAccRecTypeID()
        );
        accountWithNoChildRecord[0].Id = UTIL_UnitTestData_TEST.getFakeId(Account.sObjectType);

        Map<Id, Account> accountById = new Map<Id, Account>(accountWithNoChildRecord);

        Test.startTest();
        List<Account> accountsWithRelations = SRVC_Account_PreventDeletion.getInstance()
            .getAccountsAndChildRelationships(accountById.keySet());
        List<account> accountErroredList = SRVC_Account_PreventDeletion.getInstance()
            .preventDeletionForAccounts(accountById, accountsWithRelations);
        Test.stopTest();

        // Ensure accountsWithErrorsList is empty
        System.assertEquals(0, accountErroredList.size());
    }

    /**************************************************************************************************************************
     * @description Positive tests for AccountsAndChildRelationships method
     */
    @isTest
    static void shouldGetAccountsAndChildRelationships() {
        Account accountWithChildRecords = SRVC_Account_PreventDeletion_TEST.createAccountWithChildRecordsHelper();

        Set<Id> accountIdSet = new Set<Id>();
        accountIdSet.add(accountWithChildRecords.Id);

        Test.startTest();
        List<Account> accountsWithChildRecords = SRVC_Account_PreventDeletion.getInstance()
            .getAccountsAndChildRelationships(accountIdSet);
        Test.stopTest();

        // Ensure child records are retrieved
        System.assertEquals(1, accountsWithChildRecords[0].Addresses__r.size());
        System.assertEquals(1, accountsWithChildRecords[0].Affl_Contacts__r.size());
        System.assertEquals(1, accountsWithChildRecords[0].Attributes__r.size());
        System.assertEquals(1, accountsWithChildRecords[0].Courses__r.size());
        System.assertEquals(1, accountsWithChildRecords[0].Education_History__r.size());
        System.assertEquals(1, accountsWithChildRecords[0].Facilities__r.size());
        System.assertEquals(1, accountsWithChildRecords[0].Household_Members__r.size());
        System.assertEquals(1, accountsWithChildRecords[0].Organization_Members__r.size());
        System.assertEquals(1, accountsWithChildRecords[0].Program_Enrollments__r.size());
        System.assertEquals(1, accountsWithChildRecords[0].Program_Plans__r.size());
        System.assertEquals(1, accountsWithChildRecords[0].Terms__r.size());
        System.assertEquals(1, accountsWithChildRecords[0].Time_Blocks__r.size());
    }

    /**************************************************************************************************************************
     * @description Negative tests for AccountsAndChildRelationships method
     */
    @isTest
    static void shouldNotGetChildRelationshipsForEmptyAccounts() {
        List<Account> accounts = UTIL_UnitTestData_TEST.getMultipleTestAccounts(
            1,
            UTIL_Describe_API.getBizAccRecTypeID()
        );
        insert accounts;

        Map<Id, Account> accountById = new Map<Id, Account>(accounts);
        Set<Id> accountIdSet = accountById.keySet();

        Test.startTest();
        List<account> accountsWithChildRecords = SRVC_Account_PreventDeletion.getInstance()
            .getAccountsAndChildRelationships(accountIdSet);
        Test.stopTest();

        System.assertEquals(0, accountsWithChildRecords[0].Addresses__r.size());
        System.assertEquals(0, accountsWithChildRecords[0].Affl_Contacts__r.size());
        System.assertEquals(0, accountsWithChildRecords[0].Attributes__r.size());
        System.assertEquals(0, accountsWithChildRecords[0].Courses__r.size());
        System.assertEquals(0, accountsWithChildRecords[0].Course_Enrollments__r.size());
        System.assertEquals(0, accountsWithChildRecords[0].Education_History__r.size());
        System.assertEquals(0, accountsWithChildRecords[0].Facilities__r.size());
        System.assertEquals(0, accountsWithChildRecords[0].Household_Members__r.size());
        System.assertEquals(0, accountsWithChildRecords[0].Organization_Members__r.size());
        System.assertEquals(0, accountsWithChildRecords[0].Program_Enrollments__r.size());
        System.assertEquals(0, accountsWithChildRecords[0].Program_Plans__r.size());
        System.assertEquals(0, accountsWithChildRecords[0].Terms__r.size());
        System.assertEquals(0, accountsWithChildRecords[0].Time_Blocks__r.size());
    }

    /**************************************************************************************************************************
     * @description positive test for AccountHasChildRecords method
     */
    @isTest
    static void shouldHaveChildRecordsForAccountWithChildRelations() {
        Account accountWithChildRecords = SRVC_Account_PreventDeletion_TEST.createAccountWithChildRecordsHelper();

        Account acc = [
            SELECT
                ID,
                (SELECT ID FROM Account.Addresses__r LIMIT 1),
                (SELECT ID FROM Account.Affl_Contacts__r LIMIT 1),
                (SELECT ID FROM Account.Attributes__r LIMIT 1),
                (SELECT ID FROM Account.Courses__r LIMIT 1),
                (SELECT ID FROM Account.Course_Enrollments__r LIMIT 1),
                (SELECT ID FROM Account.Education_History__r LIMIT 1),
                (SELECT ID FROM Account.Facilities__r LIMIT 1),
                (SELECT ID FROM Account.Household_Members__r LIMIT 1),
                (SELECT ID FROM Account.Organization_Members__r LIMIT 1),
                (SELECT ID FROM Account.Program_Enrollments__r LIMIT 1),
                (SELECT ID FROM Account.Program_Plans__r LIMIT 1),
                (SELECT ID FROM Account.Terms__r LIMIT 1),
                (SELECT ID FROM Account.Time_Blocks__r LIMIT 1)
            FROM Account
            WHERE ID = :accountWithChildRecords.Id
        ];

        Test.startTest();
        Boolean accountHasChildren = SRVC_Account_PreventDeletion.getInstance().hasChildRecords(acc);
        Test.stopTest();

        // Ensure accountHasChildren is true
        System.assertEquals(true, accountHasChildren);
    }

    /**************************************************************************************************************************
     * @description Negative test for AccountHasChildRecords method
     */
    @isTest
    static void shouldNotHaveChildRecordsForEmptyAccounts() {
        List<Account> accounts = UTIL_UnitTestData_TEST.getMultipleTestAccounts(
            1,
            UTIL_Describe_API.getBizAccRecTypeID()
        );

        Test.startTest();
        Boolean accountHasChildren = SRVC_Account_PreventDeletion.getInstance().hasChildRecords(accounts[0]);
        Test.stopTest();

        // Ensure accountHasChildren is false
        System.assertEquals(false, accountHasChildren);
    }

    /**************************************************************************************************************************
     * @description Positive tests for accountWasMerged method using Account with MasterRecordId
     */
    @isTest
    static void shouldReturnTrueWhenAccountWasMerged() {
        Account accountWithChildRecords = SRVC_Account_PreventDeletion_TEST.createAccountWithChildRecordsHelper();
        List<Account> accounts = UTIL_UnitTestData_TEST.getMultipleTestAccounts(
            2,
            UTIL_Describe_API.getBizAccRecTypeID()
        );
        insert accounts[1]; //Use the second account as master to avoid duplicate error
        merge accounts[1] accountWithChildRecords;
        Account mergeLoserAccount = [
            SELECT Id, MasterRecordId
            FROM Account
            WHERE Id = :accountWithChildRecords.Id
            ALL ROWS
        ];

        Test.startTest();
        Boolean accountWasMerged = SRVC_Account_PreventDeletion.getInstance().wasMerged(mergeLoserAccount);
        Test.stopTest();

        // Ensure accountWasMerged is true
        System.assertEquals(true, accountWasMerged);
    }

    /**************************************************************************************************************************
     * @description Negative tests for accountWasMerged method using Account without MasterRecordId
     */
    @isTest
    static void shouldReturnFalseWhenAccountNotMerged() {
        List<Account> accounts = UTIL_UnitTestData_TEST.getMultipleTestAccounts(
            2,
            UTIL_Describe_API.getBizAccRecTypeID()
        );

        Test.startTest();
        Boolean accountWasMerged = SRVC_Account_PreventDeletion.getInstance().wasMerged(accounts[0]);
        Test.stopTest();

        // Ensure accountWasMerged is false
        System.assertEquals(false, accountWasMerged);
    }

    /**************************************************************************************************************************
     * @description Tests Prevent Deletion for merged accounts with STUB_MergedAccounts
     */
    @isTest
    static void shouldNotPreventDeletionForMergedAccountsUsingSTUB() {
        SRVC_Account_PreventDeletion.instance = new STUB_MergedAccounts();

        List<Account> accounts = UTIL_UnitTestData_TEST.getMultipleTestAccounts(
            1,
            UTIL_Describe_API.getBizAccRecTypeID()
        );
        accounts[0].Id = UTIL_UnitTestData_TEST.getFakeId(Account.sObjectType);

        Map<Id, Account> accountById = new Map<Id, Account>((List<Account>) accounts);

        Test.startTest();
        List<Account> accountsWithRelations = SRVC_Account_PreventDeletion.getInstance()
            .getAccountsAndChildRelationships(accountById.keySet());
        List<Account> accountsWithErrorsList = SRVC_Account_PreventDeletion.getInstance()
            .PreventDeletionForAccounts(accountById, accountsWithRelations);
        Test.stopTest();

        //Ensure prevent deletion did not mark any account
        System.assertEquals(0, accountsWithErrorsList.size());
    }

    /**************************************************************************************************************************************
     * STUB class which extends SRVC_Account_PreventDeletion, overrides getAccountsAndChildRelationships and hasChildRecords method
     */
    private virtual class STUB_AccountsWithChildRelationships extends SRVC_Account_PreventDeletion {
        @TestVisible
        public override List<Account> getAccountsAndChildRelationships(Set<Id> accountIdSet) {
            List<Account> accountsList = new List<Account>();
            for (Id eachAccountId : accountIdSet) {
                Account acc = new Account(Id = eachAccountId, Name = eachAccountId);
                accountsList.add(acc);
            }
            return accountsList;
        }

        @TestVisible
        public override Boolean hasChildRecords(Account acc) {
            return true;
        }
    }

    /***************************************************************************************************************************************
     * STUB class which extends SRVC_Account_PreventDeletion, overrides getAccountsAndChildRelationships and hasChildRecords method
     */
    private virtual class STUB_AccountsWithNoChildRelationships extends SRVC_Account_PreventDeletion {
        @TestVisible
        public override List<Account> getAccountsAndChildRelationships(Set<Id> accountIdSet) {
            List<Account> accountsList = new List<Account>();
            for (Id eachAccountId : accountIdSet) {
                Account acc = new Account(Id = eachAccountId, Name = eachAccountId);
                accountsList.add(acc);
            }
            return accountsList;
        }

        @TestVisible
        public override Boolean hasChildRecords(Account acc) {
            return false;
        }
    }

    /**************************************************************************************************************************************
     * STUB class which extends STUB_AccountsWithChildRelationships, overrides wasMerged method to simulate merging
     */
    private virtual class STUB_MergedAccounts extends STUB_AccountsWithChildRelationships {
        @TestVisible
        protected override Boolean wasMerged(Account acc) {
            return true;
        }
    }
}

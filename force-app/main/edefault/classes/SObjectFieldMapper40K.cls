@isTest
private class HealthCheckDefinitionModel_TEST {
    /**************************************************************************************************************************
    * @description Test method to verify that the constructor is working as expected.
    ***************************************************************************************************************************/
    @isTest
    private static void getInstanceExisting() {
        Test.startTest();
            HealthCheckDefinitionModel healthCheckDefinitionModel = new HealthCheckDefinitionModel('All Success', 'SRVC_HealthCheckGroupAPI', 'hed');
        Test.stopTest();

        System.assertEquals('All Success', healthCheckDefinitionModel.name);
        System.assertEquals('SRVC_HealthCheckGroupAPI', healthCheckDefinitionModel.className);
        System.assertEquals('hed', healthCheckDefinitionModel.namespace);
    }
}
public virtual with sharing class HealthCheckDefinitionService {

    /*********************************************
    * @description Instance for Singleton Pattern
    **********************************************/
    @TestVisible
    private static HealthCheckDefinitionService instance;

    /*********************************************************************
    * @description Empty constructor is not public for Singleton Pattern
    **********************************************************************/
    protected HealthCheckDefinitionService() {}

    /******************************************************************************
    * @description Static method to get the current instance for Singleton pattern
    * @return The instance of HealthCheckDefinitionService.
    ******************************************************************************/
    public static HealthCheckDefinitionService getInstance() {
        if (instance == null) {
            instance = new HealthCheckDefinitionService();
        }

        return instance;
    }

    /******************************************************************************
    * @description Get a list of Health Check Definition models
    * @return A list of HealthCheckDefinitionModel.
    ******************************************************************************/
    public virtual List<HealthCheckDefinitionModel> getHealthCheckDefinitionModels() {
        return this.locateHealthCheckDefinitionMapper().getHealthCheckDefinitionModels();
    }

    /******************************************************************************
    * @description Retrieves an instance of the HealthCheckDefinitionMapper class.
    * @return An instance of HealthCheckDefinitionMapper.
    ******************************************************************************/
    @TestVisible
    private HealthCheckDefinitionMapper locateHealthCheckDefinitionMapper() {
        return HealthCheckDefinitionMapper.getInstance();
    }
}
@isTest
private class HealthCheckDefinitionService_TEST {
    
    /**************************************************************************************************************************
    * @description Test method to verify that the getInstance method returns a new instance of the 
    * HealthCheckDefinitionService class when one does not already exist.
    ***************************************************************************************************************************/
    @isTest
    private static void getInstanceNew() {
        Test.startTest();
            HealthCheckDefinitionService healthCheckDefinitionServiceInstance = HealthCheckDefinitionService.getInstance();
        Test.stopTest();

        System.assertEquals(HealthCheckDefinitionService.instance, healthCheckDefinitionServiceInstance, 'Instance of service class returned should match static instance variable.');
        System.assertEquals(true, healthCheckDefinitionServiceInstance != null, 'Instance of service class should not be null.');
    }

    /**************************************************************************************************************************
    * @description Test method to verify that the getInstance method returns the existing instance of the 
    * HealthCheckDefinitionService class when one already exists.
    ***************************************************************************************************************************/
    @isTest
    private static void getInstanceExisting() {
        Test.startTest();
            HealthCheckDefinitionService healthCheckDefinitionServiceInstance1 = HealthCheckDefinitionService.getInstance();
            HealthCheckDefinitionService healthCheckDefinitionServiceInstance2 = HealthCheckDefinitionService.getInstance();
        Test.stopTest();

        System.assertEquals(HealthCheckDefinitionService.instance, healthCheckDefinitionServiceInstance1, 'Instance of service class returned should match static instance variable.');
        System.assertEquals(healthCheckDefinitionServiceInstance1, healthCheckDefinitionServiceInstance2, 'Subsequent retrievals of service class instance should return existing instance.');
        System.assertEquals(true, healthCheckDefinitionServiceInstance1 != null, 'Instance of service class should not be null.');
    }

    /**************************************************************************************************************************
    * @description Test method to verify that the getHealthCheckDefinitionModels method in Health Check Service class
    * returns a list of Health Check Definition models
    ***************************************************************************************************************************/
    @isTest
    private static void getHealthCheckDefinitionModelsExistingFromService() {
        HealthCheckDefinitionMapper.instance = new STUB_HealthCheckDefinitionMapper();
        Test.startTest();
            List<HealthCheckDefinitionModel> healthCheckDefinitionModels = HealthCheckDefinitionService.getInstance().getHealthCheckDefinitionModels();
        Test.stopTest();

        System.assertEquals(3, healthCheckDefinitionModels.size());
    }

    /**************************************************************************************************************************
    * @description Test method to verify that the locateHealthCheckDefinitionMapper method 
    * returns an instance of HealthCheckDefinitionMapper
    ***************************************************************************************************************************/
    @isTest
    private static void locateHealthCheckDefinitionMapperTest() {
        Test.startTest();
            HealthCheckDefinitionMapper healthCheckDefinitionMapperInstance = HealthCheckDefinitionMapper.getInstance();
        Test.stopTest();

        System.assertEquals(HealthCheckDefinitionMapper.instance, healthCheckDefinitionMapperInstance);
    }

    /**************************************************************************************************************************
    ****************************************************** STUB CLASS *********************************************************
    **************************************************************************************************************************/

    /*************************************************************************************************************
    * @description Stub class to simulate the response from HealthCheckDefinitionMapper to return a list of HealthCheckDefinitionModel
    */
    private class STUB_HealthCheckDefinitionMapper extends HealthCheckDefinitionMapper {
        public override List<HealthCheckDefinitionModel> getHealthCheckDefinitionModels() {
            List<HealthCheckDefinitionModel> stubHealthCheckDefinitionModelList = new List<HealthCheckDefinitionModel>();
            stubHealthCheckDefinitionModelList.add(new HealthCheckDefinitionModel('All Success',
                                                                        'EDAHealthCheckGroupAPIService',
                                                                        'hed'));
            stubHealthCheckDefinitionModelList.add(new HealthCheckDefinitionModel('All Failure',
                                                                        'EDAHealthCheckGroupAPIService',
                                                                        'hed'));
            stubHealthCheckDefinitionModelList.add(new HealthCheckDefinitionModel('Mixed',
                                                                        'EDAHealthCheckGroupAPIService',
                                                                        'hed'));
            return stubHealthCheckDefinitionModelList;         
        }
    }
}
public with sharing class HealthCheckDefinitionVModel implements Comparable {

    @AuraEnabled public String name;
    @AuraEnabled public String className;
    @AuraEnabled public String namespace;

    public HealthCheckDefinitionVModel(String name, String className, String namespace) {
        this.name = name;
        this.className = className;
        this.namespace = namespace;
    }

    /****************************************************************************************************************************
    * @description Implementation of compareTo() to sort HealthCheckDefinitionVModels by name.
    * @param  objectToCompareTo A HealthCheckDefinitionVModel to be used for comparison
    * @return 0 if names are equal, 1 if the current name is greater, -1 otherwise
    ****************************************************************************************************************************/ 
    public Integer compareTo(Object objectToCompareTo){
        HealthCheckDefinitionVModel healthCheckDefinitionVModelToCompareTo = (HealthCheckDefinitionVModel)objectToCompareTo;
        return this.name.toLowerCase().compareTo(healthCheckDefinitionVModelToCompareTo.name.toLowerCase());
    } 
}
@isTest 
public with sharing class HealthCheckDefinitionVModel_TEST {

    /****************************************************************************************************************************
    * @description Test to verify constructor with 3 parameters initializes object with properties set as expected.
    ****************************************************************************************************************************/
    @isTest 
    private static void threeParamConstructorValid(){
        Test.startTest();
        HealthCheckDefinitionVModel hlthChkDefVModl = new HealthCheckDefinitionVModel('TestName', 'TestClass', 'TEST');
        Test.stopTest();

        System.assertEquals('TestName', hlthChkDefVModl.name, 'Name property should be \'TestName\'.');
        System.assertEquals('TestClass', hlthChkDefVModl.className, 'Classname property should be \'TestClass\'.');
        System.assertEquals('TEST', hlthChkDefVModl.namespace, 'Namespace property should be \'TEST\'.');
    }

    /****************************************************************************************************************************
    * @description Test to verify compareTo() properly sorts Health Check View models by name
    * in ascending order when no duplicates are not present.
    ****************************************************************************************************************************/
    @isTest 
    private static void sortNamesWithoutDuplicates(){
        List<HealthCheckDefinitionVModel> healthCheckDefinitionVModelsList = new List<HealthCheckDefinitionVModel>();
        HealthCheckDefinitionVModel healthCheckDefinitionVModel1 = new HealthCheckDefinitionVModel('test1', 'TestClass', 'TEST');
        HealthCheckDefinitionVModel healthCheckDefinitionVModel2 = new HealthCheckDefinitionVModel('pineapple', 'TestClass', 'TEST');
        HealthCheckDefinitionVModel healthCheckDefinitionVModel3 = new HealthCheckDefinitionVModel('Banana', 'TestClass', 'TEST');
        HealthCheckDefinitionVModel healthCheckDefinitionVModel4 = new HealthCheckDefinitionVModel('Test4', 'TestClass', 'TEST');
        HealthCheckDefinitionVModel healthCheckDefinitionVModel5 = new HealthCheckDefinitionVModel('Papaya', 'TestClass', 'TEST');
        HealthCheckDefinitionVModel healthCheckDefinitionVModel6 = new HealthCheckDefinitionVModel('Apple', 'TestClass', 'TEST');
        
        healthCheckDefinitionVModelsList.add(healthCheckDefinitionVModel1);
        healthCheckDefinitionVModelsList.add(healthCheckDefinitionVModel2);
        healthCheckDefinitionVModelsList.add(healthCheckDefinitionVModel3);
        healthCheckDefinitionVModelsList.add(healthCheckDefinitionVModel4);
        healthCheckDefinitionVModelsList.add(healthCheckDefinitionVModel5);
        healthCheckDefinitionVModelsList.add(healthCheckDefinitionVModel6);
    
        Test.startTest();
        healthCheckDefinitionVModelsList.sort();
        Test.stopTest();

        System.assertEquals('Apple', healthCheckDefinitionVModelsList[0].name, 'First name in sorted list should be \'Apple\'');
        System.assertEquals('Banana', healthCheckDefinitionVModelsList[1].name, 'Second name in sorted list should be \'Banana\'');
        System.assertEquals('Papaya', healthCheckDefinitionVModelsList[2].name, 'Third name in sorted list should be \'Papaya\'');
        System.assertEquals('pineapple', healthCheckDefinitionVModelsList[3].name, 'Fourth name in sorted list should be \'pineapple\'');
        System.assertEquals('test1', healthCheckDefinitionVModelsList[4].name, 'Fifth name in sorted list should be \'test1\'');
        System.assertEquals('Test4', healthCheckDefinitionVModelsList[5].name, 'Sixth name in sorted list should be \'Test4\'');
    }

    /****************************************************************************************************************************
    * @description Test to verify compareTo() properly sorts Health Check View models by name
    * in ascending order when no duplicates are present.
    ****************************************************************************************************************************/
    @isTest 
    private static void sortNamesWithDuplicates(){
        List<HealthCheckDefinitionVModel> healthCheckDefinitionVModelsList = new List<HealthCheckDefinitionVModel>();
        HealthCheckDefinitionVModel healthCheckDefinitionVModel1 = new HealthCheckDefinitionVModel('Pineapple', 'TestClass', 'TEST');
        HealthCheckDefinitionVModel healthCheckDefinitionVModel2 = new HealthCheckDefinitionVModel('Pineapple', 'TestClass', 'TEST');
        HealthCheckDefinitionVModel healthCheckDefinitionVModel3 = new HealthCheckDefinitionVModel('Pineapple', 'TestClass', 'TEST');
        HealthCheckDefinitionVModel healthCheckDefinitionVModel4 = new HealthCheckDefinitionVModel('test4', 'TestClass', 'TEST');
        HealthCheckDefinitionVModel healthCheckDefinitionVModel5 = new HealthCheckDefinitionVModel('123Papaya', 'TestClass', 'TEST');
        HealthCheckDefinitionVModel healthCheckDefinitionVModel6 = new HealthCheckDefinitionVModel('Apple Pie', 'TestClass', 'TEST');
        
        healthCheckDefinitionVModelsList.add(healthCheckDefinitionVModel1);
        healthCheckDefinitionVModelsList.add(healthCheckDefinitionVModel2);
        healthCheckDefinitionVModelsList.add(healthCheckDefinitionVModel3);
        healthCheckDefinitionVModelsList.add(healthCheckDefinitionVModel4);
        healthCheckDefinitionVModelsList.add(healthCheckDefinitionVModel5);
        healthCheckDefinitionVModelsList.add(healthCheckDefinitionVModel6);
    
        Test.startTest();
        healthCheckDefinitionVModelsList.sort();
        Test.stopTest();

        System.assertEquals('123Papaya', healthCheckDefinitionVModelsList[0].name, 'First name in sorted list should be \'123Papaya\'');
        System.assertEquals('Apple Pie', healthCheckDefinitionVModelsList[1].name, 'Second name in sorted list should be \'Apple Pie\'');
        System.assertEquals('Pineapple', healthCheckDefinitionVModelsList[2].name, 'Third name in sorted list should be \'Pineapple\'');
        System.assertEquals('Pineapple', healthCheckDefinitionVModelsList[3].name, 'Fourth name in sorted list should be \'Pineapple\'');
        System.assertEquals('Pineapple', healthCheckDefinitionVModelsList[4].name, 'Fifth name in sorted list should be \'Pineapple\'');
        System.assertEquals('test4', healthCheckDefinitionVModelsList[5].name, 'Sixth name in sorted list should be \'test4\'');
    }
}
public virtual interface HealthCheckGroupAPIServiceInterface {
    HealthCheckGroupAPIServiceInterface getInstance();
    HealthCheckGroupVModel getHealthCheckGroup(String name);
}
public with sharing class HealthCheckGroupController {

    /**********************************************************************************
    * @description Locates and returns an instance of HealthCheckVMapper. 
    **********************************************************************************/
    @TestVisible
    private static HealthCheckGroupService locateHealthCheckGroupService() {
        return HealthCheckGroupService.getInstance();
    }

    /**********************************************************************************
    * getHealthCheckGroupViewModel description
    * @param  name      name description
    * @param  className className description
    * @param  namespace namespace description
    * @return           return description
    **********************************************************************************/
    @AuraEnabled(cacheable=true)
    public static HealthCheckGroupVModel getHealthCheckGroupViewModel(String name, String className, String namespace){
        try {
            return HealthCheckGroupController.locateHealthCheckGroupService().getHealthCheckGroup(name, className, namespace);
        } catch (Exception e) {
            throw new AuraHandledException(e.getMessage());
        }
    }
}
@isTest 
public with sharing class HealthCheckGroupController_TEST {
    /****************************************************************************************************************************
    * @description Test method to verify that the locateHealthCheckGroupService method returns instance of HealthCheckGroupService.
    ****************************************************************************************************************************/
    @isTest
    private static void locateHealthCheckGroupServiceValid() {
        Test.startTest();
            HealthCheckGroupService healthCheckGroupServiceInstance = HealthCheckGroupController.locateHealthCheckGroupService();
        Test.stopTest();

        System.assertEquals(HealthCheckGroupService.getInstance(), healthCheckGroupServiceInstance, 'Should return the instance of HealthCheckGroupService.');
    } 

    /****************************************************************************************************************************
    * @description Test method to verify that the getHealthCheckGroupViewModel method returns a valid HealthCheckGroupVModel.
    ****************************************************************************************************************************/
    @isTest 
    private static void getHealthCheckGroupViewModelValid(){
        HealthCheckGroupService.instance = new STUB_HealthCheckGroupServiceMixedBag();

        Test.startTest();
        HealthCheckGroupVModel healthCheckGroupVModel = HealthCheckGroupController.getHealthCheckGroupViewModel('Mixed Bag', 'TestClassName', 'abc');
        Test.stopTest();

        System.assertEquals('Mixed Bag', healthCheckGroupVModel.label, 'Label should \'Mixed Bag\'.');
        System.assertEquals('Fail', healthCheckGroupVModel.status, 'Status should be \'Fail\'.');
        System.assertEquals(5, healthCheckGroupVModel.passedChecks, 'Should be 5 health check definitions.');
        System.assertEquals(10, healthCheckGroupVModel.totalChecks, 'Should be 5 health check definitions.');
        System.assertEquals(true, healthCheckGroupVModel.expandedRowsList.isEmpty(), 'expandedRowsList should be empty.');
        System.assertEquals(true, healthCheckGroupVModel.healthCheckItemList.isEmpty(), 'healthCheckItemList should be empty.');
    }

    /****************************************************************************************************************************
    * @description Test method to verify that the getHealthCheckGroupViewModel method throws an exception when expected.
    ****************************************************************************************************************************/
    @isTest 
    private static void getHealthCheckGroupViewModelException(){
        HealthCheckGroupService.instance = new STUB_ExceptionHealthCheckGroupService();

        try{
            Test.startTest();
            HealthCheckGroupVModel healthCheckGroupVModel = HealthCheckGroupController.getHealthCheckGroupViewModel('Exception Bag', 'TestClassName', 'abc');
            Test.stopTest();
        } catch (System.AuraHandledException ex){
            System.assertEquals('System.AuraHandledException', ex.getTypeName(), 'AuraHandledException should be thrown when exception occurs.');
            System.assertEquals('Script-thrown exception', ex.getMessage(), 'AuraHandledException text should be associated with message when exception occurs.');
        }
    }

    /**************************************************************************************************************************
    ****************************************************** STUBS **************************************************************
    **************************************************************************************************************************/
    
    /**************************************************************************************************************************************
    * @description Stub class to simulate the response from HealthCheckGroupService to return a HealthCheckGroupVModel
    **************************************************************************************************************************************/ 
    private class STUB_HealthCheckGroupServiceMixedBag extends HealthCheckGroupService {
        @TestVisible 
        public override HealthCheckGroupVModel getHealthCheckGroup(String name, String className, String namespace){   
            return new HealthCheckGroupVModel('Mixed Bag', 'Fail', 5, 10, new List<String>(), new List<HealthCheckItemVModel>());
        }
    }

    /**************************************************************************************************************************************
    * @description Stub class to simulate the response from HealthCheckGroupService to throw an exception
    **************************************************************************************************************************************/ 
    private class STUB_ExceptionHealthCheckGroupService extends HealthCheckGroupService {
        @TestVisible 
        public override HealthCheckGroupVModel getHealthCheckGroup(String name, String className, String namespace){   
            throw new TestException('Test exception thrown!');
        }
    }

    /**************************************************************************************
    * @description Custom exception class for testing.
    **************************************************************************************/
    public class TestException extends Exception {}
}
public virtual with sharing class HealthCheckGroupService {
    /*********************************************
    * @description Instance for Singleton Pattern
    **********************************************/
    @TestVisible
    private static HealthCheckGroupService instance;

    /*********************************************************************
    * @description Empty constructor is not public for Singleton Pattern
    **********************************************************************/
    protected HealthCheckGroupService() {}

    /******************************************************************************
    * @description Static method to get the current instance for Singleton pattern
    * @return The instance of HealthCheckGroupService.
    ******************************************************************************/
    public static HealthCheckGroupService getInstance() {
        if (instance == null) {
            instance = new HealthCheckGroupService();
        }

        return instance;
    }

    /********************************************************************************************
    * @description Retrieves the HealthCheckGroup view model for a specified 
    * HealthCheckDefinitionModel.
    * @param  name The name corresponding to a specified HealthCheckDefinitionModel
    * @param  className The className corresponding to a specified HealthCheckDefinitionModel
    * @param  namespace The namespace corresponding to a specified HealthCheckDefinitionModel
    * @return A HealthCheckGroupVModel representing the specified HealthCheckDefinitionModel.
    ********************************************************************************************/
    public virtual HealthCheckGroupVModel getHealthCheckGroup(String name, String className, String namespace){
        HealthCheckGroupAPIServiceInterface healthCheckGroupServiceInterface = 
            this.locateHealthCheckGroupAPIService(className, namespace);

        return healthCheckGroupServiceInterface.getHealthCheckGroup(name);
    }

    /********************************************************************************************
    * @description Dynamically instantiates a HealthCheckGroupAPIServiceInterface based on a 
    * specified classname and namespace.
    * @param  className The classname of a HealthCheckDefinitionModel
    * @param  namespace The namespace of a HealthCheckDefinitionModel
    * @return A HealthCheckGroupAPIServiceInterface corresponding to the specified classname and namespace.
    ********************************************************************************************/
    @TestVisible
    private virtual HealthCheckGroupAPIServiceInterface locateHealthCheckGroupAPIService(String className, String namespace){
        HealthCheckGroupAPIServiceInterface healthCheckGroupServiceInterface;
        String nonEDANamespace = namespace;
        
        if (namespace.equalsIgnoreCase('hed')){
            nonEDANamespace = '';
        }

        try{
            Type healthCheckGroupType = Type.forName(nonEDANamespace, className);
            healthCheckGroupServiceInterface = (HealthCheckGroupAPIServiceInterface)healthCheckGroupType.newInstance();
        } catch (System.NullPointerException e){
            throw new HealthCheckNotFoundException(e.getMessage());
        } catch (System.TypeException e){
            throw new HealthCheckNotFoundException(e.getMessage());
        }

        return healthCheckGroupServiceInterface.getInstance();
    }

    /********************************************************************************************
    * @description A custom exception class to represent Health Check Not Found errors.
    ********************************************************************************************/
    public class HealthCheckNotFoundException extends Exception{}
}
@isTest 
public with sharing class HealthCheckGroupService_TEST {

    /**************************************************************************************************************************
    * @description Test method to verify that the getInstance method returns a new instance of the 
    * HealthCheckGroupService class when one does not already exist.
    ***************************************************************************************************************************/
    @isTest
    private static void getInstanceNew() {
        Test.startTest();
            HealthCheckGroupService HealthCheckGroupServiceInstance = HealthCheckGroupService.getInstance();
        Test.stopTest();

        System.assertEquals(HealthCheckGroupService.instance, HealthCheckGroupServiceInstance, 'Instance of service class returned should match static instance variable.');
        System.assertEquals(true, HealthCheckGroupServiceInstance != null, 'Instance of service class should not be null.');
    }

    /**************************************************************************************************************************
    * @description Test method to verify that the getInstance method returns the existing instance of the 
    * HealthCheckGroupService class when one already exists.
    ***************************************************************************************************************************/
    @isTest
    private static void getInstanceExisting() {
        Test.startTest();
            HealthCheckGroupService HealthCheckGroupServiceInstance1 = HealthCheckGroupService.getInstance();
            HealthCheckGroupService HealthCheckGroupServiceInstance2 = HealthCheckGroupService.getInstance();
        Test.stopTest();

        System.assertEquals(HealthCheckGroupService.instance, HealthCheckGroupServiceInstance1, 'Instance of service class returned should match static instance variable.');
        System.assertEquals(HealthCheckGroupServiceInstance1, HealthCheckGroupServiceInstance2, 'Subsequent retrievals of service class instance should return existing instance.');
        System.assertEquals(true, HealthCheckGroupServiceInstance1 != null, 'Instance of service class should not be null.');
    }

    /**************************************************************************************************************************
    * @description Test method to verify that the getHealthCheckGroup method returns a HealthCheckGroup view model when provided
    * with valid HealthCheckDefinitionModel data.
    ***************************************************************************************************************************/
    @isTest 
    private static void getHealthCheckGroupValidReciprocal(){
        ReciprocalRelHealthCheckVMapper.instance = new STUB_ReciprocalRelHealthCheckVMapper();
        HealthCheckGroupService.instance = new STUB_HealthCheckGroupServiceEDAHealthCheckAPI();
        HealthCheckGroupService healthCheckGroupService =
            HealthCheckGroupService.getInstance();

        Test.startTest();
            HealthCheckGroupVModel healthCheckGroupVModel =
                healthCheckGroupService.getHealthCheckGroup(
                    'reciprocalrelationship',
                    'EDAHealthCheckGroupAPIService',
                    'hed'
                );
        Test.stopTest();

        System.assertEquals('Mocked', healthCheckGroupVModel.label, 'Label for returned HC Group view model should match valud in EDAHealthCheckGroupAPIService.');
        System.assertEquals('Pass', healthCheckGroupVModel.status, 'Status for returned HC Group view model should match valud in EDAHealthCheckGroupAPIService.');
        System.assertEquals(2, healthCheckGroupVModel.passedChecks, 'Passed Checks for returned HC Group view model should match valud in EDAHealthCheckGroupAPIService.');
        System.assertEquals(2, healthCheckGroupVModel.totalChecks, 'Total Checks for returned HC Group view model should match valud in EDAHealthCheckGroupAPIService.');
        System.assertEquals(true, healthCheckGroupVModel.expandedRowsList.isEmpty(), 'Expanded rows list for returned HC Group view model should match valud in EDAHealthCheckGroupAPIService.');
        System.assertEquals(2, healthCheckGroupVModel.healthCheckItemList.size(), 'Health Check items list for returned HC Group view model should match valud in EDAHealthCheckGroupAPIService.');
    }

    /**************************************************************************************************************************
    * @description Test method to verify that the getHealthCheckGroup method returns a HealthCheckGroup view model when provided
    * with valid HealthCheckDefinitionModel data.
    ***************************************************************************************************************************/
    @isTest 
    private static void getHealthCheckGroupValidCourseConn(){

        CourseConSettingHealthCheckVMapper.instance = new STUB_CourseConSettingHealthCheckVMapper();
        HealthCheckGroupService.instance = new STUB_HealthCheckGroupServiceEDAHealthCheckAPI();

        Test.startTest();
            HealthCheckGroupVModel hlthChkGroupVMod = 
                HealthCheckGroupService.getInstance(
                ).getHealthCheckGroup(
                    'courseconnectionsettings', 
                    'EDAHealthCheckGroupAPIService',
                    'hed'
                );
        Test.stopTest();
            System.assertEquals('Mocked', hlthChkGroupVMod.label, 'Label for returned HC Group view model should match valud in EDAHealthCheckGroupAPIService.');
            System.assertEquals('Pass', hlthChkGroupVMod.status, 'Status for returned HC Group view model should match valud in EDAHealthCheckGroupAPIService.');
            System.assertEquals(2, hlthChkGroupVMod.passedChecks, 'Passed Checks for returned HC Group view model should match valud in EDAHealthCheckGroupAPIService.');
            System.assertEquals(2, hlthChkGroupVMod.totalChecks, 'Total Checks for returned HC Group view model should match valud in EDAHealthCheckGroupAPIService.');
            System.assertEquals(true, hlthChkGroupVMod.expandedRowsList.isEmpty(), 'Expanded rows list for returned HC Group view model should match valud in EDAHealthCheckGroupAPIService.');
            System.assertEquals(2, hlthChkGroupVMod.healthCheckItemList.size(), 'Health Check items list for returned HC Group view model should match valud in EDAHealthCheckGroupAPIService.');
    }

    /**************************************************************************************************************************
    * @description Test method to verify that the getHealthCheckGroup method returns a HealthCheckGroup view model when provided
    * with valid HealthCheckDefinitionModel data.
    ***************************************************************************************************************************/
    @isTest 
    private static void getHealthCheckGroupValidAccountModel(){

        AccountModelHealthCheckVMapper.instance = new STUB_AccountModelHealthCheckVMapper();
        HealthCheckGroupService.instance = new STUB_HealthCheckGroupServiceEDAHealthCheckAPI();

        Test.startTest();
            HealthCheckGroupVModel hlthChkGroupVMod = 
                HealthCheckGroupService.getInstance(
                ).getHealthCheckGroup(
                    'accountmodel', 
                    'EDAHealthCheckGroupAPIService',
                    'hed'
                );
        Test.stopTest();
            System.assertEquals('Mocked', hlthChkGroupVMod.label, 'Label for returned HC Group view model should match valud in EDAHealthCheckGroupAPIService.');
            System.assertEquals('Pass', hlthChkGroupVMod.status, 'Status for returned HC Group view model should match valud in EDAHealthCheckGroupAPIService.');
            System.assertEquals(2, hlthChkGroupVMod.passedChecks, 'Passed Checks for returned HC Group view model should match valud in EDAHealthCheckGroupAPIService.');
            System.assertEquals(2, hlthChkGroupVMod.totalChecks, 'Total Checks for returned HC Group view model should match valud in EDAHealthCheckGroupAPIService.');
            System.assertEquals(true, hlthChkGroupVMod.expandedRowsList.isEmpty(), 'Expanded rows list for returned HC Group view model should match valud in EDAHealthCheckGroupAPIService.');
            System.assertEquals(2, hlthChkGroupVMod.healthCheckItemList.size(), 'Health Check items list for returned HC Group view model should match valud in EDAHealthCheckGroupAPIService.');
    }

    /**************************************************************************************************************************
    * @description Test method to verify that the getHealthCheckGroup method returns a HealthCheckGroup view model when provided
    * with valid HealthCheckDefinitionModel data.
    ***************************************************************************************************************************/
    @isTest 
    private static void getHealthCheckGroupValidAffiliationMappings(){

        AffiliationMappingsHealthCheckVMapper.instance = new STUB_AffiliationMappingsHealthCheckVMapper();
        HealthCheckGroupService.instance = new STUB_HealthCheckGroupServiceEDAHealthCheckAPI();

        Test.startTest();
            HealthCheckGroupVModel hlthChkGroupVMod = 
                HealthCheckGroupService.getInstance(
                ).getHealthCheckGroup(
                    'affiliationmappings', 
                    'EDAHealthCheckGroupAPIService',
                    'hed'
                );
        Test.stopTest();
            System.assertEquals('Mocked', hlthChkGroupVMod.label, 'Label for returned HC Group view model should match valud in EDAHealthCheckGroupAPIService.');
            System.assertEquals('Pass', hlthChkGroupVMod.status, 'Status for returned HC Group view model should match valud in EDAHealthCheckGroupAPIService.');
            System.assertEquals(2, hlthChkGroupVMod.passedChecks, 'Passed Checks for returned HC Group view model should match valud in EDAHealthCheckGroupAPIService.');
            System.assertEquals(2, hlthChkGroupVMod.totalChecks, 'Total Checks for returned HC Group view model should match valud in EDAHealthCheckGroupAPIService.');
            System.assertEquals(true, hlthChkGroupVMod.expandedRowsList.isEmpty(), 'Expanded rows list for returned HC Group view model should match valud in EDAHealthCheckGroupAPIService.');
            System.assertEquals(2, hlthChkGroupVMod.healthCheckItemList.size(), 'Health Check items list for returned HC Group view model should match valud in EDAHealthCheckGroupAPIService.');
    }

    /**************************************************************************************************************************
    * @description Test method to verify that the getHealthCheckGroup method returns a null HealthCheckGroup view model when 
    * provided with invalid HealthCheckDefinitionModel data.
    ***************************************************************************************************************************/
    @isTest 
    private static void getHealthCheckGroupInValid(){
        Test.startTest();
        HealthCheckGroupVModel healthCheckGroupVModel =
            HealthCheckGroupService.getInstance(
            ).getHealthCheckGroup(
                'Non-existent Health Check Group',
                'EDAHealthCheckGroupAPIService',
                'hed'
            );
        Test.stopTest();

        System.assertEquals(true, healthCheckGroupVModel == null, 'Health Check Group view model should be null.');
    }

    /**************************************************************************************************************************
    * @description Test method to verify that the locateHealthCheckGroupAPIService method returns a valid instance of 
    * HealthCheckGroupAPIServiceInterface when a valid classname and namespace corresponding to a Serivce that implements the 
    * interface is provided.
    ***************************************************************************************************************************/
    @isTest 
    private static void locateHealthCheckGroupAPIServiceValid(){
        Test.startTest();
        HealthCheckGroupAPIServiceInterface healthCheckGroupAPIServiceInterface = 
            HealthCheckGroupService.getInstance().locateHealthCheckGroupAPIService('EDAHealthCheckGroupAPIService', 'hed');
        Test.stopTest();

        System.assertEquals(EDAHealthCheckGroupAPIService.getInstance(), healthCheckGroupAPIServiceInterface.getInstance(), 
                'HealthCheckGroupAPIServiceInterface should be instance of EDAHealthCheckGroupAPIService.');
    }

    /**************************************************************************************************************************
    * @description Test method to verify that the locateHealthCheckGroupAPIService method throws a NullPointerException  
    * when an invalid classname an an invalid namespace is provided.
    ***************************************************************************************************************************/
    @isTest 
    private static void locateHealthCheckGroupAPIServiceInValidClassName(){
        try{
            Test.startTest();
            HealthCheckGroupAPIServiceInterface healthCheckGroupAPIServiceInterface = 
            HealthCheckGroupService.getInstance().locateHealthCheckGroupAPIService('Not a Valid Service Name', 'abc');
            Test.stopTest();
        } catch (System.NullPointerException e){
            System.assertEquals(true, String.isNotBlank(e.getMessage()), 'Invalid className should throw NullPointerException.');
        } catch (HealthCheckGroupService.HealthCheckNotFoundException hcNotFoundEx){
            System.assertEquals(true, String.isNotBlank(hcNotFoundEx.getMessage()), 'NullPointerException should throw HealthCheckNotFoundException.');
        }
    }

    /**************************************************************************************************************************
    * @description Test method to verify that the locateHealthCheckGroupAPIService method throws a TypeException  
    * when a valid classname to a class that does not extend the HealthCheckGroupAPIServiceInterface and blank namespace is provided.
    ***************************************************************************************************************************/
    @isTest 
    private static void locateHealthCheckGroupAPIServiceValidClassNameNotImplementingInterface(){
        try{
            Test.startTest();
            HealthCheckGroupAPIServiceInterface healthCheckGroupAPIServiceInterface = 
            HealthCheckGroupService.getInstance().locateHealthCheckGroupAPIService('HealthCheckVMapper', '');
            Test.stopTest();
        } catch (System.TypeException e){
            System.assertEquals(true, String.isNotBlank(e.getMessage()), 'Invalid className should throw TypeException.');
        } catch (HealthCheckGroupService.HealthCheckNotFoundException hcNotFoundEx){
            System.assertEquals(true, String.isNotBlank(hcNotFoundEx.getMessage()), 'TypeException should throw HealthCheckNotFoundException.');
        }
    }

    /**************************************************************************************************************************
    ****************************************************** STUBS **************************************************************
    **************************************************************************************************************************/
    
    /**************************************************************************************************************************************
    * @description Stub class to simulate the response from HealthCheckGroupService to return instance of EDAHealthCheckGroupAPIService.
    **************************************************************************************************************************************/ 
    private class STUB_HealthCheckGroupServiceEDAHealthCheckAPI extends HealthCheckGroupService {
        @TestVisible 
        private override HealthCheckGroupAPIServiceInterface locateHealthCheckGroupAPIService(
            String className,
            String namespace
        ){ 
            return EDAHealthCheckGroupAPIService.getInstance(); 
        }
    }

    /***************************************************************************
    * @description Stub class to simulate the response from
    * EDAHealthCheckGroupAPIService to control for a static response
    ***************************************************************************/
    private class STUB_ReciprocalRelHealthCheckVMapper extends ReciprocalRelHealthCheckVMapper {

        public override HealthCheckGroupVModel getHealthCheckGroup(){
            List<HealthCheckItemVModel> healthCheckItemsList = new List<HealthCheckItemVModel>();
            List<String> rowKeysList = new List<String>();
    
            HealthCheckItemVModel healthCheckItemModel1 = 
                new HealthCheckItemVModel(
                    '01', 
                    'Passed Setting 1', 
                    'Pass', 
                    Label.stgHealthCheckStatusPassed, 
                    'Mocked description 1', 
                    'Mocked recommended fix 1',
                    new List<HealthCheckItemVModel>()
                );
                                                                                
            HealthCheckItemVModel healthCheckItemModel2 = 
                new HealthCheckItemVModel(
                    '02',
                    'Passed Setting 2',
                    'Pass',
                    Label.stgHealthCheckStatusPassed,
                    'Mocked description 2',
                    'Mocked recommended fix 2',
                    new List<HealthCheckItemVModel>()
                );
            
            healthCheckItemsList.add(healthCheckItemModel1);
            healthCheckItemsList.add(healthCheckItemModel2);

            return new HealthCheckGroupVModel(
                'Mocked',
                'Pass',
                2,
                2,
                rowKeysList,
                healthCheckItemsList
            );
        }
    }

    /***************************************************************************
    * @description Stub class to simulate the response from
    * EDAHealthCheckGroupAPIService to control for a static response
    ***************************************************************************/
    private class STUB_CourseConSettingHealthCheckVMapper extends CourseConSettingHealthCheckVMapper {

        public override HealthCheckGroupVModel getHealthCheckGroup(){
            List<HealthCheckItemVModel> hlthChkItemsList = new List<HealthCheckItemVModel>();
            List<String> rowKeysList = new List<String>();

            HealthCheckItemVModel hlthChkItemMod1 = 
                new HealthCheckItemVModel(
                    '01', 
                    'Passed Setting 1', 
                    'Pass', 
                    Label.stgHealthCheckStatusPassed, 
                    'Mocked description 1', 
                    'Mocked recommended fix 1',
                    new List<HealthCheckItemVModel>()
                );

            HealthCheckItemVModel hlthChkItemMod2 = 
                new HealthCheckItemVModel(
                    '02',
                    'Passed Setting 2',
                    'Pass',
                    Label.stgHealthCheckStatusPassed,
                    'Mocked description 2',
                    'Mocked recommended fix 2',
                    new List<HealthCheckItemVModel>()
                );

            hlthChkItemsList.add(hlthChkItemMod1);
            hlthChkItemsList.add(hlthChkItemMod2);

            return new HealthCheckGroupVModel(
                'Mocked',
                'Pass',
                2,
                2,
                rowKeysList,
                hlthChkItemsList
            );
        }
    }
    
    /***************************************************************************
    * @description Stub class to simulate the response from
    * EDAHealthCheckGroupAPIService to control for a static response
    ***************************************************************************/
    private class STUB_AccountModelHealthCheckVMapper extends AccountModelHealthCheckVMapper {

        public override HealthCheckGroupVModel getHealthCheckGroup(){
            List<HealthCheckItemVModel> hlthChkItemsList = new List<HealthCheckItemVModel>();
            List<String> rowKeysList = new List<String>();

            HealthCheckItemVModel hlthChkItemMod1 = 
                new HealthCheckItemVModel(
                    '01', 
                    'Passed Setting 1', 
                    'Pass', 
                    Label.stgHealthCheckStatusPassed, 
                    'Mocked description 1', 
                    'Mocked recommended fix 1',
                    new List<HealthCheckItemVModel>()
                );

            HealthCheckItemVModel hlthChkItemMod2 = 
                new HealthCheckItemVModel(
                    '02',
                    'Passed Setting 2',
                    'Pass',
                    Label.stgHealthCheckStatusPassed,
                    'Mocked description 2',
                    'Mocked recommended fix 2',
                    new List<HealthCheckItemVModel>()
                );

            hlthChkItemsList.add(hlthChkItemMod1);
            hlthChkItemsList.add(hlthChkItemMod2);

            return new HealthCheckGroupVModel(
                'Mocked',
                'Pass',
                2,
                2,
                rowKeysList,
                hlthChkItemsList
            );
        }
    }

    /***************************************************************************
    * @description Stub class to simulate the response from
    * EDAHealthCheckGroupAPIService to control for a static response
    ***************************************************************************/
    private class STUB_AffiliationMappingsHealthCheckVMapper extends AffiliationMappingsHealthCheckVMapper {

        public override HealthCheckGroupVModel getHealthCheckGroup(){
            List<HealthCheckItemVModel> hlthChkItemsList = new List<HealthCheckItemVModel>();
            List<String> rowKeysList = new List<String>();

            HealthCheckItemVModel hlthChkItemMod1 = 
                new HealthCheckItemVModel(
                    '01', 
                    'Passed Setting 1', 
                    'Pass', 
                    Label.stgHealthCheckStatusPassed, 
                    'Mocked description 1', 
                    'Mocked recommended fix 1',
                    new List<HealthCheckItemVModel>()
                );

            HealthCheckItemVModel hlthChkItemMod2 = 
                new HealthCheckItemVModel(
                    '02',
                    'Passed Setting 2',
                    'Pass',
                    Label.stgHealthCheckStatusPassed,
                    'Mocked description 2',
                    'Mocked recommended fix 2',
                    new List<HealthCheckItemVModel>()
                );

            hlthChkItemsList.add(hlthChkItemMod1);
            hlthChkItemsList.add(hlthChkItemMod2);

            return new HealthCheckGroupVModel(
                'Mocked',
                'Pass',
                2,
                2,
                rowKeysList,
                hlthChkItemsList
            );
        }
    }
}
public virtual with sharing class HealthCheckGroupVModel implements Comparable {
    
    @AuraEnabled public String label;
    @AuraEnabled public String status;
    @AuraEnabled public Integer passedChecks;
    @AuraEnabled public Integer totalChecks;
    @AuraEnabled public List<String> expandedRowsList { get; private set; }
    @AuraEnabled public List<HealthCheckItemVModel> healthCheckItemList { get; private set; }

    public HealthCheckGroupVModel() {
        this.label = '';
        this.passedChecks = 0;
        this.totalChecks = 0;
        this.expandedRowsList = new List<String>();
        this.healthCheckItemList = new List<HealthCheckItemVModel>();

        this.updateHealthCheckStatus();
    }
    
    public HealthCheckGroupVModel(String label, 
                                 String status, 
                                 Integer passedChecks, 
                                 Integer totalChecks, 
                                 List<String> expandedRowsList, 
                                 List<HealthCheckItemVModel> healthCheckItemList) {
        this.label = label;
        this.status = status;
        this.passedChecks = passedChecks;
        this.totalChecks = totalChecks;
        this.expandedRowsList = expandedRowsList;
        this.healthCheckItemList = healthCheckItemList;
    }

    /*********************************************************************************************************************
    * @description Update the status of a HealthCheckGroupVModel based on the number of passing health checks to total checks. 
    *********************************************************************************************************************/
    public void updateHealthCheckStatus() {      
        this.status = (this.passedChecks == this.totalChecks) ? 
            System.Label.stgHealthCheckStatusPassed : System.Label.stgHealthCheckStatusFailed;
    }
    
    /*****************************************************************************************
    * @description Implementation of CompareTo() that sorts by status (Fail above Pass), then in
    * ascending alphabetical order on label.
    * @param compareTo A HealthCheckGroupVModel object to compare to another
    * @return 0 if the current object is greater than the object to compare, -1 if it is less, 0 if
    * they are equal, or if the objec to compare is an incompatible type.
    *****************************************************************************************/ 
    public virtual Integer compareTo(Object compareTo){

        if (!(compareTo instanceof HealthCheckGroupVModel)){
            return 0;
        }

        HealthCheckGroupVModel healthCheckGroupVModelToCompareTo = (HealthCheckGroupVModel)compareTo;
        Integer statusResult = this.status.toLowerCase().compareTo(healthCheckGroupVModelToCompareTo.status.toLowerCase());
        
        if (statusResult != 0){
            return statusResult;
        }
        
        return this.label.toLowerCase().compareTo(healthCheckGroupVModelToCompareTo.label.toLowerCase());
    }
}
@isTest 
public with sharing class HealthCheckGroupVModel_TEST {
    /*****************************************************************************************
    * @description Test to verify empty constructor generates model as expected.
    *****************************************************************************************/
    @isTest 
    private static void constructorWithNoParametersValid(){
        Test.startTest();
        HealthCheckGroupVModel healthCheckGroupVModel = new HealthCheckGroupVModel();
        Test.stopTest();

        System.assertEquals('', healthCheckGroupVModel.label, 'HealthCheckGroupVModel label should be blank.');
        System.assertEquals(Label.stgHealthCheckStatusPassed, healthCheckGroupVModel.status, 'HealthCheckGroupVModel status should be set to \'' + Label.stgHealthCheckStatusPassed + ' \'.');
        System.assertEquals(0, healthCheckGroupVModel.passedChecks, 'HealthCheckGroupVModel passedChecks should be 0.');
        System.assertEquals(0, healthCheckGroupVModel.totalChecks, 'HealthCheckGroupVModel totalChecks should be 0.');
        System.assertEquals(true, healthCheckGroupVModel.expandedRowsList.isEmpty(), 'HealthCheckGroupVModel expandedRowsList should be empty.');
        System.assertEquals(true, healthCheckGroupVModel.healthCheckItemList.isEmpty(), 'HealthCheckGroupVModel healthCheckItemList should be empty.');
    }

    /*****************************************************************************************
    * @description Test to verify constructor with 7 parameters generates model as expected.
    *****************************************************************************************/
    @isTest 
    private static void constructorWithSevenParametersValid(){
        List<String> expandedRowsList = new List<String>{'aString', 'bString', 'cString'};
        List<HealthCheckItemVModel> healthCheckItemList = new List<HealthCheckItemVModel>();
        for (Integer i = 0; i<5; i++){
            HealthCheckItemVModel healthCheckItemVModel = new HealthCheckItemVModel('TestKey' + i, 
                                                                          'TestSetting' + i, 
                                                                          'TestStatus' + i, 
                                                                          'TestStatusLabel' + i,
                                                                          'TestDescription' + i, 
                                                                          'TextRecommendedFix' + i,
                                                                          new List<HealthCheckItemVModel>());
            healthCheckItemList.add(healthCheckItemVModel);
        }

        Test.startTest();
        HealthCheckGroupVModel healthCheckGroupVModel = new HealthCheckGroupVModel('TestLabel',
                                                                          'TestStatus', 
                                                                          5, 
                                                                          8,
                                                                          expandedRowsList, 
                                                                          healthCheckItemList);
        Test.stopTest();

        System.assertEquals('TestLabel', healthCheckGroupVModel.label, 'HealthCheckGroupVModel label should be set to \'TestLabel\'..');
        System.assertEquals('TestStatus', healthCheckGroupVModel.status, 'HealthCheckGroupVModel status should be set to \'TestStatus\'.');
        System.assertEquals(5, healthCheckGroupVModel.passedChecks, 'HealthCheckGroupVModel passedChecks should be 5.');
        System.assertEquals(8, healthCheckGroupVModel.totalChecks, 'HealthCheckGroupVModel totalChecks should be 8.');
        System.assertEquals(3, healthCheckGroupVModel.expandedRowsList.size(), 'HealthCheckGroupVModel expandedRowsList should contain 3 strings.');
        System.assertEquals(5, healthCheckGroupVModel.healthCheckItemList.size(), 'HealthCheckGroupVModel healthCheckItemList should contain 5 healthCheckItem view models.');
    }

    /*****************************************************************************************
    * @description Test to verify compareTo() implementation separates HealthCheckGroupVModels 
    * with 'Fail' status from those with 'Pass' status (Fail above Pass) and in ascending 
    * alphabetical order by label within each group when duplicates do not exist.
    *****************************************************************************************/
    @isTest
    private static void sortByStatusThenLabelWithoutDuplicates(){
        List<HealthCheckGroupVModel> healthCheckGroupVModelsList = new List<HealthCheckGroupVModel>();


        HealthCheckGroupVModel healthCheckGroupVModel1 = new HealthCheckGroupVModel('Zebra',
                                                                           'Fail', 
                                                                           5, 
                                                                           8,
                                                                           new List<String>(), 
                                                                           new List<HealthCheckItemVModel>());

        HealthCheckGroupVModel healthCheckGroupVModel2 = new HealthCheckGroupVModel('zebra',
                                                                           'pass', 
                                                                           5, 
                                                                           8,
                                                                           new List<String>(), 
                                                                           new List<HealthCheckItemVModel>());
        
        HealthCheckGroupVModel healthCheckGroupVModel3 = new HealthCheckGroupVModel('Baboon',
                                                                           'Pass', 
                                                                           5, 
                                                                           8,
                                                                           new List<String>(), 
                                                                           new List<HealthCheckItemVModel>());
       
        HealthCheckGroupVModel healthCheckGroupVModel4 = new HealthCheckGroupVModel('Giraffe',
                                                                           'Fail', 
                                                                           5, 
                                                                           8,
                                                                           new List<String>(), 
                                                                           new List<HealthCheckItemVModel>());
        
        HealthCheckGroupVModel healthCheckGroupVModel5 = new HealthCheckGroupVModel('Lion',
                                                                           'Pass', 
                                                                           5, 
                                                                           8,
                                                                           new List<String>(), 
                                                                           new List<HealthCheckItemVModel>());
        
        HealthCheckGroupVModel healthCheckGroupVModel6 = new HealthCheckGroupVModel('Antelope',
                                                                           'Fail', 
                                                                           5, 
                                                                           8,
                                                                           new List<String>(), 
                                                                           new List<HealthCheckItemVModel>());

        healthCheckGroupVModelsList.add(healthCheckGroupVModel1);
        healthCheckGroupVModelsList.add(healthCheckGroupVModel2);
        healthCheckGroupVModelsList.add(healthCheckGroupVModel3);        
        healthCheckGroupVModelsList.add(healthCheckGroupVModel4);
        healthCheckGroupVModelsList.add(healthCheckGroupVModel5);
        healthCheckGroupVModelsList.add(healthCheckGroupVModel6);

        Test.startTest();
        healthCheckGroupVModelsList.sort();
        Test.stopTest();

        System.assertEquals(true, healthCheckGroupVModelsList[0].label.equalsIgnoreCase('Antelope'));
        System.assertEquals(true, healthCheckGroupVModelsList[0].status.equalsIgnoreCase('Fail'));
        System.assertEquals(true, healthCheckGroupVModelsList[1].label.equalsIgnoreCase('Giraffe'));
        System.assertEquals(true, healthCheckGroupVModelsList[1].status.equalsIgnoreCase('Fail'));
        System.assertEquals(true, healthCheckGroupVModelsList[2].label.equalsIgnoreCase('Zebra'));
        System.assertEquals(true, healthCheckGroupVModelsList[2].status.equalsIgnoreCase('Fail'));
        System.assertEquals(true, healthCheckGroupVModelsList[3].label.equalsIgnoreCase('Baboon'));
        System.assertEquals(true, healthCheckGroupVModelsList[3].status.equalsIgnoreCase('Pass'));
        System.assertEquals(true, healthCheckGroupVModelsList[4].label.equalsIgnoreCase('Lion'));
        System.assertEquals(true, healthCheckGroupVModelsList[4].status.equalsIgnoreCase('Pass'));
        System.assertEquals(true, healthCheckGroupVModelsList[5].label.equalsIgnoreCase('Zebra'));
        System.assertEquals(true, healthCheckGroupVModelsList[5].status.equalsIgnoreCase('Pass'));
    }

    /*****************************************************************************************
    * @description Test to verify compareTo() implementation separates HealthCheckGroupVModels 
    * with 'Fail' status from those with 'Pass' status (Fail above Pass) and in ascending 
    * alphabetical order by label within each group when duplicates exist.
    *****************************************************************************************/
    @isTest
    private static void sortByStatusThenLabelWithDuplicates(){
        List<HealthCheckGroupVModel> healthCheckGroupVModelsList = new List<HealthCheckGroupVModel>();


        HealthCheckGroupVModel healthCheckGroupVModel1 = new HealthCheckGroupVModel('Zebra',
                                                                           'Pass', 
                                                                           5, 
                                                                           8,
                                                                           new List<String>(), 
                                                                           new List<HealthCheckItemVModel>());

        HealthCheckGroupVModel healthCheckGroupVModel2 = new HealthCheckGroupVModel('zebra',
                                                                           'pass', 
                                                                           5, 
                                                                           8,
                                                                           new List<String>(), 
                                                                           new List<HealthCheckItemVModel>());
        
        HealthCheckGroupVModel healthCheckGroupVModel3 = new HealthCheckGroupVModel('Meerkat',
                                                                           'Fail', 
                                                                           5, 
                                                                           8,
                                                                           new List<String>(), 
                                                                           new List<HealthCheckItemVModel>());
       
        HealthCheckGroupVModel healthCheckGroupVModel4 = new HealthCheckGroupVModel('lion',
                                                                           'fail', 
                                                                           5, 
                                                                           8,
                                                                           new List<String>(), 
                                                                           new List<HealthCheckItemVModel>());
        
        HealthCheckGroupVModel healthCheckGroupVModel5 = new HealthCheckGroupVModel('Lion',
                                                                           'fail', 
                                                                           5, 
                                                                           8,
                                                                           new List<String>(), 
                                                                           new List<HealthCheckItemVModel>());
        
        HealthCheckGroupVModel healthCheckGroupVModel6 = new HealthCheckGroupVModel('Antelope',
                                                                           'Pass', 
                                                                           5, 
                                                                           8,
                                                                           new List<String>(), 
                                                                           new List<HealthCheckItemVModel>());

        healthCheckGroupVModelsList.add(healthCheckGroupVModel1);
        healthCheckGroupVModelsList.add(healthCheckGroupVModel2);
        healthCheckGroupVModelsList.add(healthCheckGroupVModel3);        
        healthCheckGroupVModelsList.add(healthCheckGroupVModel4);
        healthCheckGroupVModelsList.add(healthCheckGroupVModel5);
        healthCheckGroupVModelsList.add(healthCheckGroupVModel6);

        Test.startTest();
        healthCheckGroupVModelsList.sort();
        Test.stopTest();

        System.assertEquals(true, healthCheckGroupVModelsList[0].label.equalsIgnoreCase('Lion'));
        System.assertEquals(true, healthCheckGroupVModelsList[0].status.equalsIgnoreCase('Fail'));
        System.assertEquals(true, healthCheckGroupVModelsList[1].label.equalsIgnoreCase('Lion'));
        System.assertEquals(true, healthCheckGroupVModelsList[1].status.equalsIgnoreCase('Fail'));
        System.assertEquals(true, healthCheckGroupVModelsList[2].label.equalsIgnoreCase('Meerkat'));
        System.assertEquals(true, healthCheckGroupVModelsList[2].status.equalsIgnoreCase('Fail'));
        System.assertEquals(true, healthCheckGroupVModelsList[3].label.equalsIgnoreCase('Antelope'));
        System.assertEquals(true, healthCheckGroupVModelsList[3].status.equalsIgnoreCase('Pass'));
        System.assertEquals(true, healthCheckGroupVModelsList[4].label.equalsIgnoreCase('Zebra'));
        System.assertEquals(true, healthCheckGroupVModelsList[4].status.equalsIgnoreCase('Pass'));
        System.assertEquals(true, healthCheckGroupVModelsList[5].label.equalsIgnoreCase('Zebra'));
        System.assertEquals(true, healthCheckGroupVModelsList[5].status.equalsIgnoreCase('Pass'));
    }

    /*****************************************************************************************
    * @description Test to verify compareTo() implementation does not sort lists that 
    * contain Object of type other than HealthCheckGroupVModel, when the HealthCheckGroupVModel
    * is first in the list. 
    *****************************************************************************************/
    private static void sortWithIncomparableObjectTypesRightFirstInList(){
        List<Object> objectsToSort = new List<Object>();
        HealthCheckGroupVModel healthCheckGroupVModel = new HealthCheckGroupVModel('Antelope',
                                                                           'Pass', 
                                                                           5, 
                                                                           8,
                                                                           new List<String>(), 
                                                                           new List<HealthCheckItemVModel>());

        Account testAccount = new Account(Name = 'TestAccount');
        Contact testContact = new Contact(LastName = 'Testerson');

        objectsToSort.add(healthCheckGroupVModel);
        objectsToSort.add(testContact);
        objectsToSort.add(testAccount);

        Test.startTest();
        objectsToSort.sort();
        Test.stopTest();

        System.assertEquals(true, objectsToSort[0] instanceof HealthCheckGroupVModel, 'List should not be sorted when object types are not equal.');
        System.assertEquals(true, objectsToSort[1] instanceof Contact, 'List should not be sorted when object types are not equal.');
        System.assertEquals(true, objectsToSort[2] instanceof Account, 'List should not be sorted when object types are not equal.');
    }

    /*****************************************************************************************
    * @description Test to verify compareTo() implementation does not sort lists that 
    * contain Object of type other than HealthCheckGroupVModel, when the HealthCheckGroupVModel
    * is not first in the list. 
    *****************************************************************************************/
    private static void sortWithIncomparableObjectTypesWrongFirstInList(){
        List<Object> objectsToSort = new List<Object>();
        HealthCheckGroupVModel healthCheckGroupVModel = new HealthCheckGroupVModel('Antelope',
                                                                           'Pass', 
                                                                           5, 
                                                                           8,
                                                                           new List<String>(), 
                                                                           new List<HealthCheckItemVModel>());


        HealthCheckItemVModel healthCheckItemVModel1 = new HealthCheckItemVModel('TestKey1', 
                                                                          'TestSetting', 
                                                                          'Fail', 
                                                                          'TestStatusLabel',
                                                                          'TestDescription', 
                                                                          'TextRecommendedFix',
                                                                          new List<HealthCheckItemVModel>());

        HealthCheckItemVModel healthCheckItemVModel2 = new HealthCheckItemVModel('TestKey2', 
                                                                          'TestSetting', 
                                                                          'Fail', 
                                                                          'TestStatusLabel',
                                                                          'TestDescription', 
                                                                          'TextRecommendedFix',
                                                                          new List<HealthCheckItemVModel>());
        Account testAccount = new Account(Name = 'TestAccount');
        Contact testContact = new Contact(LastName = 'Testerson');

        objectsToSort.add(healthCheckItemVModel1);
        objectsToSort.add(healthCheckGroupVModel);
        objectsToSort.add(healthCheckItemVModel1);
        objectsToSort.add(testAccount);
        objectsToSort.add(testContact);

        Test.startTest();
        objectsToSort.sort();
        Test.stopTest();

        System.assertEquals(true, objectsToSort[0] instanceof HealthCheckItemVModel, 'List should not be sorted when object types are not equal.');
        System.assertEquals(true, objectsToSort[1] instanceof HealthCheckGroupVModel, 'List should not be sorted when object types are not equal.');
        System.assertEquals(true, objectsToSort[2] instanceof HealthCheckItemVModel, 'List should not be sorted when object types are not equal.');
        System.assertEquals(true, objectsToSort[3] instanceof Account, 'List should not be sorted when object types are not equal.');
        System.assertEquals(true, objectsToSort[4] instanceof Contact, 'List should not be sorted when object types are not equal.');
    }

    /*****************************************************************************************
    * @description Test to verify compareTo() method returns 0 when an object that is not of 
    * type HealthCheckGroupVModel is provided for comparison.
    *****************************************************************************************/
    @isTest 
    private static void compareToIncompatibleObjectType(){
        Account acct = new Account(Name = 'Test Account');

        HealthCheckGroupVModel healthCheckGroupVModel = new HealthCheckGroupVModel('TestLabel',
                                                                          'TestStatus', 
                                                                          5, 
                                                                          8,
                                                                          new List<String>{'TestString'}, 
                                                                          new List<HealthCheckItemVModel>());

        Test.startTest();
        Integer compareToResult = healthCheckGroupVModel.compareTo(acct);
        Test.stopTest();

        System.assertEquals(0, compareToResult, 'Result comparing incompatible object types should be 0.');
    }

    /**************************************************************************************************************************
    * @description Test to verify updateHealthCheckStatus() returns Pass when all health checks executed pass.
    **************************************************************************************************************************/ 
    @isTest
    private static void updateHealthCheckStatusPass(){
        HealthCheckGroupVModel healthCheckGroupVModel = new HealthCheckGroupVModel('TestLabel',
                                                                          'TestStatus', 
                                                                          5, 
                                                                          5,
                                                                          new List<String>{'TestString'}, 
                                                                          new List<HealthCheckItemVModel>());
        Test.startTest();
        healthCheckGroupVModel.updateHealthCheckStatus();
        Test.stopTest();

        System.assertEquals(Label.stgHealthCheckStatusPassed, healthCheckGroupVModel.status, 'Should return \'' + Label.stgHealthCheckStatusPassed + '\'.');
    }

    /**************************************************************************************************************************
    * @description Test to verify updateHealthCheckStatus() returns Fail when any health checks executed fail.
    **************************************************************************************************************************/ 
    @isTest
    private static void updateHealthCheckStatusFail(){
        HealthCheckGroupVModel healthCheckGroupVModel = new HealthCheckGroupVModel('TestLabel',
                                                                          'TestStatus', 
                                                                          5, 
                                                                          10,
                                                                          new List<String>{'TestString'}, 
                                                                          new List<HealthCheckItemVModel>());
        Test.startTest();
        healthCheckGroupVModel.updateHealthCheckStatus();
        Test.stopTest();

        System.assertEquals(Label.stgHealthCheckStatusFailed, healthCheckGroupVModel.status, 'Should return \'' + Label.stgHealthCheckStatusFailed + '\'.');
    }
}
public virtual with sharing class HealthCheckItemVModel implements Comparable {
    @AuraEnabled public String key { get; private set; }
    @AuraEnabled public String setting { get; private set; }
    @AuraEnabled public String status;
    @AuraEnabled public String statusLabel;
    @AuraEnabled public String description;
    @AuraEnabled public String recommendedFix;
    @AuraEnabled public List<HealthCheckItemVModel> healthCheckItemList { get; private set; }
    
    public HealthCheckItemVModel(String key, 
                                 String setting, 
                                 String status, 
                                 String statusLabel,
                                 String description, 
                                 String recommendedFix,
                                 List<HealthCheckItemVModel> healthCheckItemList) {
        this.key = key;
        this.setting = setting;
        this.status = status;
        this.statusLabel = statusLabel;
        this.description = description;
        this.recommendedFix = recommendedFix;
        this.healthCheckItemList = healthCheckItemList;
    }

    /*****************************************************************************************
    * @description Implementation of CompareTo() that sorts by status (Fail above Pass), then in
    * ascending alphabetical order on setting.
    * @param compareTo A HealthCheckItemVModel object to compare to another
    * @return 0 if the current object is greater than the object to compare, -1 if it is less, 0 if
    * they are equal, or if the objec to compare is an incompatible type.
    *****************************************************************************************/ 
    public virtual Integer compareTo(Object compareTo){

        if (!(compareTo instanceof HealthCheckItemVModel)){
            return 0;
        }

        HealthCheckItemVModel healthCheckItemVModelToCompareTo = (HealthCheckItemVModel)compareTo;
        Integer statusResult = this.status.toLowerCase().compareTo(healthCheckItemVModelToCompareTo.status.toLowerCase());
        
        if (statusResult != 0){
            return statusResult;
        }
        
        return this.setting.toLowerCase().compareTo(healthCheckItemVModelToCompareTo.setting.toLowerCase());
    }
}
@isTest 
public with sharing class HealthCheckItemVModel_TEST {

    /*****************************************************************************************
    * @description Test to verify constructor with 5 parameters generates model as expected.
    *****************************************************************************************/
    @isTest 
    private static void constructorWithFiveParamsValid(){

        List<HealthCheckItemVModel> sampleHCItemVModelList = new List<HealthCheckItemVModel>();

        Test.startTest();
        HealthCheckItemVModel healthCheckItemVModel = new HealthCheckItemVModel('TestKey', 
                                                                          'TestSetting', 
                                                                          'TestStatus', 
                                                                          'TestStatusLabel',
                                                                          'TestDescription', 
                                                                          'TextRecommendedFix',
                                                                          sampleHCItemVModelList);
        Test.stopTest();

        System.assertEquals('TestKey', healthCheckItemVModel.key, 'HealthCheckItemVModel key should be set to \'TestKey\'');
        System.assertEquals('TestSetting', healthCheckItemVModel.setting, 'HealthCheckItemVModel setting should be set to \'TestSetting\'');
        System.assertEquals('TestStatus', healthCheckItemVModel.status, 'HealthCheckItemVModel status should be set to \'TestStatus\'');
        System.assertEquals('TestStatusLabel', healthCheckItemVModel.statusLabel, 'HealthCheckItemVModel statuslabel should be set to \'TestStatusLabel\'');
        System.assertEquals('TestDescription', healthCheckItemVModel.description, 'HealthCheckItemVModel description should be set to \'TestDescription\'');
        System.assertEquals('TextRecommendedFix', healthCheckItemVModel.recommendedFix, 'HealthCheckItemVModel recommendedFix should be set to \'TextRecommendedFix\'');
        System.assertEquals(sampleHCItemVModelList, healthCheckItemVModel.healthCheckItemList, 'List of HealthCheckItemVModel should not change.');
    }

    /*****************************************************************************************
    * @description Test to verify compareTo() implementation separates HealthCheckGroupVModels 
    * with 'Fail' status from those with 'Pass' status (Fail above Pass) and in ascending 
    * alphabetical order by label within each group when duplicates do not exist.
    *****************************************************************************************/
    @isTest
    private static void sortByStatusThenLabelWithoutDuplicates(){
        List<HealthCheckItemVModel> healthCheckItemVModelsList = new List<HealthCheckItemVModel>();


        HealthCheckItemVModel healthCheckItemVModel1 = new HealthCheckItemVModel('key-1',
                                                                           'Zebra',
                                                                           'Fail', 
                                                                           'Fail-Label', 
                                                                           'Test Description',
                                                                           'Test Recommended fix', 
                                                                           new List<HealthCheckItemVModel>());

        HealthCheckItemVModel healthCheckItemVModel2 = new HealthCheckItemVModel('key-2',
                                                                            'Zebra',
                                                                            'pass', 
                                                                            'pass-Label', 
                                                                            'Test Description',
                                                                            'Test Recommended fix', 
                                                                            new List<HealthCheckItemVModel>());
        
        HealthCheckItemVModel healthCheckItemVModel3 = new HealthCheckItemVModel('key-3',
                                                                            'Baboon',
                                                                            'Pass', 
                                                                            'Pass-Label', 
                                                                            'Test Description',
                                                                            'Test Recommended fix', 
                                                                            new List<HealthCheckItemVModel>());
       
        HealthCheckItemVModel healthCheckItemVModel4 = new HealthCheckItemVModel('key-4',
                                                                            'Giraffe',
                                                                            'Fail', 
                                                                            'Fail-Label', 
                                                                            'Test Description',
                                                                            'Test Recommended fix', 
                                                                            new List<HealthCheckItemVModel>());
        
        HealthCheckItemVModel healthCheckItemVModel5 = new HealthCheckItemVModel('key-5',
                                                                            'Lion',
                                                                            'Pass', 
                                                                            'Pass-Label', 
                                                                            'Test Description',
                                                                            'Test Recommended fix', 
                                                                            new List<HealthCheckItemVModel>());
        
        HealthCheckItemVModel healthCheckItemVModel6 = new HealthCheckItemVModel('key-1',
                                                                            'Antelope',
                                                                            'Fail', 
                                                                            'Fail-Label', 
                                                                            'Test Description',
                                                                            'Test Recommended fix', 
                                                                            new List<HealthCheckItemVModel>());

        healthCheckItemVModelsList.add(healthCheckItemVModel1);
        healthCheckItemVModelsList.add(healthCheckItemVModel2);
        healthCheckItemVModelsList.add(healthCheckItemVModel3);        
        healthCheckItemVModelsList.add(healthCheckItemVModel4);
        healthCheckItemVModelsList.add(healthCheckItemVModel5);
        healthCheckItemVModelsList.add(healthCheckItemVModel6);

        Test.startTest();
        healthCheckItemVModelsList.sort();
        Test.stopTest();

        System.assertEquals(true, healthCheckItemVModelsList[0].setting.equalsIgnoreCase('Antelope'));
        System.assertEquals(true, healthCheckItemVModelsList[0].status.equalsIgnoreCase('Fail'));
        System.assertEquals(true, healthCheckItemVModelsList[1].setting.equalsIgnoreCase('Giraffe'));
        System.assertEquals(true, healthCheckItemVModelsList[1].status.equalsIgnoreCase('Fail'));
        System.assertEquals(true, healthCheckItemVModelsList[2].setting.equalsIgnoreCase('Zebra'));
        System.assertEquals(true, healthCheckItemVModelsList[2].status.equalsIgnoreCase('Fail'));
        System.assertEquals(true, healthCheckItemVModelsList[3].setting.equalsIgnoreCase('Baboon'));
        System.assertEquals(true, healthCheckItemVModelsList[3].status.equalsIgnoreCase('Pass'));
        System.assertEquals(true, healthCheckItemVModelsList[4].setting.equalsIgnoreCase('Lion'));
        System.assertEquals(true, healthCheckItemVModelsList[4].status.equalsIgnoreCase('Pass'));
        System.assertEquals(true, healthCheckItemVModelsList[5].setting.equalsIgnoreCase('Zebra'));
        System.assertEquals(true, healthCheckItemVModelsList[5].status.equalsIgnoreCase('Pass'));
    }

    /*****************************************************************************************
    * @description Test to verify compareTo() implementation separates HealthCheckGroupVModels 
    * with 'Fail' status from those with 'Pass' status (Fail above Pass) and in ascending 
    * alphabetical order by label within each group when duplicates exist.
    *****************************************************************************************/
    @isTest
    private static void sortByStatusThenLabelWithDuplicates(){
        List<HealthCheckItemVModel> healthCheckItemVModelsList = new List<HealthCheckItemVModel>();


        HealthCheckItemVModel healthCheckItemVModel1 = new HealthCheckItemVModel('key-1',
                                                                          'Zebra',
                                                                          'Pass', 
                                                                          'Pass-label', 
                                                                          'Test Description',
                                                                          'Test Recommended Fix', 
                                                                          new List<HealthCheckItemVModel>());

                                                                          

        HealthCheckItemVModel healthCheckItemVModel2 = new HealthCheckItemVModel('key-2',
                                                                          'zebra',
                                                                          'pass', 
                                                                          'pass-label', 
                                                                          'Test Description',
                                                                          'Test Recommended Fix', 
                                                                          new List<HealthCheckItemVModel>());


        HealthCheckItemVModel healthCheckItemVModel3 = new HealthCheckItemVModel('key-3',
                                                                          'Meerkat',
                                                                          'Fail', 
                                                                          'Fail-label', 
                                                                          'Test Description',
                                                                          'Test Recommended Fix', 
                                                                          new List<HealthCheckItemVModel>());


        HealthCheckItemVModel healthCheckItemVModel4 = new HealthCheckItemVModel('key-4',
                                                                          'lion',
                                                                          'fail', 
                                                                          'fail-label', 
                                                                          'Test Description',
                                                                          'Test Recommended Fix', 
                                                                          new List<HealthCheckItemVModel>());


        HealthCheckItemVModel healthCheckItemVModel5 = new HealthCheckItemVModel('key-5',
                                                                          'Lion',
                                                                          'fail', 
                                                                          'fail-label', 
                                                                          'Test Description',
                                                                          'Test Recommended Fix', 
                                                                          new List<HealthCheckItemVModel>());


        HealthCheckItemVModel healthCheckItemVModel6 = new HealthCheckItemVModel('key-6',
                                                                          'Antelope',
                                                                          'Pass', 
                                                                          'Pass-label', 
                                                                          'Test Description',
                                                                          'Test Recommended Fix', 
                                                                          new List<HealthCheckItemVModel>());


        healthCheckItemVModelsList.add(healthCheckItemVModel1);
        healthCheckItemVModelsList.add(healthCheckItemVModel2);
        healthCheckItemVModelsList.add(healthCheckItemVModel3);        
        healthCheckItemVModelsList.add(healthCheckItemVModel4);
        healthCheckItemVModelsList.add(healthCheckItemVModel5);
        healthCheckItemVModelsList.add(healthCheckItemVModel6);

        Test.startTest();
        healthCheckItemVModelsList.sort();
        Test.stopTest();

        System.assertEquals(true, healthCheckItemVModelsList[0].setting.equalsIgnoreCase('Lion'));
        System.assertEquals(true, healthCheckItemVModelsList[0].status.equalsIgnoreCase('Fail'));
        System.assertEquals(true, healthCheckItemVModelsList[1].setting.equalsIgnoreCase('Lion'));
        System.assertEquals(true, healthCheckItemVModelsList[1].status.equalsIgnoreCase('Fail'));
        System.assertEquals(true, healthCheckItemVModelsList[2].setting.equalsIgnoreCase('Meerkat'));
        System.assertEquals(true, healthCheckItemVModelsList[2].status.equalsIgnoreCase('Fail'));
        System.assertEquals(true, healthCheckItemVModelsList[3].setting.equalsIgnoreCase('Antelope'));
        System.assertEquals(true, healthCheckItemVModelsList[3].status.equalsIgnoreCase('Pass'));
        System.assertEquals(true, healthCheckItemVModelsList[4].setting.equalsIgnoreCase('Zebra'));
        System.assertEquals(true, healthCheckItemVModelsList[4].status.equalsIgnoreCase('Pass'));
        System.assertEquals(true, healthCheckItemVModelsList[5].setting.equalsIgnoreCase('Zebra'));
        System.assertEquals(true, healthCheckItemVModelsList[5].status.equalsIgnoreCase('Pass'));
    }

    /*****************************************************************************************
    * @description Test to verify compareTo() implementation does not sort lists that 
    * contain Object of type other than HealthCheckItemVModel, when the HealthCheckItemVModel
    * is first in the list. 
    *****************************************************************************************/
    private static void sortWithIncomparableObjectTypesRightFirstInList(){
        List<Object> objectsToSort = new List<Object>();
        HealthCheckItemVModel healthCheckItemVModel = new HealthCheckItemVModel('key-1',
                                                                         'Antelope',
                                                                         'Pass', 
                                                                         'Pass-label', 
                                                                         'Test Description',
                                                                         'Test Recommended Fix', 
                                                                         new List<HealthCheckItemVModel>());

        Account testAccount = new Account(Name = 'TestAccount');
        Contact testContact = new Contact(LastName = 'Testerson');

        objectsToSort.add(healthCheckItemVModel);
        objectsToSort.add(testContact);
        objectsToSort.add(testAccount);

        Test.startTest();
        objectsToSort.sort();
        Test.stopTest();

        System.assertEquals(true, objectsToSort[0] instanceof HealthCheckItemVModel, 'List should not be sorted when object types are not equal.');
        System.assertEquals(true, objectsToSort[1] instanceof Contact, 'List should not be sorted when object types are not equal.');
        System.assertEquals(true, objectsToSort[2] instanceof Account, 'List should not be sorted when object types are not equal.');
    }

    /*****************************************************************************************
    * @description Test to verify compareTo() implementation does not sort lists that 
    * contain Object of type other than HealthCheckItemVModel, when the HealthCheckItemVModel
    * is not first in the list. 
    *****************************************************************************************/
    private static void sortWithIncomparableObjectTypesWrongFirstInList(){
        List<Object> objectsToSort = new List<Object>();

        HealthCheckGroupVModel healthCheckGroupVModel = new HealthCheckGroupVModel('Zebra',
                                                                             'Fail', 
                                                                             5, 
                                                                             8,
                                                                             new List<String>(), 
                                                                             new List<HealthCheckItemVModel>());

        HealthCheckItemVModel healthCheckItemVModel1 = new HealthCheckItemVModel('TestKey1', 
                                                                           'TestSetting', 
                                                                           'Fail', 
                                                                           'TestStatusLabel',
                                                                           'TestDescription', 
                                                                           'TextRecommendedFix',
                                                                           new List<HealthCheckItemVModel>());

        HealthCheckItemVModel healthCheckItemVModel2 = new HealthCheckItemVModel('TestKey2', 
                                                                           'TestSetting', 
                                                                           'Fail', 
                                                                           'TestStatusLabel',
                                                                           'TestDescription', 
                                                                           'TextRecommendedFix',
                                                                           new List<HealthCheckItemVModel>());
        Account testAccount = new Account(Name = 'TestAccount');
        Contact testContact = new Contact(LastName = 'Testerson');

        objectsToSort.add(healthCheckGroupVModel);
        objectsToSort.add(healthCheckItemVModel1);
        objectsToSort.add(healthCheckItemVModel2);
        objectsToSort.add(testAccount);
        objectsToSort.add(testContact);

        Test.startTest();
        objectsToSort.sort();
        Test.stopTest();

        System.assertEquals(true, objectsToSort[0] instanceof HealthCheckGroupVModel, 'List should not be sorted when object types are not equal.');
        System.assertEquals(true, objectsToSort[1] instanceof HealthCheckItemVModel, 'List should not be sorted when object types are not equal.');
        System.assertEquals(true, objectsToSort[2] instanceof HealthCheckItemVModel, 'List should not be sorted when object types are not equal.');
        System.assertEquals(true, objectsToSort[3] instanceof Account, 'List should not be sorted when object types are not equal.');
        System.assertEquals(true, objectsToSort[4] instanceof Contact, 'List should not be sorted when object types are not equal.');
    }

    /*****************************************************************************************
    * @description Test to verify compareTo() method returns 0 when an object that is not of 
    * type HealthCheckItemVModel is provided for comparison.
    *****************************************************************************************/
    @isTest 
    private static void compareToIncompatibleObjectType(){
        Account acct = new Account(Name = 'Test Account');

        HealthCheckItemVModel healthCheckItemVModel = new HealthCheckItemVModel('TestKey1', 
                                                                           'TestSetting', 
                                                                           'Fail', 
                                                                           'TestStatusLabel',
                                                                           'TestDescription', 
                                                                           'TextRecommendedFix',
                                                                           new List<HealthCheckItemVModel>());

        Test.startTest();
        Integer compareToResult = healthCheckItemVModel.compareTo(acct);
        Test.stopTest();

        System.assertEquals(0, compareToResult, 'Result comparing incompatible object types should be 0.');
    }
}
public virtual with sharing class HealthCheckVMapper {

    /**********************************************************************************
    * @description Instance for Singleton Pattern
    **********************************************************************************/
    @TestVisible
    private static HealthCheckVMapper instance;

    /**********************************************************************************
    * @description Empty constructor is not public for Singleton Pattern
    **********************************************************************************/
    protected HealthCheckVMapper() {}

    /**********************************************************************************
    * @description Static method to get the current instance for Singleton pattern
    * @return The instance of HealthCheckVMapper.
    **********************************************************************************/
    public static HealthCheckVMapper getInstance() {
        if (instance == null) {
            instance = new HealthCheckVMapper();
        }

        return instance;
    }

    /**********************************************************************************
    * @description Locates and returns an instance of FeatureParameterService 
    **********************************************************************************/
    @TestVisible
    private FeatureParameterService locateFeatureParameterService() {
        return FeatureParameterService.getInstance();
    }

    /**********************************************************************************
    * @description Locates and returns an instance of HealthCheckDefinitionService 
    **********************************************************************************/
    @TestVisible
    private HealthCheckDefinitionService locateHealthCheckDefinitionService() {
        return HealthCheckDefinitionService.getInstance();
    }

    /**********************************************************************************
    * @description Retrieve a view model representing a health check to run.
    * @return A HealthCheckVModel representing details of a health check to be run.
    **********************************************************************************/
    public virtual HealthCheckVModel getHealthCheckViewModel() {
        try {
            String lastRunDate = '';

            FeatureParameterDateModel featureParamDateModel = 
               (FeatureParameterDateModel)this.locateFeatureParameterService().getFeatureParameterModel('SettingsHealthCheckLastRunDate');

            if (featureParamDateModel.value != date.newinstance(2015, 12, 31)) {
                lastRunDate = featureParamDateModel.convertToString();
            }

            List<HealthCheckDefinitionVModel> healthCheckDefViewModelsList = new List<HealthCheckDefinitionVModel>(); // list to store VIEW MODELS
            List<HealthCheckDefinitionModel> healthCheckDefinitionList = this.locateHealthCheckDefinitionService().getHealthCheckDefinitionModels(); // retrieve models
            
            for (HealthCheckDefinitionModel healthCheckDefinitionModel : healthCheckDefinitionList) {
                //Generate view model for current health check definition model
                HealthCheckDefinitionVModel healthCheckDefinitionVModel = new HealthCheckDefinitionVModel(healthCheckDefinitionModel.name,
                                                                                                    healthCheckDefinitionModel.className,
                                                                                                    healthCheckDefinitionModel.namespace);

                healthCheckDefViewModelsList.add(healthCheckDefinitionVModel);
            }

            Integer numberOfRuns = healthCheckDefinitionList.size();

            return new HealthCheckVModel(lastRunDate, numberOfRuns, healthCheckDefViewModelsList);
        }
        catch (FeatureParameterMapper.FeatureParameterMapperException e) {
            throw new AuraHandledException(Label.stgHealthCheckErrorLastRunDate);
        }
    }
}
@isTest 
public class HealthCheckVMapper_TEST {

    /**************************************************************************************************************************
    ***************************************************** UNIT TESTS **********************************************************
    **************************************************************************************************************************/
    
    /**************************************************************************************************************************
    * @description Test method to verify that the getInstance method returns a new instance of the 
    * HealthCheckVMapper class when one does not already exist.
    ***************************************************************************************************************************/
    @isTest
    private static void getInstanceNew() {

        Test.startTest();
            HealthCheckVMapper healthCheckVMapperInstance = HealthCheckVMapper.getInstance();
        Test.stopTest();

        System.assertEquals(HealthCheckVMapper.instance, healthCheckVMapperInstance, 'Instance of mapper class returned should match static instance variable.');
        System.assertEquals(true, healthCheckVMapperInstance != null, 'Instance of mapper class should not be null.');
    }

    /**************************************************************************************************************************
    * @description Test method to verify that the getInstance method returns the existing instance of the 
    * HealthCheckVMapper class when one already exists.
    ***************************************************************************************************************************/
    @isTest
    private static void getInstanceExisting() {

        Test.startTest();
            HealthCheckVMapper HealthCheckVMapperInstance1 = HealthCheckVMapper.getInstance();
            HealthCheckVMapper HealthCheckVMapperInstance2 = HealthCheckVMapper.getInstance();
        Test.stopTest();

        System.assertEquals(HealthCheckVMapper.instance, HealthCheckVMapperInstance1, 'Instance of mapper class returned should match static instance variable.');
        System.assertEquals(HealthCheckVMapperInstance1, HealthCheckVMapperInstance2, 'Subsequent retrievals of mapper class instance should return existing instance.');
        System.assertEquals(true, HealthCheckVMapperInstance1 != null, 'Instance of mapper class should not be null.');
    }

    /****************************************************************************************************************************
    * @description Test method to verify that the locateFeatureParameterService method returns instance of FeatureParameterService.
    ****************************************************************************************************************************/
    @isTest
    private static void locateFeatureParameterServiceValid() {
        Test.startTest();
            FeatureParameterService featureParamService = HealthCheckVMapper.getInstance().locateFeatureParameterService();
        Test.stopTest();

        System.assertEquals(FeatureParameterService.getInstance(), featureParamService, 'Should return the instance of FeatureParameterService.');
    }    

    /****************************************************************************************************************************
    * @description Test method to verify that the locateHealthCheckDefinitionService method returns instance of HealthCheckDefinitionService.
    ****************************************************************************************************************************/
    @isTest
    private static void locateHealthCheckDefinitionServiceValid() {
        Test.startTest();
        HealthCheckDefinitionService healthCheckDefService = HealthCheckVMapper.getInstance().locateHealthCheckDefinitionService();
        Test.stopTest();

        System.assertEquals(HealthCheckDefinitionService.getInstance(), healthCheckDefService, 'Should return the instance of HealthCheckDefinitionService.');
    }

    /****************************************************************************************************************************
    * @description Test to verify that getHealthCheckViewModel method returns a Health Check View Model.
    ****************************************************************************************************************************/
    @isTest 
    private static void getHealthCheckViewModelValid(){

        FeatureParameterMapper.instance = new STUB_FeatureParameterDateModel();
        HealthCheckDefinitionService.instance = new STUB_HealthCheckDefinitionService();

        Test.startTest();
        HealthCheckVModel healthCheckVModel = HealthCheckVMapper.getInstance().getHealthCheckViewModel();
        Test.stopTest();

        System.assertEquals(Date.today().addDays(-3).format(), healthCheckVModel.lastRunDate, 'Last run date should be 3 days before current date.');
        System.assertEquals(10, healthCheckVModel.numberOfHealthChecks, 'Number of healt checks to run should equal 10.');
        System.assertEquals(10, healthCheckVModel.healthCheckDefinitionList.size(), 'There should be 10 health check definition view models.');
     
        for (Integer i = 0; i < healthCheckVModel.healthCheckDefinitionList.size(); i++){
            System.assertEquals('Test Health Check ' + i, healthCheckVModel.healthCheckDefinitionList[i].name, 'Name of health check view model should be \'Test Health Check ' + i + '\'');
            System.assertEquals('Test Classname', healthCheckVModel.healthCheckDefinitionList[i].className, 'Classname of health check should be \'Test Classname\'');
            System.assertEquals('TEST', healthCheckVModel.healthCheckDefinitionList[i].namespace, 'Classname of health check should be \'TEST\'');
        }  
    }

    /****************************************************************************************************************************
    * @description Test to verify that getHealthCheckViewModel throws AuraHandledException
    ****************************************************************************************************************************/
    @isTest 
    private static void getHealthCheckViewModelException(){

        FeatureParameterMapper.instance = new STUB_FeatureParameterMapperError();
        HealthCheckDefinitionService.instance = new STUB_HealthCheckDefinitionService();

        try {
            Test.startTest();
                HealthCheckVModel healthCheckVModel = HealthCheckVMapper.getInstance().getHealthCheckViewModel();
            Test.stopTest();
            System.assert(false, 'Should throw an exception');
        } catch (AuraHandledException ex) {
            System.assertEquals('System.AuraHandledException', ex.getTypeName(), 'AuraHandledException should be thrown when exception occurs.');
        } 
    }


    /**************************************************************************************************************************
    ****************************************************** STUBS **************************************************************
    **************************************************************************************************************************/
    
    /**************************************************************************************************************************************
    * @description Stub class to simulate the response from FeatureParameterMapper to return a new instance of a FeatureParameterDateModel
    **************************************************************************************************************************************/ 
    private class STUB_FeatureParameterDateModel extends FeatureParameterMapper {
        @TestVisible 
        public override FeatureParameterModel getFeatureParameterModel(String featureParameter){            
            FeatureParameterDateModel featureParamDateMdl = new FeatureParameterDateModel('Test Feature Param', Date.today().addDays(-3));
            return featureParamDateMdl;
        }
    }

    /**************************************************************************************************************************************
    * @description Stub class to simulate the response from HealthCheckDefinitionService to return a list of HealthCheckDefinitionVModels
    **************************************************************************************************************************************/ 
    private class STUB_HealthCheckDefinitionService extends HealthCheckDefinitionService {
        @TestVisible
        public override List<HealthCheckDefinitionModel> getHealthCheckDefinitionModels(){
            List<HealthCheckDefinitionModel> healthCheckDefModelsList = new List<HealthCheckDefinitionModel>();

            for (Integer i = 0; i < 10; i++){
                HealthCheckDefinitionModel healthCheckDefModel = new HealthCheckDefinitionModel('Test Health Check ' + i, 'Test Classname', 'TEST');
                healthCheckDefModelsList.add(healthCheckDefModel);
            }

            return healthCheckDefModelsList;
        }
    }
    
    /**************************************************************************************************************************************
    * @description Stub class to simulate the exception for FeatureParameterMapper
    **************************************************************************************************************************************/ 
    private class STUB_FeatureParameterMapperError extends FeatureParameterMapper {
        
        @TestVisible
        public override FeatureParameterModel getFeatureParameterModel(String featureParameter){
            TelemetryParameterName telemetryParameterName = FeatureParameterMapper.TelemetryParameterByString.get(featureParameter);
            throw new FeatureParameterMapperException('Feature Parameter ' + String.valueOf(telemetryParameterName) + ' is not defined.');
        }
    }
}
public with sharing class HealthCheckVModel {
    @AuraEnabled public String lastRunDate { get; private set; }
    @AuraEnabled public Integer numberOfHealthChecks { get; private set; }
    @AuraEnabled public List<HealthCheckDefinitionVModel> healthCheckDefinitionList { get; private set; }

    public HealthCheckVModel(String lastRunDate, 
                            Integer numberOfHealthChecks, 
                            List<HealthCheckDefinitionVModel> healthCheckDefinitionList) {
                                
        this.lastRunDate = lastRunDate;
        this.numberOfHealthChecks = numberOfHealthChecks;
        this.healthCheckDefinitionList = healthCheckDefinitionList;
    }
}
@isTest 
public with sharing class HealthCheckVModel_TEST {
    /****************************************************************************************************************************
    * @description Test to verify constructor with 3 parameters initializes object with properties set as expected.
    ****************************************************************************************************************************/
    @isTest 
    private static void threeParamConstructorValid(){
        List<HealthCheckDefinitionVModel> healthCheckDefinitionList = new List<HealthCheckDefinitionVModel>();

        for (Integer i=0; i<5; i++){
            HealthCheckDefinitionVModel healthCheckDefinitionVModel = new HealthCheckDefinitionVModel('Test ' + i, 'TestClass', 'TEST');
            healthCheckDefinitionList.add(healthCheckDefinitionVModel);
        }

        Test.startTest();
        HealthCheckVModel healthCheckVModel = new HealthCheckVModel(Date.today().format(), healthCheckDefinitionList.size(), healthCheckDefinitionList);
        Test.stopTest();

        System.assertEquals(Date.today().format(), healthCheckVModel.lastRunDate, 'Last run date should be today.');
        System.assertEquals(5, healthCheckVModel.numberOfHealthChecks, 'Number of health checks to run should be 5.');

        for (Integer i = 0; i < healthCheckVModel.healthCheckDefinitionList.size(); i++){
            System.assertEquals('Test ' + i, healthCheckVModel.healthCheckDefinitionList[i].name, 'View model name should be \'Test ' + i + '\'.');
        }
    }

}
public with sharing class HierarchySettingsChangesController {
    /**********************************************************************************
     * @description Update the HierarchySettingsChangesVModel with specified changes.
     * @return True if update was successful, false otherwise.
     **********************************************************************************/
    @AuraEnabled
    public static Boolean updateHierarchySettings(HierarchySettingsChangesVModel hierarchySettingsChangesVModel) {
        return HierarchySettingsChangesController.locateHierarchySettingsUpdaterService()
            .updateHierarchySettings(hierarchySettingsChangesVModel);
    }

    /************************************************************************************
     * @description Retrieve an instance of the HierarchySettingsService class.
     * @return An instance of the HierarchySettingsService class.
     ************************************************************************************/
    @TestVisible
    private static HierarchySettingsService locateHierarchySettingsUpdaterService() {
        return HierarchySettingsService.getInstance();
    }
}
@isTest
public with sharing class HierarchySettingsChangesController_TEST {
    /**************************************************************************************************************************
    * @description Test method to verify that the locateHierarchySettingsUpdaterService method returns an instance of the
    * HierarchySettingsService class.
    ***************************************************************************************************************************/
    @isTest 
    private static void locateHierarchySettingsUpdaterServiceValid() {
        Test.startTest();
        HierarchySettingsService hierarchySettingsServiceInstance = 
            HierarchySettingsChangesController.locateHierarchySettingsUpdaterService();
        Test.stopTest();

        System.assertEquals(
            HierarchySettingsService.instance, 
            hierarchySettingsServiceInstance,
            'Should return instance of HierarchySettingsService class.');
    }

    /**************************************************************************************************************************
    * @description Test method to verify that the updateHierarchySettings method returns true when an update to Hierarchy
    * Settings is successfully processed.
    ***************************************************************************************************************************/
    @isTest 
    private static void updateHierarchySettingsValid() {
        HierarchySettingsService.instance = new STUB_HierarchySettingsService();

        Map<String, String> settingsSingleValueBySettingsName = new Map<String, String> {
            'Value1' => 'Changed Value 1'
        };

        Map<String, List<String>> settingsListSettingsName = new Map<String, List<String>> {
            'CollectionValue1' => new List<String>{'Change1', 'Change2', 'Change3'}
        };

        HierarchySettingsChangesVModel hierarchySettingsChangesVModel = 
            new HierarchySettingsChangesVModel(settingsSingleValueBySettingsName, settingsListSettingsName);

        Test.startTest();
        Boolean updateHierarchySettingsResult = 
            HierarchySettingsChangesController.updateHierarchySettings(hierarchySettingsChangesVModel);
        Test.stopTest();

        System.assertEquals(
            true, 
            updateHierarchySettingsResult,
            'Should return true indicating a successful update.'
        );
    }

    /**************************************************************************************************************************
    * @description Test method to verify that the updateHierarchySettings method returns false when an update to Hierarchy
    * Settings is fails due to a DML exception.
    ***************************************************************************************************************************/
    @isTest 
    private static void updateHierarchySettingsInValid() {
        HierarchySettingsService.instance = new STUB_HierarchySettingsServiceDMLFailure();

        Map<String, String> settingsSingleValueBySettingsName = new Map<String, String> {
            'Value1' => 'Changed Value 1'
        };

        Map<String, List<String>> settingsListSettingsName = new Map<String, List<String>> {
            'CollectionValue1' => new List<String>{'Change1', 'Change2', 'Change3'}
        };

        HierarchySettingsChangesVModel hierarchySettingsChangesVModel = 
            new HierarchySettingsChangesVModel(settingsSingleValueBySettingsName, settingsListSettingsName);

        Test.startTest();
        Boolean updateHierarchySettingsResult = 
            HierarchySettingsChangesController.updateHierarchySettings(hierarchySettingsChangesVModel);
        Test.stopTest();

        System.assertEquals(
            false, 
            updateHierarchySettingsResult,
            'Should return true indicating a failure due to a DML Exception.'
        );
    }

    /**************************************************************************************************************************
    * @description Test method to verify that the updateHierarchySettings method throws an exception when the update fails due
    * to inadequate permissions or casting errors.
    ***************************************************************************************************************************/
    @isTest 
    private static void updateHierarchySettingsException() {
        HierarchySettingsService.instance = new STUB_HierarchySettingsExceptionResponse();

        Map<String, String> settingsSingleValueBySettingsName = new Map<String, String> {
            UTIL_Namespace.StrTokenNSPrefix('Value1') => 'Changed Value 1'
        };

        Map<String, List<String>> settingsListSettingsName = new Map<String, List<String>> {
            UTIL_Namespace.StrTokenNSPrefix('CollectionValue1') => new List<String>{'Change1', 'Change2', 'Change3'}
        };

        HierarchySettingsChangesVModel hierarchySettingsChangesVModel = 
            new HierarchySettingsChangesVModel(settingsSingleValueBySettingsName, settingsListSettingsName);

        try {
            Test.startTest();
            Boolean updateHierarchySettingsResult = 
                HierarchySettingsChangesController.updateHierarchySettings(hierarchySettingsChangesVModel);
            Test.stopTest();
        } catch (TestException e) {
            System.assertEquals(
                'Test Exception Encountered', 
                e.getMessage(),
                'Should throw a TestException.'
            );
        }        
    }
    /**************************************************************************************************************************
    ****************************************************** STUBS **************************************************************
    **************************************************************************************************************************/
    
    /**************************************************************************************************************************************
    * @description Stub class to simulate the response from HierarchySettingsService to indicate a successful update
    **************************************************************************************************************************************/ 
    private class STUB_HierarchySettingsService extends HierarchySettingsService {
        public override Boolean updateHierarchySettings(HierarchySettingsChangesVModel hierarchySettingsChangesVModel) {
            return true;
        }
    }
    
    /**************************************************************************************************************************************
    * @description Stub class to simulate the response from HierarchySettingsService to indicate a failure due to a DML exception.
    **************************************************************************************************************************************/ 
    private class STUB_HierarchySettingsServiceDMLFailure extends HierarchySettingsService {
        public override Boolean updateHierarchySettings(HierarchySettingsChangesVModel hierarchySettingsChangesVModel) {
            return false;
        }
    }

    /**************************************************************************************************************************************
    * @description Stub class to simulate the response from HierarchySettingsService to indicate a failure due to a DML exception.
    **************************************************************************************************************************************/ 
    private class STUB_HierarchySettingsExceptionResponse extends HierarchySettingsService {
        public override Boolean updateHierarchySettings(HierarchySettingsChangesVModel hierarchySettingsChangesVModel) {
            throw new TestException('Test Exception Encountered');
        }
    }

    /********************************************************************************************************
    * @description A custom exception class to for testing.
    ********************************************************************************************************/
    public class TestException extends Exception {}
}
public with sharing class HierarchySettingsChangesVModel {
    @AuraEnabled public Map<String, String> settingsSingleValueBySettingsName { get; set; }
    @AuraEnabled public Map<String, List<String>> settingsListSettingsName { get; set; }

    /**********************************************************************************************************************
    * @description No argument constructor
    * @return A HierarchySettingsChangesVModel with empty maps
    **********************************************************************************************************************/
    public HierarchySettingsChangesVModel() {
        this.settingsSingleValueBySettingsName = new Map<String, String>();
        this.settingsListSettingsName = new Map<String, List<String>>();
    }

    /**********************************************************************************************************************
    * @description Two parameter constructor
    * @param  settingsSingleValueBySettingsName A map of changed hierarchy settings with single values mapped by name 
    * @param  settingsListSettingsName A map of changed hierarchy settings with collections mapped by name 
    * @return A HierarchySettingsChangesVModel with all properties populated
    **********************************************************************************************************************/ 
    public HierarchySettingsChangesVModel(
        Map<String, String> settingsSingleValueBySettingsName, 
        Map<String, List<String>> settingsListSettingsName
    ) {
        this.settingsSingleValueBySettingsName = settingsSingleValueBySettingsName;
        this.settingsListSettingsName = settingsListSettingsName;
    }
}
@isTest 
public with sharing class HierarchySettingsChangesVModel_TEST {
    /******************************************************************************
    * @description Test method to verify the no argument constructor returns a
    * HierarchySettingsChangesVModel with empty properties initialized.
    ******************************************************************************/
    @isTest 
    private static void noParameterConstructor() {
        Test.startTest();
        HierarchySettingsChangesVModel hierarchySettingsChangesVModel = new HierarchySettingsChangesVModel();
        Test.stopTest();

        System.assertEquals(
            true, 
            hierarchySettingsChangesVModel.settingsSingleValueBySettingsName.isEmpty(), 
            'settingsSingleValueBySettingsName should be an empty map.'
        );

        System.assertEquals(
            true, 
            hierarchySettingsChangesVModel.settingsListSettingsName.isEmpty(), 
            'settingsListSettingsName should be an empty map.'
        );
    }

    /******************************************************************************
    * @description Test method to verify two argument constructor returns a
    * HierarchySettingsChangesVModel with all properties populated.
    ******************************************************************************/
    @isTest 
    private static void twoParameterConstructor() {
        Map<String, String> settingsSingleValueBySettingsName = new Map<String, String> {
            'Value1' => 'Changed Value 1'
        };

        Map<String, List<String>> settingsListSettingsName = new Map<String, List<String>> {
            'CollectionValue1' => new List<String>{'Change1', 'Change2', 'Change3'}
        };

        Test.startTest();
        HierarchySettingsChangesVModel hierarchySettingsChangesVModel = 
            new HierarchySettingsChangesVModel(settingsSingleValueBySettingsName, settingsListSettingsName);
        Test.stopTest();

        System.assertEquals(
            'Changed Value 1', 
            hierarchySettingsChangesVModel.settingsSingleValueBySettingsName.get('Value1'), 
            'Mapped value should match parameter value.'
        );

        System.assertEquals(
            3, 
            hierarchySettingsChangesVModel.settingsListSettingsName.get('CollectionValue1').size(), 
            'Mapped value should be list of 3 elements.'
        );

        System.assertEquals(
            true, 
            hierarchySettingsChangesVModel.settingsListSettingsName.get('CollectionValue1').contains('Change1'),
            'List of changes to setting should include \'Change1\''
        );

        System.assertEquals(
            true, 
            hierarchySettingsChangesVModel.settingsListSettingsName.get('CollectionValue1').contains('Change2'),
            'List of changes to setting should include \'Change2\''
        );

        System.assertEquals(
            true, 
            hierarchySettingsChangesVModel.settingsListSettingsName.get('CollectionValue1').contains('Change3'),
            'List of changes to setting should include \'Change3\''
        );
    }
}
public virtual with sharing class HierarchySettingsMapper {
    /**********************************************************************************
     * @description Instance for Singleton Pattern
     **********************************************************************************/
    @TestVisible
    private static HierarchySettingsMapper instance;

    /**********************************************************************************
     * @description Empty constructor is not public for Singleton Pattern
     **********************************************************************************/
    protected HierarchySettingsMapper() {
    }

    /**********************************************************************************
     * @description Static method to get the current instance for Singleton pattern
     * @return The instance of HierarchySettingsMapper.
     **********************************************************************************/
    public static HierarchySettingsMapper getInstance() {
        if (instance == null) {
            instance = new HierarchySettingsMapper();
        }

        return instance;
    }

    /**********************************************************************************
     * @description Retrieve a model representing the values set in Hierarchy Settings.
     * @return A HierarchySettingsModel.
     **********************************************************************************/
    public HierarchySettingsModel getHierarchySettings() {
        Hierarchy_Settings__c hierarchySettings = UTIL_CustomSettingsFacade.getSettings();
        return new HierarchySettingsModel(hierarchySettings);
    }

    /**********************************************************************************
     * @description Retrieve the describe result for a specified Hierarchy Settings field.
     * @return A Schema.DescribeFieldResult for the specified Hierarchy Settings field.
     **********************************************************************************/
    public Schema.DescribeFieldResult getHierarchySettingsField(String apiName) {
        return UTIL_Describe.getFieldDescribe(UTIL_Namespace.StrTokenNSPrefix('Hierarchy_Settings__c'), apiName);
    }

    /****************************************************************************************************
     * @description Update a HierarchySettingsModel to reflect changes made to setting values.
     * @param hierarchySettingsModel A HierarchySettingsModel with changes to updated Hierarchy Settings fields set.
     * @return A true if the update to Hierarchy Settings is successful, false otherwise.
     ****************************************************************************************************/
    public virtual boolean updateHierarchySettings(HierarchySettingsModel hierarchySettingsModel) {
        try {
            /* sfca-disable-next-line ApexFlsViolationRule */
            update hierarchySettingsModel.hierarchySettings;
        } catch (System.DmlException e) {
            return false;
        }

        return true;
    }
}
@isTest
public inherited sharing class HierarchySettingsMapper_TEST {
    /**************************************************************************************************************************
     * @description Test method to verify that the getInstance method returns a new instance of the
     * HierarchySettingsMapper class when one does not already exist.
     ***************************************************************************************************************************/
    @isTest
    private static void getInstanceNew() {
        Test.startTest();
        HierarchySettingsMapper hierarchySettingsMapperInstance = HierarchySettingsMapper.getInstance();
        Test.stopTest();

        System.assertEquals(
            HierarchySettingsMapper.instance,
            hierarchySettingsMapperInstance,
            'Instance of mapper class returned should match static instance variable.'
        );

        System.assertEquals(
            true,
            hierarchySettingsMapperInstance != null,
            'Instance of mapper class should not be null.'
        );
    }

    /**************************************************************************************************************************
     * @description Test method to verify that the getInstance method returns the existing instance of the
     * HierarchySettingsMapper class when one already exists.
     ***************************************************************************************************************************/
    @isTest
    private static void getInstanceExisting() {
        Test.startTest();
        HierarchySettingsMapper hierarchySettingsMapperInstance1 = HierarchySettingsMapper.getInstance();
        HierarchySettingsMapper hierarchySettingsMapperInstance2 = HierarchySettingsMapper.getInstance();
        Test.stopTest();

        System.assertEquals(
            HierarchySettingsMapper.instance,
            hierarchySettingsMapperInstance1,
            'Instance of mapper class returned should match static instance variable.'
        );

        System.assertEquals(
            hierarchySettingsMapperInstance1,
            hierarchySettingsMapperInstance2,
            'Subsequent retrievals of mapper class instance should return existing instance.'
        );

        System.assertEquals(
            true,
            hierarchySettingsMapperInstance1 != null,
            'Instance of mapper class should not be null.'
        );
    }

    /**************************************************************************************************************************
     * @description Test method to verify that the getHierarchySettings method returns the values specified in Hierarchy Settings.
     ***************************************************************************************************************************/
    @isTest
    private static void getHierarchySettingsValid() {
        Hierarchy_Settings__c hierarchySettings = UTIL_CustomSettings_API.getSettingsForTests(
            new Hierarchy_Settings__c(Account_Processor__c = 'Test Account')
        );

        HierarchySettingsMapper hierarchySettingsMapperInstance = HierarchySettingsMapper.getInstance();

        Test.startTest();
        HierarchySettingsModel hierarchySettingsModel = hierarchySettingsMapperInstance.getHierarchySettings();
        Test.stopTest();

        System.assertEquals(
            'Test Account',
            hierarchySettingsModel.hierarchySettings.Account_Processor__c,
            'Account_Processor__c hierarchy setting should match specified value.'
        );
    }

    /**************************************************************************************************************************
     * @description Test method to verify that the getHierarchySettingsField method returns the DescribeFieldResult for a
     * specified Hierarchy Settings field.
     ***************************************************************************************************************************/
    @isTest
    private static void getHierarchySettingsFieldValid() {
        HierarchySettingsMapper hierarchySettingsMapperInstance = HierarchySettingsMapper.getInstance();

        Test.startTest();
        Schema.DescribeFieldResult describeFieldResult = hierarchySettingsMapperInstance.getHierarchySettingsField(
            UTIL_Namespace.StrTokenNSPrefix('Account_Processor__c')
        );
        Test.stopTest();

        System.assertEquals(
            'Account Processor',
            describeFieldResult.getLabel(),
            'Should match field label value specified for Account Processor.'
        );
        System.assertEquals(
            UTIL_Namespace.StrTokenNSPrefix('Account_Processor__c'),
            describeFieldResult.getName(),
            'Should match api name value specified for Account Processor.'
        );
    }

    /**************************************************************************************************************************
     * @description Test method to verify that the getHierarchySettingsField method throws an exception for a field
     * that is not specified in Hierarchy Settings.
     ***************************************************************************************************************************/
    @isTest
    private static void getHierarchySettingsFieldInValid() {
        HierarchySettingsMapper hierarchySettingsMapperInstance = HierarchySettingsMapper.getInstance();

        try {
            Test.startTest();
            Schema.DescribeFieldResult describeFieldResult = hierarchySettingsMapperInstance.getHierarchySettingsField(
                UTIL_Namespace.StrTokenNSPrefix('Invalid_Field_Name__c')
            );
            Test.stopTest();
        } catch (UTIL_Describe.SchemaDescribeException e) {
            System.assertEquals(
                'Invalid field name \'' +
                UTIL_Namespace.StrTokenNSPrefix('Invalid_Field_Name__c') +
                '\'',
                e.getMessage(),
                'Invalid field name should cause exception'
            );
        }
    }

    /**************************************************************************************************************************
     * @description Test method to verify that the updateHierarchySettings method updates Hierarchy Setting values of both
     * primitive and collection data types.
     ***************************************************************************************************************************/
    @isTest
    private static void updateHierarchySettingsValid() {
        Hierarchy_Settings__c hierarchySettings = UTIL_CustomSettings_API.getSettingsForTests(
            new Hierarchy_Settings__c(
                Account_Processor__c = 'Original Account',
                Accounts_to_Delete__c = 'Original Value1;Original Value2'
            )
        );
        insert hierarchySettings;

        Hierarchy_Settings__c updatedHierarchySettings = UTIL_CustomSettings_API.getSettingsForTests(
            new Hierarchy_Settings__c(
                Account_Processor__c = 'Updated Account',
                Accounts_to_Delete__c = 'Updated Value 1;Updated Value 2'
            )
        );

        HierarchySettingsModel hierarchySettingsModel = new HierarchySettingsModel(updatedHierarchySettings);
        HierarchySettingsMapper hierarchySettingsMapperInstance = HierarchySettingsMapper.getInstance();

        Test.startTest();
        Boolean updateResult = hierarchySettingsMapperInstance.updateHierarchySettings(hierarchySettingsModel);
        Test.stopTest();

        System.assertEquals(true, updateResult, 'Update should complete successfully.');

        Hierarchy_Settings__c updatedHierarchySettingsResult = UTIL_CustomSettings_API.getSettings();

        System.assertEquals(
            'Updated Account',
            updatedHierarchySettingsResult.Account_Processor__c,
            'Account_Processor__c value should be updated.'
        );

        System.assertEquals(
            'Updated Value 1;Updated Value 2',
            updatedHierarchySettings.Accounts_to_Delete__c,
            'Accounts_to_Delete__c value should be updated.'
        );
    }
}
public with sharing class HierarchySettingsModel {
    public Hierarchy_Settings__c hierarchySettings { get; private set; }
    
    /**************************************************************************
    * @description Single parameter constructor 
    * @param  hierarchySettings A Hierarchy_Settings__c object
    * @return A HierarchySettingsModel with all parameters populated.
    **************************************************************************/
    public HierarchySettingsModel(Hierarchy_Settings__c hierarchySettings) {
        this.hierarchySettings = hierarchySettings;
    }

    /****************************************************************************
    * @description Helper method to set the value for a Hierarchy Settings field
    * with a valud of type String.
    * @param  fieldName A Hierarchy Settings field name
    * @param  fieldValue A String value for the specified Hierarchy Settings field
    ****************************************************************************/
    public void setSettingsField(String fieldName, String fieldValue) {
        this.hierarchySettings.put(fieldName, fieldValue);
    }

    /****************************************************************************
    * @description Helper method to set the value for a Hierarchy Settings field
    * with a valud of type Boolean.
    * @param  fieldName A Hierarchy Settings field name
    * @param  fieldValue A Boolean value for the specified Hierarchy Settings field
    ****************************************************************************/
    public void setSettingsField(String fieldName, Boolean fieldValue) {
        this.hierarchySettings.put(fieldName, fieldValue);
    }

    /****************************************************************************
    * @description Helper method to set the value for a Hierarchy Settings field
    * with a valud of type DateTime.
    * @param  fieldName A Hierarchy Settings field name
    * @param  fieldValue A DateTime value for the specified Hierarchy Settings field
    ****************************************************************************/
    public void setSettingsField(String fieldName, Datetime fieldValue) {
        this.hierarchySettings.put(fieldName, fieldValue);
    }
}
@isTest
public with sharing class HierarchySettingsModel_TEST {
    /******************************************************************************
    * @description Test method to verify single parameter constructor returns a
    * HierarchySettingsChangesVModel with all parameters populated.
    ******************************************************************************/
    @isTest 
    private static void singleParameterConstructor() {
        Hierarchy_Settings__c hierarchySettings = UTIL_CustomSettings_API.getSettingsForTests(
            new Hierarchy_Settings__c(
                Account_Processor__c = 'Test Account',
                Household_Addresses_RecType__c = 'Test HH Account',
                Administrative_Account_Record_Type__c = 'Test Admin Account'
            )
        );

        Test.startTest();
        HierarchySettingsModel hierarchySettingsModel = new HierarchySettingsModel(hierarchySettings);
        Test.stopTest();

        System.assertEquals(
            'Test Account', 
            hierarchySettingsModel.hierarchySettings.Account_Processor__c,
            'Account_Processor__c hierarchy setting should match specified value.'    
        );
        System.assertEquals(
            'Test HH Account', 
            hierarchySettingsModel.hierarchySettings.Household_Addresses_RecType__c,
            'Household_Addresses_RecType__c hierarchy setting should match specified value.'
        );
        System.assertEquals(
            'Test Admin Account', 
            hierarchySettingsModel.hierarchySettings.Administrative_Account_Record_Type__c,
            'Administrative_Account_Record_Type__c hierarchy setting should match specified value.'
        );
    }
}
public virtual with sharing class HierarchySettingsService {
    /**********************************************************************************
     * @description Instance for Singleton Pattern
     **********************************************************************************/
    @TestVisible
    private static HierarchySettingsService instance;

    /**********************************************************************************
     * @description Empty constructor is not public for Singleton Pattern
     **********************************************************************************/
    protected HierarchySettingsService() {
    }

    /**********************************************************************************
     * @description Static method to get the current instance for Singleton pattern
     * @return The instance of HierarchySettingsService.
     **********************************************************************************/
    public static HierarchySettingsService getInstance() {
        if (instance == null) {
            instance = new HierarchySettingsService();
        }

        return instance;
    }

    /************************************************************************************************************
     * @description Update Hierarchy Settings fields with specified changes.
     * @param  hierarchySettingsChangesVModel A HierarchySettingsChangesVModel representing updates to Hierarchy Settings.
     * @return True if the updates were completed successfully, false otherwise.
     ************************************************************************************************************/
    public virtual Boolean updateHierarchySettings(HierarchySettingsChangesVModel hierarchySettingsChangesVModel) {
        if (this.locateUserPermissionService().checkCustomizeApplicationForCurrentUser() == false) {
            return false;
        }

        HierarchySettingsModel hierarchySettingsModelToUpdate = this.locateHierarchySettingsMapper()
            .getHierarchySettings();

        try {
            // Update Hierarchy Settings fields with single values
            for (
                String changedSettingName : hierarchySettingsChangesVModel.settingsSingleValueBySettingsName.keySet()
            ) {
                String settingsField = UTIL_Namespace.StrTokenNSPrefix(changedSettingName);

                Schema.DescribeFieldResult fieldDescribeResult = this.locateHierarchySettingsMapper()
                    .getHierarchySettingsField(settingsField);
                Schema.DisplayType displayType = fieldDescribeResult.getType();

                if (displayType == Schema.DisplayType.TEXTAREA || displayType == Schema.DisplayType.STRING) {
                    String hierarchySettingValue = (String) hierarchySettingsChangesVModel.settingsSingleValueBySettingsName.get(
                        changedSettingName
                    );
                    hierarchySettingsModelToUpdate.setSettingsField(changedSettingName, hierarchySettingValue);
                }

                if (displayType == Schema.DisplayType.BOOLEAN) {
                    Boolean hierarchySettingValue = Boolean.valueOf(
                        hierarchySettingsChangesVModel.settingsSingleValueBySettingsName.get(changedSettingName)
                    );
                    hierarchySettingsModelToUpdate.setSettingsField(changedSettingName, hierarchySettingValue);
                }

                if (displayType == Schema.DisplayType.DATETIME) {
                    Datetime hierarchySettingValue = Datetime.valueOf(
                        hierarchySettingsChangesVModel.settingsSingleValueBySettingsName.get(changedSettingName)
                    );
                    hierarchySettingsModelToUpdate.setSettingsField(changedSettingName, hierarchySettingValue);
                }
            }

            // Update Hierarchy Settings fields with collections as values
            for (String changedSettingName : hierarchySettingsChangesVModel.settingsListSettingsName.keySet()) {
                String settingsField = UTIL_Namespace.StrTokenNSPrefix(changedSettingName);

                Schema.DescribeFieldResult fieldDescribeResult = this.locateHierarchySettingsMapper()
                    .getHierarchySettingsField(settingsField);

                String hierarchySettingValue = this.denormalizeListSettingChange(
                    hierarchySettingsChangesVModel.settingsListSettingsName.get(changedSettingName)
                );

                hierarchySettingsModelToUpdate.hierarchySettings.put(changedSettingName, hierarchySettingValue);
            }
        } catch (UTIL_Describe.SchemaDescribeException e) {
            UTIL_Debug.debug('****SchemaDescribeException encountered: ' + e.getMessage());
            throw new InvalidSettingsException(Label.stgErrorInvalidSettings);
        } catch (System.TypeException e) {
            UTIL_Debug.debug('****TypeException encountered: ' + e.getMessage());
            throw new InvalidSettingsException(Label.stgErrorInvalidSettings);
        } catch (Exception e) {
            UTIL_Debug.debug('****Unexpected Exception encountered: ' + e.getMessage());
            throw new InvalidSettingsException(Label.stgErrorInvalidSettings);
        }

        return this.locateHierarchySettingsMapper().updateHierarchySettings(hierarchySettingsModelToUpdate);
    }

    /******************************************************************************************************
     * @description Converts a List of Strings to a semicolon-delimited string.
     * @param  collectionTypeHierarchySettingsUpdateList List<String> to convert
     * @return A semicolon-delimited String representing each String in the specified list.
     ******************************************************************************************************/
    @TestVisible
    private String denormalizeListSettingChange(List<String> collectionTypeHierarchySettingsUpdateList) {
        return String.join(collectionTypeHierarchySettingsUpdateList, ';');
    }

    /************************************************************************************************************
     * @description Retrieve an instance of HierarchySettingsMapper
     * @return An instance of the HierarchySettingsMapper class
     ************************************************************************************************************/
    @TestVisible
    private HierarchySettingsMapper locateHierarchySettingsMapper() {
        return HierarchySettingsMapper.getInstance();
    }

    /************************************************************************************************************
     * @description Retrieve an instance of UserPermissionService
     * @return An instance of the UserPermissionService class
     ************************************************************************************************************/
    @TestVisible
    private UserPermissionService locateUserPermissionService() {
        return UserPermissionService.getInstance();
    }

    /********************************************************************************************************
     * @description A custom exception class to represent errors associated with updates to Hierarchy Settings.
     ********************************************************************************************************/
    public class InvalidSettingsException extends Exception {
    }
}
@isTest
public with sharing class HierarchySettingsService_TEST {
    /**************************************************************************************************************************
     * @description Test method to verify that the getInstance method returns a new instance of the
     * HierarchySettingsService class when one does not already exist.
     ***************************************************************************************************************************/
    @isTest
    private static void getInstanceNew() {
        Test.startTest();
        HierarchySettingsService hierarchySettingsServiceInstance = HierarchySettingsService.getInstance();
        Test.stopTest();

        System.assertEquals(
            HierarchySettingsService.instance,
            hierarchySettingsServiceInstance,
            'Instance of mapper class returned should match static instance variable.'
        );

        System.assertEquals(
            true,
            hierarchySettingsServiceInstance != null,
            'Instance of mapper class should not be null.'
        );
    }

    /**************************************************************************************************************************
     * @description Test method to verify that the getInstance method returns the existing instance of the
     * HierarchySettingsService class when one already exists.
     ***************************************************************************************************************************/
    @isTest
    private static void getInstanceExisting() {
        Test.startTest();
        HierarchySettingsService hierarchySettingsServiceInstance1 = HierarchySettingsService.getInstance();
        HierarchySettingsService hierarchySettingsServiceInstance2 = HierarchySettingsService.getInstance();
        Test.stopTest();

        System.assertEquals(
            HierarchySettingsService.instance,
            hierarchySettingsServiceInstance1,
            'Instance of mapper class returned should match static instance variable.'
        );

        System.assertEquals(
            hierarchySettingsServiceInstance1,
            hierarchySettingsServiceInstance2,
            'Subsequent retrievals of mapper class instance should return existing instance.'
        );

        System.assertEquals(
            true,
            hierarchySettingsServiceInstance1 != null,
            'Instance of mapper class should not be null.'
        );
    }

    /**************************************************************************************************************************
     * @description Test method to verify that the locateHierarchySettingsMapper method returns a valid instance of
     * HierarchySettingsMapper.
     ***************************************************************************************************************************/
    @isTest
    private static void locateHierarchySettingsMapperValid() {
        HierarchySettingsService hierarchySettingsServiceInstance = HierarchySettingsService.getInstance();

        Test.startTest();
        HierarchySettingsMapper hierarchySettingsMapperInstance = hierarchySettingsServiceInstance.locateHierarchySettingsMapper();
        Test.stopTest();

        System.assertEquals(
            HierarchySettingsMapper.getInstance(),
            hierarchySettingsMapperInstance,
            'Should return instance of HierarchySettingsMapper.'
        );
    }

    /**************************************************************************************************************************
     * @description Test method to verify that the locateUserPermissionService method returns a valid instance of
     * UserPermissionService.
     ***************************************************************************************************************************/
    @isTest
    private static void locateUserPermissionServiceValid() {
        HierarchySettingsService hierarchySettingsServiceInstance = HierarchySettingsService.getInstance();

        Test.startTest();
        UserPermissionService userPermissionServiceInstance = hierarchySettingsServiceInstance.locateUserPermissionService();
        Test.stopTest();

        System.assertEquals(
            UserPermissionService.getInstance(),
            userPermissionServiceInstance,
            'Should return instance of UserPermissionService.'
        );
    }

    /**************************************************************************************************************************
     * @description Test method to verify that the updateHierarchySettings method returns true when an update to Hierarchy
     * Settings is successfully processed.
     ***************************************************************************************************************************/
    @isTest
    private static void updateHierarchySettingsValid() {
        PermissionSetMapper.instance = new STUB_PermissionSetMapperHasAccess();
        HierarchySettingsMapper.instance = new STUB_HierarchySettingsMapper();

        HierarchySettingsChangesVModel hierarchySettingsChangesVModel = new HierarchySettingsChangesVModel();
        HierarchySettingsService hierarchySettingsServiceInstance = HierarchySettingsService.getInstance();

        Test.startTest();
        Boolean updateHierarchySettingsResult = hierarchySettingsServiceInstance.updateHierarchySettings(
            hierarchySettingsChangesVModel
        );
        Test.stopTest();

        System.assertEquals(true, updateHierarchySettingsResult, 'Should return true indicating a successful update.');
    }

    /**************************************************************************************************************************
     * @description Test method to verify that the updateHierarchySettings method throws an exception when an exception is
     * encountered from the UserPermissionService class
     ***************************************************************************************************************************/
    @isTest
    private static void updateHierarchySettingsPermissionException() {
        PermissionSetMapper.instance = new STUB_PermissionSetMapperNoAccess();

        HierarchySettingsChangesVModel hierarchySettingsChangesVModel = new HierarchySettingsChangesVModel();
        HierarchySettingsService hierarchySettingsServiceInstance = HierarchySettingsService.getInstance();

        try {
            Test.startTest();
            Boolean updateHierarchySettingsResult = hierarchySettingsServiceInstance.updateHierarchySettings(
                hierarchySettingsChangesVModel
            );
            Test.stopTest();
        } catch (System.NoAccessException e) {
            System.assertEquals(
                'Script-thrown exception',
                e.getMessage(),
                'Should throw an error when permissions are missing.'
            );
        }
    }

    /**************************************************************************************************************************
     * @description Test method to verify that the updateHierarchySettings method throws an error and does not update any
     * Hierarchy Settings fields when an error is encountered.
     ***************************************************************************************************************************/
    @isTest
    private static void updateHierarchySettingsSchemaDescribeException() {
        PermissionSetMapper.instance = new STUB_PermissionSetMapperHasAccess();

        Hierarchy_Settings__c hierarchySettings = UTIL_CustomSettings_API.getSettingsForTests(
            new Hierarchy_Settings__c(
                Account_Processor__c = 'Original Account',
                Accounts_to_Delete__c = 'Original Value1;Original Value2'
            )
        );

        Map<String, String> singleValueSettingUpdatesByNameInvalid = new Map<String, String>{
            'Account_Processor_Invalid__c' => 'Updated Value'
        };

        Map<String, List<String>> listValueSettingUpdatesByName = new Map<String, List<String>>{
            'Accounts_to_Delete__c' => new List<String>{ 'Updated Value 1', 'Updated Value 2' }
        };

        HierarchySettingsChangesVModel hierarchySettingsChangesVModel = new HierarchySettingsChangesVModel(
            singleValueSettingUpdatesByNameInvalid,
            listValueSettingUpdatesByName
        );

        HierarchySettingsService hierarchySettingsServiceInstance = HierarchySettingsService.getInstance();

        try {
            Test.startTest();
            Boolean updateResult = hierarchySettingsServiceInstance.updateHierarchySettings(
                hierarchySettingsChangesVModel
            );
            Test.stopTest();
        } catch (UTIL_Describe.SchemaDescribeException e) {
            System.assertEquals(
                'Invalid field name \'' +
                'Account_Processor_Invalid__c' +
                '\'',
                e.getMessage(),
                'Invalid field name should cause exception'
            );
        } catch (HierarchySettingsService.InvalidSettingsException e) {
            System.assertEquals(
                Label.stgErrorInvalidSettings,
                e.getMessage(),
                'Invalid mapping should throw exception.'
            );
        }

        Hierarchy_Settings__c updatedHierarchySettings = UTIL_CustomSettings_API.getSettings();

        System.assertEquals(
            'Original Account',
            updatedHierarchySettings.Account_Processor__c,
            'Account_Processor__c value should remain unchanged.'
        );

        System.assertEquals(
            'Original Value1;Original Value2',
            updatedHierarchySettings.Accounts_to_Delete__c,
            'Accounts_to_Delete__c value should remain unchanged.'
        );
    }

    /**************************************************************************************************************************
     * @description Test method to verify that the updateHierarchySettingsWithListValues method throws an error when an invalid
     * Hierarchy Setting field is specified for update.
     ***************************************************************************************************************************/
    @isTest
    private static void updateHierarchySettingsWithListValuesInValidFieldName() {
        PermissionSetMapper.instance = new STUB_PermissionSetMapperHasAccess();

        Hierarchy_Settings__c hierarchySettings = UTIL_CustomSettings_API.getSettingsForTests(
            new Hierarchy_Settings__c(Accounts_to_Delete__c = 'Original Value1;Original Value2')
        );

        Map<String, List<String>> listValueSettingUpdatesByName = new Map<String, List<String>>{
            'Accounts_to_Delete__c' => new List<String>{ 'Updated Value 1', 'Updated Value 2' },
            'Not_A_Valid_Field__c' => new List<String>{ 'Invalid value' }
        };

        HierarchySettingsChangesVModel hierarchySettingsChangesVModelListValuesError = new HierarchySettingsChangesVModel(
            new Map<String, String>(),
            listValueSettingUpdatesByName
        );

        HierarchySettingsService hierarchySettingsServiceInstance = HierarchySettingsService.getInstance();

        try {
            Test.startTest();
            Boolean updateResult = hierarchySettingsServiceInstance.updateHierarchySettings(
                hierarchySettingsChangesVModelListValuesError
            );
            Test.stopTest();
        } catch (UTIL_Describe.SchemaDescribeException e) {
            System.assertEquals(
                'Invalid field name \'' +
                'Not_A_Valid_Field__c' +
                '\'',
                e.getMessage(),
                'Invalid field mapping should throw error.'
            );
        } catch (HierarchySettingsService.InvalidSettingsException e) {
            System.assertEquals(
                Label.stgErrorInvalidSettings,
                e.getMessage(),
                'Invalid mapping should throw exception.'
            );
        }
    }

    /**************************************************************************************************************************
     * @description Test method to verify that the updateHierarchySettings method does not update the specified Hierarchy
     * Settings fields of type collection when no updates are specified.
     ***************************************************************************************************************************/
    @isTest
    private static void updateHierarchySettingsWithListValuesEmpty() {
        PermissionSetMapper.instance = new STUB_PermissionSetMapperHasAccess();
        HierarchySettingsMapper.instance = new STUB_HierarchySettingsMapper();

        Hierarchy_Settings__c hierarchySettings = UTIL_CustomSettings_API.getSettingsForTests(
            new Hierarchy_Settings__c(Accounts_to_Delete__c = 'Original Value1;Original Value2')
        );

        Map<String, List<String>> listValueSettingUpdatesByName = new Map<String, List<String>>();

        HierarchySettingsChangesVModel hierarchySettingsChangesVModelListValuesEmpty = new HierarchySettingsChangesVModel(
            new Map<String, String>(),
            listValueSettingUpdatesByName
        );

        HierarchySettingsService hierarchySettingsServiceInstance = HierarchySettingsService.getInstance();

        Test.startTest();
        Boolean updateResult = hierarchySettingsServiceInstance.updateHierarchySettings(
            hierarchySettingsChangesVModelListValuesEmpty
        );
        Test.stopTest();

        System.assertEquals(true, updateResult, 'Update to string value should complete successfully.');

        Hierarchy_Settings__c updatedHierarchySettings = UTIL_CustomSettings_API.getSettings();

        System.assertEquals(
            'Original Value1;Original Value2',
            updatedHierarchySettings.Accounts_to_Delete__c,
            'Accounts_to_Delete__c value should remain unchanged.'
        );
    }

    /**************************************************************************************************************************
     * @description Test method to verify that the updateHierarchySettings method does not update Hierarchy Settings fields
     * when updates for a primitive data type are not specified.
     ***************************************************************************************************************************/
    @isTest
    private static void updateHierarchySettingsWithSingleValuesEmpty() {
        PermissionSetMapper.instance = new STUB_PermissionSetMapperHasAccess();
        HierarchySettingsMapper.instance = new STUB_HierarchySettingsMapper();

        Hierarchy_Settings__c hierarchySettings = UTIL_CustomSettings_API.getSettingsForTests(
            new Hierarchy_Settings__c(Account_Processor__c = 'Original Value')
        );

        Map<String, String> singleValueSettingUpdatesByName = new Map<String, String>();

        HierarchySettingsChangesVModel hierarchySettingsChangesVModelEmptySingleValues = new HierarchySettingsChangesVModel(
            singleValueSettingUpdatesByName,
            new Map<String, List<String>>()
        );

        HierarchySettingsService hierarchySettingsServiceInstance = HierarchySettingsService.getInstance();

        Test.startTest();
        Boolean updateResult = hierarchySettingsServiceInstance.updateHierarchySettings(
            hierarchySettingsChangesVModelEmptySingleValues
        );
        Test.stopTest();

        System.assertEquals(true, updateResult, 'Update to string value should complete successfully.');

        Hierarchy_Settings__c updatedHierarchySettings = UTIL_CustomSettings_API.getSettings();

        System.assertEquals(
            'Original Value',
            updatedHierarchySettings.Account_Processor__c,
            'Account Processor value should remain unchanged.'
        );
    }

    /**************************************************************************************************************************
     * @description Test method to verify that the updateHierarchySettings method throws an error when a field is mapped to a
     * Hierarchy Settings field with the wrong data type is updated.
     ***************************************************************************************************************************/
    @isTest
    private static void updateHierarchySettingsWithSingleValuesInValidDateTime() {
        PermissionSetMapper.instance = new STUB_PermissionSetMapperHasAccess();

        Hierarchy_Settings__c hierarchySettings = UTIL_CustomSettings_API.getSettingsForTests(
            new Hierarchy_Settings__c(Async_Error_Check_Last_Run__c = Datetime.now().addDays(-1))
        );

        Map<String, String> singleValueSettingUpdatesByName = new Map<String, String>{
            'Async_Error_Check_Last_Run__c' => 'Updated Value'
        };

        HierarchySettingsChangesVModel hierarchySettingsChangesVModelInvalidType = new HierarchySettingsChangesVModel(
            singleValueSettingUpdatesByName,
            new Map<String, List<String>>()
        );

        HierarchySettingsService hierarchySettingsServiceInstance = HierarchySettingsService.getInstance();

        try {
            Test.startTest();
            Boolean updateResult = hierarchySettingsServiceInstance.updateHierarchySettings(
                hierarchySettingsChangesVModelInvalidType
            );
            Test.stopTest();
        } catch (System.TypeException e) {
            System.assertEquals(
                'Invalid date/time: Updated Value',
                e.getMessage(),
                'Invalid mapping should throw exception.'
            );
        } catch (HierarchySettingsService.InvalidSettingsException e) {
            System.assertEquals(
                Label.stgErrorInvalidSettings,
                e.getMessage(),
                'Invalid mapping should throw exception.'
            );
        }
    }

    /**************************************************************************************************************************
     * @description Test method to verify that the updateHierarchySettings method updates the specified Hierarchy Settings fields
     * of a collection type.
     ***************************************************************************************************************************/
    @isTest
    private static void updateHierarchySettingsWithListValuesValid() {
        PermissionSetMapper.instance = new STUB_PermissionSetMapperHasAccess();
        HierarchySettingsMapper.instance = new STUB_HierarchySettingsMapper();

        Hierarchy_Settings__c hierarchySettings = UTIL_CustomSettings_API.getSettingsForTests(
            new Hierarchy_Settings__c(Accounts_to_Delete__c = 'Original Value1;Original Value2')
        );

        Map<String, List<String>> listValueSettingUpdatesByName = new Map<String, List<String>>{
            'Accounts_to_Delete__c' => new List<String>{ 'Updated Value 1', 'Updated Value 2' }
        };

        HierarchySettingsChangesVModel hierarchySettingsChangesVModelListValues = new HierarchySettingsChangesVModel(
            new Map<String, String>(),
            listValueSettingUpdatesByName
        );

        HierarchySettingsService hierarchySettingsServiceInstance = HierarchySettingsService.getInstance();

        Test.startTest();
        Boolean updateResult = hierarchySettingsServiceInstance.updateHierarchySettings(
            hierarchySettingsChangesVModelListValues
        );
        Test.stopTest();

        System.assertEquals(true, updateResult, 'Update to string value should complete successfully.');

        Hierarchy_Settings__c updatedHierarchySettings = UTIL_CustomSettings_API.getSettings();

        System.assertEquals(
            'Updated Value 1;Updated Value 2',
            updatedHierarchySettings.Accounts_to_Delete__c,
            'Accounts_to_Delete__c value should be updated.'
        );
    }

    /**************************************************************************************************************************
     * @description Test method to verify that the updateHierarchySettings method throws an error when an
     * update is made for a field that is not in Hierarchy Settings.
     ***************************************************************************************************************************/
    @isTest
    private static void updateHierarchySettingsWithSingleValuesInValidFieldName() {
        PermissionSetMapper.instance = new STUB_PermissionSetMapperHasAccess();

        Hierarchy_Settings__c hierarchySettings = UTIL_CustomSettings_API.getSettingsForTests(
            new Hierarchy_Settings__c(Account_Processor__c = 'Original Value')
        );

        Map<String, String> singleValueSettingUpdatesByName = new Map<String, String>{
            'Account_Processor__c' => 'Updated Value',
            'Invalid_Field_Name__c' => 'Updated Invalid Value'
        };

        HierarchySettingsChangesVModel hierarchySettingsChangesVModelError = new HierarchySettingsChangesVModel(
            singleValueSettingUpdatesByName,
            new Map<String, List<String>>()
        );

        HierarchySettingsService hierarchySettingsServiceInstance = HierarchySettingsService.getInstance();

        try {
            Test.startTest();
            Boolean updateResult = hierarchySettingsServiceInstance.updateHierarchySettings(
                hierarchySettingsChangesVModelError
            );
            Test.stopTest();
        } catch (UTIL_Describe.SchemaDescribeException e) {
            System.assertEquals(
                'Invalid field name \'' +
                'Invalid_Field_Name__c' +
                '\'',
                e.getMessage(),
                'Invalid mapping should throw exception.'
            );
        } catch (HierarchySettingsService.InvalidSettingsException e) {
            System.assertEquals(
                Label.stgErrorInvalidSettings,
                e.getMessage(),
                'Invalid mapping should throw exception.'
            );
        }
    }

    /**************************************************************************************************************************
     * @description Test method to verify that the updateHierarchySettings method updates the Hierarchy Settings fields
     * for updates to fields with Datetime type.
     ***************************************************************************************************************************/
    @isTest
    private static void updateHierarchySettingsWithSingleValuesValidDateTime() {
        PermissionSetMapper.instance = new STUB_PermissionSetMapperHasAccess();
        HierarchySettingsMapper.instance = new STUB_HierarchySettingsMapper();

        Hierarchy_Settings__c hierarchySettings = UTIL_CustomSettings_API.getSettingsForTests(
            new Hierarchy_Settings__c(Async_Error_Check_Last_Run__c = Datetime.now().addDays(-3))
        );

        Map<String, String> singleValueSettingUpdatesByName = new Map<String, String>{
            'Async_Error_Check_Last_Run__c' => String.valueOf(DateTime.newInstance(2021, 3, 17, 5, 0, 0))
        };

        HierarchySettingsChangesVModel hierarchySettingsChangesVModelDateTimeValues = new HierarchySettingsChangesVModel(
            singleValueSettingUpdatesByName,
            new Map<String, List<String>>()
        );

        HierarchySettingsService hierarchySettingsServiceInstance = HierarchySettingsService.getInstance();

        Test.startTest();
        Boolean updateResult = hierarchySettingsServiceInstance.updateHierarchySettings(
            hierarchySettingsChangesVModelDateTimeValues
        );
        Test.stopTest();

        System.assertEquals(true, updateResult, 'Update to DateTime value should complete successfully.');

        Hierarchy_Settings__c updatedHierarchySettings = UTIL_CustomSettings_API.getSettings();

        System.assertEquals(
            DateTime.newInstance(2021, 3, 17, 5, 0, 0),
            updatedHierarchySettings.Async_Error_Check_Last_Run__c,
            'Async_Error_Check_Last_Run__c value should be updated.'
        );
    }

    /**************************************************************************************************************************
     * @description Test method to verify that the updateHierarchySettings method updates the Hierarchy Settings fields
     * for updates to fields with Boolean type.
     ***************************************************************************************************************************/
    @isTest
    private static void updateHierarchySettingsWithSingleValuesValidBoolean() {
        PermissionSetMapper.instance = new STUB_PermissionSetMapperHasAccess();
        HierarchySettingsMapper.instance = new STUB_HierarchySettingsMapper();

        Hierarchy_Settings__c hierarchySettings = UTIL_CustomSettings_API.getSettingsForTests(
            new Hierarchy_Settings__c(Allow_AutoCreated_Duplicates__c = false)
        );

        Map<String, String> singleValueSettingUpdatesByName = new Map<String, String>{
            'Allow_AutoCreated_Duplicates__c' => 'true'
        };

        HierarchySettingsChangesVModel hierarchySettingsChangesVModelBooleanValues = new HierarchySettingsChangesVModel(
            singleValueSettingUpdatesByName,
            new Map<String, List<String>>()
        );

        HierarchySettingsService hierarchySettingsServiceInstance = HierarchySettingsService.getInstance();

        Test.startTest();
        Boolean updateResult = hierarchySettingsServiceInstance.updateHierarchySettings(
            hierarchySettingsChangesVModelBooleanValues
        );
        Test.stopTest();

        System.assertEquals(true, updateResult, 'Update to Boolean value should complete successfully.');

        Hierarchy_Settings__c updatedHierarchySettings = UTIL_CustomSettings_API.getSettings();

        System.assertEquals(
            true,
            updatedHierarchySettings.Allow_AutoCreated_Duplicates__c,
            'Allow_AutoCreated_Duplicates__c value should be updated.'
        );
    }

    /**************************************************************************************************************************
     * @description Test method to verify that the updateHierarchySetting method updates the Hierarchy Settings fields for
     * updates to fields with String type.
     ***************************************************************************************************************************/
    @isTest
    private static void updateHierarchySettingsWithSingleValuesValidString() {
        PermissionSetMapper.instance = new STUB_PermissionSetMapperHasAccess();
        HierarchySettingsMapper.instance = new STUB_HierarchySettingsMapper();

        Hierarchy_Settings__c hierarchySettings = UTIL_CustomSettings_API.getSettingsForTests(
            new Hierarchy_Settings__c(Account_Processor__c = 'Original Value')
        );

        Map<String, String> singleValueSettingUpdatesByName = new Map<String, String>{
            'Account_Processor__c' => 'Updated Value'
        };

        HierarchySettingsChangesVModel hierarchySettingsChangesVModelStringValues = new HierarchySettingsChangesVModel(
            singleValueSettingUpdatesByName,
            new Map<String, List<String>>()
        );

        HierarchySettingsService hierarchySettingsServiceInstance = HierarchySettingsService.getInstance();

        Boolean updateResult;
        Test.startTest();
        updateResult = hierarchySettingsServiceInstance.updateHierarchySettings(
            hierarchySettingsChangesVModelStringValues
        );
        Test.stopTest();

        System.assertEquals(true, updateResult, 'Update to string value should complete successfully.');

        Hierarchy_Settings__c updatedHierarchySettings = UTIL_CustomSettings_API.getSettings();

        System.assertEquals(
            'Updated Value',
            updatedHierarchySettings.Account_Processor__c,
            'Account Processor value should be updated.'
        );
    }

    /**************************************************************************************************************************
     * @description Test method to verify that the updateHierarchySetting method updates the Hierarchy Settings fields for
     * updates to fields with TextArea type.
     ***************************************************************************************************************************/
    @isTest
    private static void updateHierarchySettingsWithSingleValuesValidTextArea() {
        PermissionSetMapper.instance = new STUB_PermissionSetMapperHasAccess();
        HierarchySettingsMapper.instance = new STUB_HierarchySettingsMapper();

        Hierarchy_Settings__c hierarchySettings = UTIL_CustomSettings_API.getSettingsForTests(
            new Hierarchy_Settings__c(Error_Notifications_To__c = 'Original Value')
        );

        Map<String, String> singleValueSettingUpdatesByName = new Map<String, String>{
            'Error_Notifications_To__c' => 'Updated Value'
        };

        HierarchySettingsChangesVModel hierarchySettingsChangesVModelStringValues = new HierarchySettingsChangesVModel(
            singleValueSettingUpdatesByName,
            new Map<String, List<String>>()
        );

        HierarchySettingsService hierarchySettingsServiceInstance = HierarchySettingsService.getInstance();

        Boolean updateResult;
        Test.startTest();
        updateResult = hierarchySettingsServiceInstance.updateHierarchySettings(
            hierarchySettingsChangesVModelStringValues
        );
        Test.stopTest();

        System.assertEquals(true, updateResult, 'Update to text area value should complete successfully.');

        Hierarchy_Settings__c updatedHierarchySettings = UTIL_CustomSettings_API.getSettings();

        System.assertEquals(
            'Updated Value',
            updatedHierarchySettings.Error_Notifications_To__c,
            'Error Notifications To value should be updated.'
        );
    }

    /**************************************************************************************************************************
     * @description Test method to verify that the denormalizeListSettingChange returns a semicolon-delimited string containing
     * all values in a specified list of strings.
     ***************************************************************************************************************************/
    @isTest
    private static void denormalizeListSettingChangeValid() {
        List<String> stringsToConvertList = new List<String>{ 'value1', 'value2', 'value3' };
        HierarchySettingsService hierarchySettingsServiceInstance = HierarchySettingsService.getInstance();

        Test.startTest();
        String denormalizedString = hierarchySettingsServiceInstance.denormalizeListSettingChange(stringsToConvertList);
        Test.stopTest();

        System.assertEquals(
            'value1;value2;value3',
            denormalizedString,
            'Should return semicolon-delimited string containing values in list.'
        );
    }

    /**************************************************************************************************************************
     * @description Test method to verify that the denormalizeListSettingChange returns an empty string when an empty list of
     * Strings is provided.
     ***************************************************************************************************************************/
    @isTest
    private static void denormalizeListSettingChangeEmptyList() {
        List<String> stringsToConvertList = new List<String>();
        HierarchySettingsService hierarchySettingsServiceInstance = HierarchySettingsService.getInstance();

        Test.startTest();
        String denormalizedString = hierarchySettingsServiceInstance.denormalizeListSettingChange(stringsToConvertList);
        Test.stopTest();

        System.assertEquals('', denormalizedString, 'Should return empty string.');
    }

    /**************************************************************************************************************************
     ****************************************************** STUBS **************************************************************
     **************************************************************************************************************************/

    /**************************************************************************************************************************************
     * @description Stub class to simulate a successful response from HierarchySettingsMapper
     **************************************************************************************************************************************/
    private class STUB_HierarchySettingsMapper extends HierarchySettingsMapper {
        public override Boolean updateHierarchySettings(HierarchySettingsModel hierarchySettingsModel) {
            return true;
        }
    }

    /*************************************************************************************************************
     * @description Stub class to simulate the response from PermissionSetMapper to return true
     */
    private class STUB_PermissionSetMapperHasAccess extends PermissionSetMapper {
        public override Boolean checkPermissionSetsWithCustomizeApplicationFromIds(Set<Id> permissionSetIdsSet) {
            return true;
        }
    }

    /*************************************************************************************************************
     * @description Stub class to simulate the response from PermissionSetMapper to return false
     */
    private class STUB_PermissionSetMapperNoAccess extends PermissionSetMapper {
        public override Boolean checkPermissionSetsWithCustomizeApplicationFromIds(Set<Id> permissionSetIdsSet) {
            return false;
        }
    }
}
public virtual with sharing class LeadConversionAccountNamingMapper {
    /*********************************************
    * @description Instance for Singleton Pattern
    **********************************************/
    @TestVisible
    private static LeadConversionAccountNamingMapper instance;

    /*********************************************************************
    * @description Empty constructor is not public for Singleton Pattern
    **********************************************************************/
    protected LeadConversionAccountNamingMapper() {}

    /*****************************************************************************
    * @description Static method to get the current instance for Singleton pattern
    * @return The instance of LeadConversionAccountNamingMapper.
    ******************************************************************************/
    public static LeadConversionAccountNamingMapper getInstance() {
        if (instance == null) {
            instance = new LeadConversionAccountNamingMapper();
        }

        return instance;
    }

    /*****************************************************************************
    * @description Retrieves an LeadConversionAccountNamingModel populated with
    * a list of Account Record Type Ids specified in Hierarchy Settings 
    * selected for renaming Accounts during Lead Conversion.
    * @return A LeadConversionAccountNamingModel
    *****************************************************************************/
    public virtual LeadConversionAccountNamingModel getLeadConversionAccountNamingModel() {
        Hierarchy_Settings__c hierarchySettings = UTIL_CustomSettingsFacade.getSettings();

        if (String.isEmpty(hierarchySettings.Lead_Converted_Account_RTypes__c) == true) {
            return new LeadConversionAccountNamingModel(new List<String>());
        }  

        // split on semi-colon and optional space
        List<String> recordTypesToNameList = hierarchySettings.Lead_Converted_Account_RTypes__c.split(';\\s?');
        return new LeadConversionAccountNamingModel(recordTypesToNameList);
    }
}
@isTest
private with sharing class LeadConversionAccountNamingMapper_TEST {
    /**************************************************************************************************************************
    * @description Test method to verify that the getInstance method returns a new instance of the 
    * LeadConversionAccountNamingMapper class when one does not already exist.
    ***************************************************************************************************************************/
    @isTest
    private static void getInstanceNew() {

        Test.startTest();
            LeadConversionAccountNamingMapper LeadConversionAccountNamingMapperInstance = 
                LeadConversionAccountNamingMapper.getInstance();
        Test.stopTest();

        System.assertEquals(
            LeadConversionAccountNamingMapper.instance, 
            LeadConversionAccountNamingMapperInstance, 
            'Instance of service class returned should match static instance variable.'
        );

        System.assertEquals(
            true, 
            LeadConversionAccountNamingMapperInstance != null, 
            'Instance of service class should not be null.'
        );
    }

    /**************************************************************************************************************************
    * @description Test method to verify that the getInstance method returns the existing instance of the 
    * LeadConversionAccountNamingMapper class when one already exists.
    ***************************************************************************************************************************/
    @isTest
    private static void getInstanceExisting() {

        Test.startTest();
            LeadConversionAccountNamingMapper LeadConversionAccountNamingMapperInstance1 = 
                LeadConversionAccountNamingMapper.getInstance();

            LeadConversionAccountNamingMapper LeadConversionAccountNamingMapperInstance2 = 
                LeadConversionAccountNamingMapper.getInstance();
        Test.stopTest();

        System.assertEquals(
            LeadConversionAccountNamingMapper.instance, 
            LeadConversionAccountNamingMapperInstance1, 
            'Instance of service class returned should match static instance variable.'
        );

        System.assertEquals(
            LeadConversionAccountNamingMapperInstance1, 
            LeadConversionAccountNamingMapperInstance2, 
            'Subsequent retrievals of service class instance should return existing instance.'
        );

        System.assertEquals(
            true, 
            LeadConversionAccountNamingMapperInstance1 != null, 
            'Instance of service class should not be null.'
        );
    }

    /**************************************************************************************************************************
    * @description Test method to verify that the getLeadConversionAccountNamingModel method correctly returns a list of
    * Ids corresponding to those specified by the semi-colon delimited list in Hierarchy Settings.
    ***************************************************************************************************************************/
    @isTest
    private static void getLeadConversionAccountNamingModelValid() {
        UTIL_CustomSettings_API.getSettingsForTests(
            new Hierarchy_Settings__c(
                Lead_Converted_Account_RTypes__c = 'Id1;Id2;Id3; Id4; Id5'
            )
        );

        LeadConversionAccountNamingMapper LeadConversionAccountNamingMapperInstance = 
                LeadConversionAccountNamingMapper.getInstance();

        Test.startTest();
        LeadConversionAccountNamingModel LeadConversionAccountNamingModel = 
            LeadConversionAccountNamingMapperInstance.getLeadConversionAccountNamingModel();
        Test.stopTest();


        for (Integer i = 0; i<5; i++) {
            System.assertEquals(
                'Id' + (i+1), 
                LeadConversionAccountNamingModel.accountRecordTypeIdsForLeadConversionWhenOrphanedList[i],
                'Id in list should match value at location ' + (i+1) + ' in semi-colon delimited list in hierarchy settings.'
            );
        }        
    }

    /**************************************************************************************************************************
    * @description Test method to verify that the getLeadConversionAccountNamingModel method correctly returns an empty list
    * Ids when there are no Account Record Types marked account renaming in the Hierarchy Settings.
    ***************************************************************************************************************************/
    @isTest
    private static void getLeadConversionAccountNamingModelEmpty() {
        UTIL_CustomSettings_API.getSettingsForTests(
            new Hierarchy_Settings__c(
                Lead_Converted_Account_RTypes__c = null
            )
        );

        LeadConversionAccountNamingMapper LeadConversionAccountNamingMapperInstance = 
                LeadConversionAccountNamingMapper.getInstance();

        Test.startTest();
        LeadConversionAccountNamingModel LeadConversionAccountNamingModel = 
            LeadConversionAccountNamingMapperInstance.getLeadConversionAccountNamingModel();
        Test.stopTest();

        System.assertEquals(
            0,
            LeadConversionAccountNamingModel.accountRecordTypeIdsForLeadConversionWhenOrphanedList.size(),
            'LeadConversionAccountNamingModel should contain an empty list of Strings.'
        );     
    }
}
public with sharing class LeadConversionAccountNamingModel {
    public List<String> accountRecordTypeIdsForLeadConversionWhenOrphanedList { get; private set; }

    /*******************************************************************************************************************
    * @description One parameter constructor.
    * @param  accountRecordTypeIdsForLeadConversionWhenOrphanedList A list representing the Account Record Type Ids 
    * selected for account naming during lead conversion.
    * @return An LeadConversionAccountNamingModel with all properties populated
    *******************************************************************************************************************/
    public LeadConversionAccountNamingModel(List<String> accountRecordTypeIdsForLeadConversionWhenOrphanedList) {
        this.accountRecordTypeIdsForLeadConversionWhenOrphanedList = accountRecordTypeIdsForLeadConversionWhenOrphanedList;
    }
}
@isTest
private inherited sharing class LeadConversionAccountNamingModel_TEST {

    /**********************************************************************
    * @description Test method to verify one parameter constructor returns
    * a populated model.
    **********************************************************************/
    @isTest 
    private static void oneParameterConstructor() {
        List<String> sampleIdsList = new List<String>{
            'testId1',
            'testId2'
        };

        Test.startTest();
        LeadConversionAccountNamingModel LeadConversionAccountNamingModel = 
            new LeadConversionAccountNamingModel(sampleIdsList);
        Test.stopTest();

        System.assertEquals(
            'testId1', 
            LeadConversionAccountNamingModel.accountRecordTypeIdsForLeadConversionWhenOrphanedList[0],
            'String should match value specified in parameter.'
        );

        System.assertEquals(
            'testId2', 
            LeadConversionAccountNamingModel.accountRecordTypeIdsForLeadConversionWhenOrphanedList[1],
            'String should match value specified in parameter.'
        );
    }
}
public virtual with sharing class LeadConversionAccountNamingService {
    /*********************************************
    * @description Instance for Singleton Pattern
    **********************************************/
    @TestVisible
    private static LeadConversionAccountNamingService instance;

    /*********************************************************************
    * @description Empty constructor is not public for Singleton Pattern
    **********************************************************************/
    protected LeadConversionAccountNamingService() {}

    /*****************************************************************************
    * @description Static method to get the current instance for Singleton pattern
    * @return The instance of LeadConversionAccountNamingService.
    ******************************************************************************/
    public static LeadConversionAccountNamingService getInstance() {
        if (instance == null) {
            instance = new LeadConversionAccountNamingService();
        }

        return instance;
    }

    /*****************************************************************************
    * @description Retrieve a LeadConversionAccountNamingModel populated with a
    * list of Account Record Type Ids from Hierarchy Settings that have been 
    * selected for Account Naming.
    * @return An LeadConversionAccountNamingModel
    *****************************************************************************/
    public LeadConversionAccountNamingModel getLeadConversionAccountNamingModel() {
        return this.locateLeadConversionAccountNamingMapper().getLeadConversionAccountNamingModel();
    }

    /*****************************************************************************
    * @description Retrieve an instance of LeadConversionAccountNamingMapper.
    * @return An instance of the LeadConversionAccountNamingMapper class
    *****************************************************************************/
    @TestVisible 
    private LeadConversionAccountNamingMapper locateLeadConversionAccountNamingMapper() {
        return LeadConversionAccountNamingMapper.getInstance();
    }
}
@isTest
private with sharing class LeadConversionAccountNamingService_TEST {
    /**************************************************************************************************************************
    * @description Test method to verify that the getInstance method returns a new instance of the 
    * LeadConversionAccountNamingService class when one does not already exist.
    ***************************************************************************************************************************/
    @isTest
    private static void getInstanceNew() {

        Test.startTest();
            LeadConversionAccountNamingService LeadConversionAccountNamingServiceInstance = 
                LeadConversionAccountNamingService.getInstance();
        Test.stopTest();

        System.assertEquals(
            LeadConversionAccountNamingService.instance, 
            LeadConversionAccountNamingServiceInstance, 
            'Instance of service class returned should match static instance variable.'
        );

        System.assertEquals(
            true, 
            LeadConversionAccountNamingServiceInstance != null, 
            'Instance of service class should not be null.'
        );
    }

    /**************************************************************************************************************************
    * @description Test method to verify that the getInstance method returns the existing instance of the 
    * LeadConversionAccountNamingService class when one already exists.
    ***************************************************************************************************************************/
    @isTest
    private static void getInstanceExisting() {

        Test.startTest();
            LeadConversionAccountNamingService LeadConversionAccountNamingServiceInstance1 = 
                LeadConversionAccountNamingService.getInstance();

            LeadConversionAccountNamingService LeadConversionAccountNamingServiceInstance2 = 
                LeadConversionAccountNamingService.getInstance();
        Test.stopTest();

        System.assertEquals(
            LeadConversionAccountNamingService.instance, 
            LeadConversionAccountNamingServiceInstance1, 
            'Instance of service class returned should match static instance variable.'
        );

        System.assertEquals(
            LeadConversionAccountNamingServiceInstance1, 
            LeadConversionAccountNamingServiceInstance2, 
            'Subsequent retrievals of service class instance should return existing instance.'
        );

        System.assertEquals(
            true, 
            LeadConversionAccountNamingServiceInstance1 != null, 
            'Instance of service class should not be null.'
        );
    }

    /**************************************************************************************************************************
    * @description Test method to verify that the getLeadConversionAccountNamingModel method returns an LeadConversionAccountNamingModel
    * populated with a list of strings matching the semi-colon delimited list specifed in Hierarchy Settings.
    ***************************************************************************************************************************/
    @isTest 
    private static void getLeadConversionAccountNamingModelValid() {
        LeadConversionAccountNamingMapper.instance = new STUB_LeadConversionAccountNamingMapper();

        LeadConversionAccountNamingService LeadConversionAccountNamingServiceInstance = 
                LeadConversionAccountNamingService.getInstance();

        Test.startTest();
        LeadConversionAccountNamingModel LeadConversionAccountNamingModel = 
            LeadConversionAccountNamingServiceInstance.getLeadConversionAccountNamingModel();
        Test.stopTest();

        System.assertEquals(
            'Id1', 
            LeadConversionAccountNamingModel.accountRecordTypeIdsForLeadConversionWhenOrphanedList[0],
            'Should match value set in stubbed model.'
        );

        System.assertEquals(
            'Id2', 
            LeadConversionAccountNamingModel.accountRecordTypeIdsForLeadConversionWhenOrphanedList[1],
            'Should match value set in stubbed model.'
        );
    }

    /**************************************************************************************************************************
    * @description Test method to verify that the locateLeadConversionAccountNamingMapper method returns an instance of 
    * the LeadConversionAccountNamingMapper class.
    ***************************************************************************************************************************/
    @isTest 
    private static void locateLeadConversionAccountNamingMapperValid() {
        LeadConversionAccountNamingService LeadConversionAccountNamingServiceInstance = 
                LeadConversionAccountNamingService.getInstance();

        Test.startTest();
        LeadConversionAccountNamingMapper LeadConversionAccountNamingMapperInstance = 
            LeadConversionAccountNamingServiceInstance.locateLeadConversionAccountNamingMapper();
        Test.stopTest();

        System.assertEquals(
            LeadConversionAccountNamingMapper.getInstance(), 
            LeadConversionAccountNamingMapperInstance,
            'Should return an instance of LeadConversionAccountNamingMapper.');
    }


    /**************************************************************************************************************************
    ****************************************************** STUB CLASS *********************************************************
    **************************************************************************************************************************/

    /*************************************************************************************************************
    * @description Stub class to simulate the response from LeadConversionAccountNamingMapper to return an 
    * LeadConversionAccountNamingModel for testing.
    *************************************************************************************************************/
    private class STUB_LeadConversionAccountNamingMapper extends LeadConversionAccountNamingMapper {
        public override LeadConversionAccountNamingModel getLeadConversionAccountNamingModel() {
            List<String> recordTypeIdsList = new List<String>{
                'Id1',
                'Id2'
            };

            return new LeadConversionAccountNamingModel(recordTypeIdsList);
        }
    }    
}
public virtual with sharing class LeadConversionAccountNamingVMapper {
    /**********************************************************************************
     * @description Instance for Singleton Pattern
     **********************************************************************************/
    @TestVisible
    private static LeadConversionAccountNamingVMapper instance;

    /**********************************************************************************
     * @description Empty constructor is not public for Singleton Pattern
     **********************************************************************************/
    protected LeadConversionAccountNamingVMapper() {
    }

    /**********************************************************************************
     * @description Static method to get the current instance for Singleton pattern
     * @return The instance of LeadConversionAccountNamingVMapper.
     **********************************************************************************/
    public static LeadConversionAccountNamingVMapper getInstance() {
        if (instance == null) {
            instance = new LeadConversionAccountNamingVMapper();
        }

        return instance;
    }

    /*******************************************************************************************************
     * @description Retrieve a DualListboxVModel representing the Account Record Types currently selected
     * for renaming accounts during Lead Conversion that available for selection.
     * @return  A DualListboxVModel
     *******************************************************************************************************/
    public virtual DualListboxVModel getLeadConversionAccountNamingViewModel() {
        // get current values set for deletion from hierarchy settings
        LeadConversionAccountNamingModel currentAccountNamingSettings = this.locateLeadConversionAccountNamingService()
            .getLeadConversionAccountNamingModel();

        // get all active account record types in org
        Map<Id, RecordTypeModel> activeAccountRecordTypeModelsById = this.locateRecordTypeService()
            .getActiveRecordTypeModelsById(
                this.locateRecordTypeService().getModelByIdMapForSObjectType(Account.SObjectType).values()
            );

        // create DualListboxValueVModels for each of the selected and available options
        List<DualListboxValueVModel> optionsDualListboxValuesList = new List<DualListboxValueVModel>();

        // populate available listbox - should contain all values regardless of if they are selected
        for (Id recordTypeId : activeAccountRecordTypeModelsById.keySet()) {
            optionsDualListboxValuesList.add(
                new DualListboxValueVModel(
                    activeAccountRecordTypeModelsById.get(recordTypeId).name,
                    activeAccountRecordTypeModelsById.get(recordTypeId).id
                )
            );
        }

        // populate selected listbox - only requires the String representing the value of the selected option
        List<String> selectedOptionsDualListboxValuesList = (List<String>) this.locateRecordTypeService()
            .filterListForValidIds(
                currentAccountNamingSettings.accountRecordTypeIdsForLeadConversionWhenOrphanedList,
                activeAccountRecordTypeModelsById.keySet()
            );

        return new DualListboxVModel(selectedOptionsDualListboxValuesList, optionsDualListboxValuesList);
    }

    /*****************************************************************************
     * @description Retrieve an instance of the LeadConversionAccountNamingService class.
     * @return An instance of LeadConversionAccountNamingService.
     *****************************************************************************/
    @TestVisible
    private LeadConversionAccountNamingService locateLeadConversionAccountNamingService() {
        return LeadConversionAccountNamingService.getInstance();
    }

    /*****************************************************************************
     * @description Retrieve an instance of the RecordTypeService class.
     * @return An instance of RecordTypeService.
     *****************************************************************************/
    @TestVisible
    private RecordTypeService locateRecordTypeService() {
        return RecordTypeService.getInstance();
    }
}
@isTest
private with sharing class LeadConversionAccountNamingVMapper_TEST {
    /**************************************************************************************************************************
     * @description Test method to verify that the getInstance method returns a new instance of the
     * LeadConversionAccountNamingMapper class when one does not already exist.
     ***************************************************************************************************************************/
    @isTest
    private static void getInstanceNew() {
        Test.startTest();
        LeadConversionAccountNamingMapper LeadConversionAccountNamingMapperInstance = LeadConversionAccountNamingMapper.getInstance();
        Test.stopTest();

        System.assertEquals(
            LeadConversionAccountNamingMapper.instance,
            LeadConversionAccountNamingMapperInstance,
            'Instance of mapper class returned should match static instance variable.'
        );
        System.assertEquals(
            true,
            LeadConversionAccountNamingMapperInstance != null,
            'Instance of mapper class should not be null.'
        );
    }

    /**************************************************************************************************************************
     * @description Test method to verify that the getInstance method returns the existing instance of the
     * LeadConversionAccountNamingMapper class when one already exists.
     ***************************************************************************************************************************/
    @isTest
    private static void getInstanceExisting() {
        Test.startTest();
        LeadConversionAccountNamingMapper LeadConversionAccountNamingMapperInstance1 = LeadConversionAccountNamingMapper.getInstance();
        LeadConversionAccountNamingMapper LeadConversionAccountNamingMapperInstance2 = LeadConversionAccountNamingMapper.getInstance();
        Test.stopTest();

        System.assertEquals(
            LeadConversionAccountNamingMapper.instance,
            LeadConversionAccountNamingMapperInstance1,
            'Instance of mapper class returned should match static instance variable.'
        );
        System.assertEquals(
            LeadConversionAccountNamingMapperInstance1,
            LeadConversionAccountNamingMapperInstance2,
            'Subsequent retrievals of mapper class instance should return existing instance.'
        );
        System.assertEquals(
            true,
            LeadConversionAccountNamingMapperInstance1 != null,
            'Instance of mapper class should not be null.'
        );
    }

    /**************************************************************************************************************************
     * @description Test to verify locateRecordTypeService() returns an instance of the RecordTypeService class.
     **************************************************************************************************************************/
    @isTest
    private static void locateRecordTypeServiceValid() {
        LeadConversionAccountNamingVMapper leadConversionAccountNamingMapperInstance = LeadConversionAccountNamingVMapper.getInstance();
        Test.startTest();
        RecordTypeService recordTypeServiceInstance = leadConversionAccountNamingMapperInstance.locateRecordTypeService();
        Test.stopTest();

        System.assertEquals(
            RecordTypeService.getInstance(),
            recordTypeServiceInstance,
            'Should return instance of RecordTypeService class.'
        );
        System.assertEquals(
            true,
            recordTypeServiceInstance != null,
            'Instance of RecordTypeService class should not be null.'
        );
    }

    /**************************************************************************************************************************
     * @description Test to verify locateLeadConversionAccountNamingService() returns an instance of the LeadConversionAccountNamingService class.
     **************************************************************************************************************************/
    @isTest
    private static void locateLeadConversionAccountNamingServiceValid() {
        LeadConversionAccountNamingVMapper LeadConversionAccountNamingMapperInstance = LeadConversionAccountNamingVMapper.getInstance();

        Test.startTest();
        LeadConversionAccountNamingService LeadConversionAccountNamingServiceInstance = LeadConversionAccountNamingMapperInstance.locateLeadConversionAccountNamingService();
        Test.stopTest();

        System.assertEquals(
            LeadConversionAccountNamingService.getInstance(),
            LeadConversionAccountNamingServiceInstance,
            'Should return instance of LeadConversionAccountNamingService class.'
        );
        System.assertEquals(
            true,
            LeadConversionAccountNamingServiceInstance != null,
            'Instance of LeadConversionAccountNamingService class should not be null.'
        );
    }

    /*************************************************************************************************************
     * @description Test method to verify getLeadConversionAccountNamingViewModel() returns a DualListboxVModel
     * representing only the active Account Record Types as selected and available options.  It also ensures that
     * all active Record Types are represented as available options regardless of whether they are also in the
     * selected list.
     *************************************************************************************************************/
    @isTest
    private static void getLeadConversionAccountNamingViewModelValid() {
        RecordTypeMapper.instance = new STUB_RecordTypeMapper();

        Hierarchy_Settings__c hierarchySettings = UTIL_CustomSettings_API.getSettingsForTests(
            new Hierarchy_Settings__c(Lead_Converted_Account_RTypes__c = '000000000000000001;000000000000000002')
        );

        LeadConversionAccountNamingVMapper leadConversionAccountNamingMapperInstance = LeadConversionAccountNamingVMapper.getInstance();

        Test.startTest();
        DualListboxVModel dualListboxVModel = leadConversionAccountNamingMapperInstance.getLeadConversionAccountNamingViewModel();
        Test.stopTest();

        System.assertEquals(
            1,
            dualListboxVModel.value.size(),
            'Should only display active account record type as selected value.'
        );
        System.assertEquals(
            '000000000000000001',
            dualListboxVModel.value[0],
            'Should only display active account record type as selected value.'
        );
        System.assertEquals(
            2,
            dualListboxVModel.options.size(),
            'Should only display active account record types as available options.'
        );
        System.assertEquals(
            '000000000000000001',
            dualListboxVModel.options[0].value,
            'Should only display active account record types as available options.'
        );
        System.assertEquals(
            '000000000000000003',
            dualListboxVModel.options[1].value,
            'Should only display active account record types as available options.'
        );
    }

    /**************************************************************************************************************************
     ****************************************************** STUB CLASS *********************************************************
     **************************************************************************************************************************/

    /*************************************************************************************************************
     * @description Stub class to simulate the response from RecordTypeMapper to return a map of Record Type model by Id
     */
    private class STUB_RecordTypeMapper extends RecordTypeMapper {
        public override Map<Id, RecordTypeModel> getModelByIdMapForSObjectType(Schema.SObjectType sObjectType) {
            Map<Id, RecordTypeModel> recordTypeModelsById = new Map<Id, RecordTypeModel>{
                '000000000000000001' => new RecordTypeModel(
                    '000000000000000001',
                    'Record Type 1',
                    'Record_Type_1',
                    true
                ),
                '000000000000000002' => new RecordTypeModel(
                    '000000000000000002',
                    'Record Type 2',
                    'Record_Type_2',
                    false
                ),
                '000000000000000003' => new RecordTypeModel(
                    '000000000000000003',
                    'Record Type 3',
                    'Record_Type_3',
                    true
                )
            };

            return recordTypeModelsById;
        }
    }
}
public virtual with sharing class LookupFieldMapper {
    /**********************************************************************************
    * @description Instance for Singleton Pattern
    **********************************************************************************/
    @TestVisible
    private static LookupFieldMapper instance;

    /**********************************************************************************
    * @description Empty constructor is not public for Singleton Pattern
    **********************************************************************************/
    protected LookupFieldMapper() {}

    /**********************************************************************************
    * @description Static method to get the current instance for Singleton pattern
    * @return The instance of LookupFieldMapper.
    **********************************************************************************/
    public static LookupFieldMapper getInstance() {
        if (instance == null) {
            instance = new LookupFieldMapper();
        }

        return instance;
    }

    /**********************************************************************************************************
    * @description Retrieve a map of LookupField models representing fields on a specified owner SObject type
    * that is a lookup to a specified target SObject type by field name.
    * @param  sObjectType  The SObject type where the field originates
    * @param  lookupToSObjectType The SObject type where the field lookup targets
    * @return Map<String, LookupFieldModel>
    **********************************************************************************************************/ 
    public virtual Map<String, LookupFieldModel> getModelByNameMapForSObjectType(SObjectType sObjectType, SObjectType lookupToSObjectType) {
        Map<String, LookupFieldModel> lookupFieldModelByName = new Map<String, LookupFieldModel>();

        Map<String, Schema.DescribeFieldResult> sObjectLookupFieldsByName = 
            UTIL_Describe.getFieldsOfType(sObjectType.getDescribe().getName(), 'REFERENCE');

        for (Schema.DescribeFieldResult lookupFieldResult : sObjectLookupFieldsByName.values()){

            if (lookupFieldResult.getReferenceTo().contains(lookupToSObjectType)){
                    lookupFieldModelByName.put(
                    lookupFieldResult.getName(), 
                    new LookupFieldModel(lookupFieldResult.getName(), lookupFieldResult.getLabel())
                );
            } 
        }

        return lookupFieldModelByName;
    }
}
@isTest
public with sharing class LookupFieldMapper_TEST {
    /**************************************************************************************************************************
    * @description Test method to verify that the getInstance method returns a new instance of the 
    * LookupFieldMapper class when one does not already exist.
    ***************************************************************************************************************************/
    @isTest
    private static void getInstanceNew() {

        Test.startTest();
            LookupFieldMapper LookupFieldMapperInstance = LookupFieldMapper.getInstance();
        Test.stopTest();

        System.assertEquals(LookupFieldMapper.instance, LookupFieldMapperInstance, 'Instance of mapper class returned should match static instance variable.');
        System.assertEquals(true, LookupFieldMapperInstance != null, 'Instance of mapper class should not be null.');
    }

    /**************************************************************************************************************************
    * @description Test method to verify that the getInstance method returns the existing instance of the 
    * LookupFieldMapper class when one already exists.
    ***************************************************************************************************************************/
    @isTest
    private static void getInstanceExisting() {

        Test.startTest();
            LookupFieldMapper LookupFieldMapperInstance1 = LookupFieldMapper.getInstance();
            LookupFieldMapper LookupFieldMapperInstance2 = LookupFieldMapper.getInstance();
        Test.stopTest();

        System.assertEquals(LookupFieldMapper.instance, LookupFieldMapperInstance1, 'Instance of mapper class returned should match static instance variable.');
        System.assertEquals(LookupFieldMapperInstance1, LookupFieldMapperInstance2, 'Subsequent retrievals of mapper class instance should return existing instance.');
        System.assertEquals(true, LookupFieldMapperInstance1 != null, 'Instance of mapper class should not be null.');
    }

    /**************************************************************************************************************************
    * @description Test to verify getModelByNameMapForSObjectTypeValid() returns a map with valid lookup field mappings
    * when a specified SObject contains fields that lookup to a specified SObject type.
    **************************************************************************************************************************/
    @isTest 
    private static void getModelByNameMapForSObjectTypeValid(){
        Test.startTest();
        Map<String, LookupFieldModel> lookupFieldModelByNameResult = 
            LookupFieldMapper.getInstance().getModelByNameMapForSObjectType(Contact.SObjectType, Account.SObjectType);
        Test.stopTest();

        System.assertEquals(false, lookupFieldModelByNameResult.isEmpty(), 'Contact object should have fields that lookup to Account.');
        System.assertEquals(true, lookupFieldModelByNameResult.containsKey(UTIL_Namespace.strTokenNSPrefix('Primary_Household__c')), 'Contact object should have field model for \'Primary Household\' field name.');
    }

    /**************************************************************************************************************************
    * @description Test to verify getModelByNameMapForSObjectTypeValid() returns an empty map when a specified SObject 
    * does not contain fields that lookup to a specified SObject type.
    **************************************************************************************************************************/
    @isTest 
    private static void getModelByNameMapForSObjectTypeEmpty(){
        Test.startTest();
        Map<String, LookupFieldModel> lookupFieldModelByNameResult = 
            LookupFieldMapper.getInstance().getModelByNameMapForSObjectType(Trigger_Handler__c.SObjectType, Error__c.SObjectType);
        Test.stopTest();

        System.assertEquals(true, lookupFieldModelByNameResult.isEmpty(), 'Trigger Handler object should have no fields that lookup to Error.');
    }    
}
public with sharing class LookupFieldModel {
    public String name; //developer name
    public String label;

    public LookupFieldModel(String name, String label) {
        this.name = name;
        this.label = label;
    }
}
public virtual with sharing class LookupFieldService {
    /*********************************************
    * @description Instance for Singleton Pattern
    **********************************************/
    @TestVisible
    private static LookupFieldService instance;

    /*********************************************************************
    * @description Empty constructor is not public for Singleton Pattern
    **********************************************************************/
    protected LookupFieldService() {}

    /*****************************************************************************
    * @description Static method to get the current instance for Singleton pattern
    * @return The instance of LookupFieldService.
    ******************************************************************************/
    public static LookupFieldService getInstance() {
            if (instance == null) {
                    instance = new LookupFieldService();
            }

            return instance;
    }

    /********************************************************************************************
    * @description Retrieve a map of LookupFieldModels by Name for a specified SObject 
    * that is a lookup to a specified SObject type.
    * @param  sObjectType The SObject type of the field model
    * @param lookupToSObjectType The SObject type that the field model looks up to 
    * @return A Map<String, LookupFieldModel>
    ********************************************************************************************/
    public virtual Map<String, LookupFieldModel> getModelByNameMapForSObjectType(
        SObjectType sObjectType, 
        SObjectType lookupToSObjectType
    ) {
        return this.locateLookupFieldMapper().getModelByNameMapForSObjectType(sObjectType, lookupToSObjectType);
    }

    /********************************************************************************************
    * @description Retrieve a map of LookupFieldModels by Label for lookup fields on an SObject.
    * @param  lookupFieldModelsByName A map of lookup fields on an SObject by developer name.
    * @return A Map<String, LookupFieldModel>
    ********************************************************************************************/
    public Map<String,LookupFieldModel> getModelByLabelMapForSObjectType(Map<String,LookupFieldModel> lookupFieldModelsByName) {
        Map<String, LookupFieldModel> lookupFieldModelsByLabel = new Map<String, LookupFieldModel>();

        for (LookupFieldModel lookupFieldModel : lookupFieldModelsByName.values()) {
            lookupFieldModelsByLabel.put(lookupFieldModel.label, lookupFieldModel);
        }

        return lookupFieldModelsByLabel;
    }

    /********************************************************************************************
    * @description Retrieve a LookupField model corresponding to a specified field name.
    * @param  fieldName  An SObject field name
    * @return A LookupFieldModel
    ********************************************************************************************/ 
    public virtual LookupFieldModel getLookupFieldModelFromNameMap(
        String fieldName, 
        Map<String, LookupFieldModel> lookupFieldModelByName) 
    {
        return lookupFieldModelByName.get(fieldName);
    }

    /******************************************************************************
    * @description Retrieve a lookup field model for a specified lookup field name or label.
    * @param LookupFieldNameOrLabel A string representing the name or label for a lookup field
    * @param LookupFieldModelByName A map of lookup field models by name
    * @param LookupFieldModelByLabel A map of lookup field models by label
    * @return A lookup field Model corresponding to the specified lookup field label or name
    ******************************************************************************/
    public virtual LookupFieldModel getLookupFieldModelFromNameAndLabelMaps(
        String lookupFieldNameOrLabel, 
        Map<String, LookupFieldModel> lookupFieldModelByName,
        Map<String, LookupFieldModel> lookupFieldModelByLabel
    ) { 
        LookupFieldModel lookupFieldModel = lookupFieldModelByName.get(lookupFieldNameOrLabel);

        if (lookupFieldModel == null) {
            lookupFieldModel = lookupFieldModelByLabel.get(lookupFieldNameOrLabel);
        }

        return lookupFieldModel;
    }

    /********************************************************************************************
    * @description Retrieve a LookupField model corresponding to a specified field label.
    * @param  fieldLabel  An SObject field label
    * @return A LookupFieldModel
    ********************************************************************************************/ 
    public virtual LookupFieldModel getLookupFieldModelFromLabelMap(
        String fieldLabel, 
        Map<String, LookupFieldModel> lookupFieldModelByLabel) 
    {
        return lookupFieldModelByLabel.get(fieldLabel);
    }

    /*****************************************************************************
    * @description Retrieves an instance of the LookupFieldMapper.
    * @return The instance of LookupFieldMapper.
    ******************************************************************************/
    @TestVisible
    private LookupFieldMapper locateLookupFieldMapper(){
        return LookupFieldMapper.getInstance();
    }
}
@isTest
public with sharing class LookupFieldService_TEST {
    /**************************************************************************************************************************
    * @description Test method to verify that the getInstance method returns a new instance of the 
    * LookupFieldService class when one does not already exist.
    ***************************************************************************************************************************/
    @isTest
    private static void getInstanceNew() {

        Test.startTest();
            LookupFieldService LookupFieldServiceInstance = LookupFieldService.getInstance();
        Test.stopTest();

        System.assertEquals(LookupFieldService.instance, LookupFieldServiceInstance, 'Instance of mapper class returned should match static instance variable.');
        System.assertEquals(true, LookupFieldServiceInstance != null, 'Instance of mapper class should not be null.');
    }

    /**************************************************************************************************************************
    * @description Test method to verify that the getInstance method returns the existing instance of the 
    * LookupFieldService class when one already exists.
    ***************************************************************************************************************************/
    @isTest
    private static void getInstanceExisting() {

        Test.startTest();
            LookupFieldService LookupFieldServiceInstance1 = LookupFieldService.getInstance();
            LookupFieldService LookupFieldServiceInstance2 = LookupFieldService.getInstance();
        Test.stopTest();

        System.assertEquals(LookupFieldService.instance, LookupFieldServiceInstance1, 'Instance of mapper class returned should match static instance variable.');
        System.assertEquals(LookupFieldServiceInstance1, LookupFieldServiceInstance2, 'Subsequent retrievals of mapper class instance should return existing instance.');
        System.assertEquals(true, LookupFieldServiceInstance1 != null, 'Instance of mapper class should not be null.');
    }

    /**************************************************************************************************************************
    * @description Test method to verify that the getModelByNameMapForSObjectType method returns the a map of LookupField models
    * by name when an SObject contains fields that lookup to the specified SObject type.
    ***************************************************************************************************************************/
    @isTest 
    private static void getModelByNameMapForSObjectTypeValid(){
        LookupFieldMapper.instance = new STUB_LookupFieldMapperValid();
        LookupFieldService lookupFieldServiceInstance = LookupFieldService.getInstance();

        Test.startTest();
        Map<String, LookupFieldModel> lookupFieldModelByNameResults = 
            lookupFieldServiceInstance.getModelByNameMapForSObjectType(Contact.SObjectType, Account.SObjectType);
        Test.stopTest();

        System.assertEquals(3, lookupFieldModelByNameResults.values().size(), 'Should return 3 mappings to Account lookup fields.');
        System.assertEquals(true, lookupFieldModelByNameResults.containsKey('testName1'), 'Should contain mapping for \'testName1\' field name.');
        System.assertEquals(true, lookupFieldModelByNameResults.containsKey('testName2'), 'Should contain mapping for \'testName2\' field name.');
        System.assertEquals(true, lookupFieldModelByNameResults.containsKey('testName3'), 'Should contain mapping for \'testName3\' field name.');
    }

    /**************************************************************************************************************************
    * @description Test method to verify that the getModelByNameMapForSObjectType method returns an empty map of LookupField models
    * by name when an SObject does not contain fields that lookup to the specified SObject type.
    ***************************************************************************************************************************/
    @isTest 
    private static void getModelByNameMapForSObjectTypeEmpty(){
        LookupFieldMapper.instance = new STUB_LookupFieldMapperEmpty();
        LookupFieldService lookupFieldServiceInstance = LookupFieldService.getInstance();

        Test.startTest();
        Map<String, LookupFieldModel> lookupFieldModelByNameResults = 
            lookupFieldServiceInstance.getModelByNameMapForSObjectType(Trigger_Handler__c.SObjectType, Error__c.SObjectType);
        Test.stopTest();

        System.assertEquals(0, lookupFieldModelByNameResults.values().size(), 'Trigger Handler should have no mappings to Error__c lookup fields.');
    }

    /**************************************************************************************************************************
    * @description Test method to verify that the getModelByLabelMapForSObjectType method returns an map of LookupField models
    * by label when a valid map of lookup field models by name is provided.
    ***************************************************************************************************************************/
    @isTest 
    private static void getModelByLabelMapForSObjectTypeValid(){
        Map<String, LookupFieldModel> lookupFieldsByName = new Map<String, LookupFieldModel>();
        lookupFieldsByName.put('LookupFieldName1', new LookupFieldModel('LookupFieldName1', 'LookupFieldLabel1'));
        lookupFieldsByName.put('LookupFieldName2', new LookupFieldModel('LookupFieldName2', 'LookupFieldLabel2'));
        lookupFieldsByName.put('LookupFieldName3', new LookupFieldModel('LookupFieldName3', 'LookupFieldLabel3'));

        LookupFieldService lookupFieldServiceInstance = LookupFieldService.getInstance();

        Test.startTest();
        Map<String, LookupFieldModel> lookupFieldModelByLabelResults = 
            lookupFieldServiceInstance.getModelByLabelMapForSObjectType(lookupFieldsByName);
        Test.stopTest();

        for (String lookupFieldKey : lookupFieldModelByLabelResults.keySet()) {
            System.assertEquals(true, lookupFieldKey.containsIgnoreCase('LookupFieldLabel'), 'Lookup field models should be mapped by Label');
        }
    }

    /**************************************************************************************************************************
    * @description Test method to verify that the getLookupFieldModelFromNameMap method returns a valid LookupField model when
    * searching by a name that matches one of the values in the provided map.
    ***************************************************************************************************************************/
    @isTest 
    private static void getLookupFieldModelFromNameMapValid() {
        Map<String, LookupFieldModel> lookupFieldModelByName = new Map<String, LookupFieldModel>();

        lookupFieldModelByName.put('TestName1', new LookupFieldModel('TestName1', 'TestLabel1'));
        lookupFieldModelByName.put('TestName2', new LookupFieldModel('TestName2', 'TestLabel2'));
        lookupFieldModelByName.put('TestName3', new LookupFieldModel('TestName3', 'TestLabel3'));

        LookupFieldService lookupFieldServiceInstance = LookupFieldService.getInstance();

        Test.startTest();
        LookupFieldModel lookupFieldModelResult = lookupFieldServiceInstance.getLookupFieldModelFromNameMap('TestName1', lookupFieldModelByName);
        Test.stopTest();

        System.assertEquals('TestLabel1', LookupFieldModelResult.label, 'Field model should have \'TestLabel1\' as label value.');
    }

    /**************************************************************************************************************************
    * @description Test method to verify that the getLookupFieldModelFromLabelMap method returns a valid LookupField model when
    * searching by a label that matches one of the values in the provided map.
    ***************************************************************************************************************************/
    @isTest 
    private static void getLookupFieldModelFromLabelMapValid() {
        Map<String, LookupFieldModel> lookupFieldModelByLabel = new Map<String, LookupFieldModel>();

        lookupFieldModelByLabel.put('TestLabel1', new LookupFieldModel('TestName1', 'TestLabel1'));
        lookupFieldModelByLabel.put('TestLabel2', new LookupFieldModel('TestName2', 'TestLabel2'));
        lookupFieldModelByLabel.put('TestLabel3', new LookupFieldModel('TestName3', 'TestLabel3'));

        LookupFieldService lookupFieldServiceInstance = LookupFieldService.getInstance();

        Test.startTest();
        LookupFieldModel lookupFieldModelResult = lookupFieldServiceInstance.getLookupFieldModelFromLabelMap('TestLabel1', lookupFieldModelByLabel);
        Test.stopTest();

        System.assertEquals('TestName1', LookupFieldModelResult.name, 'Field model should have \'TestName1\' as name value.');
    }

    /**************************************************************************************************************************
    * @description Test method to verify that the getLookupFieldModelFromNameMap method returns a null LookupField model when
    * searching by name that does not match the values in the provided map.
    ***************************************************************************************************************************/
    @isTest 
    private static void getLookupFieldModelFromNameMapInValid() {
        Map<String, LookupFieldModel> lookupFieldModelByName = new Map<String, LookupFieldModel>();

        lookupFieldModelByName.put('TestName1', new LookupFieldModel('TestName1', 'TestLabel1'));
        lookupFieldModelByName.put('TestName2', new LookupFieldModel('TestName2', 'TestLabel2'));
        lookupFieldModelByName.put('TestName3', new LookupFieldModel('TestName3', 'TestLabel3'));

        LookupFieldService lookupFieldServiceInstance = LookupFieldService.getInstance();

        Test.startTest();
        LookupFieldModel lookupFieldModelResult = lookupFieldServiceInstance.getLookupFieldModelFromNameMap('InvalidName', lookupFieldModelByName);
        Test.stopTest();

        System.assertEquals(null, lookupFieldModelResult, 'Should return null value.');
    }

    /**************************************************************************************************************************
    * @description Test method to verify that the getLookupFieldModelFromLabelMap method returns a null LookupField model when
    * searching by label that does not match the values in the provided map.
    ***************************************************************************************************************************/
    @isTest 
    private static void getLookupFieldModelFromLabelMapInValid() {
        Map<String, LookupFieldModel> lookupFieldModelByLabel = new Map<String, LookupFieldModel>();

        lookupFieldModelByLabel.put('TestLabel1', new LookupFieldModel('TestName1', 'TestLabel1'));
        lookupFieldModelByLabel.put('TestLabel2', new LookupFieldModel('TestName2', 'TestLabel2'));
        lookupFieldModelByLabel.put('TestLabel3', new LookupFieldModel('TestName3', 'TestLabel3'));

        LookupFieldService lookupFieldServiceInstance = LookupFieldService.getInstance();

        Test.startTest();
        LookupFieldModel lookupFieldModelResult = lookupFieldServiceInstance.getLookupFieldModelFromLabelMap('InvalidName', lookupFieldModelByLabel);
        Test.stopTest();

        System.assertEquals(null, lookupFieldModelResult, 'Should return null value.');
    }

    /**************************************************************************************************************************
    * @description Test method to verify that getLookupFieldModelFromNameAndLabelMaps returns a valid record type model when a match is found
    * for a specified developer name.
    ***************************************************************************************************************************/
    @isTest 
    private static void getLookupFieldModelFromNameAndLabelMapsByName() {
        Map<String, LookupFieldModel> lookupFieldModelsByName = new Map<String, LookupFieldModel>{
            'Lookup_Field_1' => new LookupFieldModel(
                'Lookup_Field_1',    
                'Lookup Field 1'
            )
        };

        Map<String, LookupFieldModel> lookupFieldModelsByLabel = new Map<String, LookupFieldModel>{
            'Lookup Field' => new LookupFieldModel(
                'Lookup_Field',
                'Lookup Field'
            )
        };

        LookupFieldService lookupFieldServiceInstance = LookupFieldService.getInstance();

        Test.startTest();
        LookupFieldModel lookupFieldModelResult = 
            lookupFieldServiceInstance.getLookupFieldModelFromNameAndLabelMaps(
                'Lookup_Field_1',
                lookupFieldModelsByName,
                lookupFieldModelsByLabel
            );
        Test.stopTest();

        System.assertEquals('Lookup_Field_1', lookupFieldModelResult.name, 'Record type model name should be \'Lookup_Field_1\'.');
        System.assertEquals('Lookup Field 1', lookupFieldModelResult.label, 'Record type model label should be \'Lookup Field 1\'.');
    }

    /**************************************************************************************************************************
    * @description Test method to verify that getLookupFieldModelFromNameAndLabelMaps returns a valid record type model when a match is found
    * for a specified label name.
    ***************************************************************************************************************************/
    @isTest 
    private static void getLookupFieldModelFromNameAndLabelMapsByLabel() {
        Map<String, LookupFieldModel> lookupFieldModelsByName = new Map<String, LookupFieldModel>{
            'Lookup_Field_1' => new LookupFieldModel(
                'Lookup_Field_1',    
                'Lookup Field 1' 
            )
        };

        Map<String, LookupFieldModel> lookupFieldModelsByLabel = new Map<String, LookupFieldModel>{
            'Lookup Field' => new LookupFieldModel(
                'Lookup_Field',
                'Lookup Field'
            )
        };

        LookupFieldService lookupFieldServiceInstance = LookupFieldService.getInstance();

        Test.startTest();
        LookupFieldModel lookupFieldModelResult = 
            lookupFieldServiceInstance.getLookupFieldModelFromNameAndLabelMaps(
                'Lookup Field',
                lookupFieldModelsByName,
                lookupFieldModelsByLabel
            );
        Test.stopTest();

        System.assertEquals('Lookup_Field', lookupFieldModelResult.name, 'Lookup field model name should be \'Lookup_Field\'.');
        System.assertEquals('Lookup Field', lookupFieldModelResult.label, 'Lookup field model label should be \'Lookup Field\'.');
    }

    /**************************************************************************************************************************
    * @description Test method to verify that getLookupFieldModelFromNameAndLabelMaps returns a null record type model when no match is found
    * for a specified developer or label name.
    ***************************************************************************************************************************/
    @isTest 
    private static void getLookupFieldModelFromNameAndLabelMapsNull() {
        Map<String, LookupFieldModel> lookupFieldModelsByName = new Map<String, LookupFieldModel>{
            'Lookup_Field_1' => new LookupFieldModel(
                'Lookup_Field_1', 
                'Lookup Field 1'
            )
        };

        Map<String, LookupFieldModel> lookupFieldModelsByLabel = new Map<String, LookupFieldModel>{
            'Lookup Field' => new LookupFieldModel(
                'Lookup_Field', 
                'Lookup Field'
            )
        };

        LookupFieldService lookupFieldServiceInstance = LookupFieldService.getInstance();

        Test.startTest();
        LookupFieldModel lookupFieldModelResult = 
            lookupFieldServiceInstance.getLookupFieldModelFromNameAndLabelMaps(
                'Non Existent Lookup Field Name',
                lookupFieldModelsByName,
                lookupFieldModelsByLabel
            );
        Test.stopTest();

        System.assertEquals(null, lookupFieldModelResult, 'Lookup field model should be null.');
    }

    /**************************************************************************************************************************
    ****************************************************** STUB CLASS *********************************************************
    **************************************************************************************************************************/

    /*************************************************************************************************************
    * @description Stub class to simulate the response from LookupFieldMapper to return Map<String, LookupFieldModel> 
    * for LookupField models by name and by label with valid mappings
    *************************************************************************************************************/
    private class STUB_LookupFieldMapperValid extends LookupFieldMapper {
        public override Map<String, LookupFieldModel> getModelByNameMapForSObjectType(SObjectType sObjectType, SObjectType lookupToSObjectType) {
            Map<String, LookupFieldModel> testLookupFieldModelsByName = new Map<String, LookupFieldModel>();

            testLookupFieldModelsByName.put('testName1', new LookupFieldModel('testName1', 'testLabel1'));
            testLookupFieldModelsByName.put('testName2', new LookupFieldModel('testName2', 'testLabel2'));
            testLookupFieldModelsByName.put('testName3', new LookupFieldModel('testName3', 'testLabel3'));

            return testLookupFieldModelsByName;
        }
    }

    /*************************************************************************************************************
    * @description Stub class to simulate the response from LookupFieldMapper to return Map<String, LookupFieldModel> 
    * for LookupField models by name and by label with empty mappings
    *************************************************************************************************************/
    private class STUB_LookupFieldMapperEmpty extends LookupFieldMapper {
        public override Map<String, LookupFieldModel> getModelByNameMapForSObjectType(SObjectType sObjectType, SObjectType lookupToSObjectType) {
            return new Map<String, LookupFieldModel>();
        }
    }
}
public virtual with sharing class MAPR_CON_PreferredEmailFields {

    /*********************************************
    * @description Instance for Singleton Pattern
    **********************************************/
    @TestVisible
    private static MAPR_CON_PreferredEmailFields instance;

    /***********************************************
    * @description preferredEmailFieldSettingsModel
    ***********************************************/
    @TestVisible
    private static MODL_PreferredEmailSettings preferredEmailFieldSettingsModel;

    /*****************************************************************************
    * @description Static method to get the current instance for Singleton pattern
    * @return The instance of MAPR_CON_PreferredEmailFields.
    ******************************************************************************/
    public static MAPR_CON_PreferredEmailFields getInstance() {

        if (instance == null) {
            instance = new MAPR_CON_PreferredEmailFields();
        }

        return instance;
    }

    /*********************************************************************
    * @description Empty constructor is not public for Singleton Pattern
    **********************************************************************/
    protected MAPR_CON_PreferredEmailFields() {}

    /**************************************************************************************
    * @description Returns the cached MODL_PreferredEmailSettings
    * @return MODL_PreferredEmailSettings
    **************************************************************************************/
    public MODL_PreferredEmailSettings getPreferredEmailSettingsModel() {

        if (preferredEmailFieldSettingsModel != null) {
            return preferredEmailFieldSettingsModel;
        }

        preferredEmailFieldSettingsModel = this.createEmailFieldSettingsModel();
        return preferredEmailFieldSettingsModel;
    }

    /**************************************************************************************
    * @description Returns the MODL_PreferredEmailSettings
    * @return MODL_PreferredEmailSettings
    **************************************************************************************/
    @TestVisible
    private MODL_PreferredEmailSettings createEmailFieldSettingsModel() {

        Boolean isPreferredEmailValidationEnabled = this.getPreferredEmailValidationEnabled();
        Map<String, Schema.DescribeFieldResult> contactEmailFieldsByApiName = this.getContactEmailFieldByApiName();
        Schema.DescribeFieldResult standardEmailField = contactEmailFieldsByApiName.get('Email');
        Map<String, String> preferredEmailPicklistValuesByLabel = this.getPreferredEmailPicklistValuesByLabel();
        Map<String, String> legacyPreferredEmailPicklistValuesByLabel = this.getLegacyPreferredEmailPicklistValuesByLabel();
        Map<String, String> preferredEmailPicklistLabelByApiName = this.getPreferredEmailPicklistLabelByApiName();
        String alternateEmailFieldPrefLabel;
        Map<String, String> edaEmailFieldAPINamesByLabel = this.getEDAEmailFieldsApiNamesByLabel(contactEmailFieldsByApiName);
        List<MODL_PreferredEmailField> prefEmailFieldModels = new List<MODL_PreferredEmailField>();
        EDAEmailFieldsModel edaEmailFieldModel = new EDAEmailFieldsModel(edaEmailFieldAPINamesByLabel);

        /* Construct a List of MODL_PreferredEmailField.cls records and alternateEmailFieldPrefLabel
           to be then used to create and return MODL_PreferredEmailSettings.cls record */
        for (String contactEmailfieldAPIName: contactEmailFieldsByApiName.keySet()) {

            String contactEmailFieldLabel = contactEmailFieldsByApiName.get(contactEmailfieldAPIName).getLabel();

            if (contactEmailfieldAPIName == standardEmailField.getName() || edaEmailFieldModel.hasDuplicateLabelForEDAField(contactEmailFieldLabel, contactEmailfieldAPIName) == true) {
                continue;
            }

            String preferredLabel = this.getPreferredLabelFromLabel(contactEmailFieldLabel, preferredEmailPicklistValuesByLabel, legacyPreferredEmailPicklistValuesByLabel);
            MODL_PreferredEmailField prefEmailFieldModel = new MODL_PreferredEmailField(contactEmailFieldLabel, contactEmailfieldAPIName, PreferredLabel);

            if (contactEmailfieldAPIName == UTIL_Namespace.StrTokenNSPrefix('AlternateEmail__c')) {
                alternateEmailFieldPrefLabel = prefEmailFieldModel.preferredLabel ;
            }
            prefEmailFieldModels.add(prefEmailFieldModel);
        }

        MODL_PreferredEmailSettings prefEmailSettingsModel = new MODL_PreferredEmailSettings(prefEmailFieldModels, alternateEmailFieldPrefLabel, standardEmailField.getLabel(), isPreferredEmailValidationEnabled, preferredEmailPicklistLabelByApiName);

        return prefEmailSettingsModel;
    }

    /**************************************************************************************
    * @description Returns the prefLabel that needs to be set for Preferred Email
    * @return prefLabel the prefLabel that needs to be set for Preferred Email
    **************************************************************************************/
    @TestVisible
    private String getPreferredLabelFromLabel(String emailTypeFieldLabel, Map<String, String> preferredEmailPicklistValuesByLabel, Map<String, String> legacyPreferredEmailPicklistValuesByLabel) {
        String prefLabel;
        if (preferredEmailPicklistValuesByLabel.containsKey(emailTypeFieldLabel)) {  
            prefLabel = preferredEmailPicklistValuesByLabel.get(emailTypeFieldLabel);
            return prefLabel;  
        }

        if (legacyPreferredEmailPicklistValuesByLabel.containsKey(emailTypeFieldLabel)) {  
            prefLabel = legacyPreferredEmailPicklistValuesByLabel.get(emailTypeFieldLabel);
            return prefLabel;  
        }

        prefLabel = emailTypeFieldLabel;
        return prefLabel;
    }

    /**************************************************************************************
    * @description Returns the value of Disable Preferred Email Enforcement custom settings
    * @return Boolean
    **************************************************************************************/
    @TestVisible
    private Boolean getPreferredEmailValidationEnabled() {
        return !UTIL_CustomSettingsFacade.getSettings().Disable_Preferred_Email_Enforcement__c;
    }

    /**************************************************************************************
    * @description Returns a map of Contact Email Field Describes by their API Names
    * @return Map<String, Schema.DescribeFieldResult>
    **************************************************************************************/
    @TestVisible
    private Map<String, Schema.DescribeFieldResult> getContactEmailFieldByApiName() {
        return UTIL_Describe.getFieldsOfType('Contact', 'EMAIL');
    }

    /**************************************************************************************
    * @description Returns a map of Preferred Email's picklist values by their labels
    * @return Map<String, String>
    **************************************************************************************/
    @TestVisible
    private Map<String, String> getPreferredEmailPicklistValuesByLabel() {
        return UTIL_Describe.getpicklistEntriesLabelToAPIMap('Contact', UTIL_Namespace.StrTokenNSPrefix('') + 'Preferred_Email__c');
    }

    /**************************************************************************************
    * @description Returns a map of Preferred Email's Legacy picklist values by their labels
    * @return Map<String, String>
    **************************************************************************************/
    @TestVisible
    private Map<String, String> getLegacyPreferredEmailPicklistValuesByLabel() {

        Map<String,String> legacyPreferredEmailPicklistValuesByLabel = new Map<String,String> {
                  'University Email' => 'University',
                 'Work Email' => 'Work',
                 'Alternate Email' => 'Alternate'
                };
      
        return legacyPreferredEmailPicklistValuesByLabel;            
    }

    /**************************************************************************************
    * @description Returns a map of Preferred Email's picklist Labels by their API names
    * @return Map<String, String>
    **************************************************************************************/
    @TestVisible
    private Map<String, String> getPreferredEmailPicklistLabelByApiName() {
        return UTIL_Describe.getPicklistEntriesApiToLabelMap('Contact', UTIL_Namespace.StrTokenNSPrefix('') + 'Preferred_Email__c');
    }

    /**************************************************************************************
    * @description Returns True if the API field name passed is an EDA field else false
    * @param fieldApiName The Contact Field's API name to check for
    * @return Boolean
    **************************************************************************************/
    @TestVisible
    private Boolean isEDAField(String fieldApiName) {

        String namespace = UTIL_Namespace.getNamespace();

        if (String.isNotBlank(namespace)) {
            return fieldApiName.startsWithIgnoreCase(namespace);
        }

        return fieldApiName.endsWithIgnoreCase('__c');
    }

    /**************************************************************************************
    * @description Returns A map of EDA Email Field Names By Label
    * @param contactFieldApiNames A map of Field Describes for Contact object by API names
    * @return edaEmailFieldAPINamesByLabels A map of EDA Email Field Names By Label
    **************************************************************************************/
    @TestVisible
    private Map<String,String> getEDAEmailFieldsApiNamesByLabel(Map<String, Schema.DescribeFieldResult> contactFieldApiNames) {

        Map<String, String> edaEmailFieldAPINamesByLabels = new Map<String, String>();

        for (String fieldApiName : contactFieldApiNames.keySet()) {
            if (this.isEDAField(fieldApiName) == true) {
                edaEmailFieldAPINamesByLabels.put(contactFieldApiNames.get(fieldApiName).getLabel(), fieldApiName);
            } 
        }

        return edaEmailFieldAPINamesByLabels;
    }

    /*******************************************************************************************************
    * @description A value object to determine if a field label or API name is a part of EDA Email fields
    ********************************************************************************************************/
    private class EDAEmailFieldsModel {

        private Map<String, String> edaEmailFieldApiNamesByLabel;
 
        private EDAEmailFieldsModel(Map<String, String> edaEmailFieldApiNamesByLabel) {
            this.edaEmailFieldApiNamesByLabel = edaEmailFieldApiNamesByLabel;
        }

        private Boolean hasDuplicateLabelForEDAField(String fieldLabel, String fieldApiName) {
            if (edaEmailFieldApiNamesByLabel.keySet().contains(fieldLabel) == false || 
                edaEmailFieldApiNamesByLabel.get(fieldLabel) == fieldApiName) {
                return false;
            }
            return true;
        }
    }

}
@isTest
private class MAPR_CON_PreferredEmailFields_TEST {

    /**************************************************************************************************************************
    * @description Test method to verify that the getInstance method returns a new instance of the 
    * MAPR_CON_PreferredEmailFields class when one does not already exist.
    ***************************************************************************************************************************/
    @isTest
    private static void getInstanceNew() {

        Test.startTest();
            MAPR_CON_PreferredEmailFields maprConPreferredEmailFieldsInstance = MAPR_CON_PreferredEmailFields.getInstance();
        Test.stopTest();

        System.assertEquals(MAPR_CON_PreferredEmailFields.instance, maprConPreferredEmailFieldsInstance, 'Instance of service class returned should match static instance variable.');
        System.assertEquals(true, maprConPreferredEmailFieldsInstance != null, 'Instance of service class should not be null.');
    }

    /**************************************************************************************************************************
    * @description Test method to verify that the getInstance method returns the existing instance of the 
    * MAPR_CON_PreferredEmailFields class when one already exists.
    ***************************************************************************************************************************/
    @isTest
    private static void getInstanceExisting() {

        Test.startTest();
            MAPR_CON_PreferredEmailFields maprConPreferredEmailFieldsInstance1 = MAPR_CON_PreferredEmailFields.getInstance();
            MAPR_CON_PreferredEmailFields maprConPreferredEmailFieldsInstance2 = MAPR_CON_PreferredEmailFields.getInstance();
        Test.stopTest();

        System.assertEquals(MAPR_CON_PreferredEmailFields.instance, maprConPreferredEmailFieldsInstance1, 'Instance of service class returned should match static instance variable.');
        System.assertEquals(maprConPreferredEmailFieldsInstance1, maprConPreferredEmailFieldsInstance2, 'Subsequent retrievals of service class instance should return existing instance.');
        System.assertEquals(true, maprConPreferredEmailFieldsInstance1 != null, 'Instance of service class should not be null.');
    }

    /*********************************************************************************************************************************************
    * @description Test method to verify that the getPreferredEmailSettingsModel returns MODL_PreferredEmailSettings
    **********************************************************************************************************************************************/
    @isTest
    private static void getPreferredEmailSettingsModelNew() {

        Test.startTest();
            MODL_PreferredEmailSettings prefEmailSettingsModel = MAPR_CON_PreferredEmailFields.getInstance().getPreferredEmailSettingsModel();
        Test.stopTest();

        System.assertEquals(false, prefEmailSettingsModel.preferredEmailFieldModels.isEmpty());
        System.assertEquals(true, String.isNotBlank(prefEmailSettingsModel.alternateEmailPreferredLabel));
        System.assertEquals(true, String.isNotBlank(prefEmailSettingsModel.emailLabel));
        System.assertEquals(false, prefEmailSettingsModel.preferredEmailPicklistLabelByApiName.isEmpty());
        
    }
    
    /*********************************************************************************************************************************************
    * @description Test method to verify that the getPreferredEmailSettingsModel returns cached MODL_PreferredEmailSettings
    **********************************************************************************************************************************************/
    @isTest
    private static void getPreferredEmailSettingsModelExisting() {

        MODL_PreferredEmailSettings prefEmailSettingsModel1 = MAPR_CON_PreferredEmailFields.getInstance().getPreferredEmailSettingsModel();
        Test.startTest();
            MODL_PreferredEmailSettings prefEmailSettingsModel2 = MAPR_CON_PreferredEmailFields.getInstance().getPreferredEmailSettingsModel();
        Test.stopTest();

        System.assertEquals(prefEmailSettingsModel1, prefEmailSettingsModel2);
        System.assertEquals(false, prefEmailSettingsModel2.preferredEmailFieldModels.isEmpty());
        System.assertEquals(true, String.isNotBlank(prefEmailSettingsModel2.alternateEmailPreferredLabel));
        System.assertEquals(true, String.isNotBlank(prefEmailSettingsModel2.emailLabel));
        System.assertEquals(false, prefEmailSettingsModel2.preferredEmailPicklistLabelByApiName.isEmpty());

    }
    
    /*********************************************************************************************************************************************
    * @description Test method to verify that the createEmailFieldSettingsModel returns MODL_PreferredEmailSettings
    **********************************************************************************************************************************************/
    @isTest
    private static void createEmailFieldSettingsModel() {

        Test.startTest();
            MODL_PreferredEmailSettings prefEmailSettingsModel = MAPR_CON_PreferredEmailFields.getInstance().createEmailFieldSettingsModel();
        Test.stopTest();

        System.assertEquals(false, prefEmailSettingsModel.preferredEmailFieldModels.isEmpty());
        System.assertEquals(true, String.isNotBlank(prefEmailSettingsModel.alternateEmailPreferredLabel));
        System.assertEquals(true, String.isNotBlank(prefEmailSettingsModel.emailLabel));
        System.assertEquals(false, prefEmailSettingsModel.preferredEmailPicklistLabelByApiName.isEmpty());

    }

    /*************************************************************************************************************************************************************
    * @description  Test method to verify that the getPreferredLabelFromLabel returns a Label when values is contained in preferredEmailPicklistValuesByLabel map
    *************************************************************************************************************************************************************/
    @isTest
    private static void getPreferredLabelFromLabel() {
        Map<String,String> legacyPreferredEmailPicklistValuesByLabel = new Map<String,String> {
                  'University Email' => 'University',
                 'Work Email' => 'Work',
                 'Alternate Email' => 'Alternate'
                };
                    
        Test.startTest();
            String preferredLabel =  MAPR_CON_PreferredEmailFields.getInstance().getPreferredLabelFromLabel('University Email', 
                                                                                                     UTIL_Describe.getpicklistEntriesLabelToAPIMap('Contact', UTIL_Namespace.StrTokenNSPrefix('') + 'Preferred_Email__c'),
                                                                                                    legacyPreferredEmailPicklistValuesByLabel);
        Test.stopTest();
        
        System.assertEquals('University Email', preferredLabel);
    }
    
    /******************************************************************************************************************************************************************
    * @description  Test method to verify that the getPreferredLabelFromLabel returns a Label when values is contained in legacyPreferredEmailPicklistValuesByLabel map
    ******************************************************************************************************************************************************************/
    @isTest
    private static void getPreferredLabelFromLabelLegacy() {
        Map<String, String> preferredEmailPicklistLabelByApiNameCustom = new Map<String, String>{
                'University' => 'University',
                'Work' => 'Work',
                'Alternate' => 'Alternate'
            };
                
         Map<String,String> legacyPreferredEmailPicklistValuesByLabel = new Map<String,String> {
            'University Email' => 'University',
                'Work Email' => 'Work',
                'Alternate Email' => 'Alternate'
             };
                    
        Test.startTest();
            String preferredLabel =  MAPR_CON_PreferredEmailFields.getInstance().getPreferredLabelFromLabel('University Email', 
                                                                                                     preferredEmailPicklistLabelByApiNameCustom,
                                                                                                     legacyPreferredEmailPicklistValuesByLabel);
        Test.stopTest();
        
        System.assertEquals('University', preferredLabel);
    }

    /******************************************************************************************************************************************************************
    * @description  Test method to verify that the getPreferredLabelFromLabel returns a Label when values is are
    * not in either preferredEmailPicklistValuesByLabel or legacyPreferredEmailPicklistValuesByLabel map
    ******************************************************************************************************************************************************************/
    @isTest
    private static void getPreferredLabelFromLabelCustom() {
        Map<String,String> legacyPreferredEmailPicklistValuesByLabel = new Map<String,String> {
            'University Email' => 'University',
                'Work Email' => 'Work',
                'Alternate Email' => 'Alternate'
                };
                    
        Test.startTest();
            String preferredLabel =  MAPR_CON_PreferredEmailFields.getInstance().getPreferredLabelFromLabel('Test Email Field', 
                                                                                                     UTIL_Describe.getpicklistEntriesLabelToAPIMap('Contact', UTIL_Namespace.StrTokenNSPrefix('') + 'Preferred_Email__c'),
                                                                                                    legacyPreferredEmailPicklistValuesByLabel);
        Test.stopTest();
        
        System.assertEquals('Test Email Field', preferredLabel);
    }

    /******************************************************************************************************************************************************************
    * @description Test method to verify that the getPreferredEmailValidationEnabled returns the negated value strored in Custom Settings
    ******************************************************************************************************************************************************************/
    @isTest
    private static void getPreferredEmailValidationEnabled() {

        UTIL_CustomSettingsFacade.getSettingsForTests(new Hierarchy_Settings__c
                                                      (Disable_Preferred_Email_Enforcement__c = true));
        
        Test.startTest();
            Boolean ispreferredEmailValidationEnabled = MAPR_CON_PreferredEmailFields.getInstance().getPreferredEmailValidationEnabled();
        Test.stopTest();
        
        System.assertEquals(false, ispreferredEmailValidationEnabled);

    }

    /*********************************************************************************************************************************************
    * @description  Test method to verify that the getContactEmailFieldByApiName returns a map of contact Email Field Describess By their API Names
    **********************************************************************************************************************************************/
    @isTest
    private static void getContactEmailFieldByApiName() {

        Test.startTest();
            Map<String, Schema.DescribeFieldResult> contactEmailFieldsByAPIName = MAPR_CON_PreferredEmailFields.getInstance().getContactEmailFieldByApiName();
        Test.stopTest();

        System.assertEquals(false, contactEmailFieldsByAPIName.isEmpty());
        System.assert(contactEmailFieldsByAPIName.get('Email') != null);
    }

    /*********************************************************************************************************************************************
    * @description Test method to verify that the getPreferredEmailPicklistValuesByLabel returns a map of contact Email Fields By their API Names
    **********************************************************************************************************************************************/
    @isTest
    private static void getPreferredEmailPicklistValuesByLabel() {

        Test.startTest();
            Map<String, String> contactEmailFieldsByAPIName = MAPR_CON_PreferredEmailFields.getInstance().getPreferredEmailPicklistValuesByLabel();
        Test.stopTest();

        System.assertEquals(false, contactEmailFieldsByAPIName.isEmpty());
    }

    /**********************************************************************************************************************************************************
    * @description Test method to verify that the getLegacyPreferredEmailPicklistValuesByLabel returns a map of contact legacy Email Fields By their API Names
    **********************************************************************************************************************************************************/
    @isTest
    private static void getLegacyPreferredEmailPicklistValuesByLabel() {

        Test.startTest();
            Map<String, String> contactEmailFieldsByAPIName = MAPR_CON_PreferredEmailFields.getInstance().getLegacyPreferredEmailPicklistValuesByLabel();
        Test.stopTest();

        System.assertEquals(false, contactEmailFieldsByAPIName.isEmpty());
        System.assertEquals('University', contactEmailFieldsByAPIName.get('University Email'));
        System.assertEquals('Work', contactEmailFieldsByAPIName.get('Work Email'));
        System.assertEquals('Alternate', contactEmailFieldsByAPIName.get('Alternate Email'));
    }

    /**********************************************************************************************************************************************************
    * @description Test method to verify that the getPreferredEmailPicklistLabelByApiName returns a map of contact legacy Email Fields By their API Names
    **********************************************************************************************************************************************************/
    @isTest
    private static void getPreferredEmailPicklistLabelByApiName() {

        Test.startTest();
            Map<String, String> preferredEmailPicklistLabelByApiName = MAPR_CON_PreferredEmailFields.getInstance().getPreferredEmailPicklistLabelByApiName();
        Test.stopTest();

        System.assertEquals(false, preferredEmailPicklistLabelByApiName.isEmpty());
    }

    /**********************************************************************************************************************************************************
    * @description Test method to verify that the isEDAField() returns true for a EDA field API name
    **********************************************************************************************************************************************************/
    @isTest
    private static void isEDAFieldPositiveTest() {

        Test.startTest();
            Boolean isEDAField = MAPR_CON_PreferredEmailFields.getInstance().isEDAField(UTIL_Namespace.StrTokenNSPrefix('') + 'Preferred_Email__c');
        Test.stopTest();

        System.assertEquals(true, isEDAField);
    }

    /**********************************************************************************************************************************************************
    * @description Test method to verify that the isEDAField() returns false for a standard field API name
    **********************************************************************************************************************************************************/
    @isTest
    private static void isEDAFieldNegativeTest() {

        Test.startTest();
            Boolean isEDAField = MAPR_CON_PreferredEmailFields.getInstance().isEDAField('Email');
        Test.stopTest();

        System.assertEquals(false, isEDAField);
    }

    /**********************************************************************************************************************************************************
    * @description Test method to verify that the getEDAEmailFieldsApiNamesByLabel() returns a map of edaEmailFieldAPINamesByLabels
    **********************************************************************************************************************************************************/
    @isTest
    private static void getEDAEmailFieldsApiNamesByLabelPoitiveTest() {

        Test.startTest();
            Map<String, String> edaEmailFieldAPINamesByLabels = MAPR_CON_PreferredEmailFields.getInstance().getEDAEmailFieldsApiNamesByLabel(UTIL_Describe.getFieldsOfType('Contact', 'EMAIL'));
        Test.stopTest();

        System.assertEquals(false, edaEmailFieldAPINamesByLabels.isEmpty());
    }

    /**********************************************************************************************************************************************************
    * @description Negative test for getEDAEmailFieldsApiNamesByLabel() to ensure the reurned Map is empty when no EDA Email fields are passed
    **********************************************************************************************************************************************************/
    @isTest
    private static void getEDAEmailFieldsApiNamesByLabelNegativeTest() {

        Map<String, Schema.DescribeFieldResult> contactEmailFieldDescribeByEmailAPI = new Map<String, Schema.DescribeFieldResult>();
        contactEmailFieldDescribeByEmailAPI.put('Email', UTIL_Describe.getFieldDescribe('Contact', 'Email'));

        Test.startTest();
            Map<String, String> edaEmailFieldAPINamesByLabels = MAPR_CON_PreferredEmailFields.getInstance().getEDAEmailFieldsApiNamesByLabel(contactEmailFieldDescribeByEmailAPI);
        Test.stopTest();

        System.assertEquals(true, edaEmailFieldAPINamesByLabels.isEmpty());
    }
}
public virtual with sharing class MAPR_PrimaryAffiliations {

    /*********************************************
    * @description Instance for Singleton Pattern
    **********************************************/
    @TestVisible
    private static MAPR_PrimaryAffiliations instance;

    /*****************************************************************************
    * @description Static method to get the current instance for Singleton pattern
    * @return The instance of MAPR_PrimaryAffiliations.
    ******************************************************************************/
    public static MAPR_PrimaryAffiliations getInstance() {
        if (instance == null) {
            instance = new MAPR_PrimaryAffiliations();
        }

        return instance;
    }

    /*********************************************************************
    * @description Empty constructor is not public for Singleton Pattern
    **********************************************************************/
    protected MAPR_PrimaryAffiliations() {}

    /**************************************************************************************
    * @description Returns the value of Affiliation_Record_Type_Enforced__c custom setting
    * @return boolean
    **************************************************************************************/
    @testVisible
    protected virtual boolean isPrimaryAffiliationValidationOn() {
        return UTIL_CustomSettingsFacade.getSettings().Affiliation_Record_Type_Enforced__c;
    }

    /**************************************************************************************
    * @description Returns a list of Models for Affiliation mappings
    * @return List<MODL_PrimaryAfflMapper>
    **************************************************************************************/
    public List<MODL_PrimaryAfflMapper> getModelsFromSettings() {
        List<Affl_Mappings__c> afflMappingsFromSettingsList = UTIL_CustomSettingsFacade.getPrimaryAfflMappings();
        return getModelsFromMappings(afflMappingsFromSettingsList);
    }

    /*********************************************************************************************************************
    * @description Returns a list of Models for Affiliation mappings for a given list of Affl_Mappings__c custom settings
    * @param afflMappingsList List of Affl_Mappings__c custom settings
    * @return List<MODL_PrimaryAfflMapper> List of models for the given list of Affl_Mappings__c custom settings
    *********************************************************************************************************************/
    @testVisible
    private List<MODL_PrimaryAfflMapper> getModelsFromMappings(List<Affl_Mappings__c> afflMappingsList) {
       List<MODL_PrimaryAfflMapper> affiliationModelsList = new List<MODL_PrimaryAfflMapper>();

       // Sets to ensure duplicate mappings won't have models added to the list to return
       Set<String> contactFieldAPINamesSet = new Set<String>();
       Set<String> accountRecordTypeIdsSet = new Set<String>();

        for (Affl_Mappings__c mapping: afflMappingsList) {
            MODL_PrimaryAfflMapper modelFromMapping = this.getModelFromMapping(mapping);

            if (modelFromMapping == null) {
                continue;
            }

            if ((contactFieldAPINamesSet.isEmpty() == false && contactFieldAPINamesSet.contains(modelFromMapping.getContactFieldApiName())) || 
                (accountRecordTypeIdsSet.isEmpty() == false && accountRecordTypeIdsSet.contains(modelFromMapping.getAccountRecordTypeId()))) {      
                continue;
            }

            affiliationModelsList.add(modelFromMapping);
            contactFieldAPINamesSet.add(modelFromMapping.getContactFieldApiName());
            accountRecordTypeIdsSet.add(modelFromMapping.getAccountRecordTypeId());

        }
       return affiliationModelsList;
    }

    /*****************************************************************************************************
    * @description Returns a Model for a given Affl_Mappings__c record
    * @param afflMapping An Affl_Mappings__c custom settings record
    * @return MODL_PrimaryAfflMapper A model for given Affl_Mappings__c record
    *****************************************************************************************************/
    @testVisible
    private MODL_PrimaryAfflMapper getModelFromMapping(Affl_Mappings__c afflMapping) {
        Boolean isValid = true;
        String invalidErrorMessage = '';

        List<MODL_PrimaryAfflMapper> primaryAfflModelsList = new List<MODL_PrimaryAfflMapper>();
        Set<Affl_Mappings__c> afflMappingSet = new Set<Affl_Mappings__c>();

        // Check if the Primary Affl Field an API name
        Schema.DescribeFieldResult primaryAfflFieldDescribe;

        try {
            primaryAfflFieldDescribe = UTIL_Describe.getFieldDescribe('Contact', afflMapping.Primary_Affl_Field__c);
        } catch (UTIL_Describe.SchemaDescribeException ex) {
            try{
                primaryAfflFieldDescribe = UTIL_Describe.getFieldDescribeByLabel('Contact', afflMapping.Primary_Affl_Field__c);
            } catch (UTIL_Describe.SchemaDescribeException exp) {
                return null;
            }
        }

        if (primaryAfflFieldDescribe == null) {
            // Affiliation mapping to Contact field that doesn't exist - skip mapping
            return null; 
        }

        if (UTIL_Describe.isLookupFieldTo(primaryAfflFieldDescribe, Account.SObjectType) == false){
            // Affiliation mapping to contact field that is not type Lookup(Account)
            List<String> params = new List<String>{
                Label.stgColContactPrimaryAfflField,
                afflMapping.Primary_Affl_Field__c
            };

            invalidErrorMessage = StringHandlingService.getInstance().formatStringWithApostrophesAndParameters(label.invalidContactFieldInAffiliationMapping, params);
        }
            
        // Get the record type info by developer name
        Schema.RecordTypeInfo accountRecTypeInfo = UTIL_Describe.getRecordTypeInfoByDeveloperName('Account', afflMapping.Account_Record_Type__c);
        // If we dont have a record type info, get the record type info by name
        if (accountRecTypeInfo == null) {
            accountRecTypeInfo = UTIL_Describe.getRecordTypeInfoByName('Account', afflMapping.Account_Record_Type__c);
        }

        if (accountRecTypeInfo == null) {
            if (this.isPrimaryAffiliationValidationOn() == true) {
                // Affiliation mapping to invalid record type
                isValid = false;

                // set custom error message text
                List<String> params = new List<String>{
                    Label.stgColAccountRecordType,
                    afflMapping.Account_Record_Type__c
                };
    
                invalidErrorMessage = StringHandlingService.getInstance().formatStringWithApostrophesAndParameters(label.invalidRecordTypeInAffiliationMapping, params);
            }

            MODL_PrimaryAfflMapper primaryAfflModel = new MODL_PrimaryAfflMapper(
                primaryAfflFieldDescribe, 
                afflMapping.Primary_Affl_Field__c, 
                afflMapping.Account_Record_Type__c, 
                isValid, 
                invalidErrorMessage);       

            return primaryAfflModel;
        }

        // primaryAfflFieldDescribe is null if contact field label mapping is invalid
        MODL_PrimaryAfflMapper primaryAfflModel = new MODL_PrimaryAfflMapper(
            accountRecTypeInfo, 
            primaryAfflFieldDescribe, 
            afflMapping.Primary_Affl_Field__c, 
            afflMapping.Account_Record_Type__c, 
            isValid,
            invalidErrorMessage);

        return primaryAfflModel;
    }
}
@isTest
private class MAPR_PrimaryAffiliations_TEST {

    /**************************************************************************************************************************************
    * @description Helper method to generate error message associated with a mapping to a field that does not lookup to Account.
    * @param  affiliationMapping An affiliation mapping with an invalid lookup field mapping.
    * @return The expected error message associated with the generated model.
    **************************************************************************************************************************************/
    private static String getExpectedInvalidFieldMappingErrorMessage(Affl_Mappings__c affiliationMapping){
        List<String> params = new List<String>{
            Label.stgColContactPrimaryAfflField,
            affiliationMapping.Primary_Affl_Field__c
        };

        return StringHandlingService.getInstance().formatStringWithApostrophesAndParameters(label.invalidContactFieldInAffiliationMapping, params);
    }

    /**************************************************************************************************************************************
    * @description Helper method to generate error message associated with a mapping to an invalid record type.
    * @param  affiliationMapping An affiliation mapping with an invalid record type mapping.
    * @return The expected error message associated with the generated model.
    **************************************************************************************************************************************/
    private static String getExpectedInvalidRTMappingErrorMessage(Affl_Mappings__c affiliationMapping){
        List<String> params = new List<String>{
            Label.stgColAccountRecordType,
            affiliationMapping.Account_Record_Type__c
        };

        return StringHandlingService.getInstance().formatStringWithApostrophesAndParameters(label.invalidRecordTypeInAffiliationMapping, params);
    }

    /**************************************************************************************************************************************
    * @description Inserts Affiliation mappings with RecordTypeDevName and PrimaryAffiliationFieldAPI
    ***************************************************************************************************************************************/
    static void insertAfflMappingsWithRecordTypeDevNameAndPrimaryFieldAPIs() {
        String prefix = UTIL_Namespace.StrTokenNSPrefix('');

        List<Affl_Mappings__c> mappings = new List<Affl_Mappings__c>();
        mappings.add(new Affl_Mappings__c(Name = 'Business Organization', Account_Record_Type__c = 'Business_Organization', Primary_Affl_Field__c = prefix + 'Primary_Organization__c'));
        mappings.add(new Affl_Mappings__c(Name = 'Household Account', Account_Record_Type__c = 'HH_Account', Primary_Affl_Field__c =  prefix + 'Primary_Household__c'));
        insert mappings;
    }

    /**************************************************************************************************************************************
    * @description Inserts Affiliation mappings with RecordTypeDevName and PrimaryAffiliationFieldLabels
    ***************************************************************************************************************************************/
    static void insertAfflMappingsWithRecordTypeDevNameAndPrimaryFieldLabels() {
        List<Affl_Mappings__c> mappings = new List<Affl_Mappings__c>();
        mappings.add(new Affl_Mappings__c(Name = 'Business Organization', Account_Record_Type__c = 'Business_Organization', Primary_Affl_Field__c = 'Primary Business Organization'));
        mappings.add(new Affl_Mappings__c(Name = 'Household Account', Account_Record_Type__c = 'HH_Account', Primary_Affl_Field__c = 'Primary Household'));
        insert mappings;
    } 

    /**************************************************************************************************************************************
    * @description Inserts Affiliation mappings with RecordTypeDevName and PrimaryAffiliationFieldAPIs
    ***************************************************************************************************************************************/
    static void insertAfflMappingsWithRecordTypeNameAndPrimaryFieldAPIs() {
        String prefix = UTIL_Namespace.StrTokenNSPrefix('');

        List<Affl_Mappings__c> mappings = new List<Affl_Mappings__c>();
        mappings.add(new Affl_Mappings__c(Name = 'Business Organization', Account_Record_Type__c = 'Business Organization', Primary_Affl_Field__c = prefix + 'Primary_Organization__c'));
        mappings.add(new Affl_Mappings__c(Name = 'Household Account', Account_Record_Type__c = 'Household Account', Primary_Affl_Field__c = prefix + 'Primary_Household__c'));
        insert mappings;
    }

    /**************************************************************************************************************************************
    * @description Inserts Affiliation mappings with RecordTypeName and PrimaryAffiliationFieldLabels
    ***************************************************************************************************************************************/
    static void insertAfflMappingsWithRecordTypeNameAndPrimaryFieldLabels() {
        List<Affl_Mappings__c> mappings = new List<Affl_Mappings__c>();
        mappings.add(new Affl_Mappings__c(Name = 'Business Organization', Account_Record_Type__c = 'Business Organization', Primary_Affl_Field__c = 'Primary Business Organization'));
        mappings.add(new Affl_Mappings__c(Name = 'Household Account', Account_Record_Type__c = 'Household Account', Primary_Affl_Field__c = 'Primary Household'));
        insert mappings;
    }

    /**************************************************************************************************************************************
    * @description Inserts Affiliation mappings with RecordTypeName and inaccurate PrimaryAffiliationFieldLabels
    ***************************************************************************************************************************************/
    static void insertAfflMappingsWithRecordTypeNameAndInaccuratePrimaryFieldLabels() {
        List<Affl_Mappings__c> mappings = new List<Affl_Mappings__c>();
        mappings.add(new Affl_Mappings__c(Name = 'Business Organization', Account_Record_Type__c = 'Business Organization', Primary_Affl_Field__c = 'Wrong field Label1'));
        mappings.add(new Affl_Mappings__c(Name = 'Household Account', Account_Record_Type__c = 'Household Account', Primary_Affl_Field__c = 'Wrong field Label2'));
        insert mappings;
    }

    /**************************************************************************************************************************************
    * @description Inserts Affiliation mappings with valid RecordTypeName and valid PrimaryAffiliationFieldLabels to a field that does not
    * lookup to Account.
    ***************************************************************************************************************************************/
    static void insertAfflMappingsWithValidRecordTypeNameAndNonLookupPrimaryFieldLabels() {
        List<Affl_Mappings__c> mappings = new List<Affl_Mappings__c>();
        mappings.add(new Affl_Mappings__c(Name = 'Business Organization', Account_Record_Type__c = 'Business Organization', Primary_Affl_Field__c = 'FirstName'));
        mappings.add(new Affl_Mappings__c(Name = 'Household Account', Account_Record_Type__c = 'Household Account', Primary_Affl_Field__c = 'Wrong field Label2'));
        insert mappings;
    }

    /**************************************************************************************************************************************
    * @description Inserts Affiliation mappings with inaccurate RecordTypeName and accurate PrimaryAffiliationFieldLabels
    ***************************************************************************************************************************************/
    static void insertAfflMappingsWithInaccurateRecordTypeNameAndAccuratePrimaryFieldLabels() {
        List<Affl_Mappings__c> mappings = new List<Affl_Mappings__c>();
        mappings.add(new Affl_Mappings__c(Name = 'Business Organization', Account_Record_Type__c = 'Business Org test', Primary_Affl_Field__c = 'Primary Business Organization'));
        mappings.add(new Affl_Mappings__c(Name = 'Household Account', Account_Record_Type__c = 'Household Org Account test', Primary_Affl_Field__c = 'Primary Household'));
        insert mappings;
    }

    /**************************************************************************************************************************************
    * @description Inserts Affiliation mappings with inaccurate RecordTypeName and PrimaryAffiliationFieldLabels for a valid field that 
    * does not lookup to Account.
    ***************************************************************************************************************************************/
    static void insertAfflMappingsWithInaccurateRecordTypeNameAndNonLookupPrimaryFieldLabels() {
        List<Affl_Mappings__c> mappings = new List<Affl_Mappings__c>();
        mappings.add(new Affl_Mappings__c(Name = 'Business Organization', Account_Record_Type__c = 'Business Org test', Primary_Affl_Field__c = 'FirstName'));
        mappings.add(new Affl_Mappings__c(Name = 'Household Account', Account_Record_Type__c = 'Household Org Account test', Primary_Affl_Field__c = 'Primary Household'));
        insert mappings;
    }

    /**************************************************************************************************************************************
    * @description Inserts Affiliation mappings with inaccurate RecordTypeName and inaccurate PrimaryAffiliationFieldLabels
    ***************************************************************************************************************************************/
    static void insertAfflMappingsWithInaccurateRecordTypeNameAndInAccuratePrimaryFieldLabels() {

        List<Affl_Mappings__c> mappings = new List<Affl_Mappings__c>();
        mappings.add(new Affl_Mappings__c(Name = 'Business Organization', Account_Record_Type__c = 'Business Org test', Primary_Affl_Field__c = 'Primary Business Organization test'));
        mappings.add(new Affl_Mappings__c(Name = 'Household Account', Account_Record_Type__c = 'Household Org Account test', Primary_Affl_Field__c = 'Primary Household test'));
        insert mappings;
    }

    /**************************************************************************************************************************
    * @description Test method to verify that the getInstance method returns a new instance of the 
    * MAPR_PrimaryAffiliations class when one does not already exist.
    ***************************************************************************************************************************/
    @isTest
    private static void getInstanceNew() {
        Test.startTest();
            MAPR_PrimaryAffiliations maprPrimaryAfflInstance = MAPR_PrimaryAffiliations.getInstance();
        Test.stopTest();
        System.assertEquals(MAPR_PrimaryAffiliations.instance, maprPrimaryAfflInstance, 'Instance of service class returned should match static instance variable.');
        System.assertEquals(true, maprPrimaryAfflInstance != null, 'Instance of service class should not be null.');
    }

    /**************************************************************************************************************************
    * @description Test method to verify that the getInstance method returns the existing instance of the 
    * MAPR_PrimaryAffiliations class when one already exists.
    ***************************************************************************************************************************/
    @isTest
    private static void getInstanceExisting() {
        Test.startTest();
            MAPR_PrimaryAffiliations maprPrimaryAfflInstance1 = MAPR_PrimaryAffiliations.getInstance();
            MAPR_PrimaryAffiliations maprPrimaryAfflInstance2 = MAPR_PrimaryAffiliations.getInstance();
        Test.stopTest();

        System.assertEquals(MAPR_PrimaryAffiliations.instance, maprPrimaryAfflInstance1, 'Instance of service class returned should match static instance variable.');
        System.assertEquals(maprPrimaryAfflInstance1, maprPrimaryAfflInstance2, 'Subsequent retrievals of service class instance should return existing instance.');
        System.assertEquals(true, maprPrimaryAfflInstance1 != null, 'Instance of service class should not be null.');
    }

    /**************************************************************************************************************************
    * @description Test method to verify that the isPrimaryAffiliationValidationOn method returns 
    * the value from Custom Settings
    ***************************************************************************************************************************/
    @isTest
    private static void isPrimaryAffiliationValidationOnTrueTest() {
        UTIL_CustomSettings_API.getSettingsForTests(new Hierarchy_Settings__c(Affiliation_Record_Type_Enforced__c = true));

        Test.startTest();
            Boolean isValidationOn = MAPR_PrimaryAffiliations.getInstance().isPrimaryAffiliationValidationOn();
        Test.stopTest();

        System.assertEquals(true, isValidationOn);
    }

    /**************************************************************************************************************************
    * @description Test method to verify that the isPrimaryAffiliationValidationOn method returns 
    * the value from Custom Settings
    ***************************************************************************************************************************/
    @isTest
    private static void isPrimaryAffiliationValidationOnFalseTest() {
        UTIL_CustomSettings_API.getSettingsForTests(new Hierarchy_Settings__c(Affiliation_Record_Type_Enforced__c = false));
        Test.startTest();
            Boolean isValidationOn = MAPR_PrimaryAffiliations.getInstance().isPrimaryAffiliationValidationOn();
        Test.stopTest();

        System.assertEquals(false, isValidationOn);
    }

    /**************************************************************************************************************************************
    * @description Test method to verify that the getModelsFromSettings method with 
    * Record Type Dev Name And Primary Field APIs in Settings returns models
    ***************************************************************************************************************************************/
    @isTest
    private static void getModelsFromSettingsTestDevNameAndPrimaryFieldAPIs() {
        MAPR_PrimaryAffiliations_TEST.insertAfflMappingsWithRecordTypeDevNameAndPrimaryFieldAPIs();
        MAPR_PrimaryAffiliations maprPrimaryAfflInstance = MAPR_PrimaryAffiliations.getInstance();

        Test.startTest();
            List<MODL_PrimaryAfflMapper> primaryAfflModels = maprPrimaryAfflInstance.getModelsFromSettings();
        Test.stopTest();

        System.assertEquals(2, primaryAfflModels.size());
    }
    
    /**************************************************************************************************************************************
    * @description Test method to verify that the getModelsFromSettings method with 
    * Record Type Dev Name And Primary Field Labels in Settings returns models
    ***************************************************************************************************************************************/
    @isTest
    private static void getModelsFromSettingsTestDevNameAndPrimaryFieldLabels() {
        MAPR_PrimaryAffiliations_TEST.insertAfflMappingsWithRecordTypeDevNameAndPrimaryFieldLabels();
        MAPR_PrimaryAffiliations maprPrimaryAfflInstance = MAPR_PrimaryAffiliations.getInstance();

        Test.startTest();
            List<MODL_PrimaryAfflMapper> primaryAfflModels = maprPrimaryAfflInstance.getModelsFromSettings();
        Test.stopTest();

        System.assertEquals(2, primaryAfflModels.size());
    }
    
    /**************************************************************************************************************************************
    * @description Test method to verify that the getModelsFromSettings method with 
    * Record Type Name And Primary Field APIs in Settings returns models
    ***************************************************************************************************************************************/
    @isTest
    private static void getModelsFromSettingsTestWithRecTypeNameAndPrimaryFieldAPIs() {
        MAPR_PrimaryAffiliations_TEST.insertAfflMappingsWithRecordTypeNameAndPrimaryFieldAPIs();
        MAPR_PrimaryAffiliations maprPrimaryAfflInstance = MAPR_PrimaryAffiliations.getInstance();

        Test.startTest();
            List<MODL_PrimaryAfflMapper> primaryAfflModels = maprPrimaryAfflInstance.getModelsFromSettings();
        Test.stopTest();

        System.assertEquals(2, primaryAfflModels.size());

    }
    
    /**************************************************************************************************************************************
    * @description Test method to verify that the getModelsFromSettings method with 
    * Record Type Name And Primary Field Labels in Settings returns models
    ***************************************************************************************************************************************/
    @isTest
    private static void getModelsFromSettingsTestWithRecTypeNameAndPrimaryFieldLabels() {
        MAPR_PrimaryAffiliations_TEST.insertAfflMappingsWithRecordTypeNameAndPrimaryFieldLabels();
        MAPR_PrimaryAffiliations maprPrimaryAfflInstance = MAPR_PrimaryAffiliations.getInstance();

        Test.startTest();
            List<MODL_PrimaryAfflMapper> primaryAfflModels = maprPrimaryAfflInstance.getModelsFromSettings();
        Test.stopTest();

        System.assertEquals(2, primaryAfflModels.size());
    }

    /**************************************************************************************************************************************
    * @description Test method to verify that the getModelsFrommappings method with 
    * Record Type Dev Name And Primary Field APIs in Settings returns models
    ***************************************************************************************************************************************/
    @isTest
    private static void getModelsFromMappingsTestWithRecTypeDevNameAndPrimaryFieldAPIs() {
        MAPR_PrimaryAffiliations_TEST.insertAfflMappingsWithRecordTypeDevNameAndPrimaryFieldAPIs();
        MAPR_PrimaryAffiliations maprPrimaryAfflInstance = MAPR_PrimaryAffiliations.getInstance();

        List<Affl_Mappings__c> primaryAfflMappings = UTIL_CustomSettingsFacade.getPrimaryAfflMappings();
        Test.startTest();
            List<MODL_PrimaryAfflMapper> primaryAfflModels = maprPrimaryAfflInstance.getModelsFromMappings(primaryAfflMappings);
        Test.stopTest();
 
        System.assertEquals(2, primaryAfflModels.size());
    }

    /**************************************************************************************************************************************
    * @description Test method to verify that the getModelsFromMappings method with 
    * Record Type Dev Name And Primary Field APIs in Settings returns no models
    ***************************************************************************************************************************************/
    @isTest
    private static void getModelsFromMappingsTestNoModelTest() {
        MAPR_PrimaryAffiliations_TEST.insertAfflMappingsWithRecordTypeNameAndInaccuratePrimaryFieldLabels();
        MAPR_PrimaryAffiliations maprPrimaryAfflInstance = new STUB_PrimaryAffiliationValidationOff();

        List<Affl_Mappings__c> primaryAfflMappings = UTIL_CustomSettingsFacade.getPrimaryAfflMappings();
        Test.startTest();
            List<MODL_PrimaryAfflMapper> primaryAfflModels = maprPrimaryAfflInstance.getModelsFromMappings(primaryAfflMappings);
        Test.stopTest();
 
        System.assertEquals(true, primaryAfflModels.isEmpty());
    }

    /**************************************************************************************************************************************
    * @description Test method to verify that the getModelsFromSettings method with 
    * duplicate Settings will filter duplicate models 
    ***************************************************************************************************************************************/
    @isTest
    private static void getModelsFromMappingsTestWithDevNameAndPrimaryFieldAPIsWithDuplicates() {
        String prefix = UTIL_Namespace.StrTokenNSPrefix('');

        MAPR_PrimaryAffiliations_TEST.insertAfflMappingsWithRecordTypeDevNameAndPrimaryFieldAPIs();
        MAPR_PrimaryAffiliations maprPrimaryAfflInstance = MAPR_PrimaryAffiliations.getInstance();

        List<Affl_Mappings__c> mappings = new List<Affl_Mappings__c>();
        mappings.add(new Affl_Mappings__c(Name = 'Business Organization duplicate', Account_Record_Type__c = 'Business_Organization', Primary_Affl_Field__c = prefix + 'Primary_Organization__c'));
        insert mappings;
 
        List<Affl_Mappings__c> primaryAfflMappings = UTIL_CustomSettingsFacade.getPrimaryAfflMappings();

        Test.startTest();
            List<MODL_PrimaryAfflMapper> primaryAfflModels = maprPrimaryAfflInstance.getModelsFromMappings(primaryAfflMappings);
        Test.stopTest();

        System.assertEquals(2, primaryAfflModels.size());
    }

    /**************************************************************************************************************************************
    * @description Test method to verify that the getModelFromMapping method with valid
    * Record Type Dev Name And valid Primary Field APIs in Settings returns valid Affiliation Mapping model
    ***************************************************************************************************************************************/
    @isTest
    private static void getModelFromMappingTestRecTypeDevNameAndPrimaryFieldAPI() {
        MAPR_PrimaryAffiliations_TEST.insertAfflMappingsWithRecordTypeDevNameAndPrimaryFieldAPIs();
        MAPR_PrimaryAffiliations maprPrimaryAfflInstance = MAPR_PrimaryAffiliations.getInstance();

        List<Affl_Mappings__c> primaryAfflMappings = UTIL_CustomSettingsFacade.getPrimaryAfflMappings();

        Test.startTest();
            MODL_PrimaryAfflMapper primaryAfflModel = maprPrimaryAfflInstance.getModelFromMapping(primaryAfflMappings[0]);
        Test.stopTest();

        String prefix = UTIL_Namespace.StrTokenNSPrefix('');

        System.assert(primaryAfflModel != null);
        System.assertEquals(true, primaryAfflModel.getIsValid());
        System.assertEquals(true, String.isBlank(primaryAfflModel.getInvalidErrorMessage()));
        System.assertEquals('Business_Organization', primaryAfflModel.getSettingsRecordTypeFieldValue());
        System.assertEquals(prefix + 'Primary_Organization__c', primaryAfflModel.getSettingsContactFieldValue());
        System.assertEquals(prefix + 'Primary_Organization__c', primaryAfflModel.getContactFieldApiName());
        System.assertEquals(UTIL_Describe_API.getBizAccRecTypeID(), primaryAfflModel.getAccountRecordTypeId());
    }
    
    /**************************************************************************************************************************************
    * @description Test method to verify that the getModelFromMapping method with valid
    * RecordType Dev Name And valid Primary Field Label in Settings returns valid Affiliation mapping model
    ***************************************************************************************************************************************/
    @isTest
    private static void getModelFromMappingTestWithRecTypeDevNameAndFieldLabel() {
        MAPR_PrimaryAffiliations_TEST.insertAfflMappingsWithRecordTypeDevNameAndPrimaryFieldLabels();
        MAPR_PrimaryAffiliations maprPrimaryAfflInstance = MAPR_PrimaryAffiliations.getInstance();

        List<Affl_Mappings__c> primaryAfflMappings = UTIL_CustomSettingsFacade.getPrimaryAfflMappings();

        Test.startTest();
            MODL_PrimaryAfflMapper primaryAfflModel = maprPrimaryAfflInstance.getModelFromMapping(primaryAfflMappings[0]);
        Test.stopTest();

        String prefix = UTIL_Namespace.StrTokenNSPrefix('');

        System.assert(primaryAfflModel != null);
        System.assertEquals(true, primaryAfflModel.getIsValid());
        System.assertEquals(true, String.isBlank(primaryAfflModel.getInvalidErrorMessage()));
        System.assertEquals('Business_Organization', primaryAfflModel.getSettingsRecordTypeFieldValue());
        System.assertEquals('Primary Business Organization', primaryAfflModel.getSettingsContactFieldValue());
        System.assertEquals(prefix + 'Primary_Organization__c', primaryAfflModel.getContactFieldApiName());
        System.assertEquals(UTIL_Describe_API.getBizAccRecTypeID(), primaryAfflModel.getAccountRecordTypeId());
    }

    /**************************************************************************************************************************************
    * @description Test method to verify that the getModelFromMapping method with 
    * valid Record Type Name And valid Primary Field API in Settings return valid Affiliation mapping model
    ***************************************************************************************************************************************/
    @isTest
    private static void getModelFromMappingTestWithRecTypeNameAndFieldAPI() {
        MAPR_PrimaryAffiliations_TEST.insertAfflMappingsWithRecordTypeNameAndPrimaryFieldAPIs();
        MAPR_PrimaryAffiliations maprPrimaryAfflInstance = MAPR_PrimaryAffiliations.getInstance();

        List<Affl_Mappings__c> primaryAfflMappings = UTIL_CustomSettingsFacade.getPrimaryAfflMappings();

        Test.startTest();
            MODL_PrimaryAfflMapper primaryAfflModel = maprPrimaryAfflInstance.getModelFromMapping(primaryAfflMappings[0]);
        Test.stopTest();

        String prefix = UTIL_Namespace.StrTokenNSPrefix('');

        System.assert(primaryAfflModel != null);
        System.assertEquals(true, primaryAfflModel.getIsValid());
        System.assertEquals(true, String.isBlank(primaryAfflModel.getInvalidErrorMessage()));
        System.assertEquals('Business Organization', primaryAfflModel.getSettingsRecordTypeFieldValue());
        System.assertEquals(prefix + 'Primary_Organization__c', primaryAfflModel.getSettingsContactFieldValue());
        System.assertEquals(prefix + 'Primary_Organization__c', primaryAfflModel.getContactFieldApiName());
        System.assertEquals(UTIL_Describe_API.getBizAccRecTypeID(), primaryAfflModel.getAccountRecordTypeId());
    }

    /**************************************************************************************************************************************
    * @description Test method to verify that the getModelFromMapping method with 
    * valid RecordType Name And valid Primary Field Label in Settings returns a valid Affiliation mapping model
    ***************************************************************************************************************************************/
    @isTest
    private static void getModelFromMappingTestWithRecTypeNameAndFieldLabel() {
        MAPR_PrimaryAffiliations_TEST.insertAfflMappingsWithRecordTypeNameAndPrimaryFieldLabels();
        MAPR_PrimaryAffiliations maprPrimaryAfflInstance = MAPR_PrimaryAffiliations.getInstance();

        List<Affl_Mappings__c> primaryAfflMappings = UTIL_CustomSettingsFacade.getPrimaryAfflMappings();

        Test.startTest();
            MODL_PrimaryAfflMapper primaryAfflModel = maprPrimaryAfflInstance.getModelFromMapping(primaryAfflMappings[0]);
        Test.stopTest();

        String prefix = UTIL_Namespace.StrTokenNSPrefix('');

        System.assert(primaryAfflModel != null);
        System.assertEquals(true, primaryAfflModel.getIsValid());
        System.assertEquals(true, String.isBlank(primaryAfflModel.getInvalidErrorMessage()));
        System.assertEquals('Business Organization', primaryAfflModel.getSettingsRecordTypeFieldValue());
        System.assertEquals('Primary Business Organization', primaryAfflModel.getSettingsContactFieldValue());
        System.assertEquals(prefix + 'Primary_Organization__c', primaryAfflModel.getContactFieldApiName());
        System.assertEquals(UTIL_Describe_API.getBizAccRecTypeID(), primaryAfflModel.getAccountRecordTypeId());
    }

    /**************************************************************************************************************************************
    * @description Test method to verify that the getModelFromMapping method with accurate
    * Record Type Name And inaccurate Primary Field Label in Settings returns a null value when Record Type Validation is enabled.
    ***************************************************************************************************************************************/
    @isTest
    private static void getModelFromMappingTestWithAccurateRecordTypeAndInaccurateFieldLabelWithValidationOn() {
        MAPR_PrimaryAffiliations_TEST.insertAfflMappingsWithRecordTypeNameAndInaccuratePrimaryFieldLabels();
        MAPR_PrimaryAffiliations maprPrimaryAfflInstance = new STUB_PrimaryAffiliationValidationOn();

        List<Affl_Mappings__c> primaryAfflMappings = UTIL_CustomSettingsFacade.getPrimaryAfflMappings();

        Test.startTest();
        MODL_PrimaryAfflMapper primAffMapResult = maprPrimaryAfflInstance.getModelFromMapping(primaryAfflMappings[0]);
        Test.stopTest();

        System.assertEquals(null, primAffMapResult, 'Affiliation mapping with invalid Contact field should return null value when validation is enabled.');
    } 

    /**************************************************************************************************************************************
    * @description Test method to verify that the getModelFromMapping method with 
    * accurate RecordType Name And invalid Primary Field Label in Settings when validation is off returns null
    ***************************************************************************************************************************************/
    @isTest
    private static void getModelFromMappingTestWithAccurateRecordTypeAndInaccurateFieldLabelWithValidationOff() {
        MAPR_PrimaryAffiliations_TEST.insertAfflMappingsWithRecordTypeNameAndInaccuratePrimaryFieldLabels();
        MAPR_PrimaryAffiliations maprPrimaryAfflInstance = new STUB_PrimaryAffiliationValidationOff();

        List<Affl_Mappings__c> primaryAfflMappings = UTIL_CustomSettingsFacade.getPrimaryAfflMappings();

        Test.startTest();
        MODL_PrimaryAfflMapper primaryAfflModel = maprPrimaryAfflInstance.getModelFromMapping(primaryAfflMappings[0]);
        Test.stopTest();

        System.assertEquals(null, primaryAfflModel, 'Affiliation mapping with invalid Contact field should return null value when validation is not enabled.');
    }

    /**************************************************************************************************************************************
    * @description Test method to verify that the getModelFromMapping method with a valid RecordType Dev Name and valid Primary Field Label
    * that is a not a lookup to Account in Settings generates a valid affiliation mapping model with an error indicating an invalid field mapping.
    ***************************************************************************************************************************************/
    @isTest
    private static void getModelFromMappingTestWithTextFieldAsLabelAndValidationOn() {
        String bizAccRecordTypeId = UTIL_Describe_API.getBizAccRecTypeID(); 

        List<Affl_Mappings__c> mappings = new List<Affl_Mappings__c>();
        mappings.add(new Affl_Mappings__c(Name = 'Business Organization', Account_Record_Type__c = 'Business_Organization', Primary_Affl_Field__c = 'Gender'));
        insert mappings;

        MAPR_PrimaryAffiliations maprPrimaryAfflInstance = new STUB_PrimaryAffiliationValidationOn();

        List<Affl_Mappings__c> primaryAfflMappings = UTIL_CustomSettingsFacade.getPrimaryAfflMappings();

        Test.startTest();
        MODL_PrimaryAfflMapper primaryAfflModel = maprPrimaryAfflInstance.getModelFromMapping(primaryAfflMappings[0]);
        Test.stopTest();

        String prefix = UTIL_Namespace.StrTokenNSPrefix('');
       
        System.assertEquals(true, primaryAfflModel.getIsValid(), 'Affiliation mapping for valid Contact field and Account record type should be valid.');
        System.assertEquals (MAPR_PrimaryAffiliations_TEST.getExpectedInvalidFieldMappingErrorMessage(primaryAfflMappings[0]), primaryAfflModel.getInvalidErrorMessage(), 'Invalid error message should be populated for non lookup field mapping.');
        System.assertEquals(bizAccRecordTypeId, primaryAfflModel.getAccountRecordTypeId(), 'Record type for Affiliation mapping should be Business Organization.');
        System.assertEquals(prefix + 'Gender__c', primaryAfflModel.getContactFieldApiName(), 'Contact field API name for Affiliation mapping should be Gender__c.');
        System.assertEquals('Gender', primaryAfflModel.getSettingsContactFieldValue(), 'Contact field name for Affiliation mapping should be Gender.');
        System.assertEquals('Business_Organization', primaryAfflModel.getSettingsRecordTypeFieldValue(), 'Record type name for Affiliation mapping should be Business_Organization.');
    } 

    /**************************************************************************************************************************************
    * @description Test method to verify that the getModelFromMapping method with a valid RecordType Dev Name an invalid Primary Field API
    * in Settings returns null.
    ***************************************************************************************************************************************/
    @isTest
    private static void getModelFromMappingTestWithLookupFieldAsAPIAndValidationOn() {
        List<Affl_Mappings__c> mappings = new List<Affl_Mappings__c>();
        mappings.add(new Affl_Mappings__c(Name = 'Business Organization', Account_Record_Type__c = 'Business_Organization', Primary_Affl_Field__c = 'Not a Contact Field'));
        insert mappings;

        MAPR_PrimaryAffiliations maprPrimaryAfflInstance = new STUB_PrimaryAffiliationValidationOn();

        List<Affl_Mappings__c> primaryAfflMappings = UTIL_CustomSettingsFacade.getPrimaryAfflMappings();

        Test.startTest();
        MODL_PrimaryAfflMapper primAffMapResult = maprPrimaryAfflInstance.getModelFromMapping(primaryAfflMappings[0]);
        Test.stopTest();

        System.assertEquals(null, primAffMapResult, 'An invalid Contact field mapping should return null when validation is enabled.');
    } 

    /**************************************************************************************************************************************
    * @description Test method to verify that the getModelFromMapping method with invalid 
    * RecordType Name And and valid Primary Field Label in Settings generates and invalid model when Record Type validations is enabled.
    ***************************************************************************************************************************************/
    @isTest
    private static void getModelFromMappingTestWithInaccurateRecordTypeAndValidationOn() {
        MAPR_PrimaryAffiliations_TEST.insertAfflMappingsWithInaccurateRecordTypeNameAndAccuratePrimaryFieldLabels();
        MAPR_PrimaryAffiliations maprPrimaryAfflInstance = new STUB_PrimaryAffiliationValidationOn();

        List<Affl_Mappings__c> primaryAfflMappings = UTIL_CustomSettingsFacade.getPrimaryAfflMappings();

        Test.startTest();
            MODL_PrimaryAfflMapper primaryAfflModel = maprPrimaryAfflInstance.getModelFromMapping(primaryAfflMappings[0]);
        Test.stopTest();

        String prefix = UTIL_Namespace.StrTokenNSPrefix('');
        
        System.assertEquals(
            false, 
            primaryAfflModel.getIsValid(), 
            'Affiliation mapping model should be invalid for invalid Account Record Type.'
        );
        System.assertEquals(
            MAPR_PrimaryAffiliations_TEST.getExpectedInvalidRTMappingErrorMessage(primaryAfflMappings[0]), 
            primaryAfflModel.getInvalidErrorMessage(), 
            'Invalid error message should be populated.'
        );
        System.assertEquals(
            prefix + 'Primary_Organization__c', 
            primaryAfflModel.getContactFieldApiName(), 
            'Contact field API name for Affiliation mapping model should be Primary_Organization__c.'
        );
        System.assertEquals(
            'Primary Business Organization', 
            primaryAfflModel.getSettingsContactFieldValue(), 
            'Contact field API name for Affiliation mapping model should be Primary Business Organization.'
        );
        System.assertEquals(
            'Business Org test', 
            primaryAfflModel.getSettingsRecordTypeFieldValue(), 
            'Record type for Affiliation mapping model should be set as Business org test.'
        );
    }

    /**************************************************************************************************************************************
    * @description Test method to verify that the getModelFromMapping method will return a valid Affiliation mapping model when 
    * inaccurate RecordType Dev Name and valid Primary Field Label in Settings when validation is Off
    ***************************************************************************************************************************************/
    @isTest
    private static void getModelFromMappingTestWithInaccurateRecordTypeAndValidationOff() {
        MAPR_PrimaryAffiliations_TEST.insertAfflMappingsWithInaccurateRecordTypeNameAndAccuratePrimaryFieldLabels();
        MAPR_PrimaryAffiliations maprPrimaryAfflInstance = new STUB_PrimaryAffiliationValidationOff();

        List<Affl_Mappings__c> primaryAfflMappings = UTIL_CustomSettingsFacade.getPrimaryAfflMappings();

        Test.startTest();
            MODL_PrimaryAfflMapper primaryAfflModel = maprPrimaryAfflInstance.getModelFromMapping(primaryAfflMappings[0]);
        Test.stopTest();

        String prefix = UTIL_Namespace.StrTokenNSPrefix('');

        System.assert(primaryAfflModel != null);
        System.assertEquals(true, primaryAfflModel.getIsValid());
        System.assertEquals(true, String.isBlank(primaryAfflModel.getInvalidErrorMessage()));
        System.assertEquals('Business Org test', primaryAfflModel.getAccountRecordTypeId());
        System.assertEquals(prefix + 'Primary_Organization__c', primaryAfflModel.getContactFieldApiName());
        System.assertEquals('Primary Business Organization', primaryAfflModel.getSettingsContactFieldValue());
        System.assertEquals('Business Org test', primaryAfflModel.getSettingsRecordTypeFieldValue());
    }

    /**************************************************************************************************************************************
    * @description Test method to verify that the getModelFromMapping method with 
    * Inaccurate RecordType Name And inaccurate Primary Field Label in EDA Settings when validation is off returns null
    ***************************************************************************************************************************************/
    @isTest
    private static void getModelFromMappingTestWithInaccurateRecordTypeAndFieldWithValidationOff() {
        MAPR_PrimaryAffiliations_TEST.insertAfflMappingsWithInaccurateRecordTypeNameAndInAccuratePrimaryFieldLabels();
        MAPR_PrimaryAffiliations maprPrimaryAfflInstance = new STUB_PrimaryAffiliationValidationOff();

        List<Affl_Mappings__c> primaryAfflMappings = UTIL_CustomSettingsFacade.getPrimaryAfflMappings();

        Test.startTest();
        MODL_PrimaryAfflMapper primAffMapResult = maprPrimaryAfflInstance.getModelFromMapping(primaryAfflMappings[0]);
        Test.stopTest();

        System.assertEquals(null, primAffMapResult, 'Invalid Contact field and Record Type mappings should return null when validation is not enabled.');
    }

    /**************************************************************************************************************************************
    * @description Test to ensure that getModelFromMapping returns a valid model with an error message indicating an invalid lookup field 
    * mapping when validation is off, an invalid record type is specified and a valid field that does not lookup to Account is mapped.
    **************************************************************************************************************************************/ 
    private static void getModelFromMappingInvalidRTAndNonLookupFieldValidationOff(){        
        MAPR_PrimaryAffiliations_TEST.insertAfflMappingsWithInaccurateRecordTypeNameAndNonLookupPrimaryFieldLabels();
        MAPR_PrimaryAffiliations maprPrimaryAfflInstance = new STUB_PrimaryAffiliationValidationOff();

        List<Affl_Mappings__c> primaryAfflMappings = UTIL_CustomSettingsFacade.getPrimaryAfflMappings();

        Test.startTest();
            MODL_PrimaryAfflMapper primaryAfflModel = maprPrimaryAfflInstance.getModelFromMapping(primaryAfflMappings[0]);
        Test.stopTest();

        String prefix = UTIL_Namespace.StrTokenNSPrefix('');

        System.assert(primaryAfflModel != null);
        System.assertEquals(true, primaryAfflModel.getIsValid());
        System.assertEquals(MAPR_PrimaryAffiliations_TEST.getExpectedInvalidFieldMappingErrorMessage(primaryAfflMappings[0]), primaryAfflModel.getInvalidErrorMessage());
        System.assertEquals('Business Org test', primaryAfflModel.getAccountRecordTypeId());
        System.assertEquals(prefix + 'FirstName', primaryAfflModel.getContactFieldApiName());
        System.assertEquals('FirstName', primaryAfflModel.getSettingsContactFieldValue());
        System.assertEquals('Business Org test', primaryAfflModel.getSettingsRecordTypeFieldValue());
    }

    /**************************************************************************************************************************************
    * @description Test to ensure that getModelFromMapping returns a valid model with an error message indicating an invalid lookup field 
    * mapping when validation is on, a valid record type is specified and a valid field that does not lookup to Account is mapped.
    **************************************************************************************************************************************/ 
    private static void getModelFromMappingValidRTAndNonLookupFieldValidationOff(){
        MAPR_PrimaryAffiliations_TEST.insertAfflMappingsWithValidRecordTypeNameAndNonLookupPrimaryFieldLabels();
        MAPR_PrimaryAffiliations maprPrimaryAfflInstance = new STUB_PrimaryAffiliationValidationOff();

        List<Affl_Mappings__c> primaryAfflMappings = UTIL_CustomSettingsFacade.getPrimaryAfflMappings();

        Test.startTest();
            MODL_PrimaryAfflMapper primaryAfflModel = maprPrimaryAfflInstance.getModelFromMapping(primaryAfflMappings[0]);
        Test.stopTest();

        String prefix = UTIL_Namespace.StrTokenNSPrefix('');

        System.assert(primaryAfflModel != null);
        System.assertEquals(true, primaryAfflModel.getIsValid());
        System.assertEquals(MAPR_PrimaryAffiliations_TEST.getExpectedInvalidFieldMappingErrorMessage(primaryAfflMappings[0]), primaryAfflModel.getInvalidErrorMessage());
        System.assertEquals('Business Organization', primaryAfflModel.getAccountRecordTypeId());
        System.assertEquals(prefix + 'FirstName', primaryAfflModel.getContactFieldApiName());
        System.assertEquals('FirstName', primaryAfflModel.getSettingsContactFieldValue());
        System.assertEquals('Business Organization', primaryAfflModel.getSettingsRecordTypeFieldValue());
    }

    /**************************************************************************************************************************************
    * @description Test to ensure that getModelFromMapping returns a valid model with an error message indicating an invalid record type 
    * mapping when validation is on, an invalid record type is specified and a valid field that does not lookup to Account is mapped.
    **************************************************************************************************************************************/ 
    private static void getModelFromMappingInvalidRTAndNonLookupFieldValidationOn(){
        MAPR_PrimaryAffiliations_TEST.insertAfflMappingsWithInaccurateRecordTypeNameAndNonLookupPrimaryFieldLabels();
        MAPR_PrimaryAffiliations maprPrimaryAfflInstance = new STUB_PrimaryAffiliationValidationOn();

        List<Affl_Mappings__c> primaryAfflMappings = UTIL_CustomSettingsFacade.getPrimaryAfflMappings();

        Test.startTest();
            MODL_PrimaryAfflMapper primaryAfflModel = maprPrimaryAfflInstance.getModelFromMapping(primaryAfflMappings[0]);
        Test.stopTest();

        String prefix = UTIL_Namespace.StrTokenNSPrefix('');

        System.assert(primaryAfflModel != null);
        System.assertEquals(false, primaryAfflModel.getIsValid());
        System.assertEquals(MAPR_PrimaryAffiliations_TEST.getExpectedInvalidRTMappingErrorMessage(primaryAfflMappings[0]), primaryAfflModel.getInvalidErrorMessage());
        System.assertEquals('Business Org test', primaryAfflModel.getAccountRecordTypeId());
        System.assertEquals(prefix + 'FirstName', primaryAfflModel.getContactFieldApiName());
        System.assertEquals('FirstName', primaryAfflModel.getSettingsContactFieldValue());
        System.assertEquals('Business Org test', primaryAfflModel.getSettingsRecordTypeFieldValue());
    }

    /**************************************************************************************************************************************
    * @description Test to ensure that getModelFromMapping returns a valid model with an error message indicating an invalid record type 
    * mapping when validation is on, an invalid record type is specified and a valid field that does lookup to Account is mapped.
    **************************************************************************************************************************************/ 
    private static void getModelFromMappingInvalidRTAndLookupFieldValidationOn(){
        MAPR_PrimaryAffiliations_TEST.insertAfflMappingsWithInaccurateRecordTypeNameAndAccuratePrimaryFieldLabels();
        MAPR_PrimaryAffiliations maprPrimaryAfflInstance = new STUB_PrimaryAffiliationValidationOn();

        List<Affl_Mappings__c> primaryAfflMappings = UTIL_CustomSettingsFacade.getPrimaryAfflMappings();

        Test.startTest();
            MODL_PrimaryAfflMapper primaryAfflModel = maprPrimaryAfflInstance.getModelFromMapping(primaryAfflMappings[0]);
        Test.stopTest();

        String prefix = UTIL_Namespace.StrTokenNSPrefix('');

        System.assert(primaryAfflModel != null);
        System.assertEquals(false, primaryAfflModel.getIsValid());
        System.assertEquals(MAPR_PrimaryAffiliations_TEST.getExpectedInvalidRTMappingErrorMessage(primaryAfflMappings[0]), primaryAfflModel.getInvalidErrorMessage());
        System.assertEquals('Business Org test', primaryAfflModel.getAccountRecordTypeId());
        System.assertEquals(prefix + 'Primary_Organization__c', primaryAfflModel.getContactFieldApiName());
        System.assertEquals('Primary_Organization__c', primaryAfflModel.getSettingsContactFieldValue());
        System.assertEquals('Business Org test', primaryAfflModel.getSettingsRecordTypeFieldValue());
    }

    /**************************************************************************************************************************************
    * @description Test to ensure that getModelFromMapping returns a valid model with an error message indicating an invalid lookup field 
    * mapping when validation is on, a valid record type is specified and a valid field that does not lookup to Account is mapped.
    **************************************************************************************************************************************/ 
    private static void getModelFromMappingValidRTAndNonLookupFieldValidationOn(){
        MAPR_PrimaryAffiliations_TEST.insertAfflMappingsWithValidRecordTypeNameAndNonLookupPrimaryFieldLabels();
        MAPR_PrimaryAffiliations maprPrimaryAfflInstance = new STUB_PrimaryAffiliationValidationOn();

        List<Affl_Mappings__c> primaryAfflMappings = UTIL_CustomSettingsFacade.getPrimaryAfflMappings();

        Test.startTest();
            MODL_PrimaryAfflMapper primaryAfflModel = maprPrimaryAfflInstance.getModelFromMapping(primaryAfflMappings[0]);
        Test.stopTest();

        String prefix = UTIL_Namespace.StrTokenNSPrefix('');

        System.assert(primaryAfflModel != null);
        System.assertEquals(false, primaryAfflModel.getIsValid());
        System.assertEquals(MAPR_PrimaryAffiliations_TEST.getExpectedInvalidFieldMappingErrorMessage(primaryAfflMappings[0]), primaryAfflModel.getInvalidErrorMessage());
        System.assertEquals('Business Organization', primaryAfflModel.getAccountRecordTypeId());
        System.assertEquals(prefix + 'FirstName', primaryAfflModel.getContactFieldApiName());
        System.assertEquals('FirstName', primaryAfflModel.getSettingsContactFieldValue());
        System.assertEquals('Business Organization', primaryAfflModel.getSettingsRecordTypeFieldValue());
    }

    /***************************************************************************************************************
    * STUB class which extends MAPR_PrimaryAffiliations, overrides isPrimaryAffiliationValidationOn to return true
    ***************************************************************************************************************/
    private class STUB_PrimaryAffiliationValidationOn extends MAPR_PrimaryAffiliations {
        @TestVisible
        protected override boolean isPrimaryAffiliationValidationOn() {
            return true;
        }
    }

    /***************************************************************************************************************
    * STUB class which extends MAPR_PrimaryAffiliations, overrides isPrimaryAffiliationValidationOn to return false
    ***************************************************************************************************************/
    private class STUB_PrimaryAffiliationValidationOff extends MAPR_PrimaryAffiliations {
        @TestVisible
        protected override boolean isPrimaryAffiliationValidationOn() {
            return false;
        }
    }
}
public class MODL_PrimaryAfflMapper {

    private Id accRecordTypeId;
    private Boolean isValid;
    private String accRecTypeDeveloperName;
    private String accRecTypeName;
    private String contactFieldApiName;
    private String contactFieldLabel;
    private String primaryAfflFieldValueFromSettings;
    private String accRecTypeValueFromSettings;
    private String invalidErrorMessage;

    /*******************************************************************************************************
    * @description Constructor with 5 parameters
    * @param accountRecordTypeInfo Schema.RecordTypeInfo of Account
    * @param contactDescribeFieldResult Schema.DescribeFieldResult for Contact's field
    * @param settingsContactFieldValue 'Contact Primary Affl Field' from EDA Settings.
    * @param settingsRecordTypeValue 'Account Record Type' value from EDA Settings.
    * @param isValid Boolean flag to indicate whether the Record Type Affiliation maps to a valid Account record type.
    *******************************************************************************************************/ 
    public MODL_PrimaryAfflMapper(Schema.RecordTypeInfo accountRecordTypeInfo, 
                                  Schema.DescribeFieldResult contactDescribeFieldResult, 
                                  String settingsContactFieldValue, 
                                  String settingsRecordTypeValue, 
                                  Boolean isValid,
                                  String invalidErrorMessage) {

        this.accRecordTypeId = accountRecordTypeInfo.getRecordTypeId();
        this.isValid = isValid;
        this.accRecTypeDeveloperName = accountRecordTypeInfo.getDeveloperName();
        this.accRecTypeName = accountRecordTypeInfo.getName();
        this.contactFieldApiName = contactDescribeFieldResult.getName();
        this.contactFieldLabel = contactDescribeFieldResult.getLabel();
        this.primaryAfflFieldValueFromSettings = settingsContactFieldValue;
        this.accRecTypeValueFromSettings = settingsRecordTypeValue;
        this.invalidErrorMessage = invalidErrorMessage;
    }

    /*******************************************************************************************************
    * @description Constructor with 4 parameters
    * @param contactDescribeFieldResult Schema.DescribeFieldResult for Contact's field
    * @param settingsContactFieldValue 'Contact Primary Affl Field' from EDA Settings.
    * @param settingsRecordTypeValue 'Account Record Type' value from EDA Settings.
    * @param isValid Boolean flag to indicate whether the Record Type Affiliation maps to a valid Account record type.
    *******************************************************************************************************/ 
    public MODL_PrimaryAfflMapper(Schema.DescribeFieldResult contactDescribeFieldResult, 
                                  String settingsContactFieldValue, 
                                  String settingsRecordTypeValue, 
                                  Boolean isValid,
                                  String invalidErrorMessage) {

        this.isValid = isValid;
        this.contactFieldApiName = contactDescribeFieldResult.getName();
        this.contactFieldLabel = contactDescribeFieldResult.getLabel();
        this.primaryAfflFieldValueFromSettings = settingsContactFieldValue;
        this.accRecTypeValueFromSettings = settingsRecordTypeValue;
        this.invalidErrorMessage = invalidErrorMessage;
    }

    /*******************************************************************************************************
    * @description Constructor with 4 parameters
    * @param accountRecordTypeInfo Schema.RecordTypeInfo of Account
    * @param settingsContactFieldValue 'Contact Primary Affl Field' from EDA Settings.
    * @param settingsRecordTypeValue 'Account Record Type' value from EDA Settings.
    * @param isValid Boolean flag to indicate whether the Record Type Affiliation maps to a valid Account record type.
    *******************************************************************************************************/ 
    public MODL_PrimaryAfflMapper(Schema.RecordTypeInfo accountRecordTypeInfo, 
                                  String settingsContactFieldValue, 
                                  String settingsRecordTypeValue, 
                                  Boolean isValid,
                                  String invalidErrorMessage) {

        this.accRecordTypeId = accountRecordTypeInfo.getRecordTypeId();
        this.isValid = isValid;
        this.accRecTypeDeveloperName = accountRecordTypeInfo.getDeveloperName();
        this.accRecTypeName = accountRecordTypeInfo.getName();
        this.primaryAfflFieldValueFromSettings = settingsContactFieldValue;
        this.accRecTypeValueFromSettings = settingsRecordTypeValue;
        this.invalidErrorMessage = invalidErrorMessage;
    }

    /*******************************************************************************************************
    * @description Getter method to return the Account Record Type Id. If it is not available then returns
    * 'Account Record Type' value from EDA Settings.
    * @return Account Record Type Id or 'Account Record Type' value from EDA Settings
    *******************************************************************************************************/ 
    public String getAccountRecordTypeId() {
        if (this.accRecordTypeId == null) {
            return this.accRecTypeValueFromSettings;
        }
        return (String)this.accRecordTypeId;
    }

    /*******************************************************************************************************
    * @description Getter method to return the isValid property.
    * @return True if setting is valid, False otherwise.
    *******************************************************************************************************/ 
    public Boolean getIsValid() {
        return this.isValid;
    }

    /*******************************************************************************************************
    * @description Getter method to return the Contact Field API name. If it is not available then returns
    * 'Contact Primary Affl Field' from EDA Settings.
    * @return Field API name for Contact or 'Primary Affl Field' value from EDA Settings
    *******************************************************************************************************/ 
    public String getContactFieldApiName() {
        if (String.isEmpty(this.contactFieldApiName) == true) {
            return this.primaryAfflFieldValueFromSettings; 
        }
        return this.contactFieldApiName;
    }

    /*******************************************************************************************************
    * @description Getter method to return the 'Contact Primary Affl Field' value from EDA Settings.
    * @return 'Primary Affl Field' value from EDA Settings
    *******************************************************************************************************/ 
    public String getSettingsContactFieldValue() {
        return this.primaryAfflFieldValueFromSettings;
    }

    /*******************************************************************************************************
    * @description Getter method to return the 'Account Record Type' value from EDA Settings.
    * 'Account Record Type' value from EDA Settings
    *******************************************************************************************************/ 
    public String getSettingsRecordTypeFieldValue() {
        return this.accRecTypeValueFromSettings;
    }

    public String getInvalidErrorMessage(){
        return this.invalidErrorMessage;
    }
}
@isTest
private class MODL_PrimaryAfflMapper_TEST {

    /**********************************************************************************************************
    * @description Tests that MODL_PrimaryAfflMapper generates a valid model with all the four Parameters 
    **********************************************************************************************************/
    @isTest
    static void constructorWithAllParametersTestValid() {

        String namespace = UTIL_Namespace.getNamespace();
        String prefix = (String.isNotBlank(namespace)) ? namespace + '__' : '';

        Schema.RecordTypeInfo busiOrgInfo = UTIL_Describe.getRecordTypeInfoByDeveloperName('Account', 'Business_Organization');
        Schema.DescribeFieldResult contactFieldDescribeResult = UTIL_Describe.getFieldDescribe('Contact', prefix + 'Primary_Organization__c');

        List<Affl_Mappings__c> mappings = new List<Affl_Mappings__c>();
        mappings.add(new Affl_Mappings__c(Name = 'Business Organization', Account_Record_Type__c = 'Business Organization', Primary_Affl_Field__c = 'Primary Business Organization'));
        insert mappings;

        Test.startTest();
            MODL_PrimaryAfflMapper conPrimaryAfflModl = new MODL_PrimaryAfflMapper(busiOrgInfo, contactFieldDescribeResult, mappings[0].Primary_Affl_Field__c, mappings[0].Account_Record_Type__c, true, '');
        Test.stopTest();

        System.assertEquals(true, conPrimaryAfflModl.getIsValid());
        System.assertEquals(true, String.isEmpty(conPrimaryAfflModl.getInvalidErrorMessage()));
        System.assertEquals(UTIL_Describe_API.getBizAccRecTypeID(), conPrimaryAfflModl.getAccountRecordTypeId());
        System.assertEquals(prefix + 'Primary_Organization__c', conPrimaryAfflModl.getContactFieldApiName());
        System.assertEquals(mappings[0].Primary_Affl_Field__c, conPrimaryAfflModl.getSettingsContactFieldValue());
        System.assertEquals(mappings[0].Account_Record_Type__c, conPrimaryAfflModl.getSettingsRecordTypeFieldValue());
    }

    /**********************************************************************************************************
    * @description Tests that MODL_PrimaryAfflMapper generates an invalid model with all the four Parameters 
    **********************************************************************************************************/
    @isTest
    static void constructorWithAllParametersTestNotValid() {

        String namespace = UTIL_Namespace.getNamespace();
        String prefix = (String.isNotBlank(namespace)) ? namespace + '__' : '';
        String errorString = 'Invalid affiliation mapping found';

        Schema.RecordTypeInfo busiOrgInfo = UTIL_Describe.getRecordTypeInfoByDeveloperName('Account', 'Business_Organization');
        Schema.DescribeFieldResult contactFieldDescribeResult = UTIL_Describe.getFieldDescribe('Contact', prefix + 'Primary_Organization__c');

        List<Affl_Mappings__c> mappings = new List<Affl_Mappings__c>();
        mappings.add(new Affl_Mappings__c(Name = 'Business Organization', Account_Record_Type__c = 'Business Organization', Primary_Affl_Field__c = 'Primary Business Organization'));
        insert mappings;

        Test.startTest();
            MODL_PrimaryAfflMapper conPrimaryAfflModl = new MODL_PrimaryAfflMapper(busiOrgInfo, contactFieldDescribeResult, mappings[0].Primary_Affl_Field__c, mappings[0].Account_Record_Type__c, false, errorString);
        Test.stopTest();

        System.assertEquals(false, conPrimaryAfflModl.getIsValid());
        System.assertEquals(errorString, conPrimaryAfflModl.getInvalidErrorMessage());
        System.assertEquals(UTIL_Describe_API.getBizAccRecTypeID(), conPrimaryAfflModl.getAccountRecordTypeId());
        System.assertEquals(prefix + 'Primary_Organization__c', conPrimaryAfflModl.getContactFieldApiName());
        System.assertEquals(mappings[0].Primary_Affl_Field__c, conPrimaryAfflModl.getSettingsContactFieldValue());
        System.assertEquals(mappings[0].Account_Record_Type__c, conPrimaryAfflModl.getSettingsRecordTypeFieldValue());
    }

    /**********************************************************************************************************
    * @description Tests that MODL_PrimaryAfflMapper generates a valid model with  
    * ContactDescribeFieldResult, Mapping Settings Parameters and no Schema.RecordTypeInfo 
    **********************************************************************************************************/
    @isTest
    static void  constructorWithContactDescribeFieldResultValidTest() {

        String namespace = UTIL_Namespace.getNamespace();
        String prefix = (String.isNotBlank(namespace)) ? namespace + '__' : '';

        Schema.DescribeFieldResult contactFieldDescribeResult = UTIL_Describe.getFieldDescribe('Contact', prefix + 'Primary_Organization__c');

        List<Affl_Mappings__c> mappings = new List<Affl_Mappings__c>();
        mappings.add(new Affl_Mappings__c(Name = 'Business Organization', Account_Record_Type__c = 'Business Organization', Primary_Affl_Field__c = 'Primary Business Organization'));
        insert mappings;

        Test.startTest();
            MODL_PrimaryAfflMapper conPrimaryAfflModl = new MODL_PrimaryAfflMapper(contactFieldDescribeResult, mappings[0].Primary_Affl_Field__c, mappings[0].Account_Record_Type__c, true, '');
        Test.stopTest();

        System.assertEquals(true, conPrimaryAfflModl.getIsValid());
        System.assertEquals(true, String.isBlank(conPrimaryAfflModl.getInvalidErrorMessage()));
        System.assertEquals(mappings[0].Account_Record_Type__c, conPrimaryAfflModl.getAccountRecordTypeId());
        System.assertEquals(prefix + 'Primary_Organization__c', conPrimaryAfflModl.getContactFieldApiName());
        System.assertEquals(mappings[0].Primary_Affl_Field__c, conPrimaryAfflModl.getSettingsContactFieldValue());
        System.assertEquals(mappings[0].Account_Record_Type__c, conPrimaryAfflModl.getSettingsRecordTypeFieldValue());
    }

    /**********************************************************************************************************
    * @description Tests that MODL_PrimaryAfflMapper generates an invalid model with  
    * ContactDescribeFieldResult, Mapping Settings Parameters and no Schema.RecordTypeInfo 
    **********************************************************************************************************/
    @isTest
    static void  constructorWithContactDescribeFieldResultNotValidTest() {

        String namespace = UTIL_Namespace.getNamespace();
        String prefix = (String.isNotBlank(namespace)) ? namespace + '__' : '';
        String errorString = 'Invalid affiliation mapping found';

        Schema.DescribeFieldResult contactFieldDescribeResult = UTIL_Describe.getFieldDescribe('Contact', prefix + 'Primary_Organization__c');

        List<Affl_Mappings__c> mappings = new List<Affl_Mappings__c>();
        mappings.add(new Affl_Mappings__c(Name = 'Business Organization', Account_Record_Type__c = 'Business Organization', Primary_Affl_Field__c = 'Primary Business Organization'));
        insert mappings;

        Test.startTest();
            MODL_PrimaryAfflMapper conPrimaryAfflModl = new MODL_PrimaryAfflMapper(contactFieldDescribeResult, mappings[0].Primary_Affl_Field__c, mappings[0].Account_Record_Type__c, false, errorString);
        Test.stopTest();

        System.assertEquals(false, conPrimaryAfflModl.getIsValid());
        System.assertEquals(errorString, conPrimaryAfflModl.getInvalidErrorMessage());
        System.assertEquals(mappings[0].Account_Record_Type__c, conPrimaryAfflModl.getAccountRecordTypeId());
        System.assertEquals(prefix + 'Primary_Organization__c', conPrimaryAfflModl.getContactFieldApiName());
        System.assertEquals(mappings[0].Primary_Affl_Field__c, conPrimaryAfflModl.getSettingsContactFieldValue());
        System.assertEquals(mappings[0].Account_Record_Type__c, conPrimaryAfflModl.getSettingsRecordTypeFieldValue());
    }

    /**********************************************************************************************************
    * @description Tests that MODL_PrimaryAfflMapper generates a valid model with Schema.RecordTypeInfo, 
    * Mapping Settings Parameters and no ContactDescribeFieldResult
    **********************************************************************************************************/
    @isTest
    static void  constructorWithRecordTypeInfoValidTest() {

        String namespace = UTIL_Namespace.getNamespace();
        String prefix = (String.isNotBlank(namespace)) ? namespace + '__' : '';

        Schema.RecordTypeInfo busiOrgInfo = UTIL_Describe.getRecordTypeInfoByDeveloperName('Account', 'Business_Organization');

        List<Affl_Mappings__c> mappings = new List<Affl_Mappings__c>();
        mappings.add(new Affl_Mappings__c(Name = 'Business Organization', Account_Record_Type__c = 'Business Organization', Primary_Affl_Field__c = 'Primary Business Organization'));
        insert mappings;

        Test.startTest();
            MODL_PrimaryAfflMapper conPrimaryAfflModl = new MODL_PrimaryAfflMapper(busiOrgInfo, mappings[0].Primary_Affl_Field__c, mappings[0].Account_Record_Type__c, true, '');
        Test.stopTest();

        System.assertEquals(true, conPrimaryAfflModl.getIsValid());
        System.assertEquals(true, String.isEmpty(conPrimaryAfflModl.getInvalidErrorMessage()));
        System.assertEquals(UTIL_Describe_API.getBizAccRecTypeID(), conPrimaryAfflModl.getAccountRecordTypeId());
        System.assertEquals(mappings[0].Primary_Affl_Field__c, conPrimaryAfflModl.getContactFieldApiName());
        System.assertEquals(mappings[0].Primary_Affl_Field__c, conPrimaryAfflModl.getSettingsContactFieldValue());
        System.assertEquals(mappings[0].Account_Record_Type__c, conPrimaryAfflModl.getSettingsRecordTypeFieldValue());
    }

    /**********************************************************************************************************
    * @description Tests that MODL_PrimaryAfflMapper generates an invalid model with Schema.RecordTypeInfo, 
    * Mapping Settings Parameters and no ContactDescribeFieldResult
    **********************************************************************************************************/
    @isTest
    static void  constructorWithRecordTypeInfoNotValidTest() {

        String namespace = UTIL_Namespace.getNamespace();
        String prefix = (String.isNotBlank(namespace)) ? namespace + '__' : '';
        String errorString = 'Invalid affiliation mapping found';

        Schema.RecordTypeInfo busiOrgInfo = UTIL_Describe.getRecordTypeInfoByDeveloperName('Account', 'Business_Organization');

        List<Affl_Mappings__c> mappings = new List<Affl_Mappings__c>();
        mappings.add(new Affl_Mappings__c(Name = 'Business Organization', Account_Record_Type__c = 'Business Organization', Primary_Affl_Field__c = 'Primary Business Organization'));
        insert mappings;

        Test.startTest();
            MODL_PrimaryAfflMapper conPrimaryAfflModl = new MODL_PrimaryAfflMapper(busiOrgInfo, mappings[0].Primary_Affl_Field__c, mappings[0].Account_Record_Type__c, false, errorString);
        Test.stopTest();

        System.assertEquals(false, conPrimaryAfflModl.getIsValid());
        System.assertEquals(errorString, conPrimaryAfflModl.getInvalidErrorMessage());
        System.assertEquals(UTIL_Describe_API.getBizAccRecTypeID(), conPrimaryAfflModl.getAccountRecordTypeId());
        System.assertEquals(mappings[0].Primary_Affl_Field__c, conPrimaryAfflModl.getContactFieldApiName());
        System.assertEquals(mappings[0].Primary_Affl_Field__c, conPrimaryAfflModl.getSettingsContactFieldValue());
        System.assertEquals(mappings[0].Account_Record_Type__c, conPrimaryAfflModl.getSettingsRecordTypeFieldValue());
    }
}
public without sharing class ObjectUsageTelemetryModel {
    public Integer countBadgeCredentials = 0;
    public Integer countHouseholdAccounts = 0;
    public Integer countLicenseCredentials = 0;
    public Integer countAdministrativeAccounts = 0;
    public Integer countCertificationCredentials = 0;
    public Integer countDegreeAcademicCertifications = 0;
    public Integer countDiplomaAcademicCertifications = 0;
    public Integer countCertificateAcademicCertifications = 0;

    public Integer numErrors;
    public Integer numFacilities;
    public Integer numTermGrades;
    public Integer numCredentials;
    public Integer numProgramPlans;
    public Integer numPlanRequirements;
    public Integer numCourseEnrollments;
    public Integer numAcademicCertifications;
    public Integer numCourseOfferingSchedules;
    public Integer numAutoEnrollmentAffMappings;
    public Integer numSeasonalAddresses;
    public Integer numCurrentYearSeasonalAddesses;

    public ObjectUsageTelemetryModel() {
        this.numErrors = [SELECT COUNT() FROM Error__c];
        this.numFacilities = [SELECT COUNT() FROM Facility__c];
        this.numTermGrades = [SELECT COUNT() FROM Term_Grade__c];
        this.numCredentials = [SELECT COUNT() FROM Credential__c];
        this.numProgramPlans = [SELECT COUNT() FROM Program_Plan__c];
        this.numPlanRequirements = [SELECT COUNT() FROM Plan_Requirement__c];
        this.numCourseEnrollments = [SELECT COUNT() FROM Course_Enrollment__c];
        this.numAcademicCertifications = [SELECT COUNT() FROM Academic_Certification__c];
        this.numCourseOfferingSchedules = [SELECT COUNT() FROM Course_Offering_Schedule__c];

        this.numAutoEnrollmentAffMappings = [
            SELECT COUNT()
            FROM Affl_Mappings__c
            WHERE Auto_Program_Enrollment__c = TRUE
        ];

        this.numSeasonalAddresses = [
            SELECT COUNT()
            FROM Address__c
            WHERE
                Seasonal_Start_Month__c != NULL
                AND Seasonal_Start_Day__c != NULL
                AND Seasonal_End_Month__c != NULL
                AND Seasonal_End_Day__c != NULL
        ];

        this.numCurrentYearSeasonalAddesses = [
            SELECT COUNT()
            FROM Address__c
            WHERE
                Seasonal_Start_Month__c != NULL
                AND Seasonal_Start_Day__c != NULL
                AND Seasonal_End_Month__c != NULL
                AND Seasonal_End_Day__c != NULL
                AND CreatedDate = LAST_N_DAYS:365
        ];

        if (UTIL_Describe.getCustomAdminAccRecTypeId() != null) {
            this.countAdministrativeAccounts = [
                SELECT COUNT()
                FROM Account
                WHERE RecordTypeId = :UTIL_Describe.getCustomAdminAccRecTypeId()
            ];
        }

        if (UTIL_Describe.getCustomHHAccRecTypeID() != null) {
            this.countHouseholdAccounts = [
                SELECT COUNT()
                FROM Account
                WHERE RecordTypeId = :UTIL_Describe.getCustomHHAccRecTypeID()
            ];
        }

        if (UTIL_Describe.getCertificateAcademicCertificationRecTypeId() != null) {
            this.countCertificateAcademicCertifications = [
                SELECT COUNT()
                FROM Academic_Certification__c
                WHERE RecordTypeId = :UTIL_Describe.getCertificateAcademicCertificationRecTypeId()
            ];
        }

        if (UTIL_Describe.getDegreeAcademicCertificationRecTypeId() != null) {
            this.countDegreeAcademicCertifications = [
                SELECT COUNT()
                FROM Academic_Certification__c
                WHERE RecordTypeId = :UTIL_Describe.getDegreeAcademicCertificationRecTypeId()
            ];
        }

        if (UTIL_Describe.getDiplomaAcademicCertificationRecTypeId() != null) {
            this.countDiplomaAcademicCertifications = [
                SELECT COUNT()
                FROM Academic_Certification__c
                WHERE RecordTypeId = :UTIL_Describe.getDiplomaAcademicCertificationRecTypeId()
            ];
        }

        if (UTIL_Describe.getBadgeCredentialRecTypeId() != null) {
            this.countBadgeCredentials = [
                SELECT COUNT()
                FROM Credential__c
                WHERE RecordTypeId = :UTIL_Describe.getBadgeCredentialRecTypeId()
            ];
        }

        if (UTIL_Describe.getLicenseCredentialRecTypeId() != null) {
            this.countLicenseCredentials = [
                SELECT COUNT()
                FROM Credential__c
                WHERE RecordTypeId = :UTIL_Describe.getLicenseCredentialRecTypeId()
            ];
        }

        if (UTIL_Describe.getCertificationCredentialRecTypeId() != null) {
            this.countCertificationCredentials = [
                SELECT COUNT()
                FROM Credential__c
                WHERE RecordTypeId = :UTIL_Describe.getCertificationCredentialRecTypeId()
            ];
        }
    }
}
@isTest
public with sharing class PPlan_CannotDelete_TEST {
    
    /*********************************************************************************************************
    * @description Tests the deletion of Program Plan with Plan Requirement as related child records
    * and when Prevent Program Plan Deletion is enabled.
    */
    @isTest
    public static void pPlanCannotDeleteWithPlanRequirement() {
        
        // Enable Custom Settings
        UTIL_CustomSettingsFacade.getSettingsForTests(new Hierarchy_Settings__c(Prevent_Program_Plan_Deletion__c = TRUE));
        
        // Insert Program Plan
        List<Program_Plan__c> pPlans = UTIL_UnitTestData_TEST.getMultipleTestProgramPlans(1);
        insert pPlans;
       
       // Insert Plan Requirement
        List<Plan_Requirement__c> prs = UTIL_UnitTestData_TEST.getMultipleTestPlanRequirements(2);
        for (Plan_Requirement__c pr : prs) {
            pr.Program_Plan__c = pPlans[0].Id;
        }
        insert prs;

        Test.startTest();
            Database.DeleteResult[] results = Database.delete(pPlans, false);
        Test.stopTest();

        //Verify pPlan was not successfully deleted
        List<Program_Plan__c> assertPps = [select ID from Program_Plan__c];
        System.assertEquals(1, assertPps.size());

        System.assertEquals(false, results[0].success);
        System.assertEquals(Label.CannotDelete, results[0].errors[0].message);
    }
    
    /*********************************************************************************************************
    * @description Tests the deletion of Program Enrollments with Program Enrollment as related child records
    * and when Prevent Program Plan Deletion is enabled.
    */
    @isTest
    public static void pPlanCannotDeleteWithProgramEnrollments() {
        
        // Enable Custom Settings
        UTIL_CustomSettingsFacade.getSettingsForTests(new Hierarchy_Settings__c(Prevent_Program_Plan_Deletion__c = TRUE));
        
        // Insert Account
        List<Account> academicPrograms = UTIL_UnitTestData_TEST.getMultipleTestAccounts(1, UTIL_Describe.getAcademicAccRecTypeID());
        insert academicPrograms;
        
        // Insert Program Plan
        List<Program_Plan__c> pPlans = UTIL_UnitTestData_TEST.getMultipleTestProgramPlans(1);
        insert pPlans;
        
        // Insert Plan Enrollment
        List<Program_Enrollment__c> pes = UTIL_UnitTestData_TEST.getMultipleTestProgramEnrollments(2, academicPrograms[0].Id);
        for (Program_Enrollment__c pe : pes) {
            pe.Program_Plan__c = pPlans[0].Id;
        }
        insert pes;

        Test.startTest();
            Database.DeleteResult[] results = Database.delete(pPlans, false);
        Test.stopTest();

        //Verify pPlan was not successfully deleted
        List<Program_Plan__c> assertPps = [select ID from Program_Plan__c];
        System.assertEquals(1, assertPps.size());

        System.assertEquals(false, results[0].success);
        System.assertEquals(Label.CannotDelete, results[0].errors[0].message);
    }
    /*********************************************************************************************************
    * @description Tests the deletion of Program Enrollments with Program Enrollment and Plan Requirement
    * as related child records and when Prevent Program Plan Deletion is disabled.
    */
    @isTest
    public static void pPlanCannotDeleteWProgramEnrollmentsAndPlanReq() {
        
        // Disable Custom Settings
        UTIL_CustomSettingsFacade.getSettingsForTests(new Hierarchy_Settings__c(Prevent_Program_Plan_Deletion__c = FALSE));

        // Insert Account
        List<Account> academicPrograms = UTIL_UnitTestData_TEST.getMultipleTestAccounts(1, UTIL_Describe.getAcademicAccRecTypeID());
        insert academicPrograms;
        
        // Insert Program plan
        List<Program_Plan__c> pPlans = UTIL_UnitTestData_TEST.getMultipleTestProgramPlans(1);
        insert pPlans;
        
        // Insert Program Enrollment
        List<Program_Enrollment__c> pes = UTIL_UnitTestData_TEST.getMultipleTestProgramEnrollments(2, academicPrograms[0].Id);
        for (Program_Enrollment__c pe : pes) {
            pe.Program_Plan__c = pPlans[0].Id;
        }
        insert pes;
        
        // Insert Plan Requirement
        List<Plan_Requirement__c> prs = UTIL_UnitTestData_TEST.getMultipleTestPlanRequirements(2);
        for (Plan_Requirement__c pr : prs) {
            pr.Program_Plan__c = pPlans[0].Id;
        }
        insert prs;
    
        Test.startTest();
           delete pPlans;
        Test.stopTest();    
        
        //Verify pPlan was successfully deleted
        List<Program_Plan__c> assertPps = [select ID from Program_Plan__c];
        System.assertEquals(0, assertPps.size());
    }
}
public with sharing class PPlan_Primary_TDTM extends TDTM_Runnable {
    /*******************************************************************************************************
    * @description Handles primary program plans.
    * @param listNew the list of Accounts from trigger new.
    * @param listOld the list of Accounts from trigger old.
    * @param triggerAction which trigger event (BeforeInsert, AfterInsert, etc.).
    * @param objResult the describe for Accounts
    * @return dmlWrapper.
    ********************************************************************************************************/
    public override DmlWrapper run(List<SObject> newlist, List<SObject> oldlist,
    TDTM_Runnable.Action triggerAction, Schema.DescribeSObjectResult objResult) {
        DmlWrapper dmlWrapper = new DmlWrapper();

        Set<Id> acccountIdsNeedNonPrimarycount = new Set<Id>();
        Set<Id> primaryProgramIds = new Set<Id>();
        
        boolean afterInsertRecursionFlag = TDTM_ProcessControl.getRecursionFlag(TDTM_ProcessControl.registeredTrigger.PPlan_Primary_TDTM_After_Insert);

        // AFTER INSERT
        if ( newlist != null && triggerAction == TDTM_Runnable.Action.AfterInsert && !afterInsertRecursionFlag) {    
            for (integer i = 0; i < newlist.size(); i++) {
                Program_Plan__c newPPlan = (Program_Plan__c)newlist[i];
                if (isNewlyPrimaryOrPrimaryAndAccountChanged(null, newPPlan)) {
                    //if multiple program plans under one single account are set as primary in same transation
                    //Use the first program plan as the primary
                    if (!acccountIdsNeedNonPrimarycount.contains(newPPlan.Account__c)) {
                        primaryProgramIds.add(newPPlan.Id);
                    }
                    acccountIdsNeedNonPrimarycount.add(newPPlan.Account__c);
                }
            }
        }

        boolean afterUpdateRecursionFlag = TDTM_ProcessControl.getRecursionFlag(TDTM_ProcessControl.registeredTrigger.PPlan_Primary_TDTM_After_Update);
    
        // AFTER UPDATE
        if ( newlist != null && triggerAction == TDTM_Runnable.Action.AfterUpdate && !afterUpdateRecursionFlag) {                
             for (integer i = 0; i < newlist.size(); i++) {
                Program_Plan__c newPPlan = (Program_Plan__c)newlist[i];
                Program_Plan__c oldPPlan = (Program_Plan__c)oldlist[i];
                if (isNewlyPrimaryOrPrimaryAndAccountChanged(oldPPlan, newPPlan)) {
                    //if multiple program plans under one single account are set as primary in same transation
                    //Use the first program plan as the primary
                    if (!acccountIdsNeedNonPrimarycount.contains(newPPlan.Account__c)) {
                        primaryProgramIds.add(newPPlan.Id);
                    }
                    acccountIdsNeedNonPrimarycount.add(newPPlan.Account__c);
                }
            }
        }

        if (acccountIdsNeedNonPrimarycount.size() > 0) {
            dmlWrapper.objectsToUpdate.addAll(makeOtherPPlanNotPrimary(acccountIdsNeedNonPrimarycount, primaryProgramIds));
        }
        
        if (triggerAction == TDTM_Runnable.Action.AfterUpdate) {
            TDTM_ProcessControl.setRecursionFlag(TDTM_ProcessControl.registeredTrigger.PPlan_Primary_TDTM_After_Update, false);
        } else if (triggerAction == TDTM_Runnable.Action.AfterInsert) {
            TDTM_ProcessControl.setRecursionFlag(TDTM_ProcessControl.registeredTrigger.PPlan_Primary_TDTM_After_Insert, false);
        }
        
        return dmlWrapper;
    }

    /*******************************************************************************************************
    * @description Compares oldPPlan (if present), and newPPlan to see if newly Primary, or if Account was changed.
    * Requires Is_Primary__c and Account__c fields to be populated.
    * @param oldPPlan old value of Program_Plan__c record (or null if new record) 
    * @param new PPlan new value of Program_Plan__c record
    * @return Boolean true if newly marked primary, or if currently primary and related Account__c was changed, false otherwise
    ********************************************************************************************************/
    @testVisible private static boolean isNewlyPrimaryOrPrimaryAndAccountChanged(Program_Plan__c oldPPlan, Program_Plan__c newPPlan) {
        boolean wasPrimary = ((oldPPlan != null) && (oldPPlan.Is_Primary__c));
        boolean isPrimary = ((newPPlan != null) && (newPPlan.Is_Primary__c));  
        Id oldAcctId = (oldPPlan != null) ? oldPPlan.Account__c : null;
        Id newAcctId = (newPPlan != null) ? newPPlan.Account__c : null;

        boolean acctChange = ((oldPPlan != null) && (oldAcctId != newAcctId));

        return (isPrimary) && ((!wasPrimary) || (acctChange));
    }

    private List<Program_Plan__c> makeOtherPPlanNotPrimary(Set<Id> accountIdsNeedNonPrimary, Set<Id> primaryProgramIds) {
        List<Program_Plan__c> pPlansNeedNonPrimary = new List<Program_Plan__c>();
        for (Program_Plan__c pPlan : [SELECT Id,
                                            Is_Primary__c
                                    From Program_Plan__c
                                    WHERE Account__c IN :accountIdsNeedNonPrimary
                                        AND Id NOT IN :primaryProgramIds
                                        AND IS_Primary__c = true]) {
            pPlan.Is_Primary__c = false;
            pPlansNeedNonPrimary.add(pPlan);
        }
        return pPlansNeedNonPrimary;
    }
}
@IsTest
private class PPlan_Primary_TEST {
    /*********************************************************************************************************
    * @description Set other program plans as non-primary
    * when a program plan is set as primary
    */
    @IsTest
    static void setOtherProgramPlanNonPrimaryUpdate() {
        List<Account> accts = UTIL_UnitTestData_TEST.getMultipleTestAccounts(1, UTIL_Describe.getCustomAdminAccRecTypeID());
        insert accts[0];

        List<Program_Plan__c> pPlans = UTIL_UnitTestData_TEST.getMultipleTestProgramPlans(3);
        for (Program_Plan__c pPlan : pPlans) {
            pPlan.Account__c = accts[0].Id;
        }
        insert pPlans;

        pPlans[0].Is_Primary__c = true;
        update pPlans[0];

        Test.startTest();
        pPlans[1].Is_Primary__c = true;
        update pPlans[1];
        Test.stopTest();

        //assert
        List<Program_Plan__c> assertProgramPlans = [SELECT Is_Primary__c FROM Program_Plan__c where Account__c = :accts[0].Id];
        for (Program_Plan__c pPlan : assertProgramPlans) {
            if (pPlan.Id != pPlans[1].Id) {
                system.assertEquals(false, pPlan.Is_Primary__c);
            }else {
                system.assertEquals(true, pPlan.Is_Primary__c);
            }
        }
    }

    /*********************************************************************************************************
     * @description Set other program plans as non-primary
     * when a new program plan is inserted and set as primary
     */
    @IsTest
    static void setOtherProgramPlanNonPrimaryInsert() {
        List<Account> accts = UTIL_UnitTestData_TEST.getMultipleTestAccounts(1, UTIL_Describe.getCustomAdminAccRecTypeID());
        insert accts[0];

        List<Program_Plan__c> pPlans = UTIL_UnitTestData_TEST.getMultipleTestProgramPlans(3);
        for (Program_Plan__c pPlan : pPlans) {
            pPlan.Account__c = accts[0].Id;
        }
        insert pPlans;

        pPlans[0].Is_Primary__c = true;
        update pPlans[0];

        Test.startTest();
        Program_Plan__c newPPlan = UTIL_UnitTestData_TEST.getProgramPlan();
        newPPlan.Account__c = accts[0].Id;
        newPPlan.Is_Primary__c = true;
        insert newPPlan;
        Test.stopTest();

        //assert
        List<Program_Plan__c> assertProgramPlans = [SELECT Is_Primary__c FROM Program_Plan__c where Account__c = :accts[0].Id];
        for (Program_Plan__c pPlan : assertProgramPlans) {
            if (pPlan.Id != newPPlan.Id) {
                system.assertEquals(false, pPlan.Is_Primary__c);
            }else {
                system.assertEquals(true, pPlan.Is_Primary__c);
            }
        }
    }

    /*********************************************************************************************************
     * @description Set other program plans as non-primary
     * when a program plan is set as primary and linked to the account
     */
    @IsTest
    static void setOtherProgramPlanNonPrimaryLinkToAccount() {
        List<Account> accts = UTIL_UnitTestData_TEST.getMultipleTestAccounts(1, UTIL_Describe.getCustomAdminAccRecTypeID());
        insert accts[0];

        List<Program_Plan__c> pPlans = UTIL_UnitTestData_TEST.getMultipleTestProgramPlans(3);
        for (Program_Plan__c pPlan : pPlans) {
            pPlan.Account__c = accts[0].Id;
        }
        insert pPlans;

        pPlans[0].Is_Primary__c = true;
        update pPlans[0];

        Test.startTest();
        Program_Plan__c newPPlan = UTIL_UnitTestData_TEST.getProgramPlan();
        newPPlan.Is_Primary__c = true;
        insert newPPlan;
        newPPlan.Account__c = accts[0].Id;
        update newPPlan;
        Test.stopTest();

        //assert
        List<Program_Plan__c> assertProgramPlans = [SELECT Is_Primary__c FROM Program_Plan__c where Account__c = :accts[0].Id];
        for (Program_Plan__c pPlan : assertProgramPlans) {
            if (pPlan.Id != newPPlan.Id) {
                system.assertEquals(false, pPlan.Is_Primary__c);
            }else {
                system.assertEquals(true, pPlan.Is_Primary__c);
            }
        }
    }

    /*********************************************************************************************************
     * @description Confirm various scenarios with isNewlyPrimaryOrPrimaryAccountChanged method
     *
     */
    @IsTest
    static void isNewlyPrimaryOrPrimaryAndAccountChanged() {
         List<Account> accts = UTIL_UnitTestData_TEST.getMultipleTestAccounts(2, UTIL_Describe.getCustomAdminAccRecTypeID());
        insert accts[0];

        List<Program_Plan__c> pPlans = UTIL_UnitTestData_TEST.getMultipleTestProgramPlans(1);
        for (Program_Plan__c pPlan : pPlans) {
            pPlan.Account__c = accts[0].Id;
        }
        insert pPlans;
        
        Program_Plan__c oldPPlan = pPlans[0].clone(true, true, true, true);
        Program_Plan__c newPPlan = pPlans[0].clone(true, true, true, true); 
                
        System.assertEquals (false, PPlan_Primary_TDTM.isNewlyPrimaryOrPrimaryAndAccountChanged(null, newPPlan), 'Test #1 - New Plan, Not Primary');
        
        newPPlan.IS_Primary__c = true;
        System.assertEquals (true, PPlan_Primary_TDTM.isNewlyPrimaryOrPrimaryAndAccountChanged(null, newPPlan), 'Test #2 - New Plan, Primary');

        oldPPlan.IS_Primary__c = false;
        newPPlan.IS_Primary__c = false;

        System.assertEquals (false, PPlan_Primary_TDTM.isNewlyPrimaryOrPrimaryAndAccountChanged(oldPPlan, newPPlan), 'Test #3 - Plan Update, neither are primary');

        oldPPlan.Is_Primary__c = false;
        newPPlan.Is_Primary__c = true;
        System.assertEquals (true, PPlan_Primary_TDTM.isNewlyPrimaryOrPrimaryAndAccountChanged(oldPPlan, newPPlan), 'Test #4 - Plan Update, Old Plan Not Primary, New Plan Primary');

        newPPlan.Is_Primary__c = true;
        oldPPlan.Is_Primary__c = true;
        System.assertEquals (false, PPlan_Primary_TDTM.isNewlyPrimaryOrPrimaryAndAccountChanged(oldPPlan, newPPlan), 'Test #5 - Plan Update, Old Plan Primary, New Plan Primary');

        oldPPlan.Is_Primary__c = true;
        newPPlan.Is_Primary__c = false;
        System.assertEquals (false, PPlan_Primary_TDTM.isNewlyPrimaryOrPrimaryAndAccountChanged(oldPPlan, newPPlan), 'Test #6 - Plan Update, Old Plan Primary, New Plan Not Primary');

        oldPPlan.Is_Primary__c = true;
        newPPlan.Is_Primary__c = true;
        newPPlan.Account__c = accts[1].Id;
        System.assertEquals (true, PPlan_Primary_TDTM.isNewlyPrimaryOrPrimaryAndAccountChanged(oldPPlan, newPPlan), 'Test #7 - Plan Update, Old Plan Primary, New Plan Primary, New Plan Account Changed');

        oldPPlan.Is_Primary__c = false;
        newPPlan.Is_Primary__c = false;
        newPPlan.Account__c = accts[1].Id;
        System.assertEquals (false, PPlan_Primary_TDTM.isNewlyPrimaryOrPrimaryAndAccountChanged(oldPPlan, newPPlan), 'Test #7 - Plan Update, Old Plan Not Primary, New Plan Not Primary, New Plan Account Changed');

        oldPPlan.Is_Primary__c = false;
        newPPlan.Is_Primary__c = true;
        newPPlan.Account__c = accts[1].Id;
        System.assertEquals (true, PPlan_Primary_TDTM.isNewlyPrimaryOrPrimaryAndAccountChanged(oldPPlan, newPPlan), 'Test #8 - Plan Update, Old Plan Not Primary, New Plan Primary, New Plan Account Changed');

        oldPPlan.Is_Primary__c = true;
        newPPlan.Is_Primary__c = false;
        newPPlan.Account__c = accts[1].Id;
        System.assertEquals (false, PPlan_Primary_TDTM.isNewlyPrimaryOrPrimaryAndAccountChanged(oldPPlan, newPPlan), 'Test #9 - Plan Update, Old Plan Primary, New Plan Not Primary, New Plan Account Changed');

    }
}
public class PREN_Affiliation_TDTM extends TDTM_Runnable {

    /*******************************************************************************************************
    * @description Handles Affiliation management for Program Enrollment.
    * @param listNew the list of Program Enrollments from trigger new. 
    * @param listOld the list of Program Enrollments from trigger old. 
    * @param triggerAction which trigger event (BeforeInsert, AfterInsert, etc.). 
    * @param objResult the describe for Program Enrollment. 
    * @return dmlWrapper.  
    ********************************************************************************************************/
    public override DmlWrapper run(List<SObject> newlist, List<SObject> oldlist, 
        TDTM_Runnable.Action triggerAction, Schema.DescribeSObjectResult objResult) {
    
        DmlWrapper dmlWrapper = new DmlWrapper();

        if (newlist != null && newlist.size() > 0) {
            // Because this runs on BeforeInsert, we don't need to worry about reentrancy here. The same program 
            // enrollment can't be inserted more than once! If inserting affiliation records creates or deletes 
            // more program enrollment records, we'd *want* these to be processed!
            createRelatedAffls(newlist, triggerAction);
        }
        
        if (oldlist != null && oldlist.size() > 0) {
            // Because this runs on AfterDelete, we don't need to worry about reentrancy here. The same program
            // enrollment can't be deleted more than once! If updating affiliation records creates or deletes
            // more program enrollment records, we'd *want* these to be processed!
            updateDeleteRelatedAffls(getDeletedPEsAfflIDs(oldlist, triggerAction), oldlist, dmlWrapper);
        }
        
        return dmlWrapper;
    }

    private void createRelatedAffls(List<SObject> newlist, TDTM_Runnable.Action triggerAction) {
        List<Affiliation__c> newAffls = new List<Affiliation__c>();

        for (SObject so : newlist) {
            Program_Enrollment__c enrollment = (Program_Enrollment__c)so;

            if (triggerAction == TDTM_Runnable.Action.BeforeInsert) {
                //Automatically create an Affiliation record if a Program Enrollment record has been created without an affiliation.
                if (enrollment.Contact__c != null && enrollment.Account__c != null && enrollment.Affiliation__c == null) {
                    Date afflEndDate = (UTIL_CustomSettingsFacade.getSettings().Affl_ProgEnroll_Copy_End_Date__c == true ? enrollment.End_Date__c : null);
                    Date afflStartDate = (UTIL_CustomSettingsFacade.getSettings().Affl_ProgEnroll_Copy_Start_Date__c == true ? enrollment.Start_Date__c : null);
                    String afflRole = (UTIL_CustomSettingsFacade.getSettings().Affl_ProgEnroll_Set_Role__c == true ? UTIL_CustomSettingsFacade.getSettings().Affl_ProgEnroll_Role_Map__c : null);

                    Affiliation__c affl = new Affiliation__c(Contact__c = enrollment.Contact__c,
                                                            Account__c = enrollment.Account__c,
                                                            EndDate__c = afflEndDate,
                                                            StartDate__c = afflStartDate,
                                                            Status__c = UTIL_CustomSettingsFacade.getSettings().Affl_ProgEnroll_Status_Map__c,
                                                            Role__c = afflRole);
                    newAffls.add(affl);
                }
            }
        }
        
        if (newAffls.size() > 0) {
            //Turn off AFFL_MultiRecordType_TDTM_After_Insert so EDA won't create duplicate program enrollment
            TDTM_ProcessControl.turnOffRecursionFlag(TDTM_ProcessControl.registeredTrigger.AFFL_MultiRecordType_TDTM_After_Insert);
            //We manually insert the affiliations because we need the IDs, in order to link the Program Enrollments with the Affls.
            insert newAffls;
            
            for (Integer i = 0; i < newAffls.size(); i++) {
                Program_Enrollment__c enrollment = (Program_Enrollment__c)newlist[i];
                enrollment.Affiliation__c = newAffls[i].ID;
            }
            //We don't need to add these enrollment records to dmlWrapper because we are in BeforeInsert.
        }
    }
    
    private List<ID> getDeletedPEsAfflIDs(List<SObject> oldlist, TDTM_Runnable.Action triggerAction) {
        List<ID> afflsToUpdateDelIDs = new List<ID>();
        //Only need to loop through the list when deleting Program Enrollment records
        if (triggerAction == TDTM_Runnable.Action.AfterDelete) {  
            
            for (SObject so : oldlist) {            
                Program_Enrollment__c oldEnrollment = (Program_Enrollment__c)so;
                
                if (oldEnrollment.Affiliation__c != null) {
                    //Get related Affls ids
                    afflsToUpdateDelIDs.add(oldEnrollment.Affiliation__c);
                }
            }
            
        }

        return afflsToUpdateDelIDs;
    }
    
    private void updateDeleteRelatedAffls(List<ID> afflsToUpdateDelIDs, List<SObject> oldlist, DmlWrapper dmlWrapper) {
        //Delete or update related affiliations when Program Enrollment records are deleted.
        List<Affiliation__c> afflsToUpdateDel = new List<Affiliation__c>();
        
        List<Program_Enrollment__c> otherProgramEnrollments = [SELECT Id, Affiliation__c FROM Program_Enrollment__c WHERE Affiliation__c IN :afflsToUpdateDelIDs AND Id NOT IN :oldList];
        Set<Id> affiliationIdsToIgnore = new Set<Id>();
        
        for (Program_Enrollment__c otherProgramEnrollment : otherProgramEnrollments) {
            affiliationIdsToIgnore.add(otherProgramEnrollment.Affiliation__c);
        }
        
        if (UTIL_CustomSettingsFacade.getSettings().Affl_ProgEnroll_Del__c) {
            
            for (ID affiliationId : afflsToUpdateDelIDs) {
                //Only delete the Affiliation if there are no other Program Enrollment records associated to it.
                if (!affiliationIdsToIgnore.contains(affiliationId)) {
                    afflsToUpdateDel.add(new Affiliation__c(ID = affiliationId));
                }
            }
            
            dmlWrapper.objectsToDelete.addAll((List<SObject>)afflsToUpdateDel);
        } else {
            String affiliationStatusOnPEDelete = UTIL_CustomSettingsFacade.getSettings().Affl_ProgEnroll_Del_Status__c;
            List<Affiliation__c> potentialAffiliationsToUpdate = [SELECT Id, Status__c FROM Affiliation__c WHERE ID IN :afflsToUpdateDelIDs];
            
            for (Affiliation__c affl : potentialAffiliationsToUpdate) {
                //Only update the Affiliation if there are no other Program Enrollment records associated to it.
                if (!affiliationIdsToIgnore.contains(affl.Id)) {
                    affl.Status__c = affiliationStatusOnPEDelete;
                    afflsToUpdateDel.add(affl);
                }
            }
            
            dmlWrapper.objectsToUpdate.addAll((List<SObject>)afflsToUpdateDel);
        }
    }
}
@isTest
private class PREN_Affiliation_TEST {
    /*********************************************************************************************************
     * @description Verifies that an Affiliation is automatically created when a Program Enrollment record is
     * manually created from a Contact.
     */
    @isTest
    public static void createAfflFromProgramEnrollment() {
        STG_InstallScript.insertMappings();

        Contact contact = new Contact(FirstName = 'Test', LastName = 'Testerson');
        insert contact;

        ID orgRecTypeID = UTIL_Describe_API.getBizAccRecTypeID();

        //Create account of Business Organization record type
        Account acc = new Account(Name = 'Acme', RecordTypeId = orgRecTypeID);
        insert acc;

        //Create Program Enrollment
        Program_Enrollment__c enrollment = new Program_Enrollment__c(Contact__c = contact.ID, Account__c = acc.ID);
        Test.startTest();
        insert enrollment;
        Test.stopTest();

        //An Affiliation should have been automatically created from the Program Enrollment
        List<Affiliation__c> affls = [SELECT Contact__c, Account__c FROM Affiliation__c WHERE Account__c = :acc.ID];
        System.assertEquals(1, affls.size());

        //The Program Enrollment record should be related to the Affiliation just created
        enrollment = [SELECT Affiliation__c FROM Program_Enrollment__c WHERE ID = :enrollment.ID];
        System.assertEquals(affls[0].ID, enrollment.Affiliation__c);

        //Only should one program enrollment exist
        List<Program_Enrollment__c> assertProgramEnrollments = [SELECT Id FROM Program_Enrollment__c];
        System.assertEquals(1, assertProgramEnrollments.size());
    }

    /*********************************************************************************************************
     * @description Creating a Program Enrollment copies the related Affiliation End Date when
     * Affl_ProgEnroll_Copy_End_Date__c setting is set to true.
     */
    @isTest
    public static void copyAfflFromProgramEnrollmentEndDateYes() {
        UTIL_CustomSettingsFacade.getSettingsForTests(
            new Hierarchy_Settings__c(Affl_ProgEnroll_Copy_End_Date__c = true)
        );

        Contact contact = new Contact(FirstName = 'Test', LastName = 'Testerson');
        insert contact;

        ID orgRecTypeID = UTIL_Describe_API.getBizAccRecTypeID();

        //Create account of Business Organization record type
        Account acc = new Account(Name = 'Acme', RecordTypeId = orgRecTypeID);
        insert acc;

        //Test for end date
        Date testDate = Date.newInstance(1970, 1, 1);

        //Create Program Enrollment
        Program_Enrollment__c enrollment = new Program_Enrollment__c(
            Contact__c = contact.ID,
            Account__c = acc.ID,
            End_Date__c = testDate
        );
        Test.startTest();
        insert enrollment;
        Test.stopTest();

        //An Affiliation should have been automatically created from the Program Enrollment
        List<Affiliation__c> affls = [SELECT EndDate__c FROM Affiliation__c WHERE Account__c = :acc.ID];
        System.assertEquals(1, affls.size());
        System.assertEquals(testDate, affls[0].EndDate__c);

        //Only should one program enrollment exist
        List<Program_Enrollment__c> assertProgramEnrollments = [SELECT Id FROM Program_Enrollment__c];
        System.assertEquals(1, assertProgramEnrollments.size());
    }

    /*********************************************************************************************************
     * @description Creating a Program Enrollment doesn't copy the related Affiliation End Date when
     * Affl_ProgEnroll_Copy_End_Date__c setting is set to false.
     */
    @isTest
    public static void copyAfflFromProgramEnrollmentEndDateNo() {
        UTIL_CustomSettingsFacade.getSettingsForTests(
            new Hierarchy_Settings__c(Affl_ProgEnroll_Copy_End_Date__c = false)
        );

        Contact contact = new Contact(FirstName = 'Test', LastName = 'Testerson');
        insert contact;

        ID orgRecTypeID = UTIL_Describe_API.getBizAccRecTypeID();

        //Create account of Business Organization record type
        Account acc = new Account(Name = 'Acme', RecordTypeId = orgRecTypeID);
        insert acc;

        //Test for end date
        Date testDate = Date.newInstance(1970, 1, 1);

        //Create Program Enrollment
        Program_Enrollment__c enrollment = new Program_Enrollment__c(
            Contact__c = contact.ID,
            Account__c = acc.ID,
            End_Date__c = testDate
        );
        Test.startTest();
        insert enrollment;
        Test.stopTest();

        //An Affiliation should have been automatically created from the Program Enrollment
        List<Affiliation__c> affls = [SELECT EndDate__c FROM Affiliation__c WHERE Account__c = :acc.ID];
        System.assertEquals(1, affls.size());
        System.assertEquals(null, affls[0].EndDate__c);

        //Only should one program enrollment exist
        List<Program_Enrollment__c> assertProgramEnrollments = [SELECT Id FROM Program_Enrollment__c];
        System.assertEquals(1, assertProgramEnrollments.size());
    }

    /*********************************************************************************************************
     * @description Creating a Program Enrollment copies the related Affiliation Start Date when
     * Affl_ProgEnroll_Copy_Start_Date__c setting is set to true.
     */
    @isTest
    public static void copyAfflFromProgramEnrollmentStartDateYes() {
        UTIL_CustomSettingsFacade.getSettingsForTests(
            new Hierarchy_Settings__c(Affl_ProgEnroll_Copy_Start_Date__c = true)
        );

        Contact contact = new Contact(FirstName = 'Test', LastName = 'Testerson');
        insert contact;

        ID orgRecTypeID = UTIL_Describe_API.getBizAccRecTypeID();

        //Create account of Business Organization record type
        Account acc = new Account(Name = 'Acme', RecordTypeId = orgRecTypeID);
        insert acc;

        //Test for end date
        Date testDate = Date.newInstance(1970, 1, 1);

        //Create Program Enrollment
        Program_Enrollment__c enrollment = new Program_Enrollment__c(
            Contact__c = contact.ID,
            Account__c = acc.ID,
            Start_Date__c = testDate
        );
        Test.startTest();
        insert enrollment;
        Test.stopTest();

        //An Affiliation should have been automatically created from the Program Enrollment
        List<Affiliation__c> affls = [SELECT StartDate__c FROM Affiliation__c WHERE Account__c = :acc.ID];
        System.assertEquals(1, affls.size());
        System.assertEquals(testDate, affls[0].StartDate__c);

        //Only should one program enrollment exist
        List<Program_Enrollment__c> assertProgramEnrollments = [SELECT Id FROM Program_Enrollment__c];
        System.assertEquals(1, assertProgramEnrollments.size());
    }

    /*********************************************************************************************************
     * @description Creating a Program Enrollment doesn't copy the related Affiliation Start Date when
     * Affl_ProgEnroll_Copy_Start_Date__c setting is set to false.
     */
    @isTest
    public static void copyAfflFromProgramEnrollmentStartDateNo() {
        UTIL_CustomSettingsFacade.getSettingsForTests(
            new Hierarchy_Settings__c(Affl_ProgEnroll_Copy_Start_Date__c = false)
        );

        Contact contact = new Contact(FirstName = 'Test', LastName = 'Testerson');
        insert contact;

        ID orgRecTypeID = UTIL_Describe_API.getBizAccRecTypeID();

        //Create account of Business Organization record type
        Account acc = new Account(Name = 'Acme', RecordTypeId = orgRecTypeID);
        insert acc;

        //Test for end date
        Date testDate = Date.newInstance(1970, 1, 1);

        //Create Program Enrollment
        Program_Enrollment__c enrollment = new Program_Enrollment__c(
            Contact__c = contact.ID,
            Account__c = acc.ID,
            Start_Date__c = testDate
        );
        Test.startTest();
        insert enrollment;
        Test.stopTest();

        //An Affiliation should have been automatically created from the Program Enrollment
        List<Affiliation__c> affls = [SELECT StartDate__c FROM Affiliation__c WHERE Account__c = :acc.ID];
        System.assertEquals(1, affls.size());
        System.assertNotEquals(testDate, affls[0].StartDate__c);

        //Only should one program enrollment exist
        List<Program_Enrollment__c> assertProgramEnrollments = [SELECT Id FROM Program_Enrollment__c];
        System.assertEquals(1, assertProgramEnrollments.size());
    }

    /*********************************************************************************************************
     * @description Creating a Program Enrollment sets the related Affiliation Role when
     * Affl_ProgEnroll_Set_Role__c setting is set to true.
     */
    @isTest
    public static void setAfflFromProgramEnrollmentRoleYes() {
        UTIL_CustomSettingsFacade.getSettingsForTests(
            new Hierarchy_Settings__c(
                Affl_ProgEnroll_Set_Role__c = true,
                Affl_ProgEnroll_Role_Map__c = AffiliationTestSetupFactory_TEST.PROG_ENROLL_ROLE_STUDENT
            )
        );

        Contact contact = new Contact(FirstName = 'Test', LastName = 'Testerson');
        insert contact;

        ID orgRecTypeID = UTIL_Describe_API.getBizAccRecTypeID();

        //Create account of Business Organization record type
        Account acc = new Account(Name = 'Acme', RecordTypeId = orgRecTypeID);
        insert acc;

        //Create Program Enrollment
        Program_Enrollment__c enrollment = new Program_Enrollment__c(Contact__c = contact.ID, Account__c = acc.ID);
        Test.startTest();
        insert enrollment;
        Test.stopTest();

        //An Affiliation should have been automatically created from the Program Enrollment
        List<Affiliation__c> affls = [SELECT Role__c FROM Affiliation__c WHERE Account__c = :acc.ID];
        System.assertEquals(1, affls.size());
        System.assertEquals(AffiliationTestSetupFactory_TEST.PROG_ENROLL_ROLE_STUDENT, affls[0].Role__c);

        //Only should one program enrollment exist
        List<Program_Enrollment__c> assertProgramEnrollments = [SELECT Id FROM Program_Enrollment__c];
        System.assertEquals(1, assertProgramEnrollments.size());
    }

    /*********************************************************************************************************
     * @description Creating a Program Enrollment does not set the related Affiliation Role when
     * Affl_ProgEnroll_Set_Role__c setting is set to false.
     * Test Scenario: T-3939003
     */
    @isTest
    public static void setAfflFromProgramEnrollmentRoleNo() {
        UTIL_CustomSettingsFacade.getSettingsForTests(
            new Hierarchy_Settings__c(
                Affl_ProgEnroll_Set_Role__c = false,
                Affl_ProgEnroll_Role_Map__c = AffiliationTestSetupFactory_TEST.PROG_ENROLL_ROLE_STUDENT
            )
        );

        Contact contact = new Contact(FirstName = 'Test', LastName = 'Testerson');
        insert contact;

        ID orgRecTypeID = UTIL_Describe_API.getBizAccRecTypeID();

        //Create account of Business Organization record type
        Account acc = new Account(Name = 'Acme', RecordTypeId = orgRecTypeID);
        insert acc;

        //Create Program Enrollment
        Program_Enrollment__c enrollment = new Program_Enrollment__c(Contact__c = contact.ID, Account__c = acc.ID);
        Test.startTest();
        insert enrollment;
        Test.stopTest();

        //An Affiliation should have been automatically created from the Program Enrollment
        List<Affiliation__c> affls = [SELECT Role__c FROM Affiliation__c WHERE Account__c = :acc.ID];
        System.assertEquals(1, affls.size());
        System.assertEquals(null, affls[0].Role__c);

        //Only should one program enrollment exist
        List<Program_Enrollment__c> assertProgramEnrollments = [SELECT Id FROM Program_Enrollment__c];
        System.assertEquals(1, assertProgramEnrollments.size());
    }

    /*********************************************************************************************************
     * @description Creating a Program Enrollment sets the related Affiliation Status when
     * to Affiliation_Program_Enrollment_Stat_Map.
     * Test Scenario: T-3939003
     */
    @isTest
    public static void setAfflFromProgramEnrollmentStatus() {
        UTIL_CustomSettingsFacade.getSettingsForTests(
            new Hierarchy_Settings__c(
                Affl_ProgEnroll_Status_Map__c = AffiliationTestSetupFactory_TEST.PROG_ENROLL_STATUS_FORMER
            )
        );

        Contact contact = new Contact(FirstName = 'Test', LastName = 'Testerson');
        insert contact;

        ID orgRecTypeID = UTIL_Describe_API.getBizAccRecTypeID();

        //Create account of Business Organization record type
        Account acc = new Account(Name = 'Acme', RecordTypeId = orgRecTypeID);
        insert acc;

        //Create Program Enrollment
        Program_Enrollment__c enrollment = new Program_Enrollment__c(Contact__c = contact.ID, Account__c = acc.ID);
        Test.startTest();
        insert enrollment;
        Test.stopTest();

        //An Affiliation should have been automatically created from the Program Enrollment
        List<Affiliation__c> affls = [SELECT Status__c FROM Affiliation__c WHERE Account__c = :acc.ID];
        System.assertEquals(1, affls.size());
        System.assertEquals(AffiliationTestSetupFactory_TEST.PROG_ENROLL_STATUS_FORMER, affls[0].Status__c);

        //Only should one program enrollment exist
        List<Program_Enrollment__c> assertProgramEnrollments = [SELECT Id FROM Program_Enrollment__c];
        System.assertEquals(1, assertProgramEnrollments.size());
    }

    /*********************************************************************************************************
     * @description Creating a Program Enrollment sets the related Affiliation Role when
     * Affl_ProgEnroll_Set_Role__c setting is set to true and sets the related Affiliation Status
     * to Affiliation_Program_Enrollment_Stat_Map
     * Test Scenario: T-3939003
     */
    @isTest
    public static void setAfflFromProgramEnrollmentRoleYesStatus() {
        UTIL_CustomSettingsFacade.getSettingsForTests(
            new Hierarchy_Settings__c(
                Affl_ProgEnroll_Set_Role__c = true,
                Affl_ProgEnroll_Role_Map__c = AffiliationTestSetupFactory_TEST.PROG_ENROLL_ROLE_STUDENT,
                Affl_ProgEnroll_Status_Map__c = AffiliationTestSetupFactory_TEST.PROG_ENROLL_STATUS_CURRENT
            )
        );

        STG_InstallScript.insertMappings();

        Contact contact = new Contact(FirstName = 'Test', LastName = 'Testerson');
        insert contact;

        //Create account of Business Organization record type
        Account acc = new Account(Name = 'Acme', RecordTypeId = UTIL_Describe_API.getAcademicAccRecTypeID());
        insert acc;

        //Create Program Enrollment
        Program_Enrollment__c enrollment = new Program_Enrollment__c(Contact__c = contact.ID, Account__c = acc.ID);
        Test.startTest();
        insert enrollment;
        Test.stopTest();

        //An Affiliation should have been automatically created from the Program Enrollment
        List<Affiliation__c> affls = [SELECT Role__c FROM Affiliation__c WHERE Account__r.ID = :acc.ID];
        System.assertEquals(1, affls.size());
        System.assertEquals(AffiliationTestSetupFactory_TEST.PROG_ENROLL_ROLE_STUDENT, affls[0].Role__c);

        //Only should one program enrollment exist
        List<Program_Enrollment__c> assertProgramEnrollments = [SELECT Id FROM Program_Enrollment__c];
        System.assertEquals(1, assertProgramEnrollments.size());
    }

    /*********************************************************************************************************
     * @description Deleting a Program Enrollment deletes the related Affiliation when Affl_ProgEnroll_Del__c setting
     * is set to true.
     */
    @isTest
    public static void deletePEnrollDelAfflYes() {
        STG_InstallScript.insertMappings();

        UTIL_CustomSettings_API.getSettingsForTests(new Hierarchy_Settings__c(Affl_ProgEnroll_Del__c = true));

        Contact contact = UTIL_UnitTestData_TEST.getContact();
        insert contact;

        //Create account of Business Organization record type
        Account acc = UTIL_UnitTestData_TEST.getMultipleTestAccounts(1, UTIL_Describe_API.getBizAccRecTypeID())[0];
        insert acc;

        //Create Program Enrollment
        Program_Enrollment__c enrollment = new Program_Enrollment__c(Contact__c = contact.ID, Account__c = acc.ID);
        insert enrollment;

        //An Affiliation should have been automatically created from the Program Enrollment
        List<Affiliation__c> affls = [SELECT Contact__c, Account__c FROM Affiliation__c WHERE Account__c = :acc.ID];
        System.assertEquals(1, affls.size());

        //The Program Enrollment record should be related to the Affiliation just created
        enrollment = [SELECT Affiliation__c FROM Program_Enrollment__c WHERE ID = :enrollment.ID];
        System.assertEquals(affls[0].ID, enrollment.Affiliation__c);
        ID enrollmentAfflID = enrollment.Affiliation__c; //Storing it to use it in next query

        //Create additional Program Enrollment
        Program_Enrollment__c enrollment2 = new Program_Enrollment__c(
            Contact__c = contact.ID,
            Account__c = acc.ID,
            Affiliation__c = enrollmentAfflID
        );
        insert enrollment2;

        //Delete both Program Enrollments
        Test.startTest();
        delete new List<Program_Enrollment__c>{ enrollment, enrollment2 };
        Test.stopTest();

        //Related Affiliation should have been automatically deleted
        affls = [SELECT ID FROM Affiliation__c WHERE ID = :enrollmentAfflID];
        System.assertEquals(0, affls.size());
    }

    /*********************************************************************************************************
     * @description Deleting a Program Enrollment does not delete the related Affiliation when Affl_ProgEnroll_Del__c setting
     * is set to true but other Program Enrollments are associated to the same Affiliation.
     */
    @isTest
    public static void deletePEnrollDelAfflYes_existingPEPreventsAffiliationDeletion() {
        STG_InstallScript.insertMappings();

        UTIL_CustomSettings_API.getSettingsForTests(new Hierarchy_Settings__c(Affl_ProgEnroll_Del__c = true));

        Contact contact = UTIL_UnitTestData_TEST.getContact();
        insert contact;

        //Create account of Business Organization record type
        Account acc = UTIL_UnitTestData_TEST.getMultipleTestAccounts(1, UTIL_Describe_API.getBizAccRecTypeID())[0];
        insert acc;

        //Create Program Enrollment
        Program_Enrollment__c enrollment = new Program_Enrollment__c(Contact__c = contact.ID, Account__c = acc.ID);
        insert enrollment;

        //An Affiliation should have been automatically created from the Program Enrollment
        List<Affiliation__c> affls = [SELECT Contact__c, Account__c FROM Affiliation__c WHERE Account__c = :acc.ID];
        System.assertEquals(1, affls.size());

        //The Program Enrollment record should be related to the Affiliation just created
        enrollment = [SELECT Affiliation__c FROM Program_Enrollment__c WHERE ID = :enrollment.ID];
        System.assertEquals(affls[0].ID, enrollment.Affiliation__c);
        ID enrollmentAfflID = enrollment.Affiliation__c; //Storing it to use it in next query

        //Create additional Program Enrollment
        Program_Enrollment__c enrollment2 = new Program_Enrollment__c(
            Contact__c = contact.ID,
            Account__c = acc.ID,
            Affiliation__c = enrollmentAfflID
        );
        insert enrollment2;

        //Delete Program Enrollment
        Test.startTest();
        delete enrollment;
        Test.stopTest();

        //Related Affiliation should have NOT been automatically deleted
        affls = [SELECT ID FROM Affiliation__c WHERE ID = :enrollmentAfflID];
        System.assertEquals(1, affls.size());
    }

    /*********************************************************************************************************
     * @description Deleting a Program Enrollment doesn't delete the related Affiliation when Affl_ProgEnroll_Del__c setting
     * is set to false. It just changes the status to what is defined in Affl_ProgEnroll_Del_Status__c.
     */
    @isTest
    public static void deletePEnrollDelAfflNo() {
        STG_InstallScript.insertMappings();

        String afflStatus = AffiliationTestSetupFactory_TEST.PROG_ENROLL_STATUS_FORMER;
        UTIL_CustomSettings_API.getSettingsForTests(
            new Hierarchy_Settings__c(Affl_ProgEnroll_Del__c = false, Affl_ProgEnroll_Del_Status__c = afflStatus)
        );

        Contact contact = UTIL_UnitTestData_TEST.getContact();
        insert contact;

        //Create account of Business Organization record type
        Account acc = UTIL_UnitTestData_TEST.getMultipleTestAccounts(1, UTIL_Describe_API.getBizAccRecTypeID())[0];
        insert acc;

        //Create Program Enrollment
        Program_Enrollment__c enrollment = new Program_Enrollment__c(Contact__c = contact.ID, Account__c = acc.ID);
        insert enrollment;

        //An Affiliation should have been automatically created from the Program Enrollment
        List<Affiliation__c> affls = [SELECT Contact__c, Account__c FROM Affiliation__c WHERE Account__c = :acc.ID];
        System.assertEquals(1, affls.size());

        //The Program Enrollment record should be related to the Affiliation just created
        enrollment = [SELECT Affiliation__c FROM Program_Enrollment__c WHERE ID = :enrollment.ID];
        System.assertEquals(affls[0].ID, enrollment.Affiliation__c);

        ID enrollmentAfflID = enrollment.Affiliation__c; //Storing it to use it in next query

        //Delete Program Enrollment
        Test.startTest();
        delete enrollment;
        Test.stopTest();

        //Related Affiliation status should have been automatically updated
        affls = [SELECT Status__c FROM Affiliation__c WHERE ID = :enrollmentAfflID];
        System.assertEquals(1, affls.size());
        System.assertEquals(afflStatus, affls[0].Status__c);
    }

    /*********************************************************************************************************
     * @description Deleting a Program Enrollment doesn't delete the related Affiliation when Affl_ProgEnroll_Del__c setting
     * is set to false, nor does it change the status to what is defined in Affl_ProgEnroll_Del_Status__c when there are
     * other Program Enrollments that are associated to the same Affiliation.
     */
    @isTest
    public static void deletePEnrollDelAfflNo_existingPEPreventsAffiliationDeletion() {
        STG_InstallScript.insertMappings();

        String afflStatus = AffiliationTestSetupFactory_TEST.PROG_ENROLL_STATUS_FORMER;
        UTIL_CustomSettings_API.getSettingsForTests(
            new Hierarchy_Settings__c(Affl_ProgEnroll_Del__c = false, Affl_ProgEnroll_Del_Status__c = afflStatus)
        );

        Contact contact = UTIL_UnitTestData_TEST.getContact();
        insert contact;

        //Create account of Business Organization record type
        Account acc = UTIL_UnitTestData_TEST.getMultipleTestAccounts(1, UTIL_Describe_API.getBizAccRecTypeID())[0];
        insert acc;

        //Create Program Enrollment
        Program_Enrollment__c enrollment = new Program_Enrollment__c(Contact__c = contact.ID, Account__c = acc.ID);
        insert enrollment;

        //An Affiliation should have been automatically created from the Program Enrollment
        List<Affiliation__c> affls = [
            SELECT Contact__c, Account__c, Status__c
            FROM Affiliation__c
            WHERE Account__c = :acc.ID
        ];
        System.assertEquals(1, affls.size());

        //The Program Enrollment record should be related to the Affiliation just created
        enrollment = [SELECT Affiliation__c FROM Program_Enrollment__c WHERE ID = :enrollment.ID];
        System.assertEquals(affls[0].ID, enrollment.Affiliation__c);

        ID enrollmentAfflID = enrollment.Affiliation__c; //Storing it to use it in next query
        String createdStatus = affls[0].Status__c;

        //Create additional Program Enrollment
        Program_Enrollment__c enrollment2 = new Program_Enrollment__c(
            Contact__c = contact.ID,
            Account__c = acc.ID,
            Affiliation__c = enrollmentAfflID
        );
        insert enrollment2;

        //Delete Program Enrollment
        Test.startTest();
        delete enrollment;
        Test.stopTest();

        //Related Affiliation status should NOT have been automatically updated
        affls = [SELECT Status__c FROM Affiliation__c WHERE ID = :enrollmentAfflID];
        System.assertEquals(1, affls.size());
        System.assertNotEquals(afflStatus, affls[0].Status__c);
        System.assertEquals(createdStatus, affls[0].Status__c);
    }
}
@isTest
private class PREN_CannotDelete_TEST {
    /*********************************************************************************************************
    * @description Retrieves the Administrative record type Id. 
    */
    public static String adminAccRecTypeId = UTIL_Describe.getAdminAccRecTypeID(); 
    
    /*********************************************************************************************************
    * @description Retrieves the Academic Program record type Id. 
    */
    public static String academicAccRecTypeId = UTIL_Describe.getAcademicAccRecTypeID(); 
    
    /*********************************************************************************************************
    * @description Test method to test if Prevent_Program_Enrollment_Deletion__c is enabled in Hierarchy Settings, and
    * Program Enrollment has a Course Connection record associated to it, then it cannot be deleted.
    */
    @isTest
    public static void cannotDeleteProgramEnrollmentWithCourseConn(){
        UTIL_CustomSettingsFacade.getSettingsForTests(new Hierarchy_Settings__c
                                                        (Account_Processor__c = PREN_CannotDelete_TEST.adminAccRecTypeId,
                                                        Prevent_Program_Enrollment_Deletion__c = True));
        
        List<Account> accounts = UTIL_UnitTestData_TEST.getMultipleTestAccounts(1, PREN_CannotDelete_TEST.academicAccRecTypeId); 
        insert accounts; 
        
        List<Contact> contacts = UTIL_UnitTestData_TEST.getMultipleTestContacts(2);
        insert contacts; 
        
        List<Program_Enrollment__c> programEnrollments = UTIL_UnitTestData_TEST.getMultipleTestProgramEnrollments(2, accounts[0].Id); 
        programEnrollments[0].Contact__c = contacts[0].Id; 
        programEnrollments[1].Contact__c = contacts[1].Id; 
        insert programEnrollments; 
        
        Course__c course = new Course__c(Name = 'Intro to Neuroscience', Account__c = accounts[0].Id); 
        insert course; 
        
        Term__c term = UTIL_UnitTestData_TEST.getTerm(accounts[0].Id, 'Fall'); 
        insert term; 

        Course_Offering__c courseOffering1 = UTIL_UnitTestData_TEST.createCourseOffering(course.Id, term.Id); 
        Course_Offering__c courseOffering2 = UTIL_UnitTestData_TEST.createCourseOffering(course.Id, term.Id);
        
        Course_Enrollment__c courseConnection1 = UTIL_UnitTestData_TEST.getCourseConnection(contacts[0].Id, courseOffering1.Id); 
        Course_Enrollment__c courseConnection2 = UTIL_UnitTestData_TEST.getCourseConnection(contacts[1].Id, courseOffering2.Id);
        courseConnection1.Program_Enrollment__c = programEnrollments[0].Id; 
        courseConnection2.Program_Enrollment__c = programEnrollments[1].Id; 
        insert courseConnection1;
        insert courseConnection2; 
        
        Test.startTest();
        Database.DeleteResult[] results = Database.delete(programEnrollments, false);
        Test.stopTest();

        List<Program_Enrollment__c> returnProgramEnrollments = [SELECT Id
                                                                FROM Program_Enrollment__c
                                                                WHERE Id IN :programEnrollments]; 
        System.assertEquals(2, returnProgramEnrollments.size());
        System.assertEquals(Label.CannotDelete, results[0].errors[0].message);  
    }
    
    /*********************************************************************************************************
    * @description Test method to test if Prevent_Program_Enrollment_Deletion__c is disabled in Hierarchy Settings, and
    * Program Enrollment has a Course Connection record associated to it, then it can be deleted.
    */
    @isTest
    public static void canDeleteProgramEnrollmentWithCourseConn(){
        UTIL_CustomSettingsFacade.getSettingsForTests(new Hierarchy_Settings__c
                                                        (Account_Processor__c = PREN_CannotDelete_TEST.adminAccRecTypeId,
                                                        Prevent_Program_Enrollment_Deletion__c = False));

        List<Account> accounts = UTIL_UnitTestData_TEST.getMultipleTestAccounts(1, PREN_CannotDelete_TEST.academicAccRecTypeId); 
        insert accounts; 

        List<Contact> contacts = UTIL_UnitTestData_TEST.getMultipleTestContacts(2);
        insert contacts; 

        List<Program_Enrollment__c> programEnrollments = UTIL_UnitTestData_TEST.getMultipleTestProgramEnrollments(2, accounts[0].Id); 
        programEnrollments[0].Contact__c = contacts[0].Id; 
        programEnrollments[1].Contact__c = contacts[1].Id; 
        insert programEnrollments; 

        Course__c course = new Course__c(Name = 'Intro to Neuroscience', Account__c = accounts[0].Id); 
        insert course; 

        Term__c term = UTIL_UnitTestData_TEST.getTerm(accounts[0].Id, 'Fall'); 
        insert term; 

        Course_Offering__c courseOffering1 = UTIL_UnitTestData_TEST.createCourseOffering(course.Id, term.Id); 
        Course_Offering__c courseOffering2 = UTIL_UnitTestData_TEST.createCourseOffering(course.Id, term.Id);

        Course_Enrollment__c courseConnection1 = UTIL_UnitTestData_TEST.getCourseConnection(contacts[0].Id, courseOffering1.Id); 
        Course_Enrollment__c courseConnection2 = UTIL_UnitTestData_TEST.getCourseConnection(contacts[1].Id, courseOffering2.Id);
        courseConnection1.Program_Enrollment__c = programEnrollments[0].Id; 
        courseConnection2.Program_Enrollment__c = programEnrollments[1].Id; 
        insert courseConnection1;
        insert courseConnection2; 

        Test.startTest();
        Database.DeleteResult[] results = Database.delete(programEnrollments, false);
        Test.stopTest();

        List<Program_Enrollment__c> returnProgramEnrollments = [SELECT Id
                                                                FROM Program_Enrollment__c
                                                                WHERE Id IN :programEnrollments]; 
        System.assertEquals(0, returnProgramEnrollments.size());
    }
    
    /*********************************************************************************************************
    * @description Tests the hasChildRecords method that the Program Enrollment record has child records. 
    */
    @isTest
    public static void testProgramEnrollmentHasChildRecords(){
        UTIL_CustomSettingsFacade.getSettingsForTests(new Hierarchy_Settings__c
                                                        (Account_Processor__c = PREN_CannotDelete_TEST.adminAccRecTypeId,
                                                        Prevent_Program_Enrollment_Deletion__c = True));
        
        List<Account> accounts = UTIL_UnitTestData_TEST.getMultipleTestAccounts(1, PREN_CannotDelete_TEST.academicAccRecTypeId); 
        insert accounts; 
        
        List<Contact> contacts = UTIL_UnitTestData_TEST.getMultipleTestContacts(2);
        insert contacts; 
        
        List<Program_Enrollment__c> programEnrollments = UTIL_UnitTestData_TEST.getMultipleTestProgramEnrollments(2, accounts[0].Id); 
        programEnrollments[0].Contact__c = contacts[0].Id; 
        programEnrollments[1].Contact__c = contacts[1].Id; 
        insert programEnrollments; 
        
        Course__c course = new Course__c(Name = 'Intro to Neuroscience', Account__c = accounts[0].Id); 
        insert course; 
        
        Term__c term = UTIL_UnitTestData_TEST.getTerm(accounts[0].Id, 'Fall'); 
        insert term; 

        Course_Offering__c courseOffering1 = UTIL_UnitTestData_TEST.createCourseOffering(course.Id, term.Id); 
        Course_Offering__c courseOffering2 = UTIL_UnitTestData_TEST.createCourseOffering(course.Id, term.Id);
        
        Course_Enrollment__c courseConnection1 = UTIL_UnitTestData_TEST.getCourseConnection(contacts[0].Id, courseOffering1.Id); 
        Course_Enrollment__c courseConnection2 = UTIL_UnitTestData_TEST.getCourseConnection(contacts[1].Id, courseOffering2.Id);
        courseConnection1.Program_Enrollment__c = programEnrollments[0].Id; 
        courseConnection2.Program_Enrollment__c = programEnrollments[1].Id; 
        insert courseConnection1;
        insert courseConnection2; 
        
        List<Program_Enrollment__c> returnProgramEnrollments = [SELECT Id,
                                                                (SELECT Id FROM Program_Enrollment__c.Course_Enrollments__r LIMIT 1)
                                                                FROM Program_Enrollment__c
                                                                WHERE Id IN :programEnrollments]; 
        
        PREN_CannotDelete_TDTM myClass = new PREN_CannotDelete_TDTM(); 
        for (Program_Enrollment__c programEnroll: returnProgramEnrollments) {
            System.assertEquals(True, myClass.hasChildRecords(programEnroll)); 
        }
    }
    
    /*********************************************************************************************************
    * @description Tests the hasChildRecords method that the Program Enrollment record has no child records. 
    */
    @isTest
    public static void testProgramEnrollmentHasNoChildRecords(){
        UTIL_CustomSettingsFacade.getSettingsForTests(new Hierarchy_Settings__c
                                                        (Account_Processor__c = PREN_CannotDelete_TEST.adminAccRecTypeId,
                                                        Prevent_Program_Enrollment_Deletion__c = True));
        
        List<Account> accounts = UTIL_UnitTestData_TEST.getMultipleTestAccounts(1, PREN_CannotDelete_TEST.academicAccRecTypeId); 
        insert accounts; 
        
        List<Contact> contacts = UTIL_UnitTestData_TEST.getMultipleTestContacts(2);
        insert contacts; 
        
        List<Program_Enrollment__c> programEnrollments = UTIL_UnitTestData_TEST.getMultipleTestProgramEnrollments(2, accounts[0].Id); 
        programEnrollments[0].Contact__c = contacts[0].Id; 
        programEnrollments[1].Contact__c = contacts[1].Id; 
        insert programEnrollments; 

        List<Program_Enrollment__c> returnProgramEnrollments = [SELECT Id,
                                                                (SELECT Id FROM Program_Enrollment__c.Course_Enrollments__r LIMIT 1)
                                                                FROM Program_Enrollment__c
                                                                WHERE Id IN :programEnrollments]; 
        
        PREN_CannotDelete_TDTM myClass = new PREN_CannotDelete_TDTM(); 
        for (Program_Enrollment__c programEnroll: returnProgramEnrollments) {
            System.assertEquals(False, myClass.hasChildRecords(programEnroll)); 
        }
    }
}
public with sharing class PREN_ProgramPlan_TDTM extends TDTM_Runnable{

    //Variables for Process Control
    static boolean beforeInsertRecursionFlag = TDTM_ProcessControl.getRecursionFlag(TDTM_ProcessControl.registeredTrigger.PREN_ProgramPlan_TDTM_Before_Insert);

    /*******************************************************************************************************
    * @description Handles Program Plan management for Program Enrollment.
    * @param listNew the list of Program Enrollments from trigger new.
    * @param listOld the list of Program Enrollments from trigger old.
    * @param triggerAction which trigger event (BeforeInsert, AfterInsert, etc.).
    * @param objResult the describe for Program Enrollment.
    * @return dmlWrapper.
    ********************************************************************************************************/
    public override DmlWrapper run(List<SObject> newlist, List<SObject> oldlist,
            TDTM_Runnable.Action triggerAction, Schema.DescribeSObjectResult objResult) {

        DmlWrapper dmlWrapper = new DmlWrapper();
                
        //Before Insert
        if (newlist != null
            	&& newlist.size() > 0
            	&& triggerAction == TDTM_Runnable.Action.BeforeInsert 
            	&& !beforeInsertRecursionFlag) {
            if(newlist != null && newlist.size() > 0) {
                populatePrimaryProgramPlan(newlist);
            }
        }
                
		if (triggerAction == TDTM_Runnable.Action.BeforeInsert) {
            TDTM_ProcessControl.setRecursionFlag(TDTM_ProcessControl.registeredTrigger.PREN_ProgramPlan_TDTM_Before_Insert, false);
        }
        return dmlWrapper;
    }

    /*******************************************************************************************************
    * @description Populate primary program plan when a program enrollment is created
    * @param List<SObject> newList the Contact
    * @return void
    */
    private void populatePrimaryProgramPlan(List<SObject> newlist) {
        Set<Id> setAcademicProgramIds = new Set<Id>();
        Map<Id, Id> mapAcademicProgramIdToPrimaryPPId = new Map<Id, Id>();
        for (SObject so : newlist) {
            Program_Enrollment__c newPe = (Program_Enrollment__c)so;
            //Build a set of academic program ids
            setAcademicProgramIds.add(newPe.Account__c);
        }

        //Query academic program and build a map of
        //Academic Program id and Primary Program Plan id
        for (Program_Plan__c pp : [SELECT Id, Account__c
                                    FROM Program_Plan__c
                                    WHERE Account__c in :setAcademicProgramIds
                                        AND Is_Primary__c = TRUE]) {
            if (pp.Account__c != null) {
                mapAcademicProgramIdToPrimaryPPId.put(pp.Account__c, pp.Id);
            }
        }

        //Loop through program enrollment again and populate primary program plan
        for (SObject so : newlist) {
            Program_Enrollment__c newPe = (Program_Enrollment__c)so;
            if (mapAcademicProgramIdToPrimaryPPId.containsKey(newPe.Account__c)
                    && mapAcademicProgramIdToPrimaryPPId.get(newPe.Account__c) != null) {
                newPe.Program_Plan__c = mapAcademicProgramIdToPrimaryPPId.get(newPe.Account__c);
            }
        }
    }

}
@isTest
private class PREQ_PreventPPlanParent_TEST {

    //Make sure an error is thrown when creating a Plan Requirement who is a child of another plan requirement,
    //linking to the same program plan and the setting of Validate_Program_Plan_for_Nested_PR__c is on
    @isTest
    public static void pReqInsertChildPRWithSamePP() {
        UTIL_CustomSettingsFacade.getSettingsForTests(new Hierarchy_Settings__c(Validate_Program_Plan_for_Nested_PR__c = true));

        List<Program_Plan__c> pPlans = UTIL_UnitTestData_TEST.getMultipleTestProgramPlans(2);
        insert pPlans;

        List<Plan_Requirement__c> prs = UTIL_UnitTestData_TEST.getMultipleTestPlanRequirements(2);
        prs[0].Program_Plan__c = pPlans[0].Id;
        insert prs[0];

        Test.startTest();
        prs[1].Plan_Requirement__c = prs[0].Id;
        prs[1].Program_Plan__c = pPlans[0].Id;
        Database.saveResult results = Database.insert(prs[1], false);
        Test.stopTest();

        //Verify new plan requirement is not saved
        List<Plan_Requirement__c> assertPReqs = [select ID from Plan_Requirement__c];

        System.assertEquals(false, results.success);    
        System.assertEquals(1, assertPReqs.size());
        System.assertEquals(Label.nestedPlanRequirementPPExp, results.errors[0].message);
    }

    //Make sure an error is thrown when creating a Plan Requirement who is a child of another plan requirement,
    //linking to a different program plan and the setting of Validate_Program_Plan_for_Nested_PR__c is on
    @isTest
    public static void pReqInsertChildPRWithDifferentPP() {
        UTIL_CustomSettingsFacade.getSettingsForTests(new Hierarchy_Settings__c(Validate_Program_Plan_for_Nested_PR__c = true));

        List<Program_Plan__c> pPlans = UTIL_UnitTestData_TEST.getMultipleTestProgramPlans(2);
        insert pPlans;

        List<Plan_Requirement__c> prs = UTIL_UnitTestData_TEST.getMultipleTestPlanRequirements(2);
        prs[0].Program_Plan__c = pPlans[0].Id;
        insert prs[0];

        Test.startTest();
        prs[1].Plan_Requirement__c = prs[0].Id;
        prs[1].Program_Plan__c = pPlans[1].Id;
        Database.saveResult results = Database.insert(prs[1], false);
        Test.stopTest();

        //Verify new plan requirement is not saved
        List<Plan_Requirement__c> assertPReqs = [select ID from Plan_Requirement__c];

        System.assertEquals(false, results.success);
        System.assertEquals(1, assertPReqs.size());
        System.assertEquals(Label.nestedPlanRequirementPPExp, results.errors[0].message);
    }

    //Make sure an error is thrown when updating a Plan Requirement who is a child of another plan requirement,
    //linking to the same program plan and the setting of Validate_Program_Plan_for_Nested_PR__c is on
    @isTest
    public static void pReqUpdateChildPRWithSamePP() {
        UTIL_CustomSettingsFacade.getSettingsForTests(new Hierarchy_Settings__c(Validate_Program_Plan_for_Nested_PR__c = true));

        List<Program_Plan__c> pPlans = UTIL_UnitTestData_TEST.getMultipleTestProgramPlans(2);
        insert pPlans;

        List<Plan_Requirement__c> prs = UTIL_UnitTestData_TEST.getMultipleTestPlanRequirements(2);
        prs[0].Program_Plan__c = pPlans[0].Id;
        insert prs[0];
        prs[1].Plan_Requirement__c = prs[0].Id;
        insert prs[1];

        Test.startTest();
        prs[1].Program_Plan__c = pPlans[0].Id;
        Database.saveResult results = Database.update(prs[1], false);
        Test.stopTest();

        //Verify new plan requirement is not saved
        List<Plan_Requirement__c> assertPReqs = [SELECT ID,Program_Plan__c
                                                FROM Plan_Requirement__c
                                                WHERE ID = :prs[1].Id
                                                LIMIT 1];

        System.assertEquals(false, results.success);                                        
        System.assertEquals(null, assertPReqs[0].Program_Plan__c);
        System.assertEquals(Label.nestedPlanRequirementPPExp, results.errors[0].message);
    }

    //Make sure an error is thrown when updating a Plan Requirement who is a child of another plan requirement,
    //linking to a different program plan and the setting of Validate_Program_Plan_for_Nested_PR__c is on
    @isTest
    public static void pReqUpdateChildPRWithDifferentPP() {
        UTIL_CustomSettingsFacade.getSettingsForTests(new Hierarchy_Settings__c(Validate_Program_Plan_for_Nested_PR__c = true));

        List<Program_Plan__c> pPlans = UTIL_UnitTestData_TEST.getMultipleTestProgramPlans(2);
        insert pPlans;

        List<Plan_Requirement__c> prs = UTIL_UnitTestData_TEST.getMultipleTestPlanRequirements(2);
        prs[0].Program_Plan__c = pPlans[0].Id;
        insert prs[0];
        prs[1].Plan_Requirement__c = prs[0].Id;
        insert prs[1];

        Test.startTest();
        prs[1].Program_Plan__c = pPlans[1].Id;
        Database.saveResult results = Database.update(prs[1], false);
        Test.stopTest();

        //Verify new plan requirement is not saved
        List<Plan_Requirement__c> assertPReqs = [SELECT ID,Program_Plan__c
                                                FROM Plan_Requirement__c
                                                WHERE ID = :prs[1].Id
                                                LIMIT 1];

        System.assertEquals(false, results.success);                                        
        System.assertEquals(null, assertPReqs[0].Program_Plan__c);
        System.assertEquals(Label.nestedPlanRequirementPPExp, results.errors[0].message);
    }

    //Make sure no error is thrown when creating a Plan Requirement who is a child of another plan requirement,
    //linking to the same program plan and the setting of Validate_Program_Plan_for_Nested_PR__c is off
    @isTest
    public static void pReqInsertChildPRWithSamePPSettingOff() {
        UTIL_CustomSettingsFacade.getSettingsForTests(new Hierarchy_Settings__c(Validate_Program_Plan_for_Nested_PR__c = false));

        List<Program_Plan__c> pPlans = UTIL_UnitTestData_TEST.getMultipleTestProgramPlans(2);
        insert pPlans;

        List<Plan_Requirement__c> prs = UTIL_UnitTestData_TEST.getMultipleTestPlanRequirements(2);
        prs[0].Program_Plan__c = pPlans[0].Id;
        insert prs[0];

        Test.startTest();
        prs[1].Plan_Requirement__c = prs[0].Id;
        prs[1].Program_Plan__c = pPlans[0].Id;
        Database.saveResult results = Database.insert(prs[1], false);
        Test.stopTest();

        //Verify new plan requirement is saved
        List<Plan_Requirement__c> assertPReqs = [select ID from Plan_Requirement__c];

        System.assertEquals(true, results.success);
        System.assertEquals(2, assertPReqs.size());
    }

    //Make sure no error is thrown when updating a Plan Requirement who is a child of another plan requirement,
    //linking to a different program plan and the setting of Validate_Program_Plan_for_Nested_PR__c is off
    @isTest
    public static void pReqUpdateChildPRWithDifferentPPSettingOff() {
        UTIL_CustomSettingsFacade.getSettingsForTests(new Hierarchy_Settings__c(Validate_Program_Plan_for_Nested_PR__c = false));

        List<Program_Plan__c> pPlans = UTIL_UnitTestData_TEST.getMultipleTestProgramPlans(2);
        insert pPlans;

        List<Plan_Requirement__c> prs = UTIL_UnitTestData_TEST.getMultipleTestPlanRequirements(2);
        prs[0].Program_Plan__c = pPlans[0].Id;
        insert prs[0];
        prs[1].Plan_Requirement__c = prs[0].Id;
        insert prs[1];

        Test.startTest();
        prs[1].Program_Plan__c = pPlans[1].Id;
        Database.saveResult results = Database.update(prs[1], false);
        Test.stopTest();

        //Verify new plan requirement is saved
        List<Plan_Requirement__c> assertPReqs = [SELECT ID,Program_Plan__c
                                                FROM Plan_Requirement__c
                                                WHERE ID = :prs[1].Id
                                                LIMIT 1];

        System.assertEquals(true, results.success);
        System.assertEquals(pPlans[1].Id, assertPReqs[0].Program_Plan__c);
    }

    //Make sure no error is thrown when inserting a Plan Requirement who is not a child of another plan requirement,
    //linking to program plan and the setting of Validate_Program_Plan_for_Nested_PR__c is on
    @isTest
    public static void pReqInsertNonChildPRWithPPSettingOn() {
        UTIL_CustomSettingsFacade.getSettingsForTests(new Hierarchy_Settings__c(Validate_Program_Plan_for_Nested_PR__c = true));

        List<Program_Plan__c> pPlans = UTIL_UnitTestData_TEST.getMultipleTestProgramPlans(1);
        insert pPlans;

        List<Plan_Requirement__c> prs = UTIL_UnitTestData_TEST.getMultipleTestPlanRequirements(1);

        Test.startTest();
        prs[0].Program_Plan__c = pPlans[0].Id;
        Database.saveResult results = Database.insert(prs[0], false);
        Test.stopTest();

        //Verify new plan requirement is saved
        List<Plan_Requirement__c> assertPReqs = [SELECT ID,Program_Plan__c
                                                FROM Plan_Requirement__c
                                                WHERE ID = :prs[0].Id
                                                LIMIT 1];

        System.assertEquals(true, results.success);
        System.assertEquals(pPlans[0].Id, assertPReqs[0].Program_Plan__c);
    }
}
@isTest
public with sharing class PReq_CannotDelete_TEST {
    /*********************************************************************************************************
    * @description Retrieves the Business Account record type Id. 
    */
    public static String bizAccRecordTypeId = UTIL_Describe_API.getBizAccRecTypeID(); 
    
    /*********************************************************************************************************
    * @description Test method to test if Prevent_Plan_Requirement_Deletion__c is enabled in Hierarchy Settings, 
    * and Plan Requirement has a Plan Requirement record associated to it, then it cannot be deleted.
    */
    @isTest
    public static void pReqCannotDeleteWithPlanRequirement() {
        UTIL_CustomSettingsFacade.getSettingsForTests(new Hierarchy_Settings__c
                                                         (Account_Processor__c = bizAccRecordTypeId,
                                                          Prevent_Plan_Requirement_Deletion__c = TRUE));
        
        List<Program_Plan__c> pPlans = UTIL_UnitTestData_TEST.getMultipleTestProgramPlans(1);
        insert pPlans;
        
        List<Plan_Requirement__c> parentPReqs = UTIL_UnitTestData_TEST.getMultipleTestPlanRequirements(2); 
        insert parentPReqs; 
        
        List<Plan_Requirement__c> childrenPReqs = UTIL_UnitTestData_TEST.getMultipleTestPlanRequirements(2); 
        childrenPReqs[0].Plan_Requirement__c = parentPReqs[0].Id;
        childrenPReqs[1].Plan_Requirement__c = parentPReqs[1].Id;
        insert childrenPReqs; 

        Test.startTest(); 
        Database.DeleteResult[] results = Database.delete(parentPReqs, false);
        Test.stopTest();

        //Verify Plan Requirement was not successfully deleted
        List<Plan_Requirement__c> returnParentPReqs = [SELECT ID
                                                       FROM Plan_Requirement__c
                                                       WHERE ID IN :parentPReqs];
        System.assertEquals(2, returnParentPReqs.size());
        System.assertEquals(false, results[0].success);
        System.assertEquals(Label.CannotDelete, results[0].errors[0].message);
    }
    
    /*********************************************************************************************************
    * @description Test method to test if Prevent_Plan_Requirement_Deletion__c is enabled in Hierarchy Settings, 
    * and if some Plan Requirement records do not have Plan Requirement child records, then the Plan Requirement
    * record can be deleted. 
    */
    @isTest
    public static void pReqCanDeleteSomePlanRequirement() {
        UTIL_CustomSettingsFacade.getSettingsForTests(new Hierarchy_Settings__c
                                                         (Account_Processor__c = bizAccRecordTypeId,
                                                          Prevent_Plan_Requirement_Deletion__c = TRUE));
        
        List<Program_Plan__c> pPlans = UTIL_UnitTestData_TEST.getMultipleTestProgramPlans(1);
        insert pPlans;
        
        List<Plan_Requirement__c> parentPReqs = UTIL_UnitTestData_TEST.getMultipleTestPlanRequirements(2);
        insert parentPReqs; 
       
        List<Plan_Requirement__c> childrenPReqs = UTIL_UnitTestData_TEST.getMultipleTestPlanRequirements(2); 
        childrenPReqs[0].Plan_Requirement__c = parentPReqs[0].Id;
        insert childrenPReqs; 

        Test.startTest(); 
        Database.DeleteResult[] results = Database.delete(parentPReqs, false);
        Test.stopTest();

        //Verify Plan Requirement was not successfully deleted
        List<Plan_Requirement__c> returnParentPReqs = [SELECT ID
                                                       FROM Plan_Requirement__c
                                                       WHERE ID IN :parentPReqs];
        
        System.assertEquals(1, returnParentPReqs.size());
        System.assertEquals(true, results[1].success);
        System.assertEquals(false, results[0].success);
        System.assertEquals(Label.CannotDelete, results[0].errors[0].message);
    }
    
    /*********************************************************************************************************
    * @description Test method to test if Prevent_Plan_Requirement_Deletion__c is disabled in Hierarchy Settings, 
    * and Plan Requirement has a Plan Requirement record associated to it, then it can be deleted.
    */
    @isTest
    public static void pReqCanDeleteWithPlanRequirement() {
        UTIL_CustomSettingsFacade.getSettingsForTests(new Hierarchy_Settings__c
                                                         (Account_Processor__c = bizAccRecordTypeId,
                                                          Prevent_Plan_Requirement_Deletion__c = FALSE));
        
        List<Program_Plan__c> pPlans = UTIL_UnitTestData_TEST.getMultipleTestProgramPlans(1);
        insert pPlans;
        
        List<Plan_Requirement__c> parentPReqs = UTIL_UnitTestData_TEST.getMultipleTestPlanRequirements(2); 
        insert parentPReqs; 
        
        List<Plan_Requirement__c> childrenPReqs = UTIL_UnitTestData_TEST.getMultipleTestPlanRequirements(2); 
        childrenPReqs[0].Plan_Requirement__c = parentPReqs[0].Id;
        childrenPReqs[1].Plan_Requirement__c = parentPReqs[1].Id;
        insert childrenPReqs; 

        Test.startTest(); 
        Database.DeleteResult[] results = Database.delete(parentPReqs, false);
        Test.stopTest();

        //Verify Plan Requirement was not successfully deleted
        List<Plan_Requirement__c> returnParentPReqs = [SELECT ID
                                                       FROM Plan_Requirement__c
                                                       WHERE ID IN :parentPReqs];
        System.assertEquals(0, returnParentPReqs.size());
        System.assertEquals(true, results[0].success);
    }
}
@isTest
public with sharing class PermissionSetAssignmentMapper_TEST {
    /**************************************************************************************************************************
     * @description Test method to verify that the getInstance method returns a new instance of the
     * PermissionSetAssignmentMapper class when one does not already exist.
     ***************************************************************************************************************************/
    @isTest
    private static void getInstanceNew() {
        Test.startTest();
        PermissionSetAssignmentMapper permissionSetAssignmentMapperInstance = PermissionSetAssignmentMapper.getInstance();
        Test.stopTest();

        System.assertEquals(
            PermissionSetAssignmentMapper.instance,
            permissionSetAssignmentMapperInstance,
            'Instance of mapper class returned should match static instance variable.'
        );
        System.assertEquals(
            true,
            permissionSetAssignmentMapperInstance != null,
            'Instance of mapper class should not be null.'
        );
    }

    /**************************************************************************************************************************
     * @description Test method to verify that the getInstance method returns the existing instance of the
     * PermissionSetAssignmentMapper class when one already exists.
     ***************************************************************************************************************************/
    @isTest
    private static void getInstanceExisting() {
        Test.startTest();
        PermissionSetAssignmentMapper permissionSetAssignmentMapperInstance1 = PermissionSetAssignmentMapper.getInstance();
        PermissionSetAssignmentMapper permissionSetAssignmentMapperInstance2 = PermissionSetAssignmentMapper.getInstance();
        Test.stopTest();

        System.assertEquals(
            PermissionSetAssignmentMapper.instance,
            permissionSetAssignmentMapperInstance1,
            'Instance of mapper class returned should match static instance variable.'
        );
        System.assertEquals(
            permissionSetAssignmentMapperInstance1,
            permissionSetAssignmentMapperInstance2,
            'Subsequent retrievals of mapper class instance should return existing instance.'
        );
        System.assertEquals(
            true,
            permissionSetAssignmentMapperInstance1 != null,
            'Instance of mapper class should not be null.'
        );
    }

    /**************************************************************************************************************************
     * @description Test method to verify that the getAssignedPermissionSetIdSetForCurrentUser method
     * returns a set of permission set ids assigned to the current user when there are some assigned
     ***************************************************************************************************************************/
    @isTest
    private static void getAssignedPermissionSetIdsSetForCurrentUserExisting() {
        User user = UTIL_UnitTestData_TEST.createNewUserForTests('testUser@eda.com');

        List<PermissionSet> permissionSets = new List<PermissionSet>();
        for (Integer i = 0; i < 5; i++) {
            PermissionSet permissionSet = new PermissionSet(
                PermissionsCustomizeApplication = false,
                Name = 'testName' + i,
                Label = 'testLabel' + i
            );
            permissionSets.add(permissionSet);
        }
        insert permissionSets;

        List<PermissionSetAssignment> permissionSetAssignments = new List<PermissionSetAssignment>();
        for (PermissionSet permissionSet : permissionSets) {
            PermissionSetAssignment permissionSetAssignment = new PermissionSetAssignment(
                AssigneeId = user.Id,
                PermissionSetId = permissionSet.Id
            );
            permissionSetAssignments.add(permissionSetAssignment);
        }
        insert permissionSetAssignments;

        Test.startTest();
        Set<Id> assignedPermissionSetIdsSet = new Set<Id>();
        System.runAs(user) {
            assignedPermissionSetIdsSet = PermissionSetAssignmentMapper.getInstance()
                .getAssignedPermissionSetIdsSetForCurrentUser();
        }
        Test.stopTest();

        System.assertEquals(
            true,
            assignedPermissionSetIdsSet.contains(permissionSets[0].Id),
            'assignedPermissionSetIdSet should contain every test permission set created'
        );
        System.assertEquals(
            true,
            assignedPermissionSetIdsSet.contains(permissionSets[1].Id),
            'assignedPermissionSetIdSet should contain every test permission set created'
        );
        System.assertEquals(
            true,
            assignedPermissionSetIdsSet.contains(permissionSets[2].Id),
            'assignedPermissionSetIdSet should contain every test permission set created'
        );
        System.assertEquals(
            true,
            assignedPermissionSetIdsSet.contains(permissionSets[3].Id),
            'assignedPermissionSetIdSet should contain every test permission set created'
        );
        System.assertEquals(
            true,
            assignedPermissionSetIdsSet.contains(permissionSets[4].Id),
            'assignedPermissionSetIdSet should contain every test permission set created'
        );
    }

    /**************************************************************************************************************************
     * @description Test method to verify that the getAssignedPermissionSetIdSetForCurrentUser method
     * returns a empty set of permission set ids assigned to the current user when there is no assigned
     ***************************************************************************************************************************/
    @isTest
    private static void getAssignedPermissionSetIdsSetForCurrentUserNoneAssigned() {
        User user = UTIL_UnitTestData_TEST.createNewUserForTests('testUser@eda.com');

        List<PermissionSet> permissionSets = new List<PermissionSet>();
        for (Integer i = 0; i < 5; i++) {
            PermissionSet permissionSet = new PermissionSet(
                PermissionsCustomizeApplication = false,
                Name = 'testName' + i,
                Label = 'testLabel' + i
            );
            permissionSets.add(permissionSet);
        }
        insert permissionSets;

        Test.startTest();
        Set<Id> assignedPermissionSetIdsSet = new Set<Id>();
        System.runAs(user) {
            assignedPermissionSetIdsSet = PermissionSetAssignmentMapper.getInstance()
                .getAssignedPermissionSetIdsSetForCurrentUser();
        }
        Test.stopTest();

        System.assertNotEquals(
            true,
            assignedPermissionSetIdsSet.contains(permissionSets[0].Id),
            'assignedPermissionSetIdSet should contain every test permission set created'
        );
        System.assertNotEquals(
            true,
            assignedPermissionSetIdsSet.contains(permissionSets[1].Id),
            'assignedPermissionSetIdSet should contain every test permission set created'
        );
        System.assertNotEquals(
            true,
            assignedPermissionSetIdsSet.contains(permissionSets[2].Id),
            'assignedPermissionSetIdSet should contain every test permission set created'
        );
        System.assertNotEquals(
            true,
            assignedPermissionSetIdsSet.contains(permissionSets[3].Id),
            'assignedPermissionSetIdSet should contain every test permission set created'
        );
        System.assertNotEquals(
            true,
            assignedPermissionSetIdsSet.contains(permissionSets[4].Id),
            'assignedPermissionSetIdSet should contain every test permission set created'
        );
    }
}
@isTest
public with sharing class PermissionSetMapper_TEST {
    /**************************************************************************************************************************
     * @description Test method to verify that the getInstance method returns a new instance of the
     * PermissionSetMapper class when one does not already exist.
     ***************************************************************************************************************************/
    @isTest
    private static void getInstanceNew() {
        Test.startTest();
        PermissionSetMapper permissionSetMapperInstance = PermissionSetMapper.getInstance();
        Test.stopTest();

        System.assertEquals(
            PermissionSetMapper.instance,
            permissionSetMapperInstance,
            'Instance of mapper class returned should match static instance variable.'
        );
        System.assertEquals(true, permissionSetMapperInstance != null, 'Instance of mapper class should not be null.');
    }

    /**************************************************************************************************************************
     * @description Test method to verify that the getInstance method returns the existing instance of the
     * PermissionSetMapper class when one already exists.
     ***************************************************************************************************************************/
    @isTest
    private static void getInstanceExisting() {
        Test.startTest();
        PermissionSetMapper permissionSetMapperInstance1 = PermissionSetMapper.getInstance();
        PermissionSetMapper permissionSetMapperInstance2 = PermissionSetMapper.getInstance();
        Test.stopTest();

        System.assertEquals(
            PermissionSetMapper.instance,
            permissionSetMapperInstance1,
            'Instance of mapper class returned should match static instance variable.'
        );
        System.assertEquals(
            permissionSetMapperInstance1,
            permissionSetMapperInstance2,
            'Subsequent retrievals of mapper class instance should return existing instance.'
        );
        System.assertEquals(true, permissionSetMapperInstance1 != null, 'Instance of mapper class should not be null.');
    }

    /**************************************************************************************************************************
     * @description Test method to verify that the checkPermissionSetsWithCustomizeApplicationFromIds method returns true
     * if any provided permission set has access to view setup
     * TODO: Commented out because PermissionsManageTranslation failing beta builds and downstream packages.
     ***************************************************************************************************************************/
    /*@isTest
    private static void checkPermissionSetsWithCustomizeApplicationFromIdsTrue() {
        List<PermissionSet> permissionSets = new List<PermissionSet>();
        for (Integer i = 0; i < 5; i++) {
            PermissionSet permissionSet = new PermissionSet(
                PermissionsCustomizeApplication = false,
                Name = 'testName' + i,
                Label = 'testLabel' + i
            );
            permissionSets.add(permissionSet);
        }
        permissionSets[0].PermissionsViewSetup = true;
        permissionSets[0].PermissionsViewRoles = true;
        permissionSets[0].PermissionsManageCustomPermissions = true;
        permissionSets[0].PermissionsManageTranslation = true;
        permissionSets[0].PermissionsCustomizeApplication = true;
        insert permissionSets;

        Test.startTest();
        Set<Id> permissionSetIdsSet = new Set<Id>();
        for (PermissionSet permissionSet : permissionSets) {
            permissionSetIdsSet.add(permissionSet.Id);
        }
        Boolean permissionSetsWithCustomizeApplication = PermissionSetMapper.getInstance()
            .checkPermissionSetsWithCustomizeApplicationFromIds(permissionSetIdsSet);
        Test.stopTest();

        System.assertEquals(
            true,
            permissionSetsWithCustomizeApplication,
            'Some of the provided permission sets should have access to view setup'
        );
    }*/

    /**************************************************************************************************************************
     * @description Test method to verify that the checkPermissionSetsWithCustomizeApplicationFromIds method returns false
     * if no provided permission set has access to view setup
     ***************************************************************************************************************************/
    @isTest
    private static void checkPermissionSetsWithCustomizeApplicationFromIdsFalse() {
        List<PermissionSet> permissionSets = new List<PermissionSet>();
        for (Integer i = 0; i < 5; i++) {
            PermissionSet permissionSet = new PermissionSet(
                PermissionsCustomizeApplication = false,
                Name = 'testName' + i,
                Label = 'testLabel' + i
            );
            permissionSets.add(permissionSet);
        }
        insert permissionSets;

        Test.startTest();
        Set<Id> permissionSetIdsSet = new Set<Id>();
        for (PermissionSet permissionSet : permissionSets) {
            permissionSetIdsSet.add(permissionSet.Id);
        }
        Boolean permissionSetsWithCustomizeApplication = PermissionSetMapper.getInstance()
            .checkPermissionSetsWithCustomizeApplicationFromIds(permissionSetIdsSet);
        Test.stopTest();

        System.assertEquals(
            false,
            permissionSetsWithCustomizeApplication,
            'None of the provided permission sets should have access to view setup'
        );
    }
}
public virtual with sharing class PicklistEntryMapper {

    /*********************************************
    * @description Instance for Singleton Pattern
    **********************************************/
    @TestVisible
    private static PicklistEntryMapper instance;

    /*********************************************************************
    * @description Empty constructor is not public for Singleton Pattern
    **********************************************************************/
    protected PicklistEntryMapper() {}

    /*****************************************************************************
    * @description Static method to get the current instance for Singleton pattern
    * @return The instance of PicklistEntryMapper.
    ******************************************************************************/
    public static PicklistEntryMapper getInstance() {

        if (instance == null) {
            instance = new PicklistEntryMapper();
        }

        return instance;
    }

    /*******************************************************************************************
    * @description Returns a map of  PicklistEntry models by their API Names
    * @return Map<String, PicklistEntryModel> A map of  PicklistEntry models by their API Names
    *******************************************************************************************/
    public virtual Map<String, PicklistEntryModel> getModelsByNameForSObjectField(SObjectType sObjectTypeName, SObjectField SObjectFieldName) {

        List<Schema.PicklistEntry> picklistEntriesList = UTIL_Describe.getFieldPicklistEntries(sObjectTypeName.getDescribe().getName(), SObjectFieldName.getDescribe().getName());
        Map<String, PicklistEntryModel> picklistEntryModelByPicklistEntryName = new Map<String, PicklistEntryModel>();

        for (Schema.PicklistEntry each: picklistEntriesList) {
            PicklistEntryModel PcklstEntryModel = new PicklistEntryModel(each.getValue(), each.getLabel(), each.isActive());
            picklistEntryModelByPicklistEntryName.put(each.getValue(), PcklstEntryModel);
        }

       return picklistEntryModelByPicklistEntryName;
    }
}
@isTest
private class PicklistEntryService_TEST {
    /**************************************************************************************************************************
     * @description Test method to verify that the getInstance method returns a new instance of the
     * PicklistEntryService class when one does not already exist.
     ***************************************************************************************************************************/
    @isTest
    private static void getInstanceNew() {
        Test.startTest();
        PicklistEntryService picklistEntryServiceInstance = PicklistEntryService.getInstance();
        Test.stopTest();

        System.assertEquals(
            PicklistEntryService.instance,
            picklistEntryServiceInstance,
            'Instance of service class returned should match static instance variable.'
        );
        System.assertEquals(
            true,
            picklistEntryServiceInstance != null,
            'Instance of service class should not be null.'
        );
    }

    /**************************************************************************************************************************
     * @description Test method to verify that the getInstance method returns the existing instance of the
     * PicklistEntryService class when one already exists.
     ***************************************************************************************************************************/
    @isTest
    private static void getInstanceExisting() {
        Test.startTest();
        PicklistEntryService picklistEntryServiceInstance1 = PicklistEntryService.getInstance();
        PicklistEntryService picklistEntryServiceInstance2 = PicklistEntryService.getInstance();
        Test.stopTest();

        System.assertEquals(
            PicklistEntryService.instance,
            picklistEntryServiceInstance1,
            'Instance of service class returned should match static instance variable.'
        );
        System.assertEquals(
            picklistEntryServiceInstance1,
            picklistEntryServiceInstance2,
            'Subsequent retrievals of service class instance should return existing instance.'
        );
        System.assertEquals(
            true,
            picklistEntryServiceInstance1 != null,
            'Instance of service class should not be null.'
        );
    }

    /***********************************************************************************************************************************
     * @description Test method to verify that the locatePicklistEntryMapper method returns instance of PicklistEntryMapper
     ***********************************************************************************************************************************/
    @isTest
    private static void locatePicklistEntryMapper() {
        Test.startTest();
        PicklistEntryMapper pcklstEntryMapper = PicklistEntryService.getInstance().locatePicklistEntryMapper();
        Test.stopTest();

        System.assertEquals(
            PicklistEntryMapper.getInstance(),
            pcklstEntryMapper,
            'Should return the instance of PicklistEntryMapper'
        );
    }

    /***********************************************************************************************************************************
     * @description Test method to verify that the getModelsByNameForSObjectField method returns instance of PicklistEntry Models
     ***********************************************************************************************************************************/
    @isTest
    private static void getModelsByNameForSObjectField() {
        PicklistEntryMapper.instance = new STUB_PicklistEntryMapper();

        Test.startTest();
        Map<String, PicklistEntryModel> picklistEntryModelsByPicklistEntryName = PicklistEntryService.getInstance()
            .getModelsByNameForSObjectField(Account.getSObjectType(), Account.Type.getDescribe().getSObjectField());
        Test.stopTest();

        System.assertEquals(
            1,
            picklistEntryModelsByPicklistEntryName.size(),
            'Retieved map should contain models for all the picklist entries'
        );
        System.assertEquals(
            'Prospect',
            picklistEntryModelsByPicklistEntryName.get('Prospect').name,
            'Map should retrieve the name of the picklist entry'
        );
        System.assertEquals(
            'Prospect',
            picklistEntryModelsByPicklistEntryName.get('Prospect').label,
            'Map should retrieve the label of the picklist entry'
        );
        System.assertEquals(
            true,
            picklistEntryModelsByPicklistEntryName.get('Prospect').isActive,
            'Map should retrieve active status of the picklist entry'
        );
    }

    /***********************************************************************************************************************************
     * @description Test method to verify that the getActivePicklistEntryModelsByName method returns a map containing only active
     * picklist entry values.
     ***********************************************************************************************************************************/
    @isTest
    private static void getActivePicklistEntryModelsByNameValid() {
        Map<String, PicklistEntryModel> picklistEntryModelsByString = new Map<String, PicklistEntryModel>{
            'Entry_1' => new PicklistEntryModel('Entry_1', 'Entry1', true),
            'Entry2' => new PicklistEntryModel('Entry_2', 'Entry2', false),
            'Entry_3' => new PicklistEntryModel('Entry_3', 'Entry3', true)
        };

        PicklistEntryService PicklistEntryServiceInstance = PicklistEntryService.getInstance();

        Test.startTest();
        Map<String, PicklistEntryModel> activePicklistEntryModelsByName = PicklistEntryServiceInstance.getActivePicklistEntryModelsByName(
            picklistEntryModelsByString
        );
        Test.stopTest();

        System.assertEquals(
            2,
            activePicklistEntryModelsByName.values().size(),
            'Should only contain active picklist entry values.'
        );
        System.assertEquals(
            'Entry_1',
            activePicklistEntryModelsByName.values()[0].name,
            'Name should match picklist entry name.'
        );
        System.assertEquals(
            'Entry1',
            activePicklistEntryModelsByName.values()[0].label,
            'Label should match picklist entry label.'
        );

        System.assertEquals(
            'Entry_3',
            activePicklistEntryModelsByName.values()[1].name,
            'Name should match picklist entry name.'
        );
        System.assertEquals(
            'Entry3',
            activePicklistEntryModelsByName.values()[1].label,
            'Label should match picklist entry label.'
        );
    }

    /***********************************************************************************************************************************
     * @description Test method to verify that the getActivePicklistEntryModelsByName method returns an empty map when no active
     * picklist values exist.
     ***********************************************************************************************************************************/
    @isTest
    private static void getActivePicklistEntryModelsByNameEmpty() {
        PicklistEntryService PicklistEntryServiceInstance = PicklistEntryService.getInstance();

        Test.startTest();
        Map<String, PicklistEntryModel> activePicklistEntryModelsByName = PicklistEntryServiceInstance.getActivePicklistEntryModelsByName(
            new Map<String, PicklistEntryModel>()
        );
        Test.stopTest();

        System.assertEquals(0, activePicklistEntryModelsByName.values().size(), 'Should return empty map.');
    }

    /***********************************************************************************************************************************
     ****************************************************** STUBS ***********************************************************************
     ***********************************************************************************************************************************/

    /**************************************************************************************************************************************
     * @description Stub class to simulate the response from PicklistEntryMapper to return a map of picklistEntryModelsByPicklistEntryName
     **************************************************************************************************************************************/
    private class STUB_PicklistEntryMapper extends PicklistEntryMapper {
        public override Map<String, PicklistEntryModel> getModelsByNameForSObjectField(
            SObjectType sObjectTypeName,
            SObjectField sObjectFieldName
        ) {
            Map<String, PicklistEntryModel> picklistEntryModelsByPicklistEntryName = new Map<String, PicklistEntryModel>();

            PicklistEntryModel pcklstEntryModel = new PicklistEntryModel('Prospect', 'Prospect', true);
            picklistEntryModelsByPicklistEntryName.put('Prospect', pcklstEntryModel);

            return picklistEntryModelsByPicklistEntryName;
        }
    }
}
@isTest
private with sharing class PreferredContactInfoSettingsMapper_TEST {
    /**************************************************************************************************************************
     * @description Test method to verify that the getInstance method returns a new instance of the
     * PreferredContactInfoSettingsMapper class when one does not already exist.
     ***************************************************************************************************************************/
    @isTest
    private static void getInstanceNew() {
        Test.startTest();
        PreferredContactInfoSettingsMapper preferredContactInfoSettingsMapperInstance = PreferredContactInfoSettingsMapper.getInstance();
        Test.stopTest();

        System.assertEquals(
            PreferredContactInfoSettingsMapper.instance,
            preferredContactInfoSettingsMapperInstance,
            'Instance of mapper class returned should match static instance variable.'
        );
        System.assertEquals(
            true,
            preferredContactInfoSettingsMapperInstance != null,
            'Instance of mapper class should not be null.'
        );
    }

    /**************************************************************************************************************************
     * @description Test method to verify that the getInstance method returns the existing instance of the
     * PreferredContactInfoSettingsMapper class when one already exists.
     ***************************************************************************************************************************/
    @isTest
    private static void getInstanceExisting() {
        Test.startTest();
        PreferredContactInfoSettingsMapper preferredContactInfoSettingsMapper1 = PreferredContactInfoSettingsMapper.getInstance();
        PreferredContactInfoSettingsMapper preferredContactInfoSettingsMapper2 = PreferredContactInfoSettingsMapper.getInstance();
        Test.stopTest();

        System.assertEquals(
            PreferredContactInfoSettingsMapper.instance,
            preferredContactInfoSettingsMapper1,
            'Instance of mapper class returned should match static instance variable.'
        );
        System.assertEquals(
            preferredContactInfoSettingsMapper1,
            preferredContactInfoSettingsMapper2,
            'Subsequent retrievals of mapper class instance should return existing instance.'
        );
        System.assertEquals(
            true,
            preferredContactInfoSettingsMapper1 != null,
            'Instance of mapper class should not be null.'
        );
    }

    /**************************************************************************************************************************
     * @description Test method to verify that the getPreferredContactInfoSettingsModel method returns a PreferredContactInfoSettingsModel
     * with all properties set to match the corresponding values in hierarchy settings.  In the case of Disable_Preferred_Email_Enforcement__c
     * and Disable_Preferred_Phone_Enforcement__c, the model values should be the invers of the hierarchy setting values.
     ***************************************************************************************************************************/
    @isTest
    private static void getPreferredContactInfoSettingsModelValid() {
        Hierarchy_Settings__c hierarchySettings = UTIL_CustomSettings_API.getSettingsForTests(
            new Hierarchy_Settings__c(
                Disable_Preferred_Email_Enforcement__c = true, //false
                Enable_New_Preferred_Phone_Sync__c = true,
                Disable_Preferred_Phone_Enforcement__c = true, //false
                Preferred_Phone_Selection__c = 'Test Phone Field'
            )
        );
        PreferredContactInfoSettingsMapper preferredContactInfoSettingsMapperInstance = PreferredContactInfoSettingsMapper.getInstance();

        Test.startTest();
        PreferredContactInfoSettingsModel preferredContactInfoSettingsModel = preferredContactInfoSettingsMapperInstance.getPreferredContactInfoSettingsModel();
        Test.stopTest();

        System.assertEquals(
            false,
            preferredContactInfoSettingsModel.requirePreferredEmail,
            'True value for hierarchy setting Disable_Preferred_Email_Enforcement__c, should set requirePreferredEmail property to false.'
        );

        System.assertEquals(
            true,
            preferredContactInfoSettingsModel.enhancedPhoneFunctionality,
            'True value for hierarchy setting Enable_New_Preferred_Phone_Sync__c, should set enhancedPhoneFunctionality property to true.'
        );

        System.assertEquals(
            false,
            preferredContactInfoSettingsModel.preferredPhoneEnforcement,
            'True value for hierarchy setting Disable_Preferred_Phone_Enforcement__c, should set preferredPhoneEnforcement property to false.'
        );

        System.assertEquals(
            'Test Phone Field',
            preferredContactInfoSettingsModel.defaultPreferredPhone,
            'defaultPreferredPhone property should be set to match Preferred_Phone_Selection__c hierarchy setting.'
        );
    }

    /**************************************************************************************************************************
     * @description Test method to verify that the getPreferredContactInfoSettingsModel method returns a PreferredContactInfoSettingsModel
     * with all properties set to match the corresponding values in hierarchy settings and specify a blank value when no preferred
     * phone value is specified.  In the case of Disable_Preferred_Email_Enforcement__c
     * and Disable_Preferred_Phone_Enforcement__c, the model values should be the invers of the hierarchy setting values.
     ***************************************************************************************************************************/
    @isTest
    private static void getPreferredContactInfoSettingsModelBlankString() {
        Hierarchy_Settings__c hierarchySettings = UTIL_CustomSettings_API.getSettingsForTests(
            new Hierarchy_Settings__c(
                Disable_Preferred_Email_Enforcement__c = false, //true
                Enable_New_Preferred_Phone_Sync__c = false,
                Disable_Preferred_Phone_Enforcement__c = false, //true
                Preferred_Phone_Selection__c = ''
            )
        );
        PreferredContactInfoSettingsMapper preferredContactInfoSettingsMapperInstance = PreferredContactInfoSettingsMapper.getInstance();

        Test.startTest();
        PreferredContactInfoSettingsModel preferredContactInfoSettingsModel = preferredContactInfoSettingsMapperInstance.getPreferredContactInfoSettingsModel();
        Test.stopTest();

        System.assertEquals(
            true,
            preferredContactInfoSettingsModel.requirePreferredEmail,
            'False value for hierarchy setting Disable_Preferred_Email_Enforcement__c, should set requirePreferredEmail property to true.'
        );

        System.assertEquals(
            false,
            preferredContactInfoSettingsModel.enhancedPhoneFunctionality,
            'False value for hierarchy setting Enable_New_Preferred_Phone_Sync__c, should set enhancedPhoneFunctionality property to false.'
        );

        System.assertEquals(
            true,
            preferredContactInfoSettingsModel.preferredPhoneEnforcement,
            'False value for hierarchy setting Disable_Preferred_Phone_Enforcement__c, should set preferredPhoneEnforcement property to true.'
        );

        System.assertEquals(
            '""',
            preferredContactInfoSettingsModel.defaultPreferredPhone,
            'defaultPreferredPhone property should be blank when no valud is specified for Preferred_Phone_Selection__c hierarchy setting.'
        );
    }
}
@isTest
private with sharing class PreferredContactInfoSettingsModel_TEST {
    /****************************************************************************
     * @description Test method to verify 4 argument constructor returns a model
     * with all properties populated
     ****************************************************************************/
    @isTest
    private static void fourArgumentConstructorValid() {
        Test.startTest();
        PreferredContactInfoSettingsModel referredContactInfoSettingsModel = new PreferredContactInfoSettingsModel(
            true,
            false,
            false,
            'Test Phone Field'
        );
        Test.stopTest();

        System.assertEquals(
            true,
            referredContactInfoSettingsModel.requirePreferredEmail,
            'Should require preferred email.'
        );
        System.assertEquals(
            false,
            referredContactInfoSettingsModel.enhancedPhoneFunctionality,
            'Should not require enhanced phone functionality.'
        );
        System.assertEquals(
            false,
            referredContactInfoSettingsModel.preferredPhoneEnforcement,
            'Should not require preferred phone enforcement.'
        );
        System.assertEquals(
            'Test Phone Field',
            referredContactInfoSettingsModel.defaultPreferredPhone,
            'Default preferred phone field should be specified.'
        );
    }

    /****************************************************************************
     * @description Test method to verify 4 argument constructor returns a model
     * with all properties appropriately defaulted when blank or null values are
     * provided.
     ****************************************************************************/
    @isTest
    private static void fourArgumentConstructorEmptyString() {
        Test.startTest();
        PreferredContactInfoSettingsModel referredContactInfoSettingsModel = new PreferredContactInfoSettingsModel(
            false,
            false,
            true,
            ''
        );
        Test.stopTest();

        System.assertEquals(
            false,
            referredContactInfoSettingsModel.requirePreferredEmail,
            'Preferred email value should be set to false.'
        );
        System.assertEquals(
            false,
            referredContactInfoSettingsModel.enhancedPhoneFunctionality,
            'Enhanced phone functionality should be set to false.'
        );
        System.assertEquals(
            true,
            referredContactInfoSettingsModel.preferredPhoneEnforcement,
            'Preferred phone enforcement should be set to true.'
        );
        System.assertEquals(
            '""',
            referredContactInfoSettingsModel.defaultPreferredPhone,
            'Blank value for default preferred phone field should be represented as blank value.'
        );
    }
}
@isTest
private with sharing class PreferredContactInfoSettingsService_TEST {
    /**************************************************************************************************************************
     * @description Test method to verify that the getInstance method returns a new instance of the
     * PreferredContactInfoSettingsService class when one does not already exist.
     ***************************************************************************************************************************/
    @isTest
    private static void getInstanceNew() {
        Test.startTest();
        PreferredContactInfoSettingsService preferredContactInfoSettingsServiceInstance = PreferredContactInfoSettingsService.getInstance();
        Test.stopTest();

        System.assertEquals(
            PreferredContactInfoSettingsService.instance,
            preferredContactInfoSettingsServiceInstance,
            'Instance of mapper class returned should match static instance variable.'
        );
        System.assertEquals(
            true,
            preferredContactInfoSettingsServiceInstance != null,
            'Instance of mapper class should not be null.'
        );
    }

    /**************************************************************************************************************************
     * @description Test method to verify that the getInstance method returns the existing instance of the
     * PreferredContactInfoSettingsService class when one already exists.
     ***************************************************************************************************************************/
    @isTest
    private static void getInstanceExisting() {
        Test.startTest();
        PreferredContactInfoSettingsService preferredContactInfoSettingsService1 = PreferredContactInfoSettingsService.getInstance();
        PreferredContactInfoSettingsService preferredContactInfoSettingsService2 = PreferredContactInfoSettingsService.getInstance();
        Test.stopTest();

        System.assertEquals(
            PreferredContactInfoSettingsService.instance,
            preferredContactInfoSettingsService1,
            'Instance of mapper class returned should match static instance variable.'
        );
        System.assertEquals(
            preferredContactInfoSettingsService1,
            preferredContactInfoSettingsService2,
            'Subsequent retrievals of mapper class instance should return existing instance.'
        );
        System.assertEquals(
            true,
            preferredContactInfoSettingsService1 != null,
            'Instance of mapper class should not be null.'
        );
    }

    /***********************************************************************************************************************************
     * @description Test method to verify that the locatePreferredContactInfoSettingsMapper method returns instance of PreferredContactInfoSettingsMapper
     ***********************************************************************************************************************************/
    @isTest
    private static void locatePreferredContactInfoSettingsMapper() {
        PreferredContactInfoSettingsService preferredContactInfoSettingsServiceInstance = PreferredContactInfoSettingsService.getInstance();

        Test.startTest();
        PreferredContactInfoSettingsMapper preferredContactInfoSettingsMapperInstance = preferredContactInfoSettingsServiceInstance.locatePreferredContactInfoSettingsMapper();
        Test.stopTest();

        System.assertEquals(
            PreferredContactInfoSettingsMapper.getInstance(),
            preferredContactInfoSettingsMapperInstance,
            'Should return the instance of PreferredContactInfoSettingsMapper'
        );
    }

    /***********************************************************************************************************************************
     * @description Test method to verify that the getPreferredContactInfoSettingsModel method returns a valid PreferredContactInfoSettingsModel
     ***********************************************************************************************************************************/
    @isTest
    private static void getPreferredContactInfoSettingsModelValid() {
        PreferredContactInfoSettingsMapper.instance = new STUB_PreferredContactInfoSettingsMapper();

        Hierarchy_Settings__c hierarchySettings = UTIL_CustomSettings_API.getSettingsForTests(
            new Hierarchy_Settings__c(
                Disable_Preferred_Email_Enforcement__c = false,
                Enable_New_Preferred_Phone_Sync__c = true,
                Disable_Preferred_Phone_Enforcement__c = false,
                Preferred_Phone_Selection__c = 'Test Phone Field'
            )
        );

        PreferredContactInfoSettingsService preferredContactInfoSettingsServiceInstance = PreferredContactInfoSettingsService.getInstance();

        Test.startTest();
        PreferredContactInfoSettingsModel preferredContactInfoSettingsModel = preferredContactInfoSettingsServiceInstance.getPreferredContactInfoSettingsModel();
        Test.stopTest();

        System.assertEquals(
            true,
            preferredContactInfoSettingsModel.requirePreferredEmail,
            'Should be set to inverse of value in hierarchy settings.'
        );
        System.assertEquals(
            true,
            preferredContactInfoSettingsModel.enhancedPhoneFunctionality,
            'Should match value in hierarchy settings.'
        );
        System.assertEquals(
            true,
            preferredContactInfoSettingsModel.preferredPhoneEnforcement,
            'Should be set to inverse of value in hierarchy settings.'
        );
        System.assertEquals(
            'Test Phone Field',
            preferredContactInfoSettingsModel.defaultPreferredPhone,
            'Should match value in hierarchy settings.'
        );
    }

    /***********************************************************************************************************************************
     ****************************************************** STUBS ***********************************************************************
     ***********************************************************************************************************************************/

    /**************************************************************************************************************************************
     * @description Stub class to simulate the response from PreferredContactInfoSettingsMapper to return a valid PreferredContactInfoSettingsModel
     **************************************************************************************************************************************/
    private class STUB_PreferredContactInfoSettingsMapper extends PreferredContactInfoSettingsMapper {
        public override PreferredContactInfoSettingsModel getPreferredContactInfoSettingsModel() {
            return new PreferredContactInfoSettingsModel(true, true, true, 'Test Phone Field');
        }
    }
}
@isTest
private with sharing class PreferredContactInfoSettingsVModel_TEST {
    private static Integer loopCounter = 5;

    /**************************************************************************************************************************
     * @description Test method to verify the four argument constructor returns a PreferredContactInfoSettingsVModel with all
     * properties populated.
     ***************************************************************************************************************************/
    @isTest
    private static void fourArugmentConstructorValid() {
        List<ComboboxValueVModel> preferredPhoneOptionComboboxValueVModelsList = new List<ComboboxValueVModel>();

        for (Integer i = 0; i < loopCounter; i++) {
            preferredPhoneOptionComboboxValueVModelsList.add(
                new ComboboxValueVModel('Phone Field Label ' + i, 'Phone Field Value ' + i)
            );
        }

        ComboboxVModel preferredPhoneComboboxVModel = new ComboboxVModel(
            'Phone Field Value 1',
            preferredPhoneOptionComboboxValueVModelsList
        );

        Test.startTest();
        PreferredContactInfoSettingsVModel preferredContactInfoSettingsVModel = new PreferredContactInfoSettingsVModel(
            true,
            true,
            false,
            preferredPhoneComboboxVModel
        );
        Test.stopTest();

        System.assertEquals(
            true,
            preferredContactInfoSettingsVModel.requirePreferredEmail,
            'Require Preferred Email setting in view model should match argument value.'
        );

        System.assertEquals(
            true,
            preferredContactInfoSettingsVModel.enhancedPhoneFunctionality,
            'Enhanced Phone Functionality setting in view model should match argument value.'
        );

        System.assertEquals(
            false,
            preferredContactInfoSettingsVModel.preferredPhoneEnforcement,
            'Preferred Phone Enforcement setting in view model should match argument value.'
        );

        System.assertEquals(
            'Phone Field Value 1',
            preferredContactInfoSettingsVModel.defaultPreferredPhone.value,
            'Default Preferred Phone selected value in view model should match value in specified ComboboxVModel.'
        );

        for (Integer i = 0; i < loopCounter; i++) {
            System.assertEquals(
                'Phone Field Label ' + i,
                preferredContactInfoSettingsVModel.defaultPreferredPhone.options[i].label,
                'Label for preferred phone option should match value in specified ComboboxVModel.'
            );

            System.assertEquals(
                'Phone Field Value ' + i,
                preferredContactInfoSettingsVModel.defaultPreferredPhone.options[i].value,
                'Value for preferred phone option should match value in specified ComboboxVModel.'
            );
        }
    }
}
@isTest
private with sharing class PreferredPhoneEmailBatchController_TEST {
    /***********************************************************************************************************************************
     * @description Test method to verify that the locatePrefEmailPhoneService method returns instance of locatePrefEmailPhoneService
     ***********************************************************************************************************************************/
    @isTest
    private static void locatePrefEmailPhoneService() {
        Test.startTest();
        SRVC_Contact_PreferredEmail prefEmailPhoneServiceInstance = PreferredPhoneEmailBatchController.locatePrefEmailPhoneService();
        Test.stopTest();

        System.assertEquals(
            SRVC_Contact_PreferredEmail.getInstance(),
            prefEmailPhoneServiceInstance,
            'Should return the instance of SRVC_Contact_PreferredEmail'
        );
    }

    /***********************************************************************************************************************************
     * @description Test method to verify runPreferredPhoneAndEmailCleanupJob method runs successfully
     ***********************************************************************************************************************************/
    @isTest
    private static void runPreferredPhoneAndEmailCleanupJobValid() {
        SRVC_Contact_PreferredEmail.instance = new STUB_PrefEmailPhoneServiceValid();
        Test.startTest();
        Boolean batchJobSuccessful = PreferredPhoneEmailBatchController.runPreferredPhoneAndEmailCleanupJob();
        Test.stopTest();

        System.assertEquals(true, batchJobSuccessful, 'Should return true if the batch job has run successfully');
    }

    /***********************************************************************************************************************************
     * @description Test method to verify runPreferredPhoneAndEmailCleanupJob method throws an error
     ***********************************************************************************************************************************/
    @isTest
    private static void runPreferredPhoneAndEmailCleanupJobError() {
        SRVC_Contact_PreferredEmail.instance = new STUB_PrefEmailPhoneServiceError();
        try {
            Test.startTest();
            Boolean batchJobSuccessful = PreferredPhoneEmailBatchController.runPreferredPhoneAndEmailCleanupJob();
            Test.stopTest();
            System.assert(false, 'should always throw an exception');
        } catch (AuraHandledException e) {
            System.assertEquals('Script-thrown exception', e.getMessage(), 'Should throw exception.');
        }
    }

    /**************************************************************************************************************************
     ****************************************************** STUBS **************************************************************
     **************************************************************************************************************************/

    /**************************************************************************************************************************************************
     * @description Stub class to simulate the response from SRVC_Contact_PreferredEmail to return a true for runPreferredPhoneAndEmailCleanupJob method .
     **************************************************************************************************************************************************/
    private class STUB_PrefEmailPhoneServiceValid extends SRVC_Contact_PreferredEmail {
        public override Boolean runPreferredPhoneAndEmailCleanupJob() {
            return true;
        }
    }

    /***************************************************************************************************************************************************
     * @description Stub class to simulate the response from SRVC_Contact_PreferredEmail to throw an error for runPreferredPhoneAndEmailCleanupJob method
     ***************************************************************************************************************************************************/
    private class STUB_PrefEmailPhoneServiceError extends SRVC_Contact_PreferredEmail {
        public override Boolean runPreferredPhoneAndEmailCleanupJob() {
            throw new AuraHandledException(Label.BatchJobRunningProblem);
        }
    }
}
@isTest
private with sharing class PrimaryAffiliationSettingsVModel_TEST {
    private static Integer loopCounter = 5;

    /****************************************************************************************
     * @description Test method to verify constructor returns a PrimaryAffiliationSettingsVModel
     * with all properties populated.
     ****************************************************************************************/
    @isTest
    private static void singleArgumentConstructorValid() {
        List<PrimaryAffiliationMappingVModel> primaryAffiliationMappings = new List<PrimaryAffiliationMappingVModel>();

        for (Integer i = 0; i < loopCounter; i++) {
            primaryAffiliationMappings.add(
                new PrimaryAffiliationMappingVModel(
                    'mappingName' + i,
                    'accountRecordTypeName' + i,
                    'accountRecordTypeLabel' + i,
                    'contactFieldName' + i,
                    'contactFieldLabel' + i,
                    true
                )
            );
        }

        Test.startTest();
        PrimaryAffiliationSettingsVModel primaryAffiliationSettingsVModel = new PrimaryAffiliationSettingsVModel(
            primaryAffiliationMappings
        );
        Test.stopTest();

        System.assertEquals(
            loopCounter,
            primaryAffiliationSettingsVModel.primaryAffiliationMappings.size(),
            'Settings View model should contain ' +
            loopCounter +
            ' primary affiliation mapping models.'
        );

        for (Integer i = 0; i < loopCounter; i++) {
            System.assertEquals(
                'mappingName' + i,
                primaryAffiliationSettingsVModel.primaryAffiliationMappings[i].mappingName,
                'Mapping name of primary affiliation mapping model should match value provided as argument.'
            );

            System.assertEquals(
                'accountRecordTypeName' + i,
                primaryAffiliationSettingsVModel.primaryAffiliationMappings[i].accountRecordTypeName,
                'Account Record Type Name of primary affiliation mapping model should match value provided as argument.'
            );

            System.assertEquals(
                'accountRecordTypeLabel' + i,
                primaryAffiliationSettingsVModel.primaryAffiliationMappings[i].accountRecordTypeLabel,
                'Account Record Type Label of primary affiliation mapping model should match value provided as argument.'
            );

            System.assertEquals(
                'contactFieldName' + i,
                primaryAffiliationSettingsVModel.primaryAffiliationMappings[i].contactFieldName,
                'Contact Field Name of primary affiliation mapping model should match value provided as argument.'
            );

            System.assertEquals(
                'contactFieldLabel' + i,
                primaryAffiliationSettingsVModel.primaryAffiliationMappings[i].contactFieldLabel,
                'Contact Field Label of primary affiliation mapping model should match value provided as argument.'
            );
        }
    }
}
public virtual with sharing class PrimaryAffiliationsSettingsVMapper {
    /**********************************************************************************
     * @description Instance for Singleton Pattern
     **********************************************************************************/
    @TestVisible
    private static PrimaryAffiliationsSettingsVMapper instance;

    /**********************************************************************************
     * @description Empty constructor is not public for Singleton Pattern
     **********************************************************************************/
    protected PrimaryAffiliationsSettingsVMapper() {
    }

    /**********************************************************************************
     * @description Static method to get the current instance for Singleton pattern
     * @return The instance of AffiliationsSettingsVMapper.
     **********************************************************************************/
    public static PrimaryAffiliationsSettingsVMapper getInstance() {
        if (instance == null) {
            instance = new PrimaryAffiliationsSettingsVMapper();
        }

        return instance;
    }

    /**********************************************************************************************************
     * @description Retrieve a PrimaryffiliationsSettingsVModel for affiliations mappings
     * @return  A PrimaryffiliationsSettingsVModel
     *********************************************************************************************************/
    public virtual PrimaryAffiliationSettingsVModel getPrimaryAffiliationsSettingsVModel() {
        List<AffiliationMappingsModel> affiliationMappingsModelsList = this.locateAffiliationMappingsService()
            .getAffiliationMappingsModels();

        Map<Id, RecordTypeModel> accRecordTypeModelsById = this.locateRecordTypeService()
            .getModelByIdMapForSObjectType(Account.SObjectType);

        Map<String, RecordTypeModel> accountRecordTypeModelsByName = this.locateRecordTypeService()
            .getRecordTypeModelMapByName(accRecordTypeModelsById);
        Map<String, RecordTypeModel> accountRecordTypeModelsByLabel = this.locateRecordTypeService()
            .getRecordTypeModelMapByLabel(accRecordTypeModelsById);

        Map<String, LookupFieldModel> accountLookupsOnContactFieldModelsByName = this.locateLookupFieldService()
            .getModelByNameMapForSObjectType(Contact.SObjectType, Account.SObjectType);
        Map<String, LookupFieldModel> accountLookupsOnContactFieldModelsByLabel = this.locateLookupFieldService()
            .getModelByLabelMapForSObjectType(accountLookupsOnContactFieldModelsByName);

        List<PrimaryAffiliationMappingVModel> primaryAffiliationMappingVModelList = new List<PrimaryAffiliationMappingVModel>();

        for (AffiliationMappingsModel affiliationMappingsModel : affiliationMappingsModelsList) {
            primaryAffiliationMappingVModelList.add(
                this.getPrimaryAffiliationsMappingVModel(
                    affiliationMappingsModel,
                    accountRecordTypeModelsByName,
                    accountRecordTypeModelsByLabel,
                    accountLookupsOnContactFieldModelsByName,
                    accountLookupsOnContactFieldModelsByLabel
                )
            );
        }

        return new PrimaryAffiliationSettingsVModel(primaryAffiliationMappingVModelList);
    }

    /**********************************************************************************************************
     * @description Generate a view model representing the settings specified for an affiliation mapping.
     * @param  affiliationMappingsModel A model representing the affililation mapping
     * @param  accountRecordTypeModelsByName A Map of Account Record Type models by developer name
     * @param  accountRecordTypeModelsByLabel A Map of Account Record Type models by label
     * @param  accountLookupsOnContactFieldModelsByName A Map of Lookup fields of type Account on the Contact object by name
     * @param  accountLookupsOnContactFieldModelsByLabel A Map of Lookup fields of type Account on the Contact object by label
     * @return A PrimaryAffiliationMappingVModel
     **********************************************************************************************************/
    @TestVisible
    protected PrimaryAffiliationMappingVModel getPrimaryAffiliationsMappingVModel(
        AffiliationMappingsModel affiliationMappingsModel,
        Map<String, RecordTypeModel> accountRecordTypeModelsByName,
        Map<String, RecordTypeModel> accountRecordTypeModelsByLabel,
        Map<String, LookupFieldModel> accountLookupsOnContactFieldModelsByName,
        Map<String, LookupFieldModel> accountLookupsOnContactFieldModelsByLabel
    ) {
        String accountRecordTypeName = affiliationMappingsModel.accountRecordTypeFieldValue;
        String accountRecordTypeLabel = affiliationMappingsModel.accountRecordTypeFieldValue;
        String contactFieldName = affiliationMappingsModel.primaryAffiliationField;
        String contactFieldLabel = affiliationMappingsModel.primaryAffiliationField;

        // get RecordType model matching Account Record Type specified in Affiliation mapping
        RecordTypeModel recordTypeModel = this.locateRecordTypeService()
            .getRecordTypeModelFromNameAndLabelMaps(
                affiliationMappingsModel.accountRecordTypeFieldValue,
                accountRecordTypeModelsByName,
                accountRecordTypeModelsByLabel
            );

        if (recordTypeModel != null) {
            accountRecordTypeName = recordTypeModel.developerName;
            accountRecordTypeLabel = recordTypeModel.name;
        }

        // get LookupField model matching Primary Affiliation Field specified in Affiliation mapping
        LookupFieldModel lookupFieldModel = this.locateLookupFieldService()
            .getLookupFieldModelFromNameAndLabelMaps(
                affiliationMappingsModel.primaryAffiliationField,
                accountLookupsOnContactFieldModelsByName,
                accountLookupsOnContactFieldModelsByLabel
            );

        if (lookupFieldModel != null) {
            contactFieldName = lookupFieldModel.name;
            contactFieldLabel = lookupFieldModel.label;
        }

        return new PrimaryAffiliationMappingVModel(
            affiliationMappingsModel.name,
            accountRecordTypeName,
            accountRecordTypeLabel,
            contactFieldName,
            contactFieldLabel,
            affiliationMappingsModel.autoProgramEnrollment
        );
    }

    /**********************************************************************************************************
     * @description Retrieve a ComboBoxVModel for all active account record types
     * @param recordTypeToCheck Selected account record type in the modal
     * @return  A ComboBoxVModel
     *********************************************************************************************************/
    public virtual ComboBoxVModel getAccountRecordTypeComboboxVModel(String recordTypeToCheck) {
        String comboboxValue = recordTypeToCheck;
        List<ComboboxValueVModel> comboboxValues = new List<ComboboxValueVModel>();

        // Get all recordtype models for the account
        Map<Id, RecordTypeModel> accRecordTypeModelsById = this.locateRecordTypeService()
            .getModelByIdMapForSObjectType(Account.SObjectType);

        // Filter to get the active recordtypes model map
        Map<Id, RecordTypeModel> activeAccountRecordTypeModelsById = this.locateRecordTypeService()
            .getActiveRecordTypeModelsById(accRecordTypeModelsById.values());

        Map<String, RecordTypeModel> activeAccountRecordTypeModelsByName = this.locateRecordTypeService()
            .getRecordTypeModelMapByName(activeAccountRecordTypeModelsById);
        Map<String, RecordTypeModel> activeAccountRecordTypeModelsByLabel = this.locateRecordTypeService()
            .getRecordTypeModelMapByLabel(activeAccountRecordTypeModelsById);

        if (String.isBlank(recordTypeToCheck)) {
            comboboxValues.addAll(
                this.getComboboxVModelOptionsForActiveAccountRecordTypes(activeAccountRecordTypeModelsById.values())
            );

            return new ComboboxVModel(comboboxValue, comboboxValues);
        }

        RecordTypeModel recordTypeModel = this.locateRecordTypeService()
            .getRecordTypeModelFromNameAndLabelMaps(
                recordTypeToCheck,
                activeAccountRecordTypeModelsByName,
                activeAccountRecordTypeModelsByLabel
            );

        if (recordTypeModel == null) {
            comboboxValues.add(new ComboboxValueVModel(recordTypeToCheck, recordTypeToCheck));
        } else {
            comboboxValue = recordTypeModel.developerName;
        }

        comboboxValues.addAll(
            this.getComboboxVModelOptionsForActiveAccountRecordTypes(activeAccountRecordTypeModelsById.values())
        );

        return new ComboboxVModel(comboboxValue, comboboxValues);
    }

    /**********************************************************************************************************************
     * @description Helper method to generate a list of comboboxValueVModels for all active Account record types.
     * @param  activeAccountRecordTypeModelsList A list of RecordType models corresponding to active Account record types.
     * @return A List<ComboboxValueVModel> containing comboboxValueVModels for all active Account record types.
     **********************************************************************************************************************/
    @TestVisible
    private List<ComboboxValueVModel> getComboboxVModelOptionsForActiveAccountRecordTypes(
        List<RecordTypeModel> activeAccountRecordTypeModelsList
    ) {
        List<ComboboxValueVModel> activeRecordTypeComboboxValueVModelsList = new List<ComboboxValueVModel>();

        for (RecordTypeModel activeAccountRecordTypeModel : activeAccountRecordTypeModelsList) {
            activeRecordTypeComboboxValueVModelsList.add(
                new ComboboxValueVModel(activeAccountRecordTypeModel.name, activeAccountRecordTypeModel.developerName)
            );
        }

        return activeRecordTypeComboboxValueVModelsList;
    }

    /**********************************************************************************************************
     * @description Retrieve a ComboBoxVModel for all Contact Account Lookup Fields
     * @return  A ComboBoxVModel
     *********************************************************************************************************/
    public virtual ComboBoxVModel getContactAccountLookupFieldComboboxVModel(String contactFieldToCheck) {
        String comboboxValue = contactFieldToCheck;
        List<ComboboxValueVModel> comboboxValues = new List<ComboboxValueVModel>();

        Map<String, LookupFieldModel> accountLookupsOnContactFieldModelsByName = this.locateLookupFieldService()
            .getModelByNameMapForSObjectType(Contact.SObjectType, Account.SObjectType);
        Map<String, LookupFieldModel> accountLookupsOnContactFieldModelsByLabel = this.locateLookupFieldService()
            .getModelByLabelMapForSObjectType(accountLookupsOnContactFieldModelsByName);

        if (String.isBlank(contactFieldToCheck)) {
            comboboxValues.addAll(
                this.getComboboxVModelOptionsForContactAccountLookupFields(
                    accountLookupsOnContactFieldModelsByName.values()
                )
            );

            return new ComboboxVModel(comboboxValue, comboboxValues);
        }

        LookupFieldModel lookupFieldModel = this.locateLookupFieldService()
            .getLookupFieldModelFromNameAndLabelMaps(
                contactFieldToCheck,
                accountLookupsOnContactFieldModelsByName,
                accountLookupsOnContactFieldModelsByLabel
            );

        if (lookupFieldModel == null) {
            comboboxValues.add(new ComboboxValueVModel(contactFieldToCheck, contactFieldToCheck));
        } else {
            comboboxValue = lookupFieldModel.name;
        }

        comboboxValues.addAll(
            this.getComboboxVModelOptionsForContactAccountLookupFields(
                accountLookupsOnContactFieldModelsByName.values()
            )
        );

        return new ComboboxVModel(comboboxValue, comboboxValues);
    }

    /**********************************************************************************************************************
     * @description Helper method to generate a list of comboboxValueVModels for all Contact Account Lookup Fields.
     * @param  contactLookupFieldModelList A list of LookupField models corresponding to Contact Account Lookup Fields.
     * @return A List<ComboboxValueVModel> containing comboboxValueVModels for all Contact Account Lookup Fields.
     **********************************************************************************************************************/
    @TestVisible
    private List<ComboboxValueVModel> getComboboxVModelOptionsForContactAccountLookupFields(
        List<LookupFieldModel> contactLookupFieldModelList
    ) {
        List<ComboboxValueVModel> contactAccountLookupFieldComboboxValueVModelsList = new List<ComboboxValueVModel>();

        for (LookupFieldModel contactLookupFieldModel : contactLookupFieldModelList) {
            contactAccountLookupFieldComboboxValueVModelsList.add(
                new ComboboxValueVModel(contactLookupFieldModel.label, contactLookupFieldModel.name)
            );
        }

        return contactAccountLookupFieldComboboxValueVModelsList;
    }

    /*****************************************************************************
     * @description Retrieve an instance of the AffiliationMappingsService class.
     * @return An instance of AffiliationMappingsService.
     *****************************************************************************/
    @TestVisible
    private AffiliationMappingsService locateAffiliationMappingsService() {
        return AffiliationMappingsService.getInstance();
    }

    /*****************************************************************************
     * @description Retrieve an instance of the RecordTypeService class.
     * @return An instance of RecordTypeService.
     *****************************************************************************/
    @TestVisible
    private RecordTypeService locateRecordTypeService() {
        return RecordTypeService.getInstance();
    }

    /*****************************************************************************
     * @description Retrieve an instance of the LookupFieldService class.
     * @return An instance of LookupFieldService.
     *****************************************************************************/
    @TestVisible
    private LookupFieldService locateLookupFieldService() {
        return LookupFieldService.getInstance();
    }
}
@isTest
private with sharing class PrimaryAffiliationsSettingsVMapper_TEST {
    private static Integer loopCounter = 5;

    /**************************************************************************************************
     * @description Test method to verify that the getInstance method returns a new instance of the
     * PrimaryAffiliationsSettingsVMapper class when one does not already exist.
     **************************************************************************************************/
    @isTest
    private static void getInstanceNew() {
        Test.startTest();
        PrimaryAffiliationsSettingsVMapper primaryAffiliationsSettingsVMapperInstance = PrimaryAffiliationsSettingsVMapper.getInstance();
        Test.stopTest();

        System.assertEquals(
            PrimaryAffiliationsSettingsVMapper.instance,
            primaryAffiliationsSettingsVMapperInstance,
            'Instance of mapper class returned should match static instance variable.'
        );
        System.assertEquals(
            true,
            primaryAffiliationsSettingsVMapperInstance != null,
            'Instance of mapper class should not be null.'
        );
    }

    /**************************************************************************************************
     * @description Test method to verify that the getInstance method returns the existing instance of the
     * PrimaryAffiliationsSettingsVMapper class when one already exists.
     **************************************************************************************************/
    @isTest
    private static void getInstanceExisting() {
        Test.startTest();
        PrimaryAffiliationsSettingsVMapper primaryAffiliationsSettingsVMapperInstance1 = PrimaryAffiliationsSettingsVMapper.getInstance();
        PrimaryAffiliationsSettingsVMapper primaryAffiliationsSettingsVMapperInstance2 = PrimaryAffiliationsSettingsVMapper.getInstance();
        Test.stopTest();

        System.assertEquals(
            PrimaryAffiliationsSettingsVMapper.instance,
            primaryAffiliationsSettingsVMapperInstance1,
            'Instance of mapper class returned should match static instance variable.'
        );
        System.assertEquals(
            primaryAffiliationsSettingsVMapperInstance1,
            primaryAffiliationsSettingsVMapperInstance2,
            'Subsequent retrievals of mapper class instance should return existing instance.'
        );
        System.assertEquals(
            true,
            primaryAffiliationsSettingsVMapperInstance1 != null,
            'Instance of mapper class should not be null.'
        );
    }

    /****************************************************************************************
     * @description Test method to verify locateLookupFieldService() returns an instance of
     * the LookupFieldService class.
     ****************************************************************************************/
    @isTest
    private static void locateLookupFieldServiceValid() {
        PrimaryAffiliationsSettingsVMapper primaryAffiliationsSettingsVMapperInstance = PrimaryAffiliationsSettingsVMapper.getInstance();

        Test.startTest();
        LookupFieldService lookupFieldServiceInstance = primaryAffiliationsSettingsVMapperInstance.locateLookupFieldService();
        Test.stopTest();

        System.assertEquals(
            LookupFieldService.getInstance(),
            lookupFieldServiceInstance,
            'Should return instance of LookupFieldService class.'
        );
    }

    /****************************************************************************************
     * @description Test method to verify locateRecordTypeService() returns an instance of
     * the RecordTypeService class.
     ****************************************************************************************/
    @isTest
    private static void locateRecordTypeServiceValid() {
        PrimaryAffiliationsSettingsVMapper primaryAffiliationsSettingsVMapperInstance = PrimaryAffiliationsSettingsVMapper.getInstance();

        Test.startTest();
        RecordTypeService recordTypeServiceInstance = primaryAffiliationsSettingsVMapperInstance.locateRecordTypeService();
        Test.stopTest();

        System.assertEquals(
            RecordTypeService.getInstance(),
            recordTypeServiceInstance,
            'Should return instance of RecordTypeService class.'
        );
    }

    /****************************************************************************************
     * @description Test method to verify locateAffiliationMappingsService() returns an instance of
     * the AffiliationMappingsService class.
     ****************************************************************************************/
    @isTest
    private static void locateAffiliationMappingsServiceValid() {
        PrimaryAffiliationsSettingsVMapper primaryAffiliationsSettingsVMapperInstance = PrimaryAffiliationsSettingsVMapper.getInstance();

        Test.startTest();
        AffiliationMappingsService affiliationMappingsServiceInstance = primaryAffiliationsSettingsVMapperInstance.locateAffiliationMappingsService();
        Test.stopTest();

        System.assertEquals(
            AffiliationMappingsService.getInstance(),
            affiliationMappingsServiceInstance,
            'Should return instance of AffiliationMappingsService class.'
        );
    }

    /****************************************************************************************
     * @description Test method to verify getComboboxVModelOptionsForContactAccountLookupFields()
     * returns a list of ComboboxValueVModels representing the Account lookup fields on the
     * Contact object.
     ****************************************************************************************/
    @isTest
    private static void getComboboxVModelOptionsForContactAccountLookupFieldsValid() {
        List<LookupFieldModel> contactLookupFieldModelList = new List<LookupFieldModel>();

        for (Integer i = 0; i < loopCounter; i++) {
            contactLookupFieldModelList.add(new LookupFieldModel('Lookup Field Name ' + i, 'Lookup Field Label ' + i));
        }

        PrimaryAffiliationsSettingsVMapper primaryAffiliationsSettingsVMapperInstance = PrimaryAffiliationsSettingsVMapper.getInstance();

        Test.startTest();
        List<ComboboxValueVModel> lookupFieldComboboxValueVModelsList = primaryAffiliationsSettingsVMapperInstance.getComboboxVModelOptionsForContactAccountLookupFields(
            contactLookupFieldModelList
        );
        Test.stopTest();

        System.assertEquals(
            loopCounter,
            lookupFieldComboboxValueVModelsList.size(),
            'Should return ' +
            loopCounter +
            ' ComboboxValueVModels.'
        );

        for (Integer i = 0; i < loopCounter; i++) {
            System.assertEquals(
                'Lookup Field Name ' + i,
                lookupFieldComboboxValueVModelsList[i].value,
                'ComoboboxValueVModel value should match lookup field model name.'
            );

            System.assertEquals(
                'Lookup Field Label ' + i,
                lookupFieldComboboxValueVModelsList[i].label,
                'ComoboboxValueVModel label should match lookup field model label.'
            );
        }
    }

    /****************************************************************************************
     * @description Test method to verify getContactAccountLookupFieldComboboxVModel()
     * returns a ComboboxVModel representing the selected Account lookup field and a list of
     * options all account lookup fields on contact.
     ****************************************************************************************/
    @isTest
    private static void getContactAccountLookupFieldComboboxVModelValid() {
        LookupFieldService.instance = new STUB_LookupFieldService();

        PrimaryAffiliationsSettingsVMapper primaryAffiliationsSettingsVMapperInstance = PrimaryAffiliationsSettingsVMapper.getInstance();

        Test.startTest();
        ComboBoxVModel accountLookupFieldComboBoxVModel = primaryAffiliationsSettingsVMapperInstance.getContactAccountLookupFieldComboboxVModel(
            'Contact Account Lookup Name 1'
        );
        Test.stopTest();

        System.assertEquals(
            'Contact Account Lookup Name 1',
            accountLookupFieldComboBoxVModel.value,
            'Selected value in combobox view model should match contact field to check.'
        );

        System.assertEquals(
            2,
            accountLookupFieldComboBoxVModel.options.size(),
            'Combobox options should include only existing account lookup fields.'
        );
    }

    /****************************************************************************************
     * @description Test method to verify getContactAccountLookupFieldComboboxVModel()
     * returns a ComboboxVModel representing a list of options all account lookup fields on contact.
     ****************************************************************************************/
    @isTest
    private static void getContactAccountLookupFieldComboboxVModelEmpty() {
        LookupFieldService.instance = new STUB_LookupFieldService();

        PrimaryAffiliationsSettingsVMapper primaryAffiliationsSettingsVMapperInstance = PrimaryAffiliationsSettingsVMapper.getInstance();

        Test.startTest();
        ComboBoxVModel accountLookupFieldComboBoxVModel = primaryAffiliationsSettingsVMapperInstance.getContactAccountLookupFieldComboboxVModel(
            null
        );
        Test.stopTest();

        System.assertEquals(
            null,
            accountLookupFieldComboBoxVModel.value,
            'Selected value in combobox view model should be null.'
        );

        System.assertEquals(
            2,
            accountLookupFieldComboBoxVModel.options.size(),
            'Combobox options should include only existing account lookup fields.'
        );
    }

    /****************************************************************************************
     * @description Test method to verify getContactAccountLookupFieldComboboxVModel()
     * returns a ComboboxVModel representing the selected Account lookup field and a list of
     * options that includes the selected lookup field when it is not currently a specified field.
     ****************************************************************************************/
    @isTest
    private static void getContactAccountLookupFieldComboboxVModelInValid() {
        LookupFieldService.instance = new STUB_LookupFieldService();

        PrimaryAffiliationsSettingsVMapper primaryAffiliationsSettingsVMapperInstance = PrimaryAffiliationsSettingsVMapper.getInstance();

        Test.startTest();
        ComboBoxVModel accountLookupFieldComboBoxVModel = primaryAffiliationsSettingsVMapperInstance.getContactAccountLookupFieldComboboxVModel(
            'Invalid Field Name'
        );
        Test.stopTest();

        System.assertEquals(
            'Invalid Field Name',
            accountLookupFieldComboBoxVModel.value,
            'Selected value in combobox view model should match contact field to check.'
        );

        System.assertEquals(
            3,
            accountLookupFieldComboBoxVModel.options.size(),
            'Combobox options should include invalid field name as an option in addition to existing account lookup fields.'
        );
    }

    /****************************************************************************************
     * @description Test method to verify getComboboxVModelOptionsForActiveAccountRecordTypes()
     * returns a List<ComboboxValueVModel> representing the record type models provided as
     * arguments.
     ****************************************************************************************/
    @isTest
    private static void getComboboxVModelOptionsForActiveAccountRecordTypesValid() {
        List<RecordTypeModel> activeAccountRecordTypeModelsList = new List<RecordTypeModel>();

        for (Integer i = 0; i < loopCounter; i++) {
            activeAccountRecordTypeModelsList.add(
                new RecordTypeModel('00000000000000000' + i, 'AcctRT' + i, 'Acct_RT_' + i, true)
            );
        }

        PrimaryAffiliationsSettingsVMapper primaryAffiliationsSettingsVMapperInstance = PrimaryAffiliationsSettingsVMapper.getInstance();

        Test.startTest();
        List<ComboboxValueVModel> activeRecordTypeComboboxValueVModelsList = primaryAffiliationsSettingsVMapperInstance.getComboboxVModelOptionsForActiveAccountRecordTypes(
            activeAccountRecordTypeModelsList
        );
        Test.stopTest();

        System.assertEquals(
            loopCounter,
            activeRecordTypeComboboxValueVModelsList.size(),
            'Should return ' +
            loopCounter +
            ' comboboxValueVModels corresponding to active record type models.'
        );

        for (Integer i = 0; i < loopCounter; i++) {
            System.assertEquals(
                'AcctRT' + i,
                activeRecordTypeComboboxValueVModelsList[i].label,
                'ComboboxVModel label should correspond to record type model name.'
            );

            System.assertEquals(
                'Acct_RT_' + i,
                activeRecordTypeComboboxValueVModelsList[i].value,
                'ComboboxVModel label should correspond to record type model developer name.'
            );
        }
    }

    /****************************************************************************************
     * @description Test method to verify getAccountRecordTypeComboboxVModel()
     * returns a ComboboxVModel representing a selected account record type that is also an
     * existing value.
     ****************************************************************************************/
    @isTest
    private static void getAccountRecordTypeComboboxVModelValid() {
        RecordTypeService.instance = new STUB_RecordTypeService();

        PrimaryAffiliationsSettingsVMapper primaryAffiliationsSettingsVMapperInstance = PrimaryAffiliationsSettingsVMapper.getInstance();

        Test.startTest();
        ComboBoxVModel accountRTComboboxVModel = primaryAffiliationsSettingsVMapperInstance.getAccountRecordTypeComboboxVModel(
            'Record_Type_2'
        );
        Test.stopTest();

        System.assertEquals(
            'Record_Type_2',
            accountRTComboboxVModel.value,
            'Selected account record type should match record type to check.'
        );
        System.assertEquals(
            2,
            accountRTComboboxVModel.options.size(),
            'Account record type options list should consist only of active values.'
        );
    }

    /****************************************************************************************
     * @description Test method to verify getAccountRecordTypeComboboxVModel()
     * returns a ComboboxVModel representing a list of all active Account Record Types
     ****************************************************************************************/
    @isTest
    private static void getAccountRecordTypeComboboxVModelEmpty() {
        RecordTypeService.instance = new STUB_RecordTypeService();

        PrimaryAffiliationsSettingsVMapper primaryAffiliationsSettingsVMapperInstance = PrimaryAffiliationsSettingsVMapper.getInstance();

        Test.startTest();
        ComboBoxVModel accountRTComboboxVModel = primaryAffiliationsSettingsVMapperInstance.getAccountRecordTypeComboboxVModel(
            null
        );
        Test.stopTest();

        System.assertEquals(null, accountRTComboboxVModel.value, 'Selected account record type should be null.');
        System.assertEquals(
            2,
            accountRTComboboxVModel.options.size(),
            'Account record type options list should consist only of active values.'
        );
    }

    /****************************************************************************************
     * @description Test method to verify getAccountRecordTypeComboboxVModel()
     * returns a ComboboxVModel representing a selected account record type that is not an
     * existing value.
     ****************************************************************************************/
    @isTest
    private static void getAccountRecordTypeComboboxVModelInValid() {
        RecordTypeService.instance = new STUB_RecordTypeService();

        PrimaryAffiliationsSettingsVMapper primaryAffiliationsSettingsVMapperInstance = PrimaryAffiliationsSettingsVMapper.getInstance();

        Test.startTest();
        ComboBoxVModel accountRTComboboxVModel = primaryAffiliationsSettingsVMapperInstance.getAccountRecordTypeComboboxVModel(
            'New Record Type'
        );
        Test.stopTest();

        System.assertEquals(
            'New Record Type',
            accountRTComboboxVModel.value,
            'Selected account record type should match record type to check.'
        );
        System.assertEquals(
            3,
            accountRTComboboxVModel.options.size(),
            'Account record type options list should include new value with active values.'
        );
    }

    /****************************************************************************************
     * @description Test method to verify getPrimaryAffiliationsMappingVModel()
     * returns a PrimaryAffiliationMappingVModel with account record type and lookup field names
     * and labels corresponding to the matching model properties when matching models exists.
     ****************************************************************************************/
    @isTest
    private static void getPrimaryAffiliationsMappingVModelValid() {
        RecordTypeService.instance = new STUB_RecordTypeServiceValid();
        LookupFieldService.instance = new STUB_LookupFieldServiceValid();

        AffiliationMappingsModel affiliationMappingsModel = new AffiliationMappingsModel(
            'Affliation Name',
            'Account Record Type',
            'Primary Affiliation Field',
            true,
            'autoProgramEnrollmentStatus',
            'autoProgramEnrollmentRole'
        );
        Map<String, RecordTypeModel> accountRecordTypeModelsByName = new Map<String, RecordTypeModel>{
            'Account_Record_Type' => new RecordTypeModel(
                '000000000000000009',
                'Account Record Type',
                'Account_Record_Type',
                true
            )
        };

        Map<String, RecordTypeModel> accountRecordTypeModelsByLabel = new Map<String, RecordTypeModel>{
            'Account Record Type' => new RecordTypeModel(
                '000000000000000009',
                'Account Record Type',
                'Account_Record_Type',
                true
            )
        };

        Map<String, LookupFieldModel> accountLookupsOnContactFieldModelsByName = new Map<String, LookupFieldModel>{
            'Account Field Name' => new LookupFieldModel('Account Field Name', 'Account Field Label')
        };

        Map<String, LookupFieldModel> accountLookupsOnContactFieldModelsByLabel = new Map<String, LookupFieldModel>{
            'Account Field Label' => new LookupFieldModel('Account Field Name', 'Account Field Label')
        };

        PrimaryAffiliationsSettingsVMapper primaryAffiliationsSettingsVMapperInstance = PrimaryAffiliationsSettingsVMapper.getInstance();

        Test.startTest();
        PrimaryAffiliationMappingVModel primaryAffiliationMappingVModel = primaryAffiliationsSettingsVMapperInstance.getPrimaryAffiliationsMappingVModel(
            affiliationMappingsModel,
            accountRecordTypeModelsByName,
            accountRecordTypeModelsByLabel,
            accountLookupsOnContactFieldModelsByName,
            accountLookupsOnContactFieldModelsByLabel
        );
        Test.stopTest();

        System.assertEquals(
            'Affliation Name',
            PrimaryAffiliationMappingVModel.mappingName,
            'Mapping name should match name of affiliation mapping.'
        );

        System.assertEquals(
            'Account_Record_Type',
            PrimaryAffiliationMappingVModel.accountRecordTypeName,
            'Account Record Type name should match developer name of Record Type model corresponding to record type specified for the affiliation mapping.'
        );

        System.assertEquals(
            'Account Record Type',
            PrimaryAffiliationMappingVModel.accountRecordTypeLabel,
            'Account Record Type label should match label of Record Type model corresponding to record type specified for the affiliation mapping.'
        );

        System.assertEquals(
            'Account Field Name',
            PrimaryAffiliationMappingVModel.contactFieldName,
            'Contact field name should match name of Lookup Field model corresponding to primary affiliation field specified for the affiliation mapping.'
        );

        System.assertEquals(
            'Account Field Label',
            PrimaryAffiliationMappingVModel.contactFieldLabel,
            'Contact field label should match label of Lookup Field model corresponding to primary affiliation field specified for the affiliation mapping.'
        );

        System.assertEquals(
            true,
            PrimaryAffiliationMappingVModel.autoProgramEnrollment,
            'Auto-enrollment enablement should match value specified for the affiliation mapping.'
        );
    }

    /****************************************************************************************
     * @description Test method to verify getPrimaryAffiliationsMappingVModel()
     * returns a PrimaryAffiliationMappingVModel with account record type and lookup field names
     * and labels corresponding to the properties specified for the affiliation mapping
     * when matching models do not exist.
     ****************************************************************************************/
    @isTest
    private static void getPrimaryAffiliationsMappingVModelInValid() {
        RecordTypeService.instance = new STUB_RecordTypeServiceInvalid();
        LookupFieldService.instance = new STUB_LookupFieldServiceInvalid();

        AffiliationMappingsModel affiliationMappingsModel = new AffiliationMappingsModel(
            'Affliation Name',
            'Invalid Account Record Type',
            'Invalid Primary Affiliation Field',
            false,
            'autoProgramEnrollmentStatus',
            'autoProgramEnrollmentRole'
        );
        Map<String, RecordTypeModel> accountRecordTypeModelsByName = new Map<String, RecordTypeModel>{
            'Account_Record_Type' => new RecordTypeModel(
                '000000000000000009',
                'Account Record Type',
                'Account_Record_Type',
                true
            )
        };

        Map<String, RecordTypeModel> accountRecordTypeModelsByLabel = new Map<String, RecordTypeModel>{
            'Account Record Type' => new RecordTypeModel(
                '000000000000000009',
                'Account Record Type',
                'Account_Record_Type',
                true
            )
        };

        Map<String, LookupFieldModel> accountLookupsOnContactFieldModelsByName = new Map<String, LookupFieldModel>{
            'Account Field Name' => new LookupFieldModel('Account Field Name', 'Account Field Label')
        };

        Map<String, LookupFieldModel> accountLookupsOnContactFieldModelsByLabel = new Map<String, LookupFieldModel>{
            'Account Field Label' => new LookupFieldModel('Account Field Name', 'Account Field Label')
        };

        PrimaryAffiliationsSettingsVMapper primaryAffiliationsSettingsVMapperInstance = PrimaryAffiliationsSettingsVMapper.getInstance();

        Test.startTest();
        PrimaryAffiliationMappingVModel primaryAffiliationMappingVModel = primaryAffiliationsSettingsVMapperInstance.getPrimaryAffiliationsMappingVModel(
            affiliationMappingsModel,
            accountRecordTypeModelsByName,
            accountRecordTypeModelsByLabel,
            accountLookupsOnContactFieldModelsByName,
            accountLookupsOnContactFieldModelsByLabel
        );
        Test.stopTest();

        System.assertEquals(
            'Affliation Name',
            PrimaryAffiliationMappingVModel.mappingName,
            'Mapping name should match name of affiliation mapping.'
        );

        System.assertEquals(
            'Invalid Account Record Type',
            PrimaryAffiliationMappingVModel.accountRecordTypeName,
            'Account Record Type name should match value specified for the affiliation mapping.'
        );

        System.assertEquals(
            'Invalid Account Record Type',
            PrimaryAffiliationMappingVModel.accountRecordTypeLabel,
            'Account Record Type label should match value specified for the affiliation mapping.'
        );

        System.assertEquals(
            'Invalid Primary Affiliation Field',
            PrimaryAffiliationMappingVModel.contactFieldName,
            'Contact field name should match value specified for the affiliation mapping.'
        );

        System.assertEquals(
            'Invalid Primary Affiliation Field',
            PrimaryAffiliationMappingVModel.contactFieldLabel,
            'Contact field label should match value specified for the affiliation mapping.'
        );

        System.assertEquals(
            false,
            PrimaryAffiliationMappingVModel.autoProgramEnrollment,
            'Auto-enrollment enablement should match value specified for the affiliation mapping.'
        );
    }

    /****************************************************************************************
     * @description Test method to verify getPrimaryAffiliationsSettingsVModel()
     * returns a PrimaryAffiliationSettingsVModel with a list of PrimaryAffiliationMappingVModels
     * corresponding to the affiliation mappings with account record type and lookup field names
     * and labels matching the corresponding models when matching models exist.
     ****************************************************************************************/
    @isTest
    private static void getPrimaryAffiliationsSettingsVModelValid() {
        AffiliationMappingsService.instance = new STUB_AffiliationMappingsService();
        RecordTypeService.instance = new STUB_RecordTypeService();
        LookupFieldService.instance = new STUB_LookupFieldService();

        PrimaryAffiliationsSettingsVMapper primaryAffiliationsSettingsVMapperInstance = PrimaryAffiliationsSettingsVMapper.getInstance();

        Test.startTest();
        PrimaryAffiliationSettingsVModel primaryAffiliationSettingsVModel = primaryAffiliationsSettingsVMapperInstance.getPrimaryAffiliationsSettingsVModel();
        Test.stopTest();

        System.assertEquals(
            2,
            PrimaryAffiliationSettingsVModel.primaryAffiliationMappings.size(),
            'Should return 2 PrimaryAffiliationMappingVModels.'
        );

        for (Integer i = 0; i < PrimaryAffiliationSettingsVModel.primaryAffiliationMappings.size(); i++) {
            System.assertEquals(
                'Affiliation Name ' + (i + 1),
                PrimaryAffiliationSettingsVModel.primaryAffiliationMappings[i].mappingName,
                'Mapping name on PrimaryAffiliationMappingVModel should match affiliation.'
            );

            System.assertEquals(
                'Record_Type_' + (i + 1),
                PrimaryAffiliationSettingsVModel.primaryAffiliationMappings[i].accountRecordTypeName,
                'Account record type name on PrimaryAffiliationMappingVModel should match developer name of corresponding record type model.'
            );

            System.assertEquals(
                'Record Type ' + (i + 1),
                PrimaryAffiliationSettingsVModel.primaryAffiliationMappings[i].accountRecordTypeLabel,
                'Account record type label on PrimaryAffiliationMappingVModel should match label of corresponding record type model.'
            );

            System.assertEquals(
                'Contact Account Lookup Name ' + (i + 1),
                PrimaryAffiliationSettingsVModel.primaryAffiliationMappings[i].contactFieldName,
                'Contact field name on PrimaryAffiliationMappingVModel should match name of corresponding lookup field model.'
            );

            System.assertEquals(
                'Contact Account Lookup Label ' + (i + 1),
                PrimaryAffiliationSettingsVModel.primaryAffiliationMappings[i].contactFieldLabel,
                'Contact field label on PrimaryAffiliationMappingVModel should match label of corresponding lookup field model.'
            );

            System.assertEquals(
                true,
                PrimaryAffiliationSettingsVModel.primaryAffiliationMappings[i].autoProgramEnrollment,
                'Auto-Enrollment enablement on PrimaryAffiliationMappingVModel should match affiliation.'
            );
        }
    }

    /****************************************************************************************
     * @description Test method to verify getPrimaryAffiliationsSettingsVModel()
     * returns a PrimaryAffiliationSettingsVModel with a list of PrimaryAffiliationMappingVModels
     * corresponding to the affiliation mappings with account record type and lookup field names
     * and labels matching the affiliation model properties when matching models do not exist.
     ****************************************************************************************/
    @isTest
    private static void getPrimaryAffiliationsSettingsVModelInValid() {
        AffiliationMappingsService.instance = new STUB_AffiliationMappingsService();
        RecordTypeService.instance = new STUB_RecordTypeServiceInvalid();
        LookupFieldService.instance = new STUB_LookupFieldServiceInvalid();

        PrimaryAffiliationsSettingsVMapper primaryAffiliationsSettingsVMapperInstance = PrimaryAffiliationsSettingsVMapper.getInstance();

        Test.startTest();
        PrimaryAffiliationSettingsVModel primaryAffiliationSettingsVModel = primaryAffiliationsSettingsVMapperInstance.getPrimaryAffiliationsSettingsVModel();
        Test.stopTest();

        System.assertEquals(
            2,
            PrimaryAffiliationSettingsVModel.primaryAffiliationMappings.size(),
            'Should return 2 PrimaryAffiliationMappingVModels.'
        );

        for (Integer i = 0; i < PrimaryAffiliationSettingsVModel.primaryAffiliationMappings.size(); i++) {
            System.assertEquals(
                'Affiliation Name ' + (i + 1),
                PrimaryAffiliationSettingsVModel.primaryAffiliationMappings[i].mappingName,
                'Mapping name on PrimaryAffiliationMappingVModel should match affiliation.'
            );

            System.assertEquals(
                'Record Type ' + (i + 1),
                PrimaryAffiliationSettingsVModel.primaryAffiliationMappings[i].accountRecordTypeName,
                'Account record type name on PrimaryAffiliationMappingVModel should match affiliation.'
            );

            System.assertEquals(
                'Record Type ' + (i + 1),
                PrimaryAffiliationSettingsVModel.primaryAffiliationMappings[i].accountRecordTypeLabel,
                'Account record type label on PrimaryAffiliationMappingVModel should match affiliation.'
            );

            System.assertEquals(
                'Contact Account Lookup Label ' + (i + 1),
                PrimaryAffiliationSettingsVModel.primaryAffiliationMappings[i].contactFieldName,
                'Contact field name on PrimaryAffiliationMappingVModel should match affiliation.'
            );

            System.assertEquals(
                'Contact Account Lookup Label ' + (i + 1),
                PrimaryAffiliationSettingsVModel.primaryAffiliationMappings[i].contactFieldLabel,
                'Contact field label on PrimaryAffiliationMappingVModel should match affiliation.'
            );

            System.assertEquals(
                true,
                PrimaryAffiliationSettingsVModel.primaryAffiliationMappings[i].autoProgramEnrollment,
                'Auto-Enrollment enablement on PrimaryAffiliationMappingVModel should match affiliation.'
            );
        }
    }

    /***********************************************************************************************************************************
     ****************************************************** STUBS ***********************************************************************
     ***********************************************************************************************************************************/

    /**************************************************************************************************************************************
     * @description Stub class to simulate valid responses from AffiliationMappingsService
     **************************************************************************************************************************************/
    private class STUB_AffiliationMappingsService extends AffiliationMappingsService {
        public override List<AffiliationMappingsModel> getAffiliationMappingsModels() {
            return new List<AffiliationMappingsModel>{
                new AffiliationMappingsModel(
                    'Affiliation Name 1',
                    'Record Type 1',
                    'Contact Account Lookup Label 1',
                    true,
                    'autoProgramEnrollmentStatus1',
                    'autoProgramEnrollmentRole1'
                ),
                new AffiliationMappingsModel(
                    'Affiliation Name 2',
                    'Record Type 2',
                    'Contact Account Lookup Label 2',
                    true,
                    'autoProgramEnrollmentStatus2',
                    'autoProgramEnrollmentRole2'
                )
            };
        }
    }

    /**************************************************************************************************************************************
     * @description Stub class to simulate valid responses from LookupFieldService
     **************************************************************************************************************************************/
    private class STUB_LookupFieldService extends LookupFieldService {
        public override Map<String, LookupFieldModel> getModelByNameMapForSObjectType(
            SObjectType sObjectType,
            SObjectType lookupToSObjectType
        ) {
            return new Map<String, LookupFieldModel>{
                'Contact Account Lookup Name 1' => new LookupFieldModel(
                    'Contact Account Lookup Name 1',
                    'Contact Account Lookup Label 1'
                ),
                'Contact Account Lookup Name 2' => new LookupFieldModel(
                    'Contact Account Lookup Name 2',
                    'Contact Account Lookup Label 2'
                )
            };
        }
    }

    /**************************************************************************************************************************************
     * @description Stub class to simulate valid responses from LookupFieldService
     **************************************************************************************************************************************/
    private class STUB_LookupFieldServiceValid extends LookupFieldService {
        public override LookupFieldModel getLookupFieldModelFromNameAndLabelMaps(
            String lookupFieldNameOrLabel,
            Map<String, LookupFieldModel> lookupFieldModelByName,
            Map<String, LookupFieldModel> lookupFieldModelByLabel
        ) {
            return new LookupFieldModel('Account Field Name', 'Account Field Label');
        }
    }

    /**************************************************************************************************************************************
     * @description Stub class to simulate valid responses from RecordTypeService
     **************************************************************************************************************************************/
    private class STUB_RecordTypeService extends RecordTypeService {
        public override Map<Id, RecordTypeModel> getModelByIdMapForSObjectType(Schema.SObjectType sObjectType) {
            return new Map<Id, RecordTypeModel>{
                '000000000000000001' => new RecordTypeModel(
                    '000000000000000001',
                    'Record Type 1',
                    'Record_Type_1',
                    true
                ),
                '000000000000000002' => new RecordTypeModel(
                    '000000000000000002',
                    'Record Type 2',
                    'Record_Type_2',
                    true
                ),
                '000000000000000003' => new RecordTypeModel(
                    '000000000000000003',
                    'Record Type 3',
                    'Record_Type_3',
                    false
                )
            };
        }
    }

    /**************************************************************************************************************************************
     * @description Stub class to simulate valid responses from RecordTypeService
     **************************************************************************************************************************************/
    private class STUB_RecordTypeServiceValid extends RecordTypeService {
        public override RecordTypeModel getRecordTypeModelFromNameAndLabelMaps(
            String recordTypeNameOrLabel,
            Map<String, RecordTypeModel> recordTypeModelByName,
            Map<String, RecordTypeModel> recordTypeModelByLabel
        ) {
            return new RecordTypeModel('000000000000000009', 'Account Record Type', 'Account_Record_Type', true);
        }
    }

    /**************************************************************************************************************************************
     * @description Stub class to simulate invalid responses from LookupFieldService
     **************************************************************************************************************************************/
    private class STUB_LookupFieldServiceInvalid extends LookupFieldService {
        public override LookupFieldModel getLookupFieldModelFromNameAndLabelMaps(
            String lookupFieldNameOrLabel,
            Map<String, LookupFieldModel> lookupFieldModelByName,
            Map<String, LookupFieldModel> lookupFieldModelByLabel
        ) {
            return null;
        }
    }

    /**************************************************************************************************************************************
     * @description Stub class to simulate invalid responses from RecordTypeService
     **************************************************************************************************************************************/
    private class STUB_RecordTypeServiceInvalid extends RecordTypeService {
        public override RecordTypeModel getRecordTypeModelFromNameAndLabelMaps(
            String recordTypeNameOrLabel,
            Map<String, RecordTypeModel> recordTypeModelByName,
            Map<String, RecordTypeModel> recordTypeModelByLabel
        ) {
            return null;
        }
    }
}
@isTest
private with sharing class ProgramEnrollDeletionSettingsMapper_TEST {
    /**************************************************************************************************************************
     * @description Test method to verify that the getInstance method returns a new instance of the
     * ProgramEnrollmentDeletionSettingsMapper class when one does not already exist.
     ***************************************************************************************************************************/
    @isTest
    private static void getInstanceNew() {
        Test.startTest();
        ProgramEnrollmentDeletionSettingsMapper programEnrollmentDeletionSettingsMapperInstance = ProgramEnrollmentDeletionSettingsMapper.getInstance();
        Test.stopTest();

        System.assertEquals(
            ProgramEnrollmentDeletionSettingsMapper.instance,
            programEnrollmentDeletionSettingsMapperInstance,
            'Instance of mapper class returned should match static instance variable.'
        );
        System.assertEquals(
            true,
            programEnrollmentDeletionSettingsMapperInstance != null,
            'Instance of mapper class should not be null.'
        );
    }

    /**************************************************************************************************************************
     * @description Test method to verify that the getInstance method returns the existing instance of the
     * ProgramEnrollmentDeletionSettingsMapper class when one already exists.
     ***************************************************************************************************************************/
    @isTest
    private static void getInstanceExisting() {
        Test.startTest();
        ProgramEnrollmentDeletionSettingsMapper programEnrollmentDeletionSettingsMapper1 = ProgramEnrollmentDeletionSettingsMapper.getInstance();
        ProgramEnrollmentDeletionSettingsMapper programEnrollmentDeletionSettingsMapper2 = ProgramEnrollmentDeletionSettingsMapper.getInstance();
        Test.stopTest();

        System.assertEquals(
            ProgramEnrollmentDeletionSettingsMapper.instance,
            programEnrollmentDeletionSettingsMapper1,
            'Instance of mapper class returned should match static instance variable.'
        );
        System.assertEquals(
            programEnrollmentDeletionSettingsMapper1,
            programEnrollmentDeletionSettingsMapper2,
            'Subsequent retrievals of mapper class instance should return existing instance.'
        );
        System.assertEquals(
            true,
            programEnrollmentDeletionSettingsMapper1 != null,
            'Instance of mapper class should not be null.'
        );
    }

    /**************************************************************************************************************************
     * @description Test method to verify that the getProgramEnrollmentDeletionSettingsModel method returns a
     * ProgramEnrollmentDeletionSettingsModel matching the program enrollment deletion settings specified in hierarchy
     * settings.
     ***************************************************************************************************************************/
    @isTest
    private static void getProgramEnrollmentDeletionSettingsModelValid() {
        Hierarchy_Settings__c hierarchySettings = UTIL_CustomSettings_API.getSettingsForTests(
            new Hierarchy_Settings__c(Affl_ProgEnroll_Del__c = false, Affl_ProgEnroll_Del_Status__c = 'Former Status')
        );

        ProgramEnrollmentDeletionSettingsMapper programEnrollmentDeletionSettingsMapperInstance = ProgramEnrollmentDeletionSettingsMapper.getInstance();

        Test.startTest();
        ProgramEnrollmentDeletionSettingsModel programEnrollmentDeletionSettingsModel = programEnrollmentDeletionSettingsMapperInstance.getProgramEnrollmentDeletionSettingsModel();
        Test.stopTest();

        System.assertEquals(
            false,
            programEnrollmentDeletionSettingsModel.programEnrollmentDeletion,
            'Program Enrollment Deletion should not be enabled.'
        );
        System.assertEquals(
            'Former Status',
            programEnrollmentDeletionSettingsModel.programEnrollmentDeletionStatus,
            'Program Enrollment Deletion Status should be \'Former Status\'.'
        );
    }

    /**************************************************************************************************************************
     * @description Test method to verify that the getProgramEnrollmentDeletionSettingsModel method returns a
     * ProgramEnrollmentDeletionSettingsModel matching the program enrollment deletion settings specified in hierarchy
     * settings with a blank string for the deletion status when the corresponding hierarchy setting field is blank.
     ***************************************************************************************************************************/
    @isTest
    private static void getProgramEnrollmentDeletionSettingsModelEmptyValid() {
        Hierarchy_Settings__c hierarchySettings = UTIL_CustomSettings_API.getSettingsForTests(
            new Hierarchy_Settings__c(Affl_ProgEnroll_Del__c = true, Affl_ProgEnroll_Del_Status__c = '')
        );

        ProgramEnrollmentDeletionSettingsMapper programEnrollmentDeletionSettingsMapperInstance = ProgramEnrollmentDeletionSettingsMapper.getInstance();

        Test.startTest();
        ProgramEnrollmentDeletionSettingsModel programEnrollmentDeletionSettingsModel = programEnrollmentDeletionSettingsMapperInstance.getProgramEnrollmentDeletionSettingsModel();
        Test.stopTest();

        System.assertEquals(
            true,
            programEnrollmentDeletionSettingsModel.programEnrollmentDeletion,
            'Program Enrollment Deletion should be enabled.'
        );
        System.assertEquals(
            '""',
            programEnrollmentDeletionSettingsModel.programEnrollmentDeletionStatus,
            'Program Enrollment Deletion Status should be a blank string.'
        );
    }
}
@isTest
private with sharing class ProgramEnrollDeletionSettingsModel_TEST {
    /*******************************************************************************
     * @description Test method to verify 2 argument constructor returns a
     * ProgramEnrollmentDeletionSettingsModel with all properties populated.
     *******************************************************************************/
    @isTest
    private static void twoArgumentConstructorValid() {
        Test.startTest();
        ProgramEnrollmentDeletionSettingsModel programEnrollmentDeletionSettingsModel = new ProgramEnrollmentDeletionSettingsModel(
            true,
            'Test Status'
        );
        Test.stopTest();

        System.assertEquals(
            true,
            programEnrollmentDeletionSettingsModel.programEnrollmentDeletion,
            'Program enrollment deletion enablement should match value specified.'
        );
        System.assertEquals(
            'Test Status',
            programEnrollmentDeletionSettingsModel.programEnrollmentDeletionStatus,
            'Program enrollment deletion status should match value specified.'
        );
    }

    /*******************************************************************************
     * @description Test method to verify 2 argument constructor returns a
     * ProgramEnrollmentDeletionSettingsModel with all properties populated when a blank
     * string is provided as an argument.
     *******************************************************************************/
    @isTest
    private static void twoArgumentConstructorWithBlankValid() {
        Test.startTest();
        ProgramEnrollmentDeletionSettingsModel programEnrollmentDeletionSettingsModel = new ProgramEnrollmentDeletionSettingsModel(
            false,
            ''
        );
        Test.stopTest();

        System.assertEquals(
            false,
            programEnrollmentDeletionSettingsModel.programEnrollmentDeletion,
            'Program enrollment deletion enablement should match value specified.'
        );
        System.assertEquals(
            '""',
            programEnrollmentDeletionSettingsModel.programEnrollmentDeletionStatus,
            'Program enrollment deletion status should be blank.'
        );
    }

    /*******************************************************************************
     * @description Test method to verify 2 argument constructor returns a
     * ProgramEnrollmentDeletionSettingsModel with all properties populated when a null
     * string is provided as an argument.
     *******************************************************************************/
    @isTest
    private static void twoArgumentConstructorWithNullValid() {
        Test.startTest();
        ProgramEnrollmentDeletionSettingsModel programEnrollmentDeletionSettingsModel = new ProgramEnrollmentDeletionSettingsModel(
            false,
            null
        );
        Test.stopTest();

        System.assertEquals(
            false,
            programEnrollmentDeletionSettingsModel.programEnrollmentDeletion,
            'Program enrollment deletion enablement should match value specified.'
        );
        System.assertEquals(
            '""',
            programEnrollmentDeletionSettingsModel.programEnrollmentDeletionStatus,
            'Program enrollment deletion status should be blank.'
        );
    }
}
@isTest
private with sharing class ProgramEnrollDeletionSettingsSrvc_TEST {
    /**************************************************************************************************************************
     * @description Test method to verify that the getInstance method returns a new instance of the
     * ProgramEnrollmentDeletionSettingsService class when one does not already exist.
     ***************************************************************************************************************************/
    @isTest
    private static void getInstanceNew() {
        Test.startTest();
        ProgramEnrollmentDeletionSettingsService programEnrollmentDeletionSettingsServiceInstance = ProgramEnrollmentDeletionSettingsService.getInstance();
        Test.stopTest();

        System.assertEquals(
            ProgramEnrollmentDeletionSettingsService.instance,
            programEnrollmentDeletionSettingsServiceInstance,
            'Instance of service class returned should match static instance variable.'
        );
        System.assertEquals(
            true,
            programEnrollmentDeletionSettingsServiceInstance != null,
            'Instance of service class should not be null.'
        );
    }

    /**************************************************************************************************************************
     * @description Test method to verify that the getInstance method returns the existing instance of the
     * ProgramEnrollmentDeletionSettingsService class when one already exists.
     ***************************************************************************************************************************/
    @isTest
    private static void getInstanceExisting() {
        Test.startTest();
        ProgramEnrollmentDeletionSettingsService programEnrollmentDeletionSettingsMapper1 = ProgramEnrollmentDeletionSettingsService.getInstance();
        ProgramEnrollmentDeletionSettingsService programEnrollmentDeletionSettingsMapper2 = ProgramEnrollmentDeletionSettingsService.getInstance();
        Test.stopTest();

        System.assertEquals(
            ProgramEnrollmentDeletionSettingsService.instance,
            programEnrollmentDeletionSettingsMapper1,
            'Instance of service class returned should match static instance variable.'
        );
        System.assertEquals(
            programEnrollmentDeletionSettingsMapper1,
            programEnrollmentDeletionSettingsMapper2,
            'Subsequent retrievals of service class instance should return existing instance.'
        );
        System.assertEquals(
            true,
            programEnrollmentDeletionSettingsMapper1 != null,
            'Instance of service class should not be null.'
        );
    }

    /**************************************************************************************************************************
     * @description Test method to verify that the locateProgramEnrollmentDeletionSettingsMapper method returns an instance
     * of the ProgramEnrollmentDeletionSettingsMapper class.
     ***************************************************************************************************************************/
    @isTest
    private static void locateProgramEnrollmentDeletionSettingsMapperValid() {
        ProgramEnrollmentDeletionSettingsService programEnrollmentDeletionSettingsServiceInstance = ProgramEnrollmentDeletionSettingsService.getInstance();

        Test.startTest();
        ProgramEnrollmentDeletionSettingsMapper programEnrollmentDeletionSettingsMapperInstance = programEnrollmentDeletionSettingsServiceInstance.locateProgramEnrollmentDeletionSettingsMapper();
        Test.stopTest();

        System.assertEquals(
            ProgramEnrollmentDeletionSettingsMapper.getInstance(),
            programEnrollmentDeletionSettingsMapperInstance,
            'Should return instance of ProgramEnrollmentDeletionSettingsMapper class.'
        );
    }

    /**************************************************************************************************************************
     * @description Test method to verify that the getProgramEnrollmentDeletionSettingsModel method returns a ProgramEnrollmentDeletionSettingsModel
     ***************************************************************************************************************************/
    @isTest
    private static void getProgramEnrollmentDeletionSettingsModelValid() {
        ProgramEnrollmentDeletionSettingsMapper.instance = new STUB_ProgramEnrollmentDeletionSettingsMapper();

        ProgramEnrollmentDeletionSettingsService programEnrollmentDeletionSettingsServiceInstance = ProgramEnrollmentDeletionSettingsService.getInstance();

        Test.startTest();
        ProgramEnrollmentDeletionSettingsModel programEnrollmentDeletionSettingsModel = programEnrollmentDeletionSettingsServiceInstance.getProgramEnrollmentDeletionSettingsModel();
        Test.stopTest();

        System.assertEquals(
            false,
            programEnrollmentDeletionSettingsModel.programEnrollmentDeletion,
            'Program enrollment deletion should not be enabled.'
        );
        System.assertEquals(
            'Left Behind',
            programEnrollmentDeletionSettingsModel.programEnrollmentDeletionStatus,
            'Program enrollment deletion status should be \'Left Behind\'.'
        );
    }

    /***********************************************************************************************************************************
     ****************************************************** STUBS ***********************************************************************
     ***********************************************************************************************************************************/

    /**************************************************************************************************************************************
     * @description Stub class to simulate the response from ProgramEnrollmentDeletionSettingsMapper to return
     * a valid ProgramEnrollmentDeletionSettingsModel
     **************************************************************************************************************************************/
    private class STUB_ProgramEnrollmentDeletionSettingsMapper extends ProgramEnrollmentDeletionSettingsMapper {
        public override ProgramEnrollmentDeletionSettingsModel getProgramEnrollmentDeletionSettingsModel() {
            return new ProgramEnrollmentDeletionSettingsModel(false, 'Left Behind');
        }
    }
}
public virtual with sharing class ProgramEnrollmentDeletionSettingsVMapper {
    /**********************************************************************************
     * @description Instance for Singleton Pattern
     **********************************************************************************/
    @TestVisible
    private static ProgramEnrollmentDeletionSettingsVMapper instance;

    /**********************************************************************************
     * @description Empty constructor is not public for Singleton Pattern
     **********************************************************************************/
    protected ProgramEnrollmentDeletionSettingsVMapper() {
    }

    /**********************************************************************************
     * @description Static method to get the current instance for Singleton pattern
     * @return The instance of AffiliationsSettingsVMapper.
     **********************************************************************************/
    public static ProgramEnrollmentDeletionSettingsVMapper getInstance() {
        if (instance == null) {
            instance = new ProgramEnrollmentDeletionSettingsVMapper();
        }

        return instance;
    }

    /**********************************************************************************************************
     * @description Retrieve an instance of ProgramEnrollmentDeletionSettingsVModel
     * @return An instance of ProgramEnrollmentDeletionSettingsVModel
     *********************************************************************************************************/
    public virtual ProgramEnrollmentDeletionSettingsVModel getProgramEnrollmentDeletionSettingsVModel() {
        ProgramEnrollmentDeletionSettingsModel programSettingsModel = this.locateProgramEnrollmentDeletionSettingsService()
            .getProgramEnrollmentDeletionSettingsModel();

        List<ComboboxValueVModel> programEnrollmentDeletionStatusOptions = new List<ComboboxValueVModel>();

        Map<String, PicklistEntryModel> affiliationStatusPicklistEntryModelsByName = this.locatePicklistEntryService()
            .getModelsByNameForSObjectField(Affiliation__c.SObjectType, Affiliation__c.Status__c);

        Map<String, PicklistEntryModel> activeAffiliationStatusPicklistEntryModelsByName = this.locatePicklistEntryService()
            .getActivePicklistEntryModelsByName(affiliationStatusPicklistEntryModelsByName);

        for (
            PicklistEntryModel activeAffiliationStatusPicklistEntryModel : activeAffiliationStatusPicklistEntryModelsByName.values()
        ) {
            programEnrollmentDeletionStatusOptions.add(
                new ComboboxValueVModel(
                    activeAffiliationStatusPicklistEntryModel.label,
                    activeAffiliationStatusPicklistEntryModel.name
                )
            );
        }

        ComboboxVModel programEnrollmentDeletionStatusComboboxVModel = new ComboboxVModel(
            programSettingsModel.programEnrollmentDeletionStatus,
            programEnrollmentDeletionStatusOptions
        );

        return new ProgramEnrollmentDeletionSettingsVModel(
            programSettingsModel.programEnrollmentDeletion,
            programEnrollmentDeletionStatusComboboxVModel
        );
    }

    /*****************************************************************************
     * @description Retrieve an instance of the ProgramEnrollmentDeletionSettingsService class.
     * @return An instance of ProgramEnrollmentDeletionSettingsService.
     *****************************************************************************/
    @TestVisible
    private ProgramEnrollmentDeletionSettingsService locateProgramEnrollmentDeletionSettingsService() {
        return ProgramEnrollmentDeletionSettingsService.getInstance();
    }

    /*****************************************************************************
     * @description Retrieve an instance of the PicklistEntryService class.
     * @return An instance of PicklistEntryService.
     *****************************************************************************/
    @TestVisible
    private PicklistEntryService locatePicklistEntryService() {
        return PicklistEntryService.getInstance();
    }
}
@isTest
public with sharing class ProgramPlanSettingsController_TEST {
    /****************************************************************************************
     * @description Test method to verify locateProgramPlanSettingsVMapper() returns an instance of
     * the ProgramPlanSettingsVMapper class.
     ****************************************************************************************/
    @isTest
    private static void locateProgramPlanSettingsVMapperValid() {
        Test.startTest();
        ProgramPlanSettingsVMapper programPlanSettingsVMapperInstance = ProgramPlanSettingsController.locateProgramPlanSettingsVMapper();
        Test.stopTest();

        System.assertEquals(
            ProgramPlanSettingsVMapper.getInstance(),
            programPlanSettingsVMapperInstance,
            'Should return instance of ProgramPlanSettingsVMapper class.'
        );
    }

    /****************************************************************************************
     * @description Test method to verify getProgramPlanSettingsVModel()
     * throws an exception when exception occurs.
     ****************************************************************************************/
    @isTest
    private static void getProgramPlanSettingsVModelValid() {
        ProgramPlanSettingsVMapper.instance = new STUB_ProgramPlanSettingsVMapperValid();

        Test.startTest();
        ProgramPlanSettingsVModel programPlanSettingsVModelInstance = ProgramPlanSettingsController.getProgramPlanSettingsVModel();
        Test.stopTest();

        System.assertEquals(
            true,
            programPlanSettingsVModelInstance.validateProgramPlanForNestedPR,
            'validateProgramPlanForNestedPR should return true'
        );
    }

    /****************************************************************************************
     * @description Test method to verify getProgramPlanSettingsVModel()
     * throws an exception when exception occurs.
     ****************************************************************************************/
    @isTest
    private static void getProgramPlanSettingsVModelException() {
        ProgramPlanSettingsVMapper.instance = new STUB_ExceptionProgramPlanSettingsVMapper();

        try {
            Test.startTest();
            ProgramPlanSettingsVModel programPlanSettingsVModelInstance = ProgramPlanSettingsController.getProgramPlanSettingsVModel();
            Test.stopTest();
            System.assert(false, 'should always throw an exception');
        } catch (AuraHandledException e) {
            System.assertEquals('Script-thrown exception', e.getMessage(), 'Should throw exception.');
        }
    }

    /***********************************************************************************************************************************
     ****************************************************** STUBS ***********************************************************************
     ***********************************************************************************************************************************/

    /**************************************************************************************************************************************
     * @description Stub class to simulate valid responses from ProgramPlanSettingsVMapper
     **************************************************************************************************************************************/
    private class STUB_ProgramPlanSettingsVMapperValid extends ProgramPlanSettingsVMapper {
        public override ProgramPlanSettingsVModel getProgramPlanSettingsVModel() {
            return new ProgramPlanSettingsVModel(true);
        }
    }

    /**************************************************************************************************************************************
     * @description Stub class to simulate exception responses from ProgramPlanSettingsVMapper
     **************************************************************************************************************************************/
    private class STUB_ExceptionProgramPlanSettingsVMapper extends ProgramPlanSettingsVMapper {
        public override ProgramPlanSettingsVModel getProgramPlanSettingsVModel() {
            throw new TestException('Exception encountered!');
        }
    }

    private class TestException extends Exception {
    }
}
@isTest
public with sharing class ProgramPlanSettingsMapper_TEST {
    /**************************************************************************************************************************
     * @description Test method to verify that the getInstance method returns a new instance of the
     * programPlanSettingsMapperInstance class when one does not already exist.
     ***************************************************************************************************************************/
    @isTest
    private static void getInstanceNew() {
        Test.startTest();
        ProgramPlanSettingsMapper programPlanSettingsMapperInstance = ProgramPlanSettingsMapper.getInstance();
        Test.stopTest();

        System.assertEquals(
            ProgramPlanSettingsMapper.instance,
            programPlanSettingsMapperInstance,
            'Instance of mapper class returned should match static instance variable.'
        );
        System.assertEquals(
            true,
            programPlanSettingsMapperInstance != null,
            'Instance of mapper class should not be null.'
        );
    }

    /**************************************************************************************************************************
     * @description Test method to verify that the getInstance method returns the existing instance of the
     * programPlanSettingsMapperInstance class when one already exists.
     ***************************************************************************************************************************/
    @isTest
    private static void getInstanceExisting() {
        Test.startTest();
        ProgramPlanSettingsMapper programPlanSettingsMapperInstance1 = ProgramPlanSettingsMapper.getInstance();
        ProgramPlanSettingsMapper programPlanSettingsMapperInstance2 = ProgramPlanSettingsMapper.getInstance();
        Test.stopTest();

        System.assertEquals(
            ProgramPlanSettingsMapper.instance,
            programPlanSettingsMapperInstance1,
            'Instance of mapper class returned should match static instance variable.'
        );
        System.assertEquals(
            programPlanSettingsMapperInstance1,
            programPlanSettingsMapperInstance1,
            'Subsequent retrievals of mapper class instance should return existing instance.'
        );
        System.assertEquals(
            true,
            programPlanSettingsMapperInstance1 != null,
            'Instance of mapper class should not be null.'
        );
    }

    /**************************************************************************************************************************
     * @description Test method to verify that the getProgramPlanSettingsModel method returns a
     * ProgramPlanSettingsModel matching the program plan settings specified in hierarchy
     * settings.
     ***************************************************************************************************************************/
    @isTest
    private static void getProgramPlanSettingsModelValid() {
        Hierarchy_Settings__c hierarchySettings = UTIL_CustomSettings_API.getSettingsForTests(
            new Hierarchy_Settings__c(Validate_Program_Plan_for_Nested_PR__c = true)
        );

        ProgramPlanSettingsMapper programPlanSettingsMapperInstance = ProgramPlanSettingsMapper.getInstance();

        Test.startTest();
        ProgramPlanSettingsModel programPlanSettingsModelInstance = programPlanSettingsMapperInstance.getProgramPlanSettingsModel();
        Test.stopTest();

        System.assertEquals(
            true,
            programPlanSettingsModelInstance.validateProgramPlanForNestedPR,
            'validateProgramPlanForNestedPR should be enabled.'
        );
    }
}
@isTest
public with sharing class ProgramPlanSettingsService_TEST {
    /**************************************************************************************************************************
     * @description Test method to verify that the getInstance method returns a new instance of the
     * ProgramPlanSettingsService class when one does not already exist.
     ***************************************************************************************************************************/
    @isTest
    private static void getInstanceNew() {
        Test.startTest();
        ProgramPlanSettingsService programPlanSettingsServiceInstance = ProgramPlanSettingsService.getInstance();
        Test.stopTest();

        System.assertEquals(
            ProgramPlanSettingsService.instance,
            programPlanSettingsServiceInstance,
            'Instance of service class returned should match static instance variable.'
        );
        System.assertEquals(
            true,
            programPlanSettingsServiceInstance != null,
            'Instance of service class should not be null.'
        );
    }

    /**************************************************************************************************************************
     * @description Test method to verify that the getInstance method returns the existing instance of the
     * ProgramPlanSettingsService class when one already exists.
     ***************************************************************************************************************************/
    @isTest
    private static void getInstanceExisting() {
        Test.startTest();
        ProgramPlanSettingsService ppSettingsMapper1 = ProgramPlanSettingsService.getInstance();
        ProgramPlanSettingsService ppSettingsMapper2 = ProgramPlanSettingsService.getInstance();
        Test.stopTest();

        System.assertEquals(
            ProgramPlanSettingsService.instance,
            ppSettingsMapper1,
            'Instance of service class returned should match static instance variable.'
        );
        System.assertEquals(
            ppSettingsMapper1,
            ppSettingsMapper2,
            'Subsequent retrievals of service class instance should return existing instance.'
        );
        System.assertEquals(true, ppSettingsMapper1 != null, 'Instance of service class should not be null.');
    }

    /**************************************************************************************************************************
     * @description Test method to verify that the locateProgramPlanSettingsMapper method returns an instance
     * of the ProgramPlanSettingsMapper class.
     ***************************************************************************************************************************/
    @isTest
    private static void locateProgramPlanSettingsMapperValid() {
        ProgramPlanSettingsService programPlanSettingsServiceInstance = ProgramPlanSettingsService.getInstance();

        Test.startTest();
        ProgramPlanSettingsMapper programPlanSettingsMapperInstance = programPlanSettingsServiceInstance.locateProgramPlanSettingsMapper();
        Test.stopTest();

        System.assertEquals(
            ProgramPlanSettingsMapper.getInstance(),
            programPlanSettingsMapperInstance,
            'Should return instance of ProgramPlanSettingsMapper class.'
        );
    }

    /**************************************************************************************************************************
     * @description Test method to verify that the getProgramPlanSettingsModel method returns a ProgramPlanSettingsModel
     ***************************************************************************************************************************/
    @isTest
    private static void getProgramEnrollmentDeletionSettingsModelValid() {
        ProgramPlanSettingsMapper.instance = new STUB_ProgramPlanSettingsMapper();

        ProgramPlanSettingsService programPlanSettingsServiceInstance = ProgramPlanSettingsService.getInstance();

        Test.startTest();
        ProgramPlanSettingsModel ppSettingsModel = programPlanSettingsServiceInstance.getProgramPlanSettingsModel();
        Test.stopTest();

        System.assertEquals(
            false,
            ppSettingsModel.validateProgramPlanForNestedPR,
            'validateProgramPlanForNestedPR should not be enabled.'
        );
    }

    /***********************************************************************************************************************************
     ****************************************************** STUBS ***********************************************************************
     ***********************************************************************************************************************************/

    /**************************************************************************************************************************************
     * @description Stub class to simulate the response from ProgramPlanSettingsMapper to return
     * a valid ProgramPlanSettingsModel
     **************************************************************************************************************************************/
    private class STUB_ProgramPlanSettingsMapper extends ProgramPlanSettingsMapper {
        public override ProgramPlanSettingsModel getProgramPlanSettingsModel() {
            return new ProgramPlanSettingsModel(false);
        }
    }
}
@isTest
public with sharing class ProgramPlanSettingsVMapper_TEST {
    /**************************************************************************************************
     * @description Test method to verify that the getInstance method returns a new instance of the
     * ProgramPlanSettingsVMapper class when one does not already exist.
     **************************************************************************************************/
    @isTest
    private static void getInstanceNew() {
        Test.startTest();
        ProgramPlanSettingsVMapper programPlanSettingsVMapperInstance = ProgramPlanSettingsVMapper.getInstance();
        Test.stopTest();

        System.assertEquals(
            ProgramPlanSettingsVMapper.instance,
            programPlanSettingsVMapperInstance,
            'Instance of mapper class returned should match static instance variable.'
        );
        System.assertEquals(
            true,
            ProgramPlanSettingsVMapperInstance != null,
            'Instance of mapper class should not be null.'
        );
    }

    /**************************************************************************************************
     * @description Test method to verify that the getInstance method returns the existing instance of the
     * ProgramPlanSettingsVMapper class when one already exists.
     **************************************************************************************************/
    @isTest
    private static void getInstanceExisting() {
        Test.startTest();
        ProgramPlanSettingsVMapper programPlanSettingsVMapperInstance1 = ProgramPlanSettingsVMapper.getInstance();
        ProgramPlanSettingsVMapper programPlanSettingsVMapperInstance2 = ProgramPlanSettingsVMapper.getInstance();
        Test.stopTest();

        System.assertEquals(
            ProgramPlanSettingsVMapper.instance,
            programPlanSettingsVMapperInstance1,
            'Instance of mapper class returned should match static instance variable.'
        );
        System.assertEquals(
            programPlanSettingsVMapperInstance1,
            programPlanSettingsVMapperInstance2,
            'Subsequent retrievals of mapper class instance should return existing instance.'
        );
        System.assertEquals(
            true,
            ProgramPlanSettingsVMapperInstance1 != null,
            'Instance of mapper class should not be null.'
        );
    }

    /****************************************************************************************
     * @description Test method to verify locateProgramPlanSettingsService() returns an instance of
     * the ProgramPlanSettingsService class.
     ****************************************************************************************/
    @isTest
    private static void locateProgramPlanSettingsServiceValid() {
        ProgramPlanSettingsVMapper ProgramPlanSettingsVMapperInstance = ProgramPlanSettingsVMapper.getInstance();

        Test.startTest();
        ProgramPlanSettingsService programSettingsSettingsServiceInstance = ProgramPlanSettingsVMapperInstance.locateProgramPlanSettingsService();
        Test.stopTest();

        System.assertEquals(
            ProgramPlanSettingsService.getInstance(),
            programSettingsSettingsServiceInstance,
            'Should return instance of ProgramPlanSettingsService class.'
        );
    }

    /************************************************************************************************************************************
     * @description Test method to verify getProgramPlanSettingsVModel returns a ProgramPlanSettingsVModel
     * corresponding to the Program Plan settings specified in Hierarchy Settings
     ************************************************************************************************************************************/
    @isTest
    private static void getProgramPlanSettingsVModelValid() {
        ProgramPlanSettingsService.instance = new STUB_ProgramPlanSettingsService();

        ProgramPlanSettingsVMapper programPlanSettingsVMapperInstance = ProgramPlanSettingsVMapper.getInstance();

        Test.startTest();
        ProgramPlanSettingsVModel programPlanSettingsVModelInstance = programPlanSettingsVMapperInstance.getProgramPlanSettingsVModel();
        Test.stopTest();

        System.assertEquals(
            false,
            programPlanSettingsVModelInstance.validateProgramPlanForNestedPR,
            'validateProgramPlanForNestedPR should not be enabled.'
        );
    }

    /***********************************************************************************************************************************
     ****************************************************** STUBS ***********************************************************************
     ***********************************************************************************************************************************/

    /**************************************************************************************************************************************
     * @description Stub class to simulate the response from ProgramPlanSettingsService to return a valid respose
     **************************************************************************************************************************************/
    private class STUB_ProgramPlanSettingsService extends ProgramPlanSettingsService {
        public override ProgramPlanSettingsModel getProgramPlanSettingsModel() {
            return new ProgramPlanSettingsModel(false);
        }
    }
}
public with sharing class ProgramSettingsController {
    /************************************************************************************
     * @description Retrieve an instance of AutoEnrollmentMappingsVModel representing the current values
     * specified for Settings fields in Hierarchy Settings.
     * @return An instance of AutoEnrollmentMappingsVModel
     ************************************************************************************/
    @AuraEnabled(cacheable=true)
    public static AutoEnrollmentMappingsVModel getAutoEnrollmentMappingsVModel() {
        try {
            return ProgramSettingsController.locateAutoEnrollmentMappingsVMapper().getAutoEnrollmentMappingsVModel();
        } catch (Exception e) {
            throw new AuraHandledException(e.getMessage());
        }
    }

    /**********************************************************************************************************
     * @description Retrieve an integer representing the number of unmapped record types
     * @return The number of unmapped record types.
     *********************************************************************************************************/
    @AuraEnabled
    public static Boolean unmappedRecordTypesExist() {
        try {
            return ProgramSettingsController.locateAutoEnrollmentMappingsVMapper().unmappedRecordTypesExist();
        } catch (Exception e) {
            throw new AuraHandledException(e.getMessage());
        }
    }

    /************************************************************************************
     * @description Retrieve a ComoboxVModel representing the list of active Account
     * Record Types
     * @return A ComboboxVModel
     ************************************************************************************/
    @AuraEnabled
    public static ComboBoxVModel getAccountRecordTypeComboboxVModel(String accountRecordType) {
        try {
            return ProgramSettingsController.locateAutoEnrollmentMappingsVMapper()
                .getAccountRecordTypeComboboxVModel(accountRecordType);
        } catch (Exception e) {
            throw new AuraHandledException(e.getMessage());
        }
    }

    /************************************************************************************
     * @description Retrieve a ComoboxVModel for auto enrollment status.
     * @return A ComboboxVModel
     ************************************************************************************/
    @AuraEnabled(cacheable=true)
    public static ComboBoxVModel getAutoEnrollmentMappingStatusComboboxVModel(String autoProgramEnrollmentStatus) {
        try {
            return ProgramSettingsController.locateAutoEnrollmentMappingsVMapper()
                .getAutoEnrollmentMappingStatusComboboxVModel(autoProgramEnrollmentStatus);
        } catch (Exception e) {
            throw new AuraHandledException(e.getMessage());
        }
    }

    /************************************************************************************
     * @description Retrieve a ComoboxVModel for auto enrollment role.
     * @return A ComboboxVModel
     ************************************************************************************/
    @AuraEnabled(cacheable=true)
    public static ComboBoxVModel getAutoEnrollmentMappingRoleComboboxVModel(String autoProgramEnrollmentRole) {
        try {
            return ProgramSettingsController.locateAutoEnrollmentMappingsVMapper()
                .getAutoEnrollmentMappingRoleComboboxVModel(autoProgramEnrollmentRole);
        } catch (Exception e) {
            throw new AuraHandledException(e.getMessage());
        }
    }

    /***
     * @description Update the affiliation mappping with new auto enrollment mapping.
     * @param accountRecordType The account record type for the auto enrollment mapping
     * @param status The status for the auto enrollment mapping
     * @param role The role for the auto enrollment mapping
     * @return The account record type of the mapping updated.
     */
    @AuraEnabled
    public static String createAutoEnrollmentMapping(String accountRecordType, String status, String role) {
        try {
            return ProgramSettingsController.locateAutoEnrollmentMappingService()
                .createAutoEnrollmentMapping(accountRecordType, status, role)
                .accountRecordTypeFieldValue;
        } catch (Exception e) {
            throw new AuraHandledException(e.getMessage());
        }
    }

    /**
     * @description Updates auto enrollment mappings
     * @param mappingName The name of the original auto enrollment mapping
     * @param accountRecordType The account record type for the original auto enrollment mapping
     * @param newAccountRecordType The account record type for the updated auto enrollment mapping
     * @param status The status for the auto enrollment mapping
     * @param role The role for the auto enrollment mapping
     * @return The account record type of the mapping updated.
     */
    @AuraEnabled
    public static String updateAutoEnrollmentMappings(
        String mappingName,
        String accountRecordType,
        String newAccountRecordType,
        String status,
        String role
    ) {
        try {
            return ProgramSettingsController.locateAutoEnrollmentMappingService()
                .updateAutoEnrollmentMappings(mappingName, accountRecordType, newAccountRecordType, status, role)
                .accountRecordTypeFieldValue;
        } catch (Exception e) {
            throw new AuraHandledException(e.getMessage());
        }
    }

    /**
     * @description Deletes auto enrollment mapping
     * @param mappingName The name of the original auto enrollment mapping
     * @return The account record type of the mapping deleted or null if no mapping found.
     */
    @AuraEnabled
    public static String deleteAutoEnrollmentMappings(String mappingName) {
        try {
            AutoEnrollmentMappingModel deletedMappingModel = ProgramSettingsController.locateAutoEnrollmentMappingService()
                .deleteAutoEnrollmentMappings(mappingName);
            return deletedMappingModel == null ? null : deletedMappingModel.accountRecordTypeFieldValue;
        } catch (Exception e) {
            throw new AuraHandledException(e.getMessage());
        }
    }

    /********************************************************************************
     * @description Retrieve a view model representing the Program Enrollment Deletion
     * settings specified in Hierarchy Settings.
     * @return A ProgramEnrollmentDeletionSettingsVModel.
     ********************************************************************************/
    @AuraEnabled(cacheable=true)
    public static ProgramEnrollmentDeletionSettingsVModel getProgramEnrollmentDeletionSettingsVModel() {
        try {
            return ProgramSettingsController.locateProgramEnrollmentDeletionSettingsVMapper()
                .getProgramEnrollmentDeletionSettingsVModel();
        } catch (Exception e) {
            throw new AuraHandledException(e.getMessage());
        }
    }

    /**********************************************************************************
     * @description Locates and returns an instance of ProgramSettingsVMapper.
     * @return An instance of ProgramSettingsVMapper
     **********************************************************************************/
    @TestVisible
    private static AutoEnrollmentMappingsVMapper locateAutoEnrollmentMappingsVMapper() {
        return AutoEnrollmentMappingsVMapper.getInstance();
    }

    /*****************************************************************************
     * @description Retrieve an instance of the AutoEnrollmentMappingService class.
     * @return An instance of AutoEnrollmentMappingService.
     *****************************************************************************/
    @TestVisible
    private static AutoEnrollmentMappingService locateAutoEnrollmentMappingService() {
        return AutoEnrollmentMappingService.getInstance();
    }

    /**********************************************************************************
     * @description Locates and returns an instance of ProgramEnrollmentDeletionSettingsVMapper.
     * @return An instance of ProgramEnrollmentDeletionSettingsVMapper
     **********************************************************************************/
    @TestVisible
    private static ProgramEnrollmentDeletionSettingsVMapper locateProgramEnrollmentDeletionSettingsVMapper() {
        return ProgramEnrollmentDeletionSettingsVMapper.getInstance();
    }
}
@isTest
private with sharing class ProgramSettingsController_TEST {
    private static Integer loopCounter = 5;

    /****************************************************************************************
     * @description Test method to verify locateAutoEnrollmentMappingsVMapper() returns an instance of
     * the AutoEnrollmentMappingsVMapper class.
     ****************************************************************************************/
    @isTest
    private static void locateAutoEnrollmentMappingsVMapperValid() {
        Test.startTest();
        AutoEnrollmentMappingsVMapper autoEnrollmentMappingsVMapperInstance = ProgramSettingsController.locateAutoEnrollmentMappingsVMapper();
        Test.stopTest();

        System.assertEquals(
            AutoEnrollmentMappingsVMapper.getInstance(),
            autoEnrollmentMappingsVMapperInstance,
            'Should return instance of AutoEnrollmentMappingsVMapper class.'
        );
    }

    /****************************************************************************************
     * @description Test method to verify AutoEnrollmentMappingService() returns an instance of
     * the AutoEnrollmentMappingService class.
     ****************************************************************************************/
    @isTest
    private static void locateAutoEnrollmentMappingService() {
        Test.startTest();
        AutoEnrollmentMappingService autoEnrollmentMappingServiceInstance = ProgramSettingsController.locateAutoEnrollmentMappingService();
        Test.stopTest();

        System.assertEquals(
            AutoEnrollmentMappingService.getInstance(),
            autoEnrollmentMappingServiceInstance,
            'Should return instance of AutoEnrollmentMappingService class.'
        );
    }

    /****************************************************************************************
     * @description Test method to verify getAutoEnrollmentMappingsVModel()
     * returns an instance of AutoEnrollmentMappingsVModel with valid values from valid stub.
     ****************************************************************************************/
    @isTest
    private static void getAutoEnrollmentMappingsVModelValid() {
        AutoEnrollmentMappingsVMapper.instance = new STUB_AutoEnrollmentMappingsVMapperValid();

        Test.startTest();
        AutoEnrollmentMappingsVModel autoEnrollmentMappingsVModel = ProgramSettingsController.getAutoEnrollmentMappingsVModel();
        Test.stopTest();

        System.assertEquals(
            2,
            autoEnrollmentMappingsVModel.autoEnrollmentMappingVModels.size(),
            'Should return 2 autoEnrollmentMappingVModels.'
        );

        for (Integer i = 0; i < autoEnrollmentMappingsVModel.autoEnrollmentMappingVModels.size(); i++) {
            System.assertEquals(
                'Record_Type_' + (i + 1),
                autoEnrollmentMappingsVModel.autoEnrollmentMappingVModels[i].accountRecordTypeName,
                'Account record type name should match developer name of corresponding record type model.'
            );

            System.assertEquals(
                'Record Type ' + (i + 1),
                autoEnrollmentMappingsVModel.autoEnrollmentMappingVModels[i].accountRecordTypeLabel,
                'Account record type label should match label of corresponding record type model.'
            );

            System.assertEquals(
                'autoProgramEnrollmentStatus' + (i + 1),
                autoEnrollmentMappingsVModel.autoEnrollmentMappingVModels[i].autoProgramEnrollmentStatus,
                'Auto-Enrollment status should match.'
            );

            System.assertEquals(
                'autoProgramEnrollmentRole' + (i + 1),
                autoEnrollmentMappingsVModel.autoEnrollmentMappingVModels[i].autoProgramEnrollmentRole,
                'Auto-Enrollment role should match.'
            );
        }
    }

    /****************************************************************************************
     * @description Test method to verify getAutoEnrollmentMappingsVModel()
     * throws an exception when exception occurs.
     ****************************************************************************************/
    @isTest
    private static void getAutoEnrollmentMappingsVModelException() {
        AutoEnrollmentMappingsVMapper.instance = new STUB_ExceptionAutoEnrollmentMappingsVMapper();

        try {
            Test.startTest();
            AutoEnrollmentMappingsVModel autoEnrollmentMappingsVModel = ProgramSettingsController.getAutoEnrollmentMappingsVModel();
            Test.stopTest();
            System.assert(false, 'should always throw an exception');
        } catch (AuraHandledException e) {
            System.assertEquals('Script-thrown exception', e.getMessage(), 'Should throw exception.');
        }
    }

    /****************************************************************************************
     * @description Test method to verify getAccountRecordTypeComboboxVModelValid()
     * returns an instance of ComboBoxVModel with valid values from valid stub.
     ****************************************************************************************/
    @isTest
    private static void getAccountRecordTypeComboboxVModelValid() {
        AutoEnrollmentMappingsVMapper.instance = new STUB_AutoEnrollmentMappingsVMapperValid();

        Test.startTest();
        ComboBoxVModel accountRecordTypeComboboxVModel = ProgramSettingsController.getAccountRecordTypeComboboxVModel(
            'Record_Type_1'
        );
        Test.stopTest();

        System.assertEquals(
            'Record_Type_1',
            accountRecordTypeComboboxVModel.value,
            'The value of accountRecordTypeComboboxVModel should be Record_Type_1'
        );

        System.assertEquals(
            1,
            accountRecordTypeComboboxVModel.options.size(),
            'The size of accountRecordTypeComboboxVModel options should be 1'
        );

        System.assertEquals(
            'Record_Type_1',
            accountRecordTypeComboboxVModel.options[0].value,
            'The value of accountRecordTypeComboboxVModel option 1 should be Record_Type_1'
        );

        System.assertEquals(
            'Record Type 1',
            accountRecordTypeComboboxVModel.options[0].label,
            'The label of accountRecordTypeComboboxVModel option 1 should be Record Type 1'
        );
    }

    /****************************************************************************************
     * @description Test method to verify getAccountRecordTypeComboboxVModel()
     * throws an exception when exception occurs.
     ****************************************************************************************/
    @isTest
    private static void getAccountRecordTypeComboboxVModelException() {
        AutoEnrollmentMappingsVMapper.instance = new STUB_ExceptionAutoEnrollmentMappingsVMapper();
        try {
            Test.startTest();
            ComboBoxVModel accountRecordTypeComboboxVModel = ProgramSettingsController.getAccountRecordTypeComboboxVModel(
                'Record_Type_1'
            );
            Test.stopTest();
            System.assert(false, 'should always throw an exception');
        } catch (AuraHandledException e) {
            System.assertEquals('Script-thrown exception', e.getMessage(), 'Should throw exception.');
        }
    }

    /****************************************************************************************
     * @description Test method to verify getAutoEnrollmentMappingStatusComboboxVModel()
     * returns an instance of ComboBoxVModel with valid values from valid stub.
     ****************************************************************************************/
    @isTest
    private static void getAutoEnrollmentMappingStatusComboboxVModelValid() {
        AutoEnrollmentMappingsVMapper.instance = new STUB_AutoEnrollmentMappingsVMapperValid();

        Test.startTest();
        ComboBoxVModel autoEnrollmentMappingStatusComboboxVModel = ProgramSettingsController.getAutoEnrollmentMappingStatusComboboxVModel(
            'Test_Status'
        );
        Test.stopTest();

        System.assertEquals(
            'Test_Status',
            autoEnrollmentMappingStatusComboboxVModel.value,
            'The value of autoEnrollmentMappingStatusComboboxVModel should be Test_Status'
        );

        System.assertEquals(
            1,
            autoEnrollmentMappingStatusComboboxVModel.options.size(),
            'The size of autoEnrollmentMappingStatusComboboxVModel options should be 1'
        );

        System.assertEquals(
            'Test_Status',
            autoEnrollmentMappingStatusComboboxVModel.options[0].value,
            'The value of autoEnrollmentMappingStatusComboboxVModel option 1 should be Test_Status'
        );

        System.assertEquals(
            'Test Status',
            autoEnrollmentMappingStatusComboboxVModel.options[0].label,
            'The label of autoEnrollmentMappingStatusComboboxVModel option 1 should be Test Status'
        );
    }

    /****************************************************************************************
     * @description Test method to verify getAutoEnrollmentMappingStatusComboboxVModel()
     * throws an exception when exception occurs.
     ****************************************************************************************/
    @isTest
    private static void getAutoEnrollmentMappingStatusComboboxVModelException() {
        AutoEnrollmentMappingsVMapper.instance = new STUB_ExceptionAutoEnrollmentMappingsVMapper();
        try {
            Test.startTest();
            ComboBoxVModel autoEnrollmentMappingStatusComboboxVModel = ProgramSettingsController.getAutoEnrollmentMappingStatusComboboxVModel(
                'Test_Status'
            );
            Test.stopTest();
            System.assert(false, 'should always throw an exception');
        } catch (AuraHandledException e) {
            System.assertEquals('Script-thrown exception', e.getMessage(), 'Should throw exception.');
        }
    }

    /****************************************************************************************
     * @description Test method to verify getAutoEnrollmentMappingRoleComboboxVModel()
     * returns an instance of ComboBoxVModel with valid values from valid stub.
     ****************************************************************************************/
    @isTest
    private static void getAutoEnrollmentMappingRoleComboboxVModelValid() {
        AutoEnrollmentMappingsVMapper.instance = new STUB_AutoEnrollmentMappingsVMapperValid();

        Test.startTest();
        ComboBoxVModel autoEnrollmentMappingRoleComboboxVModel = ProgramSettingsController.getAutoEnrollmentMappingRoleComboboxVModel(
            'Test_Role'
        );
        Test.stopTest();

        System.assertEquals(
            'Test_Role',
            autoEnrollmentMappingRoleComboboxVModel.value,
            'The value of autoEnrollmentMappingRoleComboboxVModel should be Test_Role'
        );

        System.assertEquals(
            1,
            autoEnrollmentMappingRoleComboboxVModel.options.size(),
            'The size of autoEnrollmentMappingRoleComboboxVModel options should be 1'
        );

        System.assertEquals(
            'Test_Role',
            autoEnrollmentMappingRoleComboboxVModel.options[0].value,
            'The value of autoEnrollmentMappingRoleComboboxVModel option 1 should be Test_Role'
        );

        System.assertEquals(
            'Test Role',
            autoEnrollmentMappingRoleComboboxVModel.options[0].label,
            'The label of autoEnrollmentMappingRoleComboboxVModel option 1 should be Test Role'
        );
    }

    /****************************************************************************************
     * @description Test method to verify getAutoEnrollmentMappingRoleComboboxVModel()
     * throws an exception when exception occurs.
     ****************************************************************************************/
    @isTest
    private static void getAutoEnrollmentMappingRoleComboboxVModelException() {
        AutoEnrollmentMappingsVMapper.instance = new STUB_ExceptionAutoEnrollmentMappingsVMapper();
        try {
            Test.startTest();
            ComboBoxVModel autoEnrollmentMappingRoleComboboxVModel = ProgramSettingsController.getAutoEnrollmentMappingRoleComboboxVModel(
                'Test_Role'
            );
            Test.stopTest();
            System.assert(false, 'should always throw an exception');
        } catch (AuraHandledException e) {
            System.assertEquals('Script-thrown exception', e.getMessage(), 'Should throw exception.');
        }
    }

    /****************************************************************************************
     * @description Test method to verify getProgramEnrollmentDeletionSettingsVModel()
     * returns an instance of ProgramEnrollmentDeletionSettingsVModel with valid values from valid stub.
     ****************************************************************************************/
    @isTest
    private static void getProgramEnrollmentDeletionSettingsVModelValid() {
        ProgramEnrollmentDeletionSettingsVMapper.instance = new STUB_ProgramEnrollmentDeletionSettingsVMapperValid();

        Test.startTest();
        ProgramEnrollmentDeletionSettingsVModel programEnrollmentDeletionSettingsVModel = ProgramSettingsController.getProgramEnrollmentDeletionSettingsVModel();
        Test.stopTest();

        System.assertEquals(
            false,
            programEnrollmentDeletionSettingsVModel.programEnrollmentDeletion,
            'Program Enrollment Deletion should not be enabled.'
        );
        System.assertEquals(
            'Selected Status',
            programEnrollmentDeletionSettingsVModel.programEnrollmentDeletionStatus.value,
            'Selected Program Enrollment Deletion status should be \'Selected Status\'.'
        );
        System.assertEquals(
            loopCounter + 1,
            programEnrollmentDeletionSettingsVModel.programEnrollmentDeletionStatus.options.size(),
            'Should have ' +
            (loopCounter + 1) +
            ' status options.'
        );
    }

    /****************************************************************************************
     * @description Test method to verify getProgramEnrollmentDeletionSettingsVModel()
     * throws an exception when exception occurs.
     ****************************************************************************************/
    @isTest
    private static void getProgramEnrollmentDeletionSettingsVModelException() {
        ProgramEnrollmentDeletionSettingsVMapper.instance = new STUB_ExceptionProgramEnrollmentDeletionSettingsVMapper();

        try {
            Test.startTest();
            ProgramEnrollmentDeletionSettingsVModel programEnrollmentDeletionSettingsVModel = ProgramSettingsController.getProgramEnrollmentDeletionSettingsVModel();
            Test.stopTest();
            System.assert(false, 'should always throw an exception');
        } catch (AuraHandledException e) {
            System.assertEquals('Script-thrown exception', e.getMessage(), 'Should throw exception.');
        }
    }

    /****************************************************************************************
     * @description Test method to verify createAutoEnrollmentMapping() updates auto
     * enrollment on affiliation mappings
     ****************************************************************************************/
    @isTest
    private static void createAutoEnrollmentMapping() {
        AutoEnrollmentMappingService.instance = new STUB_AutoEnrollmentMappingService();
        Test.startTest();
        String accountRecordTypeDeveloperName = ProgramSettingsController.createAutoEnrollmentMapping(
            'Record_Type_1',
            'Test_Status_1',
            'Test_Role_1'
        );
        Test.stopTest();

        System.assertEquals(
            accountRecordTypeDeveloperName,
            'Record_Type_1',
            'The affected mapping should be that of the same account record type'
        );
    }

    /****************************************************************************************
     * @description Test method to verify createAutoEnrollmentMapping()
     * when exception occurs
     ****************************************************************************************/
    @isTest
    private static void createAutoEnrollmentMappingException() {
        AutoEnrollmentMappingService.instance = new STUB_ExceptionAutoEnrollmentMappingService();

        try {
            Test.startTest();
            String accountRecordTypeDeveloperName = ProgramSettingsController.createAutoEnrollmentMapping(
                'Record_Type_1',
                'Test_Status_1',
                'Test_Role_1'
            );
            Test.stopTest();
            System.assert(false, 'should always throw an exception');
        } catch (AuraHandledException e) {
            System.assertEquals('Script-thrown exception', e.getMessage(), 'Should throw exception.');
        }
    }

    /****************************************************************************************
     * @description Test method to verify deleteAutoEnrollmentMapping() deletes auto
     * enrollment on affiliation mappings
     ****************************************************************************************/
    @isTest
    private static void deleteAutoEnrollmentMapping() {
        AutoEnrollmentMappingService.instance = new STUB_AutoEnrollmentMappingService();
        Test.startTest();
        String accountRecordTypeDeveloperName = ProgramSettingsController.deleteAutoEnrollmentMappings(
            'Mapping_Name_1'
        );
        Test.stopTest();

        System.assertEquals(
            accountRecordTypeDeveloperName,
            'Record_Type_1',
            'The affected mapping should be that of the same account record type'
        );
    }

    /****************************************************************************************
     * @description Test method to verify deleteAutoEnrollmentMapping()
     * when exception occurs
     ****************************************************************************************/
    @isTest
    private static void deleteAutoEnrollmentMappingException() {
        AutoEnrollmentMappingService.instance = new STUB_ExceptionAutoEnrollmentMappingService();

        try {
            Test.startTest();
            String accountRecordTypeDeveloperName = ProgramSettingsController.deleteAutoEnrollmentMappings(
                'Mapping_Name_1'
            );
            Test.stopTest();
            System.assert(false, 'should always throw an exception');
        } catch (AuraHandledException e) {
            System.assertEquals('Script-thrown exception', e.getMessage(), 'Should throw exception.');
        }
    }

    /****************************************************************************************
     * @description Test method to verify unmappedRecordTypesExist()
     ****************************************************************************************/
    @isTest
    private static void unmappedRecordTypesExist() {
        AutoEnrollmentMappingsVMapper.instance = new STUB_AutoEnrollmentMappingsVMapperValid();

        Test.startTest();
        Boolean unmappedRecordTypesExistValue = ProgramSettingsController.unmappedRecordTypesExist();
        Test.stopTest();

        System.assertEquals(true, unmappedRecordTypesExistValue, 'Unmapped Record Types');
    }

    /****************************************************************************************
     * @description Test method to verify updateAutoEnrollmentMappings() updates auto
     * enrollment on affiliation mappings when account record type passed are the same
     ****************************************************************************************/
    @isTest
    private static void updateAutoEnrollmentMappingsSameAccountRecordType() {
        AutoEnrollmentMappingService.instance = new STUB_AutoEnrollmentMappingService();
        Test.startTest();
        String accountRecordTypeDeveloperName = ProgramSettingsController.updateAutoEnrollmentMappings(
            'Test Affl Mapping 1',
            'Record_Type_1',
            'Record_Type_1',
            'Test_Status_3',
            'Test_Role_3'
        );
        Test.stopTest();

        System.assertEquals(
            accountRecordTypeDeveloperName,
            'Record_Type_1',
            'The affected mapping should be that of the same account record type'
        );
    }

    /****************************************************************************************
     * @description Test method to verify updateAutoEnrollmentMappings() updates
     * auto enrollment on affiliation mappings when account record type passed are different
     ****************************************************************************************/
    @isTest
    private static void updateAutoEnrollmentMappingsDifferentAccountRecordType() {
        AutoEnrollmentMappingService.instance = new STUB_AutoEnrollmentMappingService();
        Test.startTest();
        String accountRecordTypeDeveloperName = ProgramSettingsController.updateAutoEnrollmentMappings(
            'Test Affl Mapping 1',
            'Record_Type_1',
            'Record_Type_2',
            'Test_Status_3',
            'Test_Role_3'
        );
        Test.stopTest();

        System.assertEquals(
            accountRecordTypeDeveloperName,
            'Record_Type_2',
            'The affected mapping should be that of the new account record type'
        );
    }

    /****************************************************************************************
     * @description Test method to verify updateAutoEnrollmentMappings()
     * when exception occurs
     ****************************************************************************************/
    @isTest
    private static void updateAutoEnrollmentMappingsException() {
        AutoEnrollmentMappingService.instance = new STUB_ExceptionAutoEnrollmentMappingService();

        try {
            Test.startTest();
            String mappingName = ProgramSettingsController.updateAutoEnrollmentMappings(
                'Test Affl Mapping 1',
                'Record_Type_1',
                'Record_Type_2',
                'Test_Status_3',
                'Test_Role_3'
            );
            Test.stopTest();
            System.assert(false, 'should always throw an exception');
        } catch (AuraHandledException e) {
            System.assertEquals('Script-thrown exception', e.getMessage(), 'Should throw exception.');
        }
    }

    /***********************************************************************************************************************************
     ****************************************************** STUBS ***********************************************************************
     ***********************************************************************************************************************************/

    /**************************************************************************************************************************************
     * @description Stub class to simulate valid responses from AutoEnrollmentMappingsVMapper
     **************************************************************************************************************************************/
    private class STUB_AutoEnrollmentMappingsVMapperValid extends AutoEnrollmentMappingsVMapper {
        public override Boolean unmappedRecordTypesExist() {
            return true;
        }

        public override AutoEnrollmentMappingsVModel getAutoEnrollmentMappingsVModel() {
            List<AutoEnrollmentMappingVModel> autoEnrollmentMappingVModelsList = new List<AutoEnrollmentMappingVModel>();
            autoEnrollmentMappingVModelsList.add(
                new AutoEnrollmentMappingVModel(
                    'Mapping 1',
                    'Record_Type_1',
                    'Record Type 1',
                    'autoProgramEnrollmentStatus1',
                    'autoProgramEnrollmentRole1'
                )
            );
            autoEnrollmentMappingVModelsList.add(
                new AutoEnrollmentMappingVModel(
                    'Mapping 2',
                    'Record_Type_2',
                    'Record Type 2',
                    'autoProgramEnrollmentStatus2',
                    'autoProgramEnrollmentRole2'
                )
            );
            return new AutoEnrollmentMappingsVModel(autoEnrollmentMappingVModelsList);
        }

        public override ComboBoxVModel getAccountRecordTypeComboboxVModel(String accountRecordType) {
            List<ComboboxValueVModel> comboboxOptions = new List<ComboboxValueVModel>();
            comboboxOptions.add(new ComboboxValueVModel('Record Type 1', 'Record_Type_1'));
            return new ComboBoxVModel('Record_Type_1', comboboxOptions);
        }

        public override ComboBoxVModel getAutoEnrollmentMappingStatusComboboxVModel(
            String autoProgramEnrollmentStatus
        ) {
            List<ComboboxValueVModel> comboboxOptions = new List<ComboboxValueVModel>();
            comboboxOptions.add(new ComboboxValueVModel('Test Status', 'Test_Status'));
            return new ComboBoxVModel('Test_Status', comboboxOptions);
        }

        public override ComboBoxVModel getAutoEnrollmentMappingRoleComboboxVModel(String autoProgramEnrollmentRole) {
            List<ComboboxValueVModel> comboboxOptions = new List<ComboboxValueVModel>();
            comboboxOptions.add(new ComboboxValueVModel('Test Role', 'Test_Role'));
            return new ComboBoxVModel('Test_Role', comboboxOptions);
        }
    }

    /**************************************************************************************************************************************
     * @description Stub class to simulate valid responses from ProgramEnrollmentDeletionSettingsVMapper
     **************************************************************************************************************************************/
    private class STUB_ProgramEnrollmentDeletionSettingsVMapperValid extends ProgramEnrollmentDeletionSettingsVMapper {
        public override ProgramEnrollmentDeletionSettingsVModel getProgramEnrollmentDeletionSettingsVModel() {
            List<ComboboxValueVModel> programEnrollmentDeletionStatusOptions = new List<ComboboxValueVModel>();

            programEnrollmentDeletionStatusOptions.add(new ComboboxValueVModel('Selected Status', 'Selected_Status'));

            for (Integer i = 0; i < loopCounter; i++) {
                programEnrollmentDeletionStatusOptions.add(new ComboboxValueVModel('Status ' + i, 'Status_' + i));
            }

            ComboboxVModel programEnrollmentDeletionStatusComboboxVModel = new ComboboxVModel(
                'Selected Status',
                programEnrollmentDeletionStatusOptions
            );
            return new ProgramEnrollmentDeletionSettingsVModel(false, programEnrollmentDeletionStatusComboboxVModel);
        }
    }

    /**************************************************************************************************************************************
     * @description Stub class to simulate valid responses from AutoEnrollmentMappingService
     **************************************************************************************************************************************/
    private class STUB_AutoEnrollmentMappingService extends AutoEnrollmentMappingService {
        public override AutoEnrollmentMappingModel createAutoEnrollmentMapping(
            String accountRecordType,
            String status,
            String role
        ) {
            return new AutoEnrollmentMappingModel(accountRecordType, accountRecordType, status, role, true);
        }

        public override AutoEnrollmentMappingModel updateAutoEnrollmentMappings(
            String mappingName,
            String accountRecordType,
            String newAccountRecordType,
            String status,
            String role
        ) {
            if (accountRecordType != newAccountRecordType) {
                return new AutoEnrollmentMappingModel(accountRecordType, newAccountRecordType, status, role, true);
            }

            return new AutoEnrollmentMappingModel(mappingName, accountRecordType, status, role, true);
        }

        public override AutoEnrollmentMappingModel deleteAutoEnrollmentMappings(String mappingName) {
            return new AutoEnrollmentMappingModel(mappingName, 'Record_Type_1', null, null, false);
        }
    }

    /**************************************************************************************************************************************
     * @description Stub class to simulate exception responses from ProgramSettingsVMapper
     **************************************************************************************************************************************/
    private class STUB_ExceptionAutoEnrollmentMappingsVMapper extends AutoEnrollmentMappingsVMapper {
        public override AutoEnrollmentMappingsVModel getAutoEnrollmentMappingsVModel() {
            throw new TestException('Exception encountered!');
        }

        public override ComboBoxVModel getAccountRecordTypeComboboxVModel(String accountRecordType) {
            throw new TestException('Exception encountered!');
        }

        public override ComboBoxVModel getAutoEnrollmentMappingStatusComboboxVModel(
            String autoProgramEnrollmentStatus
        ) {
            throw new TestException('Exception encountered!');
        }

        public override ComboBoxVModel getAutoEnrollmentMappingRoleComboboxVModel(String autoProgramEnrollmentRole) {
            throw new TestException('Exception encountered!');
        }
    }

    /**************************************************************************************************************************************
     * @description Stub class to simulate exception responses from AutoEnrollmentMappingService
     **************************************************************************************************************************************/
    private class STUB_ExceptionAutoEnrollmentMappingService extends AutoEnrollmentMappingService {
        public override AutoEnrollmentMappingModel createAutoEnrollmentMapping(
            String accountRecordType,
            String status,
            String role
        ) {
            throw new TestException('Exception encountered!');
        }

        public override AutoEnrollmentMappingModel updateAutoEnrollmentMappings(
            String mappingName,
            String accountRecordType,
            String newAccountRecordType,
            String status,
            String role
        ) {
            throw new TestException('Exception encountered!');
        }

        public override AutoEnrollmentMappingModel deleteAutoEnrollmentMappings(String mappingName) {
            throw new TestException('Exception encountered!');
        }
    }

    /**************************************************************************************************************************************
     * @description Stub class to simulate exception responses from ProgramEnrollmentDeletionSettingsVMapper
     **************************************************************************************************************************************/
    private class STUB_ExceptionProgramEnrollmentDeletionSettingsVMapper extends ProgramEnrollmentDeletionSettingsVMapper {
        public override ProgramEnrollmentDeletionSettingsVModel getProgramEnrollmentDeletionSettingsVModel() {
            throw new TestException('Exception encountered!');
        }
    }

    private class TestException extends Exception {
    }
}
public class REL_Relationships_Cm_TDTM extends TDTM_Runnable {

    @testVisible
    private static Boolean reentrancyPrevented;

    public override DmlWrapper run(List<SObject> newList, List<SObject> oldList, 
    TDTM_Runnable.Action triggerAction, Schema.DescribeSObjectResult objResult) {

        List<CampaignMember> newListCasted = (newList == null ? new List<CampaignMember>(): (List<CampaignMember>)newList);
        List<CampaignMember> oldListCasted = (oldList == null ? new List<CampaignMember>(): (List<CampaignMember>)oldList);
        Map<Id, CampaignMember> oldMap = new Map<Id, CampaignMember>(oldListCasted);
            
        DmlWrapper dmlWrapper = new DmlWrapper();

        if (TDTM_ProcessControl.getRecursionFlag(TDTM_ProcessControl.registeredTrigger.REL_Relationships_Cm_TDTM)) {
            reentrancyPrevented = true;
            return dmlWrapper;
         }
        
        List<Id> contactIds = new List<Id>();
        List<Id> reciprocalIds = new List<Id>();
        List<String> types = new List<String>();
        List<Id> cIds = new List<Id>();  
        
        // Create Campaign map based on newMap keyset, then get type and use that map to determine if type matched
        for (CampaignMember cm : newListCasted){
            cIds.add(cm.CampaignId);
        }
        
        Map<Id, Campaign> cMap = new Map<Id, Campaign>([SELECT Id, Type FROM Campaign WHERE Id IN :cIds]);
                
        for (CampaignMember cm : newListCasted){
            // Ignore campaign members for leads
            if (cm.ContactId == null) {
                continue;
            }

            for(String s : REL_Utils.getAutoCreateMap().keySet()){
                Relationship_Auto_Create__c rac = REL_Utils.getAutoCreateMap().get(s);

                if (rac.Object__c != 'CampaignMember' || rac.Campaign_Types__c == null) {
                    continue;
                }
                
                //retrieve the campaign for matching type
                Campaign c = cMap.get(cm.CampaignId);
                UTIL_Debug.debug('****Current Campaign Type: ' + c.Type);
                
                //create a set from the rac
                List<String> cTypeList = rac.Campaign_Types__c.split(';');
                UTIL_Debug.debug('****All Campaign Types: ' + cTypeList);
                Set<String> cTypeSet = new Set<String>();
                cTypeSet.addAll(cTypeList);                            
                
                if (cTypeSet.contains(c.Type)){                     
                    Id relatedContactId;
                    try{
                        //get the id from the field                        
                        relatedContactId = (Id)cm.get(rac.Field__c);
                    }catch(Exception e) {
                        cm.addError(Label.AutoCreateFieldError); 
                    }
                    
                    if(triggerAction == TDTM_Runnable.Action.afterInsert && relatedContactId != null) {                        
                        contactIds.add(cm.ContactId);
                        reciprocalIds.add(relatedContactId);
                        types.add(rac.Relationship_Type__c);
                    } else if (triggerAction == TDTM_Runnable.Action.afterUpdate && relatedContactId != null 
                            && relatedContactId != oldMap.get(cm.id).get(rac.Field__c)){
                        contactIds.add(cm.ContactId);
                        reciprocalIds.add(relatedContactId);
                        types.add(rac.Relationship_Type__c);
                    }
                }              
            }         
        }   

        if (!contactIds.isEmpty()) {
            DmlWrapper w = REL_Relationships_Con_TDTM.createNewRelationships(contactIds, reciprocalIds, types);
            dmlWrapper.objectsToInsert.addAll(w.objectsToInsert);
        }

        TDTM_ProcessControl.setRecursionFlag(TDTM_ProcessControl.registeredTrigger.REL_Relationships_Cm_TDTM, true);
        TDTM_TriggerHandler.processDML(dmlWrapper, true);
        dmlWrapper = null;
        TDTM_ProcessControl.setRecursionFlag(TDTM_ProcessControl.registeredTrigger.REL_Relationships_Cm_TDTM, false);

        return dmlWrapper;
    }
}
public class REL_Relationships_Con_TDTM extends TDTM_Runnable {

    @testVisible
    private static Boolean reentrancyPrevented;
	
	/*******************************************************************************************************
    * @description Trigger Handler on Contact that handles relationship autocreation and gender change.
    * @param newList the list of Contacts from trigger new. 
    * @param oldList the list of Contacts from trigger old. 
    * @param triggerAction which trigger event (BeforeInsert, AfterInsert, etc.). 
    * @param objResult the describe for Contacts 
    * @return dmlWrapper Any relationships that need DML.
    ********************************************************************************************************/
	public override DmlWrapper run(List<SObject> newList, List<SObject> oldList, 
    TDTM_Runnable.Action triggerAction, Schema.DescribeSObjectResult objResult) {

        DmlWrapper dmlWrapper = new DmlWrapper();

        if (newList == null || newList.isEmpty() == true){
            return dmlWrapper;
        }

        UTIL_Describe.cacheDescribeSObjectResult(Contact.SObjectType.getDescribe());

        if (triggerAction == TDTM_Runnable.Action.AfterInsert){
            return this.handleAfterInsert(newList);
        }

        /******************************************************************************************************************** */
         //Casting them to contacts, since this class should be run only for contacts
         List<Contact> newListCasted = (newList == null ? new List<Contact>(): (List<Contact>)newList);
         List<Contact> oldListCasted = (oldList == null ? new List<Contact>(): (List<Contact>)oldList);
         Map<Id, Contact> oldMap = new Map<Id, Contact>(oldListCasted);
                      
         if (TDTM_ProcessControl.getRecursionFlag(TDTM_ProcessControl.registeredTrigger.REL_Relationships_Con_TDTM)) {
             reentrancyPrevented = true;
             return dmlWrapper;
          }
         
         List<Id> contactIds = new List<Id>();
         List<Id> reciprocalIds = new List<Id>();
         List<String> types = new List<String>();
         
         Set<Id> changedGender = new Set<Id>();        
         
         if(newlist != null && newlist.size() > 0) {
             for (Contact c : newListCasted){
                 for(String s : REL_Utils.getAutoCreateMap().keySet()){
                     Relationship_Auto_Create__c rac = REL_Utils.getAutoCreateMap().get(s);
                     if (rac.Object__c != 'Contact') {
                         continue;
                     }
                     
                     Id relatedContactId;
                     try{
                         //get the id from the field                        
                         relatedContactId = (Id)c.get(rac.Field__c);
                     }catch(Exception e){
                         c.addError(system.Label.AutoCreateFieldError);
                     }    
                     
                     if(triggerAction == TDTM_Runnable.Action.afterInsert && relatedContactId != null) {                        
                         contactIds.add(c.Id);
                         reciprocalIds.add(relatedContactId);
                         types.add(rac.Relationship_Type__c);
                     } else if (triggerAction == TDTM_Runnable.Action.afterUpdate && relatedContactId != null 
                             && relatedContactId != oldMap.get(c.id).get(rac.Field__c)){
                         contactIds.add(c.Id);
                         reciprocalIds.add(relatedContactId);
                         types.add(rac.Relationship_Type__c);
                     }         
                 }
                 
                 //handle updates to the gender field
                 if (triggerAction == TDTM_Runnable.Action.afterUpdate && oldMap.get(c.id) != null) {
                     if (c.Gender__c != oldMap.get(c.id).Gender__c) {
                         changedGender.add(c.id);
                     }
                 }           
             }
         }
         
         if(triggerAction == TDTM_Runnable.Action.AfterDelete) {
             DmlWrapper w = deleteEmptyRelationships(oldMap);
             dmlWrapper.objectsToDelete.addAll(w.objectsToDelete);
         }
         
         if (!contactIds.isEmpty()){
             DmlWrapper w = createNewRelationships(contactIds, reciprocalIds, types);
             dmlWrapper.objectsToInsert.addAll(w.objectsToInsert);
         }
         
         if (!changedGender.isEmpty()) {
             //query for a map of all relationships where where contact or related contact has changed gender
             map<id,Relationship__c> mapRelationship = new map<Id,Relationship__c>(
                 [SELECT Id, Contact__c, RelatedContact__c, ReciprocalRelationship__c, Type__c 
                 FROM Relationship__c WHERE Contact__c IN :changedGender OR RelatedContact__c IN :changedGender]
             );
             //make a list of "Related Contact" lookup relationships in our set, these we want to update
             list<Relationship__c> listRelsForUpdate = new list<Relationship__c>();
             //make a list of mirror relationships for our first list, we need these for the addType method
             list<Relationship__c> listMirrorRels = new list<Relationship__c>();
 
             //get the relationships that the gender change affects
             for (Relationship__c rel : mapRelationship.values()) {
                 //add the changed gender's relationship and reciprocal
                 if (changedGender.contains(rel.RelatedContact__c)) {
                     listRelsForUpdate.add(rel);
                     listMirrorRels.add(mapRelationship.get(rel.ReciprocalRelationship__c));
                 }
             }
 
             //update type info
             REL_Relationships_TDTM.addType(listMirrorRels, listRelsForUpdate);
             dmlWrapper.objectsToUpdate.addAll((list<sObject>)listRelsForUpdate);
         }
 
        TDTM_ProcessControl.setRecursionFlag(TDTM_ProcessControl.registeredTrigger.REL_Relationships_Con_TDTM, true);
        TDTM_TriggerHandler.processDML(dmlWrapper, true);
        dmlWrapper = null;
        TDTM_ProcessControl.setRecursionFlag(TDTM_ProcessControl.registeredTrigger.REL_Relationships_Con_TDTM, false);
        /********************************************************************************************************/


        return dmlWrapper;
    }


    /********************************************************************************************************
    * @description Handles processing of logic necessary for an After Insert trigger action.
    * @param newList The list of inserted objects.
    * @return A DmlWrapper
    ********************************************************************************************************/ 
    @TestVisible
    private DmlWrapper handleAfterInsert(List<SObject> newList){        
        if (this.isInsertRecursion() == true){
            return null;
        }

        this.setInsertRecursion();

        List<Contact> newContactsList = (List<Contact>)newList;
        List<ContactRelAutoCreateMappingModel> contactRelAutoCreateModelsList = this.locateRelationshipAutoCreateMapper().getContactMappingModelsFromSettings();     

        ContactsRelationshipsModel contactsRelationshipsMdl = this.locateRelationshipAutoCreateService().getRelationshipsToCreateForContacts(newContactsList, contactRelAutoCreateModelsList);

        if (contactsRelationshipsMdl != null){
            List<Relationship__c> contactRelationshipsToCreate = contactsRelationshipsMdl.relationshipList;

            if (contactRelationshipsToCreate != null && contactRelationshipsToCreate.isEmpty() == false){
                DmlWrapper dmlWrapper = new DmlWrapper();
                
                dmlWrapper.objectsToInsert.addAll((List<SObject>)contactRelationshipsToCreate);
                TDTM_TriggerHandler.processDML(dmlWrapper, true);
            }
        }
        
        this.unsetInsertRecursion();

        return null;
    }

    /*******************************************************************************************************
    * @description Retrieves an instance of the RelAutoCreateSettingsMapper mapper class.
    * @return An instance of RelAutoCreateSettingsMapper.
    *******************************************************************************************************/ 
    @TestVisible
    private RelAutoCreateSettingsMapper locateRelationshipAutoCreateMapper(){
        return RelAutoCreateSettingsMapper.getInstance();
    }

    /*******************************************************************************************************
    * @description Retrieves an instance of the ContactRelAutoCreateService service class.
    * @return An instance of ContactRelAutoCreateService.
    *******************************************************************************************************/ 
    @TestVisible
    private ContactRelAutoCreateService locateRelationshipAutoCreateService(){
        return ContactRelAutoCreateService.getInstance();
    }

    /*******************************************************************************************************
    * @description Determines whether current context is associated with an insert recursion.
    * @return True if After Insert recursion flag for REL_Relationships_Con_TDTM is set, False otherwise.
    *******************************************************************************************************/ 
    @TestVisible
    private Boolean isInsertRecursion(){
        return TDTM_ProcessControl.getRecursionFlag(TDTM_ProcessControl.registeredTrigger.REL_Relationships_Con_TDTM);
    }
    
    /*******************************************************************************************************
    * @description Sets the After Insert recursion flag for REL_Relationships_Con_TDTM.
    *******************************************************************************************************/    
    @TestVisible
    private void setInsertRecursion(){
        TDTM_ProcessControl.setRecursionFlag(TDTM_ProcessControl.registeredTrigger.REL_Relationships_Con_TDTM, true);
    }

    /*******************************************************************************************************
    * @description Clears the After Insert recursion flag for REL_Relationships_Con_TDTM.
    *******************************************************************************************************/ 
    @TestVisible
    private void unsetInsertRecursion(){
        TDTM_ProcessControl.setRecursionFlag(TDTM_ProcessControl.registeredTrigger.REL_Relationships_Con_TDTM, false);
    }


    /*******************************************************************************************************
    * @description Deletes Relationships when a Contact is deleted
    * @param contacts the Map of Contacts from trigger oldMap. 
    * @return dmlWrapper Relationships to delete.
    ********************************************************************************************************/
    public static DmlWrapper deleteEmptyRelationships(Map<Id, Contact> contacts) {
        DmlWrapper dmlWrapper = new DmlWrapper();
        List<SObject> relationshipsToDelete = new List<SObject>();

        // The Contacts primary Relationships have already been cascade deleted in Contact After Delete context
        // Using ALL ROWS returns them in the query used to gather the mirror Relationships to be deleted 
        for (Relationship__c r : [SELECT Id, ReciprocalRelationship__c FROM Relationship__c 
                WHERE Contact__c IN :contacts.keySet() ALL ROWS]){
            if (r.ReciprocalRelationship__c != null) {
                relationshipsToDelete.add(new Relationship__c(Id = r.ReciprocalRelationship__c));
            }
        }
        if ( relationshipsToDelete.size() > 0 ) {
            dmlWrapper.objectsToDelete.addAll(relationshipsToDelete);
        }
        return dmlWrapper;
    }
    
    public static DmlWrapper createNewRelationships(List<Id> contactIds, List<Id> relatedContactIds, List<String> types) {
        
        DmlWrapper dmlWrapper = new DmlWrapper();
        Integer i = 0;
        List<SObject> relationshipsForInsert = new List<SObject>();
        
        //used to hold existing relationships for the group of contacts and check for dupes
        List<Relationship__c> existingRelationships = new List<Relationship__c>();
        Map<Id, List<Relationship__c>> relationshipsByContact = new Map<Id, List<Relationship__c>>();
        
        if (!UTIL_CustomSettingsFacade.getSettings().Allow_AutoCreated_Duplicates__c) {
            
            existingRelationships = [SELECT Id, Contact__c, RelatedContact__c, Type__c 
                FROM Relationship__c WHERE Contact__c IN :contactIds LIMIT 2000];
            
            //sort by Contact__c so we can pull relationships based on the inserted Contact
            for(Relationship__c r : existingRelationships){
                if(relationshipsByContact.containsKey(r.Contact__c)){
                    List<Relationship__c> rList = relationshipsByContact.get(r.Contact__c);
                    rList.add(r);
                    relationshipsByContact.put(r.Contact__c, rList);
                }
                else{
                    relationshipsByContact.put(r.Contact__c, new List<Relationship__c>{r});
                }               
            }        
        }        
            
        for (Id conId : contactIds){
            boolean doNotCreate = false;
            
            //prevent duplicates from being created if they exist and setting is enabled
            if (relationshipsByContact.containsKey(conId)){
                for (Relationship__c r : relationshipsByContact.get(conId)){
                    if (r.Type__c == types[i] && r.RelatedContact__c == relatedContactIds[i]){
                        doNotCreate = true;                     
                        break;
                    }                   
                }    
            }
            
            if (!doNotCreate){
                UTIL_Debug.debug('****Creating relationship in createNewRelationships method');
                Relationship__c r = new Relationship__c(
                    Contact__c = conId, 
                    RelatedContact__c = relatedContactIds[i],
                    Type__c = types[i],           
                    Status__c = 'Current'                 
                );
                relationshipsForInsert.add(r);
            }
            i++;
        }       
        
        if (!relationshipsForInsert.isEmpty()){
            dmlWrapper.objectsToInsert.addAll(relationshipsForInsert);
        }
        
        return dmlWrapper;
    }
}
@isTest
private with sharing class REL_Relationships_Con_TEST {
    /*********************************************************************************************************
     ****************************** RELATIONSHIP AUTO CREATION FUNCTIONAL TESTS *******************************
     *********************************************************************************************************/

    /*********************************************************************************************************
     * @description Test to verify that inserting a Contact record without an Auto Creation mapping does not
     * generate a relationship or reciprocal relationship record.
     *********************************************************************************************************/
    @isTest
    private static void insertContactWithoutRelationshipAutoCreate() {
        List<Contact> contactsList = UTIL_UnitTestData_TEST.getMultipleTestContacts(5);

        Test.startTest();
        insert contactsList;
        Test.stopTest();

        List<Relationship__c> relationshipResultsList = [
            SELECT Id, Contact__c, RelatedContact__c, Status__c, Type__c
            FROM Relationship__c
            WHERE Contact__c IN :contactsList OR RelatedContact__c IN :contactsList
        ];

        System.assertEquals(
            true,
            relationshipResultsList.isEmpty(),
            'There should be no auto created relationship records.'
        );
    }

    /*********************************************************************************************************
     * @description Test to verify that inserting a Contact record with invalid Auto Creation
     * mappings results in an error when Contact is created and all fields associated with invalid mappings are populated.
     *********************************************************************************************************/
    @isTest
    private static void insertContactWithInvalidRelationshipsAutoCreate() {
        List<Relationship_Auto_Create__c> relAutoCreateList = new List<Relationship_Auto_Create__c>();

        Relationship_Auto_Create__c relAutoCreateInValid1 = new Relationship_Auto_Create__c(
            Name = 'ConReportToAutoCreateInvalid1',
            Object__c = 'Contact',
            Field__c = 'FirstName',
            Relationship_Type__c = 'Testee',
            Campaign_Types__c = ''
        );

        Relationship_Auto_Create__c relAutoCreateInValid2 = new Relationship_Auto_Create__c(
            Name = 'ConReportToAutoCreateInvalid2',
            Object__c = 'Contact',
            Field__c = 'LastName',
            Relationship_Type__c = 'Tester',
            Campaign_Types__c = ''
        );

        relAutoCreateList.add(relAutoCreateInValid1);
        relAutoCreateList.add(relAutoCreateInValid2);
        insert relAutoCreateList;

        List<Relationship_Lookup__c> relationshipLookupsList = new List<Relationship_Lookup__c>();
        Relationship_Lookup__c testerRelationshipLookup = new Relationship_Lookup__c(
            Name = 'Tester',
            Male__c = 'Testee-Male',
            Female__c = 'Testee-Female',
            Neutral__c = 'Testee'
        );

        Relationship_Lookup__c testeeRelationshipLookup = new Relationship_Lookup__c(
            Name = 'Testee',
            Male__c = 'Tester-Male',
            Female__c = 'Tester-Female',
            Neutral__c = 'Tester'
        );

        relationshipLookupsList.add(TesterRelationshipLookup);
        relationshipLookupsList.add(TesteeRelationshipLookup);
        insert relationshipLookupsList;

        List<Contact> contactsList = UTIL_UnitTestData_TEST.getMultipleTestContacts(5);
        for (Integer i = 0; i < contactsList.size(); i++) {
            contactsList[i].FirstName = 'Test';
            contactsList[i].LastName = 'Contact ' + i;
        }

        Test.startTest();
        try {
            insert contactsList;
        } catch (DmlException e) {
            System.assertEquals(
                true,
                e.getMessage().contains(Label.AutoCreateFieldError),
                'Inserting a Contact with invalid Auto Create mappings should display an error.'
            );
        }
        Test.stopTest();

        List<Relationship__c> relationshipResultsList = [
            SELECT Id, Contact__c, RelatedContact__c, Status__c, Type__c
            FROM Relationship__c
            WHERE Contact__c IN :contactsList
        ];

        System.assertEquals(
            true,
            relationshipResultsList.isEmpty(),
            'No Contact records should be inserted when invalid Auto Create mappings.'
        );
    }

    /*********************************************************************************************************
     * @description Test to verify that inserting a Contact record with a valid Auto Creation
     * mappings and relationship lookup results in a reciprocal relationship record.
     * Test Scenario: T-4314976
     *********************************************************************************************************/
    @isTest
    private static void insertContactWithValidRelationshipsAutoCreate() {
        List<Relationship_Lookup__c> lookups = new List<Relationship_Lookup__c>();

        lookups.add(
            new Relationship_Lookup__c(
                Name = 'Employee',
                Male__c = 'Employer',
                Female__c = 'Employer',
                Neutral__c = 'Employer',
                Active__c = true
            )
        );
        lookups.add(
            new Relationship_Lookup__c(
                Name = 'Employer',
                Male__c = 'Employee',
                Female__c = 'Employee',
                Neutral__c = 'Employee',
                Active__c = true
            )
        );
        insert lookups;

        insert new Relationship_Auto_Create__c(
            Name = 'ConReportToAutoCreate',
            Object__c = 'Contact',
            Field__c = 'ReportsToId',
            Relationship_Type__c = 'Employer',
            Campaign_Types__c = ''
        );

        Contact employer = UTIL_UnitTestData_TEST.getUniqueContact(0);
        insert employer;

        Contact employee = UTIL_UnitTestData_TEST.getUniqueContact(1);
        employee.ReportsToId = employer.Id;

        Test.startTest();
        insert employee;
        Test.stopTest();

        List<Relationship__c> employeeRelationship = [
            SELECT Id, Contact__c, RelatedContact__c, Status__c, Type__c
            FROM Relationship__c
            WHERE RelatedContact__c = :employee.Id
        ];

        List<Relationship__c> employerRelationship = [
            SELECT Id, Contact__c, RelatedContact__c, Status__c, Type__c
            FROM Relationship__c
            WHERE RelatedContact__c = :employer.Id
        ];

        System.assertEquals(1, employeeRelationship.size());
        System.assertEquals(1, employerRelationship.size());

        System.assertEquals('Current', employerRelationship[0].Status__c);
        System.assertEquals('Employer', employerRelationship[0].Type__c);

        System.assertEquals('Current', employeeRelationship[0].Status__c);
        System.assertEquals('Employee', employeeRelationship[0].Type__c);
    }

    /*********************************************************************************************************
     * @description Test to verify that relationships are marked for insertion upon multiple relationships
     * being configured and inserting of a given Contact record.
     * Test Scenario: T-4315028
     *********************************************************************************************************/
    @isTest
    private static void ensureRelationshipServiceInsertsContactsWithValidRelationshipsAutoCreate() {
        List<Relationship_Lookup__c> lookups = new List<Relationship_Lookup__c>();

        lookups.add(
            new Relationship_Lookup__c(
                Name = 'Employee',
                Male__c = 'Employer',
                Female__c = 'Employer',
                Neutral__c = 'Employer',
                Active__c = true
            )
        );
        lookups.add(
            new Relationship_Lookup__c(
                Name = 'Employer',
                Male__c = 'Employee',
                Female__c = 'Employee',
                Neutral__c = 'Employee',
                Active__c = true
            )
        );
        lookups.add(
            new Relationship_Lookup__c(
                Name = 'Supervised',
                Male__c = 'Superviser',
                Female__c = 'Superviser',
                Neutral__c = 'Superviser',
                Active__c = true
            )
        );
        lookups.add(
            new Relationship_Lookup__c(
                Name = 'Superviser',
                Male__c = 'Supervised',
                Female__c = 'Supervised',
                Neutral__c = 'Supervised',
                Active__c = true
            )
        );
        insert lookups;

        insert new Relationship_Auto_Create__c(
            Name = 'ConReportToAutoCreate1',
            Object__c = 'Contact',
            Field__c = 'ReportsToId',
            Relationship_Type__c = 'Employer',
            Campaign_Types__c = ''
        );

        /*insert new Relationship_Auto_Create__c(
            Name = 'ConReportToAutoCreate2',
            Object__c = 'Contact',
            Field__c = 'IndividualId',
            Relationship_Type__c = 'Superviser',
            Campaign_Types__c = ''
        );*/

        Contact employer = UTIL_UnitTestData_TEST.getUniqueContact(0);
        insert employer;

        Contact superviser = UTIL_UnitTestData_TEST.getUniqueContact(1);
        insert superviser;

        Contact employee = UTIL_UnitTestData_TEST.getUniqueContact(2);
        employee.ReportsToId = employer.Id;
        //employee.IndividualId = superviser.Id;

        Test.startTest();
        REL_Relationships_Con_TDTM instance = new REL_Relationships_Con_TDTM();
        List<ContactRelAutoCreateMappingModel> contactRelAutoCreateModelsList = instance.locateRelationshipAutoCreateMapper()
            .getContactMappingModelsFromSettings();

        ContactsRelationshipsModel contactsRelationshipsMdl = instance.locateRelationshipAutoCreateService()
            .getRelationshipsToCreateForContacts(new List<Contact>{ employee }, contactRelAutoCreateModelsList);
        Test.stopTest();

        System.assertEquals(1, contactsRelationshipsMdl.relationshipList.size());
        System.assertEquals('Employer', contactsRelationshipsMdl.relationshipList[0].Type__c);
        //System.assertEquals('Superviser', contactsRelationshipsMdl.relationshipList[1].Type__c);
    }

    /*********************************************************************************************************
     * @description Test to verify that inserting a Contact record with invalid Auto Creation
     * mappings results in an error even when Contact is created and all fields associated with invalid mappings are not populated.
     * Test Scenario: T-4316897
     *********************************************************************************************************/
    @isTest
    private static void insertContactWithInvalidRelationshipsAutoCreateUnpopulated() {
        List<Relationship_Auto_Create__c> relAutoCreateList = new List<Relationship_Auto_Create__c>();

        Relationship_Auto_Create__c relAutoCreateInValid1 = new Relationship_Auto_Create__c(
            Name = 'ConReportToAutoCreateInvalid1',
            Object__c = 'Contact',
            Field__c = 'FirstName',
            Relationship_Type__c = 'Testee',
            Campaign_Types__c = ''
        );

        Relationship_Auto_Create__c relAutoCreateInValid2 = new Relationship_Auto_Create__c(
            Name = 'ConReportToAutoCreateInvalid2',
            Object__c = 'Contact',
            Field__c = 'Birthdate',
            Relationship_Type__c = 'Tester',
            Campaign_Types__c = ''
        );

        relAutoCreateList.add(relAutoCreateInValid1);
        relAutoCreateList.add(relAutoCreateInValid2);
        insert relAutoCreateList;

        List<Relationship_Lookup__c> relationshipLookupsList = new List<Relationship_Lookup__c>();
        Relationship_Lookup__c testerRelationshipLookup = new Relationship_Lookup__c(
            Name = 'Tester',
            Male__c = 'Testee-Male',
            Female__c = 'Testee-Female',
            Neutral__c = 'Testee'
        );

        Relationship_Lookup__c testeeRelationshipLookup = new Relationship_Lookup__c(
            Name = 'Testee',
            Male__c = 'Tester-Male',
            Female__c = 'Tester-Female',
            Neutral__c = 'Tester'
        );

        relationshipLookupsList.add(TesterRelationshipLookup);
        relationshipLookupsList.add(TesteeRelationshipLookup);
        insert relationshipLookupsList;

        List<Contact> contactsList = UTIL_UnitTestData_TEST.getMultipleTestContacts(5);
        for (Integer i = 0; i < contactsList.size(); i++) {
            contactsList[i].LastName = 'Contact ' + i;
        }

        Test.startTest();
        try {
            insert contactsList;
        } catch (DmlException e) {
            System.assertEquals(
                true,
                e.getMessage().contains(Label.AutoCreateFieldError),
                'Inserting a Contact with invalid Auto Create mappings should display an error even when mapped fields are not populated.'
            );
        }
        Test.stopTest();

        List<Relationship__c> relationshipResultsList = [
            SELECT Id, Contact__c, RelatedContact__c, Status__c, Type__c
            FROM Relationship__c
            WHERE Contact__c IN :contactsList
        ];

        System.assertEquals(
            true,
            relationshipResultsList.isEmpty(),
            'No Contact records should be inserted when invalid Auto Create mappings.'
        );
    }

    /*********************************************************************************************************
     * @description Test to verify that inserting a Contact record with both valid and invalid Auto Creation
     * mappings results in an error when Contact is created and field associated with invalid mapping is populated.
     *********************************************************************************************************/
    @isTest
    private static void insertContactWithValidAndInvalidRelationshipsAutoCreateInvalidPopulated() {
        List<Relationship_Auto_Create__c> relAutoCreateList = new List<Relationship_Auto_Create__c>();

        Relationship_Auto_Create__c relAutoCreateInvalid = new Relationship_Auto_Create__c(
            Name = 'ConReportToAutoCreateInvalid',
            Object__c = 'Contact',
            Field__c = 'LastName',
            Relationship_Type__c = 'Testee',
            Campaign_Types__c = ''
        );

        Relationship_Auto_Create__c relAutoCreateValid = new Relationship_Auto_Create__c(
            Name = 'ConReportToAutoCreateValid',
            Object__c = 'Contact',
            Field__c = 'ReportsToId',
            Relationship_Type__c = 'Tester',
            Campaign_Types__c = ''
        );

        relAutoCreateList.add(relAutoCreateInvalid);
        relAutoCreateList.add(relAutoCreateValid);
        insert relAutoCreateList;

        List<Relationship_Lookup__c> relationshipLookupsList = new List<Relationship_Lookup__c>();
        Relationship_Lookup__c testerRelationshipLookup = new Relationship_Lookup__c(
            Name = 'Tester',
            Male__c = 'Testee-Male',
            Female__c = 'Testee-Female',
            Neutral__c = 'Testee'
        );

        Relationship_Lookup__c testeeRelationshipLookup = new Relationship_Lookup__c(
            Name = 'Testee',
            Male__c = 'Tester-Male',
            Female__c = 'Tester-Female',
            Neutral__c = 'Tester'
        );

        relationshipLookupsList.add(TesterRelationshipLookup);
        relationshipLookupsList.add(TesteeRelationshipLookup);
        insert relationshipLookupsList;

        List<Contact> contactsList = UTIL_UnitTestData_TEST.getMultipleTestContacts(5);
        for (Integer i = 0; i < contactsList.size(); i++) {
            contactsList[i].FirstName = 'Test';
            contactsList[i].LastName = 'Contact ' + i;
        }

        Test.startTest();
        try {
            insert contactsList;
        } catch (DmlException e) {
            System.assertEquals(
                true,
                e.getMessage().contains(Label.AutoCreateFieldError),
                'Inserting a Contact with invalid Auto Create mappings should display an error.'
            );
        }
        Test.stopTest();

        List<Relationship__c> relationshipResultsList = [
            SELECT Id, Contact__c, RelatedContact__c, Status__c, Type__c
            FROM Relationship__c
            WHERE Contact__c IN :contactsList
        ];

        System.assertEquals(
            true,
            relationshipResultsList.isEmpty(),
            'No Contact records should be inserted when invalid Auto Create mappings.'
        );
    }

    /*********************************************************************************************************
     * @description Test to verify that inserting a Contact record with both valid and invalid Auto Creation
     * mappings results in an error even when Contact is created and field associated with invalid mapping is not populated.
     *********************************************************************************************************/
    @isTest
    private static void insertContactWithValidAndInvalidRelationshipsAutoCreateInvalidUnpopulated() {
        Contact reportContact = UTIL_UnitTestData_TEST.getMultipleTestContacts(1)[0];
        insert reportContact;

        List<Relationship_Auto_Create__c> relAutoCreateList = new List<Relationship_Auto_Create__c>();

        Relationship_Auto_Create__c relAutoCreateInvalid = new Relationship_Auto_Create__c(
            Name = 'ConReportToAutoCreateInvalid',
            Object__c = 'Contact',
            Field__c = 'FirstName',
            Relationship_Type__c = 'Testee',
            Campaign_Types__c = ''
        );

        Relationship_Auto_Create__c relAutoCreateValid = new Relationship_Auto_Create__c(
            Name = 'ConReportToAutoCreateValid',
            Object__c = 'Contact',
            Field__c = 'ReportsToId',
            Relationship_Type__c = 'Tester',
            Campaign_Types__c = ''
        );

        relAutoCreateList.add(relAutoCreateInvalid);
        relAutoCreateList.add(relAutoCreateValid);
        insert relAutoCreateList;

        List<Relationship_Lookup__c> relationshipLookupsList = new List<Relationship_Lookup__c>();
        Relationship_Lookup__c testerRelationshipLookup = new Relationship_Lookup__c(
            Name = 'Tester',
            Male__c = 'Testee-Male',
            Female__c = 'Testee-Female',
            Neutral__c = 'Testee'
        );

        Relationship_Lookup__c testeeRelationshipLookup = new Relationship_Lookup__c(
            Name = 'Testee',
            Male__c = 'Tester-Male',
            Female__c = 'Tester-Female',
            Neutral__c = 'Tester'
        );

        relationshipLookupsList.add(TesterRelationshipLookup);
        relationshipLookupsList.add(TesteeRelationshipLookup);
        insert relationshipLookupsList;

        List<Contact> contactsList = UTIL_UnitTestData_TEST.getMultipleTestContacts(5);
        for (Integer i = 0; i < contactsList.size(); i++) {
            contactsList[i].LastName = 'Contact ' + i;
            contactsList[i].ReportsToId = reportContact.Id;
        }

        Test.startTest();
        try {
            insert contactsList;
        } catch (DmlException e) {
            System.assertEquals(
                true,
                e.getMessage().contains(Label.AutoCreateFieldError),
                'Inserting a Contact with invalid Auto Create mappings should display an error.'
            );
        }
        Test.stopTest();

        List<Relationship__c> relationshipResultsList = [
            SELECT Id, Contact__c, RelatedContact__c, Status__c, Type__c
            FROM Relationship__c
            WHERE Contact__c IN :contactsList
        ];

        System.assertEquals(
            true,
            relationshipResultsList.isEmpty(),
            'No Contact records should be inserted when invalid Auto Create mappings.'
        );
    }

    /*********************************************************************************************************
    * @description Test to verify that when Relationship Auto Creation is enabled, inserting a Contact record 
    * with an Auto Creation mapped field populated generates the expected relationship  and reciprocal 
    * reciprocal relationship records.
    *********************************************************************************************************/
    @isTest
    private static void insertContactWithRelationshipAutoCreateFieldPopulated() {
        Relationship_Auto_Create__c contactReportToRelAutoCreate = new Relationship_Auto_Create__c(Name = 'ConReportToAutoCreate', 
                                                                                                   Object__c = 'Contact',
                                                                                                   Field__c = 'ReportsToId', 
                                                                                                   Relationship_Type__c = 'Tester',
                                                                                                   Campaign_Types__c = '');

        insert contactReportToRelAutoCreate;

        List<Relationship_Lookup__c> relationshipLookupsList = new List<Relationship_Lookup__c>();
        Relationship_Lookup__c testerRelationshipLookup = new Relationship_Lookup__c(Name = 'Tester', 
                                                                                   Male__c = 'Testee-Male',
                                                                                   Female__c = 'Testee-Female', 
                                                                                   Neutral__c = 'Testee');

        Relationship_Lookup__c testeeRelationshipLookup = new Relationship_Lookup__c(Name = 'Testee', 
                                                                                   Male__c = 'Tester-Male',
                                                                                   Female__c = 'Tester-Female', 
                                                                                   Neutral__c = 'Tester');

        relationshipLookupsList.add(TesterRelationshipLookup);
        relationshipLookupsList.add(TesteeRelationshipLookup);
        insert relationshipLookupsList;

        List<Contact> relatedContactsList = UTIL_UnitTestData_TEST.getMultipleTestContacts(5);
        for (Integer i = 0; i < relatedContactsList.size(); i++){
            relatedContactsList[i].FirstName = 'Test';
            relatedContactsList[i].LastName = 'Related ' + i; 
        }
        insert relatedContactsList;
        
        Map<Id, Contact> relatedContactsById = new Map<Id, Contact>();
        for (Contact con : relatedContactsList){
            relatedContactsById.put(con.Id, con);
        }

        List<Contact> contactsList = UTIL_UnitTestData_TEST.getMultipleTestContacts(5);
        for (Integer i = 0; i < contactsList.size(); i++){
            contactsList[i].FirstName = 'Test';
            contactsList[i].LastName = 'Contact ' + i;
            contactsList[i].ReportsToId = relatedContactsList[i].Id;
        }

        Test.startTest();
        insert contactsList;
        Test.stopTest();

        Map<Id, Contact> contactsById = new Map<Id, Contact>();
        for (Contact con : contactsList){
            contactsById.put(con.Id, con);
        }

        List<Relationship__c> relationshipResultsList = [SELECT Id, 
                                                                Contact__c,
                                                                RelatedContact__c,
                                                                Status__c,
                                                                Type__c
                                                        FROM Relationship__c
                                                        WHERE Contact__c IN :contactsList
                                                        OR Contact__c IN :relatedContactsList];

        Map<Id, Relationship__c> relationshipsByContactId = new Map<Id, Relationship__c>();
        for (Relationship__c rel : relationshipResultsList){
            relationshipsByContactId.put(rel.Contact__c, rel);
        }

        Map<Id, List<Relationship__c>> relationshipsListByContactId = new Map<Id, List<Relationship__c>>();
        for (Relationship__c rel : relationshipResultsList){
            List<Relationship__c> associatedRelationshipsList;

            if (contactsById.containsKey(rel.Contact__c)){
                associatedRelationshipsList = relationshipsListByContactId.get(rel.Contact__c);
            } else {
                associatedRelationshipsList = relationshipsListByContactId.get(rel.relatedContact__c);
            }
            
            if (associatedRelationshipsList == null){
                associatedRelationshipsList = new List<Relationship__c>();
            }

            associatedRelationshipsList.add(rel);
            relationshipsListByContactId.put(rel.Contact__c, associatedRelationshipsList);
        }

        System.assertEquals(10, relationshipResultsList.size(), 'There should be 10 auto created relationship records.');

        for (Id contactId : relationshipsListByContactId.keySet()){
            System.assertEquals(2, relationshipsListByContactId.get(contactId).size(), 'Each contact should be associated with 1 relationship and 1 reciprocal relationship.');
        }

        for (Relationship__c rel : relationshipsByContactId.values()){
            System.assertEquals(true, relationshipsByContactId.containsKey(rel.RelatedContact__c), 'Each relationship has a corresponding reciprocal relationship record.');
            System.assertEquals(rel.Contact__c, relationshipsByContactId.get(rel.RelatedContact__c).RelatedContact__c, 'The related contact on the reciprocal relationships should match the contact on the current relationship.');
            System.assertEquals('Current', rel.Status__c, 'Relationship status should be Current.');

            if (rel.Type__c.contains('Tester')){
                System.assertEquals(true, contactsById.containsKey(rel.Contact__c), 'Relationship contact should correspond with an inserted contact.');
                System.assertEquals(true, relatedContactsById.containsKey(rel.RelatedContact__c), 'Relationship should be associated with a related contact.');
            } else {
                System.assertEquals(true, relatedContactsById.containsKey(rel.Contact__c), 'Relationship contact should correspond with a related contact.');
                System.assertEquals(true, contactsById.containsKey(rel.RelatedContact__c), 'Relationship should be associated with an inserted contact.');
            }
        }
    }

    /*********************************************************************************************************
     * @description Test to verify that when Relationship Auto Creation is enabled, inserting a Contact record
     * with an Auto Creation mapping, but leaving the corresponding field unpopulated on the contact inserted
     * does not generate any relationships.
     *********************************************************************************************************/
    @isTest
    private static void insertContactWithRelationshipAutoCreateFieldUnpopulated() {
        Relationship_Auto_Create__c contactReportToRelAutoCreate = new Relationship_Auto_Create__c(
            Name = 'ConReportToAutoCreate',
            Object__c = 'Contact',
            Field__c = 'ReportsToId',
            Relationship_Type__c = 'Tester',
            Campaign_Types__c = ''
        );

        insert contactReportToRelAutoCreate;

        List<Relationship_Lookup__c> relationshipLookupsList = new List<Relationship_Lookup__c>();
        Relationship_Lookup__c testerRelationshipLookup = new Relationship_Lookup__c(
            Name = 'Tester',
            Male__c = 'Testee-Male',
            Female__c = 'Testee-Female',
            Neutral__c = 'Testee'
        );

        Relationship_Lookup__c testeeRelationshipLookup = new Relationship_Lookup__c(
            Name = 'Testee',
            Male__c = 'Tester-Male',
            Female__c = 'Tester-Female',
            Neutral__c = 'Tester'
        );

        relationshipLookupsList.add(TesterRelationshipLookup);
        relationshipLookupsList.add(TesteeRelationshipLookup);
        insert relationshipLookupsList;

        List<Contact> contactsList = UTIL_UnitTestData_TEST.getMultipleTestContacts(5);
        for (Integer i = 0; i < contactsList.size(); i++) {
            contactsList[i].FirstName = 'Test';
            contactsList[i].LastName = 'Contact ' + i;
        }

        Test.startTest();
        insert contactsList;
        Test.stopTest();

        Map<Id, Contact> contactsById = new Map<Id, Contact>();
        for (Contact con : contactsList) {
            contactsById.put(con.Id, con);
        }

        List<Relationship__c> relationshipResultsList = [
            SELECT Id, Contact__c, RelatedContact__c, Status__c, Type__c
            FROM Relationship__c
            WHERE Contact__c IN :contactsList OR RelatedContact__c IN :contactsList
        ];

        System.assertEquals(
            true,
            relationshipResultsList.isEmpty(),
            'No relationships should be created when mapped field is not populated.'
        );
    }

    /*********************************************************************************************************
     * @description Test to verify that when Relationship Auto Creation is enabled, inserting a Contact record
     * without populating a mapped Auto Creation field will not generate any relationship records.
     *********************************************************************************************************/
    @isTest
    private static void insertContactWithoutRelationshipAutoCreateFieldPopulated() {
        Relationship_Auto_Create__c contactReportToRelAutoCreate = new Relationship_Auto_Create__c(
            Name = 'ConReportToAutoCreate',
            Object__c = 'Contact',
            Field__c = 'ReportsToId',
            Relationship_Type__c = 'Tester',
            Campaign_Types__c = ''
        );

        insert contactReportToRelAutoCreate;

        List<Relationship_Lookup__c> relationshipLookupsList = new List<Relationship_Lookup__c>();
        Relationship_Lookup__c testerRelationshipLookup = new Relationship_Lookup__c(
            Name = 'Tester',
            Male__c = 'Testee-Male',
            Female__c = 'Testee-Female',
            Neutral__c = 'Testee'
        );

        Relationship_Lookup__c testeeRelationshipLookup = new Relationship_Lookup__c(
            Name = 'Testee',
            Male__c = 'Tester-Male',
            Female__c = 'Tester-Female',
            Neutral__c = 'Tester'
        );

        relationshipLookupsList.add(TesterRelationshipLookup);
        relationshipLookupsList.add(TesteeRelationshipLookup);
        insert relationshipLookupsList;

        List<Contact> contactsList = UTIL_UnitTestData_TEST.getMultipleTestContacts(5);
        for (Integer i = 0; i < contactsList.size(); i++) {
            contactsList[i].FirstName = 'Test';
            contactsList[i].LastName = 'Contact ' + i;
            contactsList[i].ReportsToId = null;
        }

        Test.startTest();
        insert contactsList;
        Test.stopTest();

        Map<Id, Contact> contactsById = new Map<Id, Contact>();
        for (Contact con : contactsList) {
            contactsById.put(con.Id, con);
        }

        List<Relationship__c> relationshipResultsList = [
            SELECT Id, Contact__c, RelatedContact__c, Status__c, Type__c
            FROM Relationship__c
            WHERE Contact__c IN :contactsList OR RelatedContact__c IN :contactsList
        ];

        System.assertEquals(
            true,
            relationshipResultsList.isEmpty(),
            'There should be no auto created relationship records when the auto create mapped field is null.'
        );
    }

    /*********************************************************************************************************
     * @description Test to verify that with Auto-Created Duplicate Relations and Relationship Auto Create
     * enabled, populating an Auto Create mapped field on Contact with the same value multiple times will
     * generate duplicate relationship and reciprocal relationship records.
     * Test Scenario: T-4316903
     *********************************************************************************************************/
    @isTest
    private static void updateContactWithRelationshipAutoCreateDuplicatesAllowed() {
        UTIL_CustomSettings_API.getSettingsForTests(new Hierarchy_Settings__c(Allow_AutoCreated_Duplicates__c = true));

        Relationship_Auto_Create__c contactReportToRelAutoCreate = new Relationship_Auto_Create__c(
            Name = 'ConReportToAutoCreate',
            Object__c = 'Contact',
            Field__c = 'ReportsToId',
            Relationship_Type__c = 'Tester',
            Campaign_Types__c = ''
        );

        insert contactReportToRelAutoCreate;

        List<Relationship_Lookup__c> relationshipLookupsList = new List<Relationship_Lookup__c>();
        Relationship_Lookup__c testerRelationshipLookup = new Relationship_Lookup__c(
            Name = 'Tester',
            Male__c = 'Testee-Male',
            Female__c = 'Testee-Female',
            Neutral__c = 'Testee'
        );

        Relationship_Lookup__c testeeRelationshipLookup = new Relationship_Lookup__c(
            Name = 'Testee',
            Male__c = 'Tester-Male',
            Female__c = 'Tester-Female',
            Neutral__c = 'Tester'
        );

        relationshipLookupsList.add(TesterRelationshipLookup);
        relationshipLookupsList.add(TesteeRelationshipLookup);
        insert relationshipLookupsList;

        List<Contact> relatedContactsList = UTIL_UnitTestData_TEST.getMultipleTestContacts(5);
        for (Integer i = 0; i < relatedContactsList.size(); i++) {
            relatedContactsList[i].FirstName = 'Test';
            relatedContactsList[i].LastName = 'Related ' + i;
        }
        insert relatedContactsList;

        List<Contact> contactsList = UTIL_UnitTestData_TEST.getMultipleTestContacts(5);
        for (Integer i = 0; i < contactsList.size(); i++) {
            contactsList[i].FirstName = 'Test';
            contactsList[i].LastName = 'Contact ' + i;
            contactsList[i].ReportsToId = relatedContactsList[i].Id;
        }

        insert contactsList;

        for (Integer i = 0; i < contactsList.size(); i++) {
            contactsList[i].FirstName = 'Test';
            contactsList[i].LastName = 'Contact ' + i;
            contactsList[i].ReportsToId = null;
        }

        update contactsList;

        for (Integer i = 0; i < contactsList.size(); i++) {
            contactsList[i].FirstName = 'Test';
            contactsList[i].LastName = 'Contact ' + i;
            contactsList[i].ReportsToId = relatedContactsList[i].Id;
        }

        Test.startTest();
        update contactsList;
        Test.stopTest();

        Map<Id, Contact> contactsById = new Map<Id, Contact>();
        for (Contact con : contactsList) {
            contactsById.put(con.Id, con);
        }

        List<Relationship__c> relationshipResultsList = [
            SELECT Id, Contact__c, RelatedContact__c, Status__c, Type__c
            FROM Relationship__c
            WHERE Contact__c IN :contactsList OR Contact__c IN :relatedContactsList
        ];

        Map<Id, TestRelationshipMapper> testRelationshipMapperByContactId = REL_Relationships_Con_TEST.mapRelationshipListsToContact(
            contactsById,
            relationshipResultsList
        );

        for (Id contactId : testRelationshipMapperByContactId.keySet()) {
            List<Relationship__c> testerRelList = testRelationshipMapperByContactId.get(contactId)
                .testerRelationshipsList;
            List<Relationship__c> testeeRelList = testRelationshipMapperByContactId.get(contactId)
                .testeeRelationshipsList;

            Boolean testerRecordsDuplicated =
                (testerRelList[0].Contact__c == testerRelList[1].Contact__c) &&
                (testerRelList[0].RelatedContact__c == testerRelList[1].RelatedContact__c);

            Boolean testeeRecordsDuplicated =
                (testeeRelList[0].Contact__c == testeeRelList[1].Contact__c) &&
                (testeeRelList[0].RelatedContact__c == testeeRelList[1].RelatedContact__c);

            System.assertEquals(
                2,
                testerRelList.size(),
                'Each contact should be associated with 2 Tester relationship records.'
            );
            System.assertEquals(
                2,
                testeeRelList.size(),
                'Each contact should be associated with 2 Testee relationship records.'
            );
            System.assertEquals(true, testerRecordsDuplicated, 'Tester relationship records should be duplicated.');
            System.assertEquals(true, testeeRecordsDuplicated, 'Testee relationship records should be duplicated.');
        }
    }

    /*********************************************************************************************************
     * @description Test to verify that when Relationship Auto Creation is enabled and Auto-Created Duplicate
     * Relations is not, associating a Contact multiple times with the same value for an Auto Creation mapped
     * field only results in a single relationship and reciprocal relationship record.
     * Test Scenario: T-4316901
     *********************************************************************************************************/
    @isTest
    private static void updateContactWithRelationshipAutoCreateDuplicatesNotAllowed() {
        UTIL_CustomSettings_API.getSettingsForTests(new Hierarchy_Settings__c(Allow_AutoCreated_Duplicates__c = false));

        Relationship_Auto_Create__c contactReportToRelAutoCreate = new Relationship_Auto_Create__c(
            Name = 'ConReportToAutoCreate',
            Object__c = 'Contact',
            Field__c = 'ReportsToId',
            Relationship_Type__c = 'Tester',
            Campaign_Types__c = ''
        );

        insert contactReportToRelAutoCreate;

        List<Relationship_Lookup__c> relationshipLookupsList = new List<Relationship_Lookup__c>();
        Relationship_Lookup__c testerRelationshipLookup = new Relationship_Lookup__c(
            Name = 'Tester',
            Male__c = 'Testee-Male',
            Female__c = 'Testee-Female',
            Neutral__c = 'Testee'
        );

        Relationship_Lookup__c testeeRelationshipLookup = new Relationship_Lookup__c(
            Name = 'Testee',
            Male__c = 'Tester-Male',
            Female__c = 'Tester-Female',
            Neutral__c = 'Tester'
        );

        relationshipLookupsList.add(TesterRelationshipLookup);
        relationshipLookupsList.add(TesteeRelationshipLookup);
        insert relationshipLookupsList;

        List<Contact> relatedContactsList = UTIL_UnitTestData_TEST.getMultipleTestContacts(5);
        for (Integer i = 0; i < relatedContactsList.size(); i++) {
            relatedContactsList[i].FirstName = 'Test';
            relatedContactsList[i].LastName = 'Related ' + i;
        }
        insert relatedContactsList;

        List<Contact> contactsList = UTIL_UnitTestData_TEST.getMultipleTestContacts(5);
        for (Integer i = 0; i < contactsList.size(); i++) {
            contactsList[i].FirstName = 'Test';
            contactsList[i].LastName = 'Contact ' + i;
            contactsList[i].ReportsToId = relatedContactsList[i].Id;
        }

        insert contactsList;

        for (Integer i = 0; i < contactsList.size(); i++) {
            contactsList[i].FirstName = 'Test';
            contactsList[i].LastName = 'Contact ' + i;
            contactsList[i].ReportsToId = null;
        }

        update contactsList;

        for (Integer i = 0; i < contactsList.size(); i++) {
            contactsList[i].FirstName = 'Test';
            contactsList[i].LastName = 'Contact ' + i;
            contactsList[i].ReportsToId = relatedContactsList[i].Id;
        }

        Test.startTest();
        update contactsList;
        Test.stopTest();

        Map<Id, Contact> contactsById = new Map<Id, Contact>();
        for (Contact con : contactsList) {
            contactsById.put(con.Id, con);
        }

        List<Relationship__c> relationshipResultsList = [
            SELECT Id, Contact__c, RelatedContact__c, Status__c, Type__c
            FROM Relationship__c
            WHERE Contact__c IN :contactsList OR Contact__c IN :relatedContactsList
        ];

        Map<Id, TestRelationshipMapper> testRelationshipMapperByContactId = REL_Relationships_Con_TEST.mapRelationshipListsToContact(
            contactsById,
            relationshipResultsList
        );

        for (Id contactId : testRelationshipMapperByContactId.keySet()) {
            System.assertEquals(
                1,
                testRelationshipMapperByContactId.get(contactId).testerRelationshipsList.size(),
                'Each contact should only have 1 Tester relationship record.'
            );
            System.assertEquals(
                1,
                testRelationshipMapperByContactId.get(contactId).testeeRelationshipsList.size(),
                'Each contact should only have 1 Testee relationship record.'
            );
        }
    }

    /*********************************************************************************************************
     ********************************************* UNIT TESTS *************************************************
     *********************************************************************************************************/

    /*********************************************************************************************************
     * @description Test method to validate that unsetInsertRecursion() updates the REL_Relationships_Con_TDTM
     * recursion trigger flag from true to false.
     *********************************************************************************************************/
    @isTest
    private static void unsetInsertRecursionTrue() {
        TDTM_ProcessControl.setRecursionFlag(TDTM_ProcessControl.registeredTrigger.REL_Relationships_Con_TDTM, true);

        REL_Relationships_Con_TDTM relConTdtm = new REL_Relationships_Con_TDTM();
        Test.startTest();
        relConTdtm.unsetInsertRecursion();
        Test.stopTest();

        System.assertEquals(
            false,
            TDTM_ProcessControl.getRecursionFlag(TDTM_ProcessControl.registeredTrigger.REL_Relationships_Con_TDTM),
            'Insert recursion trigger should be set to false.'
        );
    }

    /*********************************************************************************************************
     * @description Test method to validate that unsetInsertRecursion() does not change the
     * REL_Relationships_Con_TDTM recursion trigger flag if already set to false.
     *********************************************************************************************************/
    @isTest
    private static void unsetInsertRecursionFalse() {
        TDTM_ProcessControl.setRecursionFlag(TDTM_ProcessControl.registeredTrigger.REL_Relationships_Con_TDTM, false);

        REL_Relationships_Con_TDTM relConTdtm = new REL_Relationships_Con_TDTM();
        Test.startTest();
        relConTdtm.unsetInsertRecursion();
        Test.stopTest();

        System.assertEquals(
            false,
            TDTM_ProcessControl.getRecursionFlag(TDTM_ProcessControl.registeredTrigger.REL_Relationships_Con_TDTM),
            'Insert recursion trigger should remain set to false.'
        );
    }

    /*********************************************************************************************************
     * @description Test method to validate that setInsertRecursion() changes the
     * REL_Relationships_Con_TDTM recursion trigger flag from false to true.
     *********************************************************************************************************/
    @isTest
    private static void setInsertRecursionTrue() {
        TDTM_ProcessControl.setRecursionFlag(TDTM_ProcessControl.registeredTrigger.REL_Relationships_Con_TDTM, false);

        REL_Relationships_Con_TDTM relConTdtm = new REL_Relationships_Con_TDTM();
        Test.startTest();
        relConTdtm.setInsertRecursion();
        Test.stopTest();

        System.assertEquals(
            true,
            TDTM_ProcessControl.getRecursionFlag(TDTM_ProcessControl.registeredTrigger.REL_Relationships_Con_TDTM),
            'Insert recursion trigger should be set to true.'
        );
    }

    /*********************************************************************************************************
     * @description Test method to validate that setInsertRecursion() does not change the
     * REL_Relationships_Con_TDTM recursion trigger flag if already set to true.
     *********************************************************************************************************/
    @isTest
    private static void setInsertRecursionFalse() {
        TDTM_ProcessControl.setRecursionFlag(TDTM_ProcessControl.registeredTrigger.REL_Relationships_Con_TDTM, true);

        REL_Relationships_Con_TDTM relConTdtm = new REL_Relationships_Con_TDTM();
        Test.startTest();
        relConTdtm.setInsertRecursion();
        Test.stopTest();

        System.assertEquals(
            true,
            TDTM_ProcessControl.getRecursionFlag(TDTM_ProcessControl.registeredTrigger.REL_Relationships_Con_TDTM),
            'Insert recursion trigger should remain set to true.'
        );
    }

    /*********************************************************************************************************
     * @description Test method to validate that isInsertRecursion() returns true when the
     * REL_Relationships_Con_TDTM recursion trigger flag is set to true.
     *********************************************************************************************************/
    @isTest
    private static void isInsertRecursionTrue() {
        TDTM_ProcessControl.setRecursionFlag(TDTM_ProcessControl.registeredTrigger.REL_Relationships_Con_TDTM, true);

        REL_Relationships_Con_TDTM relConTdtm = new REL_Relationships_Con_TDTM();
        Test.startTest();
        System.assertEquals(true, relConTdtm.isInsertRecursion(), 'Insert recursion trigger should be true.');
        Test.stopTest();
    }

    /*********************************************************************************************************
     * @description Test method to validate that isInsertRecursion() returns false when the
     * REL_Relationships_Con_TDTM recursion trigger flag is set to false.
     *********************************************************************************************************/
    @isTest
    private static void isInsertRecursionFalse() {
        TDTM_ProcessControl.setRecursionFlag(TDTM_ProcessControl.registeredTrigger.REL_Relationships_Con_TDTM, false);

        REL_Relationships_Con_TDTM relConTdtm = new REL_Relationships_Con_TDTM();
        Test.startTest();
        System.assertEquals(false, relConTdtm.isInsertRecursion(), 'Insert recursion trigger should be false.');
        Test.stopTest();
    }

    /************************************************************************************************************
     * @description Test method to verify that the locateRelationshipAutoCreateService returns an instance of the
     * ContactRelAutoCreateService service class.
     *************************************************************************************************************/
    @isTest
    private static void getInstanceOfRelationshipAutoCreateService() {
        Test.startTest();
        REL_Relationships_Con_TDTM relConTdtm = new REL_Relationships_Con_TDTM();
        ContactRelAutoCreateService srvcConRelAutoCreateInstance = relConTdtm.locateRelationshipAutoCreateService();
        Test.stopTest();

        System.assertEquals(
            true,
            srvcConRelAutoCreateInstance != null,
            'Instance of service class should be retrieved.'
        );
    }

    /************************************************************************************************************
     * @description Test method to verify that the locateRelationshipAutoCreateMapper() returns an instance
     * of the RelAutoCreateSettingsMapper service class.
     *************************************************************************************************************/
    @isTest
    private static void getInstanceOfRelationshipAutoCreateMappingService() {
        Test.startTest();
        REL_Relationships_Con_TDTM relConTdtm = new REL_Relationships_Con_TDTM();
        RelAutoCreateSettingsMapper srvcRelAutoCreateSettingsMapperInstance = relConTdtm.locateRelationshipAutoCreateMapper();
        Test.stopTest();

        System.assertEquals(
            true,
            srvcRelAutoCreateSettingsMapperInstance != null,
            'Instance of service class should be retrieved.'
        );
    }

    /************************************************************************************************************
     * @description Test method to verify that the handleAfterInsert() returns null and does not perform an
     * insert when executed in an Insert Recursion context.
     ************************************************************************************************************/
    @isTest
    private static void handleAfterInsertWithRecursion() {
        TDTM_ProcessControl.setRecursionFlag(TDTM_ProcessControl.registeredTrigger.REL_Relationships_Con_TDTM, true);

        List<Contact> relatedContactsList = new List<Contact>();

        for (Integer i = 0; i < 5; i++) {
            Contact con = new Contact(
                Id = UTIL_UnitTestData_TEST.getFakeId(Contact.SObjectType),
                LastName = 'Testerson',
                ReportsToId = UTIL_UnitTestData_TEST.getFakeId(Contact.SObjectType)
            );
            relatedContactsList.add(con);
        }

        REL_Relationships_Con_TDTM relConTdtm = new REL_Relationships_Con_TDTM();
        Test.startTest();
        System.assertEquals(
            null,
            relConTdtm.handleAfterInsert((List<SObject>) relatedContactsList),
            'Insert logic in insert recursion context should not execute.'
        );
        Test.stopTest();
    }

    /************************************************************************************************************
     * @description Test method to verify that the handleAfterInsert() inserts contacts and does not create
     * relationships when Auto Create is not enabled.
     ************************************************************************************************************/
    @isTest
    private static void handleAfterInsertWithoutAutoCreate() {
        List<Contact> contactsList = UTIL_UnitTestData_TEST.getMultipleTestContacts(5);
        insert contactsList;

        REL_Relationships_Con_TDTM relConTdtm = new REL_Relationships_Con_TDTM();
        Test.startTest();
        relConTdtm.handleAfterInsert((List<SObject>) contactsList);
        Test.stopTest();

        List<Relationship__c> relationshipResultsList = [
            SELECT Id
            FROM Relationship__c
            WHERE Contact__c IN :contactsList OR RelatedContact__c IN :contactsList
        ];

        System.assertEquals(
            true,
            relationshipResultsList.isEmpty(),
            'There should be no relationship records auto created.'
        );
    }

    /************************************************************************************************************
     * @description Test method to verify that the handleAfterInsert() does not create a relationship and
     * reciprocal relationship when Auto Create is enabled, but the mapped field is not populated.
     ************************************************************************************************************/
    @isTest
    private static void handleAfterInsertWithAutoCreateNoFieldPopulated() {
        Relationship_Auto_Create__c contactReportToRelAutoCreate = new Relationship_Auto_Create__c(
            Name = 'ConReportToAutoCreate',
            Object__c = 'Contact',
            Field__c = 'ReportsToId',
            Relationship_Type__c = 'Tester',
            Campaign_Types__c = ''
        );

        insert contactReportToRelAutoCreate;

        List<Relationship_Lookup__c> relationshipLookupsList = new List<Relationship_Lookup__c>();
        Relationship_Lookup__c testerRelationshipLookup = new Relationship_Lookup__c(
            Name = 'Tester',
            Male__c = 'Testee-Male',
            Female__c = 'Testee-Female',
            Neutral__c = 'Testee'
        );

        Relationship_Lookup__c testeeRelationshipLookup = new Relationship_Lookup__c(
            Name = 'Testee',
            Male__c = 'Tester-Male',
            Female__c = 'Tester-Female',
            Neutral__c = 'Tester'
        );

        relationshipLookupsList.add(TesterRelationshipLookup);
        relationshipLookupsList.add(TesteeRelationshipLookup);
        insert relationshipLookupsList;

        Set<Id> fakeContactIdsSet = new Set<Id>();
        List<Contact> contactsList = UTIL_UnitTestData_TEST.getMultipleTestContacts(5);
        for (Contact con : contactsList) {
            Id fakeConId = UTIL_UnitTestData_TEST.getFakeId(Contact.SObjectType);
            fakeContactIdsSet.add(fakeConId);
            con.Id = fakeConId;
            con.ReportsToId = null;
        }

        REL_Relationships_Con_TDTM relConTdtm = new REL_Relationships_Con_TDTM();
        Test.startTest();
        relConTdtm.handleAfterInsert((List<SObject>) contactsList);
        Test.stopTest();

        List<Relationship__c> relationshipResultsList = [
            SELECT Id
            FROM Relationship__c
            WHERE Contact__c IN :fakeContactIdsSet OR RelatedContact__c IN :fakeContactIdsSet
        ];

        System.assertEquals(
            true,
            relationshipResultsList.isEmpty(),
            'There should be no relationship records auto created.'
        );
    }

    /************************************************************************************************************
     * @description Test method to verify that the handleAfterInsert() inserts contacts and creates a relationship
     * and reciprocal relationship when Auto Create is enabled and a mappe field is populated.
     ************************************************************************************************************/
    @isTest
    private static void handleAfterInsertWithAutoCreateFieldPopulated() {
        UTIL_CustomSettings_API.getSettingsForTests(new Hierarchy_Settings__c(Allow_AutoCreated_Duplicates__c = false));

        Relationship_Auto_Create__c contactReportToRelAutoCreate = new Relationship_Auto_Create__c(
            Name = 'ConReportToAutoCreate',
            Object__c = 'Contact',
            Field__c = 'ReportsToId',
            Relationship_Type__c = 'Tester',
            Campaign_Types__c = ''
        );

        insert contactReportToRelAutoCreate;

        List<Relationship_Lookup__c> relationshipLookupsList = new List<Relationship_Lookup__c>();
        Relationship_Lookup__c testerRelationshipLookup = new Relationship_Lookup__c(
            Name = 'Tester',
            Male__c = 'Testee-Male',
            Female__c = 'Testee-Female',
            Neutral__c = 'Testee'
        );

        Relationship_Lookup__c testeeRelationshipLookup = new Relationship_Lookup__c(
            Name = 'Testee',
            Male__c = 'Tester-Male',
            Female__c = 'Tester-Female',
            Neutral__c = 'Tester'
        );

        relationshipLookupsList.add(TesterRelationshipLookup);
        relationshipLookupsList.add(TesteeRelationshipLookup);
        insert relationshipLookupsList;

        List<Contact> relatedContactsList = UTIL_UnitTestData_TEST.getMultipleTestContacts(5);
        for (Integer i = 0; i < relatedContactsList.size(); i++) {
            relatedContactsList[i].FirstName = 'Test';
            relatedContactsList[i].LastName = 'Related ' + i;
        }
        insert relatedContactsList;

        Map<Id, Contact> relatedContactsById = new Map<Id, Contact>();
        for (Contact con : relatedContactsList) {
            relatedContactsById.put(con.Id, con);
        }

        List<Contact> contactsList = UTIL_UnitTestData_TEST.getMultipleTestContacts(5);
        for (Integer i = 0; i < contactsList.size(); i++) {
            contactsList[i].FirstName = 'Test';
            contactsList[i].LastName = 'Contact ' + i;
            contactsList[i].ReportsToId = relatedContactsList[i].Id;
        }

        insert contactsList; // inserts 10 additional relationship records

        Map<Id, Contact> contactsById = new Map<Id, Contact>();
        for (Contact con : contactsList) {
            contactsById.put(con.Id, con);
        }

        REL_Relationships_Con_TDTM relConTdtm = new REL_Relationships_Con_TDTM();
        Test.startTest();
        relConTdtm.handleAfterInsert((List<SObject>) contactsList);
        Test.stopTest();

        List<Relationship__c> relationshipResultsList = [
            SELECT Id, Contact__c, RelatedContact__c, Status__c, Type__c
            FROM Relationship__c
            WHERE Contact__c IN :contactsList OR Contact__c IN :relatedContactsList
        ];

        System.assertEquals(
            20,
            relationshipResultsList.size(),
            '10 Relationship records should be auto created (10 extra created due to test setup).'
        );

        Map<Id, TestRelationshipMapper> testRelationshipMapperByContactId = REL_Relationships_Con_TEST.mapRelationshipListsToContact(
            contactsById,
            relationshipResultsList
        );

        for (Id contactId : testRelationshipMapperByContactId.keySet()) {
            System.assertEquals(
                2,
                testRelationshipMapperByContactId.get(contactId).testerRelationshipsList.size(),
                'Each contact should only have 2 Tester relationship records (1 extra created due to test setup).'
            );
            System.assertEquals(
                2,
                testRelationshipMapperByContactId.get(contactId).testeeRelationshipsList.size(),
                'Each contact should only have 2 Testee relationship records (1 extra created due to test setup).'
            );
        }
    }

    /************************************************************************************************************
     * @description Test to verify that run() creates relationships for contacts inserted with Relationship Auto
     * Create enabled.
     ************************************************************************************************************/
    @isTest
    private static void runAfterInsertWithAutoCreate() {
        UTIL_CustomSettings_API.getSettingsForTests(new Hierarchy_Settings__c(Allow_AutoCreated_Duplicates__c = false));

        Relationship_Auto_Create__c contactReportToRelAutoCreate = new Relationship_Auto_Create__c(
            Name = 'ConReportToAutoCreate',
            Object__c = 'Contact',
            Field__c = 'ReportsToId',
            Relationship_Type__c = 'Tester',
            Campaign_Types__c = ''
        );

        insert contactReportToRelAutoCreate;

        List<Relationship_Lookup__c> relationshipLookupsList = new List<Relationship_Lookup__c>();
        Relationship_Lookup__c testerRelationshipLookup = new Relationship_Lookup__c(
            Name = 'Tester',
            Male__c = 'Testee-Male',
            Female__c = 'Testee-Female',
            Neutral__c = 'Testee'
        );

        Relationship_Lookup__c testeeRelationshipLookup = new Relationship_Lookup__c(
            Name = 'Testee',
            Male__c = 'Tester-Male',
            Female__c = 'Tester-Female',
            Neutral__c = 'Tester'
        );

        relationshipLookupsList.add(TesterRelationshipLookup);
        relationshipLookupsList.add(TesteeRelationshipLookup);
        insert relationshipLookupsList;

        List<Contact> relatedContactsList = UTIL_UnitTestData_TEST.getMultipleTestContacts(5);
        for (Integer i = 0; i < relatedContactsList.size(); i++) {
            relatedContactsList[i].FirstName = 'Test';
            relatedContactsList[i].LastName = 'Related ' + i;
        }
        insert relatedContactsList;

        Map<Id, Contact> relatedContactsById = new Map<Id, Contact>();
        for (Contact con : relatedContactsList) {
            relatedContactsById.put(con.Id, con);
        }

        List<Contact> contactsList = UTIL_UnitTestData_TEST.getMultipleTestContacts(5);
        for (Integer i = 0; i < contactsList.size(); i++) {
            contactsList[i].FirstName = 'Test';
            contactsList[i].LastName = 'Contact ' + i;
            contactsList[i].ReportsToId = relatedContactsList[i].Id;
        }

        insert contactsList; // inserts 10 additional relationship records

        Map<Id, Contact> contactsById = new Map<Id, Contact>();
        for (Contact con : contactsList) {
            contactsById.put(con.Id, con);
        }

        REL_Relationships_Con_TDTM relConTdtm = new REL_Relationships_Con_TDTM();
        TDTM_Runnable.Action triggerAction = TDTM_Runnable.Action.AfterInsert;
        Schema.DescribeSObjectResult objResult = Schema.SObjectType.Contact;

        Test.startTest();
        relConTdtm.run((List<SObject>) contactsList, null, triggerAction, objResult);
        Test.stopTest();

        List<Relationship__c> relationshipResultsList = [
            SELECT Id, Contact__c, RelatedContact__c, Status__c, Type__c
            FROM Relationship__c
            WHERE Contact__c IN :contactsList OR Contact__c IN :relatedContactsList
        ];

        System.assertEquals(
            20,
            relationshipResultsList.size(),
            '10 Relationship records should be auto created (10 extra created due to test setup).'
        );
    }

    /************************************************************************************************************
     * @description Test to verify that run() does not create relationships for contacts inserted with
     * Relationship Auto Create disabled.
     ************************************************************************************************************/
    @isTest
    private static void runAfterInsertWithoutAutoCreate() {
        UTIL_CustomSettings_API.getSettingsForTests(new Hierarchy_Settings__c(Allow_AutoCreated_Duplicates__c = false));

        List<Contact> contactsList = UTIL_UnitTestData_TEST.getMultipleTestContacts(5);
        insert contactsList;

        Map<Id, Contact> contactsById = new Map<Id, Contact>();
        for (Contact con : contactsList) {
            contactsById.put(con.Id, con);
        }

        REL_Relationships_Con_TDTM relConTdtm = new REL_Relationships_Con_TDTM();
        TDTM_Runnable.Action triggerAction = TDTM_Runnable.Action.AfterInsert;
        Schema.DescribeSObjectResult objResult = Schema.SObjectType.Contact;

        Test.startTest();
        relConTdtm.run((List<SObject>) contactsList, null, triggerAction, objResult);
        Test.stopTest();

        List<Relationship__c> relationshipResultsList = [
            SELECT Id, Contact__c, RelatedContact__c, Status__c, Type__c
            FROM Relationship__c
            WHERE Contact__c IN :contactsList OR RelatedContact__c IN :contactsList
        ];

        System.assertEquals(true, relationshipResultsList.isEmpty(), 'No Relationship records should be auto created.');
    }

    /*********************************************************************************************************
     * @description Helper method to generate a map relating a contact to all associated Tester and Testee relationship records.
     * @param  contactsById A map of inserted contacts by Id
     * @param  relationshipsList A list of relationship records to be mapped
     * @return A map of TestRelationshipMapper value objects by Contact Id.
     *********************************************************************************************************/
    private static Map<Id, TestRelationshipMapper> mapRelationshipListsToContact(
        Map<Id, Contact> contactsById,
        List<Relationship__c> relationshipsList
    ) {
        Map<Id, TestRelationshipMapper> testRelationshipMapperByContactId = new Map<Id, TestRelationshipMapper>();

        for (Relationship__c rel : relationshipsList) {
            TestRelationshipMapper testRelMapper;

            if (contactsById.containsKey(rel.Contact__c)) {
                testRelMapper = testRelationshipMapperByContactId.get(rel.Contact__c);

                if (testRelMapper == null) {
                    testRelMapper = new TestRelationshipMapper(rel.Contact__c);
                }
            } else {
                testRelMapper = testRelationshipMapperByContactId.get(rel.relatedContact__c);

                if (testRelMapper == null) {
                    testRelMapper = new TestRelationshipMapper(rel.relatedContact__c);
                }
            }

            testRelMapper.addRelationship(rel);
        }

        return testRelationshipMapperByContactId;
    }

    /*********************************************************************************************************
     * @describe Wrapper class to associate Tester and Testee relationships to a Contact.
     *********************************************************************************************************/
    private class TestRelationshipMapper {
        public Id contactId { get; set; }
        public List<Relationship__c> testerRelationshipsList { get; set; }
        public List<Relationship__c> testeeRelationshipsList { get; set; }

        public TestRelationshipMapper(Id contactId) {
            this.contactId = contactId;
            testerRelationshipsList = new List<Relationship__c>();
            testeeRelationshipsList = new List<Relationship__c>();
        }

        /*********************************************************************************************************
         * @description Adds a new relationship to the Tester or Testee relationship
         * list for a contact based on relationship type.
         * @param  rel A relationship to add.
         *********************************************************************************************************/
        public void addRelationship(Relationship__c rel) {
            if (rel.Type__c.contains('Tester')) {
                testerRelationshipsList.add(rel);
            }

            if (rel.Type__c.contains('Testee')) {
                testeeRelationshipsList.add(rel);
            }
        }
    }
}
public class REL_Relationships_TDTM extends TDTM_Runnable {
    
    @testVisible
    private static Boolean reentrancyPrevented;
    
    /*******************************************************************************************************
    * @description Handles Relationship management.
    * @param newList the list of Relationships from trigger new. 
    * @param oldList the list of Relationships from trigger old. 
    * @param triggerAction which trigger event (BeforeInsert, AfterInsert, etc.). 
    * @param objResult the describe for Relationship.
    * @return dmlWrapper.  
    ********************************************************************************************************/
    public override DmlWrapper run(List<SObject> newList, List<SObject> oldList, 
        TDTM_Runnable.Action triggerAction, Schema.DescribeSObjectResult objResult) {

        if (TDTM_ProcessControl.getRecursionFlag(TDTM_ProcessControl.registeredTrigger.REL_Relationships_TDTM_After_Update)) {
            reentrancyPrevented = true;
            return new DmlWrapper();
        }
    	
    	List<Relationship__c> newListCasted = (newList == null ? new List<Relationship__c>(): (List<Relationship__c>)newList);
        List<Relationship__c> oldListCasted = (oldList == null ? new List<Relationship__c>(): (List<Relationship__c>)oldList);
    	
    	if (triggerAction != TDTM_Runnable.Action.AfterDelete) {
    		return runForRelationships(newListCasted, oldListCasted, triggerAction);
        } else {
        	return runForRelationships(oldListCasted, null, triggerAction);
        }
    }
    
    /*******************************************************************************************************
    * @description Handles Relationship management.
    * @param newList the list of Relationships from trigger new. 
    * @param oldList the list of Relationships from trigger old. 
    * @param triggerAction which trigger event (BeforeInsert, AfterInsert, etc.). 
    * @return dmlWrapper.  
    ********************************************************************************************************/
    private DmlWrapper runForRelationships(List<Relationship__c> newList, List<Relationship__c> oldList, 
        TDTM_Runnable.Action triggerAction) {
    	    
    	DmlWrapper mainWrapper = new DmlWrapper();
    	
        // Relationship List for termination updates
        List<Relationship__c> origrelationships = new List<Relationship__c>();
        List<Relationship__c> relationshipsToCreate = new List<Relationship__c>();
        List<Relationship__c> relationshipsToUpdate = new List<Relationship__c>();
        List<Relationship__c> relationshipsToDelete = new List<Relationship__c>();
        List<Relationship__c> reciprocalsToUpdate = new List<Relationship__c>();

        //Keeps track of relationships that have already been deleted to prevent Entity is Deleted error
        Set<Id> hasBeenDeleted = new Set<Id>();

        if (triggerAction == TDTM_Runnable.Action.AfterDelete) {
            hasBeenDeleted.addAll((new Map<Id, Relationship__c>(newList)).keySet());
        }
        
        Integer i = 0;          // processing counter            
        for (Relationship__c r : newList) {
            // AFTER INSERT
            if (triggerAction == TDTM_Runnable.Action.AfterInsert) {
                if (r.ReciprocalRelationship__c == null) {
                    relationshipsToCreate.add(r);
                } else {
                    reciprocalsToUpdate.add(r);
                }
            }
            
            // AFTER UPDATE
            if (triggerAction == TDTM_Runnable.Action.AfterUpdate) {   
                if (r.ReciprocalRelationship__c == oldList[i].ReciprocalRelationship__c && 
                        r.RelatedContact__c != null) {
                    relationshipsToUpdate.add(r);
                    origRelationships.add(oldList[i]);
                }
                
                if (r.RelatedContact__c == null) {
                    relationshipsToDelete.add(r);
                }
            }

            // AFTER DELETE
            if (triggerAction == TDTM_Runnable.Action.AfterDelete) {
                if (r.ReciprocalRelationship__c != null && !hasBeenDeleted.contains(r.ReciprocalRelationship__c)) {
                    relationshipsToDelete.add(r);
                }
            }

            i++;
        }

        if (relationshipsToCreate.size() > 0) {
        	DmlWrapper wrapper = createRelationship(relationshipsToCreate);
            mainWrapper.objectsToInsert.addAll(wrapper.objectsToInsert);
            mainWrapper.objectsToUpdate.addAll(wrapper.objectsToUpdate);
        }

        if (relationshipsToUpdate.size() > 0) {
            // relationshipsToUpdate is only populated in the AfterUpdate sequence.
            // In this sequence, we're updating reciprocal relationships after the other relationship has been updated.
            // So, let's prevent reentrancy here so that the code doesn't run through for a second time.
            DmlWrapper wrapper = updateRelationship(relationshipsToUpdate, origRelationships);
            TDTM_ProcessControl.setRecursionFlag(TDTM_ProcessControl.registeredTrigger.REL_Relationships_TDTM_After_Update, true);
            TDTM_TriggerHandler.processDML(wrapper, true);
            TDTM_ProcessControl.setRecursionFlag(TDTM_ProcessControl.registeredTrigger.REL_Relationships_TDTM_After_Update, false);
        }
        
        if (reciprocalsToUpdate.size() > 0) {
            DmlWrapper wrapper = reciprocate(reciprocalsToUpdate);
            mainWrapper.objectsToUpdate.addAll(wrapper.objectsToUpdate);
        }
        
        if (relationshipsToDelete.size() > 0) {
            DmlWrapper wrapper = deleteRelationships(relationshipsToDelete);
            mainWrapper.objectsToDelete.addAll(wrapper.objectsToDelete);
        }

        return mainWrapper;
    }

    /*******************************************************************************************************
    * @description Deletes Reciprocal Relationships when a Relationship is deleted
    * @param relationships the list of Relationships that are being deleted
    * @return dmlWrapper 
    ********************************************************************************************************/
    private static DmlWrapper deleteRelationships(List<Relationship__c> relationships) {
    	UTIL_Debug.debug('****Deleting relationships: ' + relationships);
    	DmlWrapper dmlWrapper = new DmlWrapper();
        List<SObject> relationshipsToDelete = new List<SObject>();
        
        for (Relationship__c r : relationships) {
        	Relationship__c relationshipToDelete;
            if (r.ReciprocalRelationship__c != null) {
            	relationshipToDelete = new Relationship__c(Id = r.ReciprocalRelationship__c);
            } else if (r.RelatedContact__c == null) {
            	relationshipToDelete = new Relationship__c(Id = r.Id);
	        }

	        relationshipsToDelete.add(relationshipToDelete);
        }
        
        dmlWrapper.objectsToDelete.addAll(relationshipsToDelete);
        return dmlWrapper;
    }
    
    /*******************************************************************************************************
    * @description Updates the existing Reciprocal Relationships for new Relationship records
    * @param relationships the list of new Relationships
    * @return dmlWrapper 
    ********************************************************************************************************/
    private static DmlWrapper reciprocate(List<Relationship__c> relationships) {
    	DmlWrapper dmlWrapper = new DmlWrapper();
        List<SObject> relationshipsToUpdate = new List<SObject>();
        
        for (Relationship__c r : relationships) {
        	UTIL_Debug.debug('****Updating reciprocal relationship');
            Relationship__c copy = new Relationship__c(Id = r.ReciprocalRelationship__c, 
                                                        ReciprocalRelationship__c = r.Id);
            relationshipsToUpdate.add(copy);
        }
        
        dmlWrapper.objectsToUpdate.addAll(relationshipsToUpdate);
        return dmlWrapper;
    }
    
    /*******************************************************************************************************
    * @description Creates the new Reciprocal Relationships for new Relationship records
    * @param relationships the list of new Relationships
    * @return dmlWrapper 
    ********************************************************************************************************/
    private static DmlWrapper createRelationship(List<Relationship__c> relationships) {
    	
    	DmlWrapper dmlWrapper = new DmlWrapper();
    	
        List<SObject> relationshipsToCreate = new List<SObject>();
                
        for (Relationship__c r : relationships) {
        	UTIL_Debug.debug('****Creating relationship in createRelationship method');
            Relationship__c copy = new Relationship__c();              
            copy.Contact__c = r.RelatedContact__c;
            copy.RelatedContact__c = r.Contact__c;
            copy.Status__c = r.Status__c;
            copy.ReciprocalRelationship__c = r.Id;
            copy.Description__c = r.Description__c;
            copy.SYSTEM_SystemCreated__c = true;
            relationshipsToCreate.add(copy);
        }
        
        //evaluate and add the type
        addType(relationships, relationshipsToCreate);      
        dmlWrapper.objectsToInsert.addAll(relationshipsToCreate);
        
        return dmlWrapper;
    }

    /*******************************************************************************************************
    * @description Updates the Status and/or Type of a Relationship after its reciprocal has been updated
    * @param relationships the list of Reciprocal Relationships that were updated
    * @param oldRelationships the old list of Reciprocal Relationships prior to the update
    * @return dmlWrapper 
    ********************************************************************************************************/
    private static DmlWrapper updateRelationship(List<Relationship__c> relationships, 
            List<Relationship__c> oldRelationships) {
    	
    	DmlWrapper dmlWrapper = new DmlWrapper();
    	
        List<Relationship__c> originalRelationships = new List<Relationship__c>();
        List<SObject> relationshipsTypesToUpdate = new List<SObject>();
        List<SObject> reciprocalsToUpdate = new List<SObject>();
        Integer counter = 0;                                            // processing counter       

        for (Relationship__c r : relationships) {
        	
            //SWA 2009-05-13 removed a duplicate check for change to Status__c from this OR statement
            if ((r.Status__c != oldRelationships[counter].Status__c 
                    || r.Type__c != oldRelationships[counter].Type__c 
                    || r.Description__c != oldRelationships[counter].Description__c) 
                    && r.ReciprocalRelationship__c != null) {
            	
                UTIL_Debug.debug('****Updating relationship in updateRelationship method');
                Relationship__c copy = new Relationship__c(Id = r.ReciprocalRelationship__c);
                
                //SWA 2009-05-13 - only attempt to modify the Contact field if the Related Contact  has changed
                if (oldRelationships[counter].RelatedContact__c != r.RelatedContact__c) {
                    copy.Contact__c = r.RelatedContact__c;
                }

                copy.Status__c = r.Status__c;
                copy.Description__c = r.Description__c;
                
                //only recalculate type on reciprocal if the original type has changed
                if (r.Type__c != oldRelationships[counter].Type__c) {
                    relationshipsTypesToUpdate.add(copy);
                    originalRelationships.add(r);
                } else {
                    reciprocalsToUpdate.add(copy);
                }

            }
            counter++;
        }

        //add type info as needed and update
        if (!originalRelationships.isEmpty() && !relationshipsTypesToUpdate.isEmpty()) {
            addType(originalRelationships, relationshipsTypesToUpdate);
            dmlWrapper.objectsToUpdate.addAll(relationshipsTypesToUpdate);
        }
        
        //update reciprocals without type change
        dmlWrapper.objectsToUpdate.addAll(reciprocalsToUpdate);
        
        return dmlWrapper;
    }
    
    /*******************************************************************************************************
    * @description Updates the Type of a list of Relationships based on the defined settings in the org.
    * @param rList the original list of new or updated Relationships
    * @param rCopy the reciprocals of the original list of new or updated Relationships
    ********************************************************************************************************/
    public static void addType(List<Relationship__c> rList, List<SObject> rCopy) {
        
        Hierarchy_Settings__c rs = UTIL_CustomSettingsFacade.getSettings();
        
        //used for tracking place in array
        Integer counter = 0;            
        
        if (rs.Reciprocal_Method__c == 'List Setting') { 
            List<Relationship_Lookup__c> settings = UTIL_CustomSettingsFacade.getReciprocalSettings().clone();           
            Map<String, Relationship_Lookup__c> rlMap = new Map<String, Relationship_Lookup__c>();
            for (Relationship_Lookup__c setting : settings) {
                rlMap.put(setting.Name, setting);
            }
        
            //remove inactive values
            for (String s : rlMap.keySet()) {
                Relationship_Lookup__c thisRl = rlMap.get(s);
                if (thisRl.Active__c != true) {
                    rlMap.remove(s);
                }
            }
        
            List<Id> rIDs = new List<Id>();
            for (Relationship__c r : rList) {
                rIDs.add(r.Contact__c);
            }            
            
            String queryString = 'SELECT Id, Salutation, Gender__c FROM Contact WHERE Id IN :rIDs';                         
            
            Map<Id, Contact> cMap = new Map<Id, Contact>((List<Contact>)Database.query(queryString));
            
            for (Relationship__c r : rList) {
                
                Relationship__c copy = (Relationship__c)rCopy[counter];

                Contact relatedContact = cMap.get(r.Contact__c);
            
                if (rlMap.containsKey(r.Type__c)) {
                    List<String> maleList = system.label.Male.split(',');                                                                                                        
                    List<String> femaleList = system.label.Female.split(',');
                    
                    Set<String> maleSet = new Set<String>();
                    Set<String> femaleSet = new Set<String>();
                    maleSet.addAll(maleList);
                    femaleSet.addAll(femaleList);                    
                                        
                    //was a gender field defined? 
                    if (relatedContact.Gender__c != null) {
                        String match_type = '';                        
                        
                        //try male
                        for (String s : maleList) {
                            if (relatedContact.Gender__c.toLowerCase() == s.toLowerCase().trim()) {
                                match_type = 'male';
                                break;
                            }
                        }

                        //if we haven't found it, try female
                        if (match_type == '') {
                            for (String s : femaleList) {
                                if (relatedContact.Gender__c.toLowerCase() == s.toLowerCase().trim()) {
                                    match_type = 'female';
                                    break;
                                }
                            }
                        }     
                        
                        if (match_type == 'male' && rlMap.get(r.Type__c).Male__c != null) {
                            copy.Type__c = rlMap.get(r.Type__c).Male__c;
                        } else if (match_type == 'female' && rlMap.get(r.Type__c).Female__c != null) {
                            copy.Type__c = rlMap.get(r.Type__c).Female__c;
                        } else {
                            copy.Type__c = rlMap.get(r.Type__c).Neutral__c;
                        }
                    } else if ((relatedContact.Salutation == 'Mr.' || maleSet.contains(relatedContact.Salutation))  
                            && rlMap.get(r.Type__c).Male__c != null) {
                        copy.Type__c = rlMap.get(r.Type__c).Male__c;
                    } else if (((relatedContact.Salutation == 'Ms.' || relatedContact.Salutation == 'Mrs.') 
                            || femaleSet.contains(relatedContact.Salutation)) && rlMap.get(r.Type__c).Female__c != null) {
                        copy.Type__c = rlMap.get(r.Type__c).Female__c;
                    
                    //can't match up gender, bad field or otherwise
                    } else {
                        copy.Type__c = rlMap.get(r.Type__c).Neutral__c;                     
                    }                                     
                //no matching custom List setting, use provided type
                } else {
                    copy.Type__c = r.Type__c;
                }                
                counter++;
            }            
        } else if (rs.Reciprocal_Method__c == 'Value Inversion') {
            
            for (Relationship__c r : rList) {                           
                //instead lets split the type
                List<String> splitrelationship = r.Type__c.split(system.label.Relationship_Split);
                String newString = '';
                if (splitrelationship.size() > 1)
                    newString = splitrelationship[1] + system.label.Relationship_Split + splitrelationship[0];
                else
                    newString = r.Type__c;
            
                Relationship__c castedObject = (Relationship__c)rCopy[counter];
                castedObject.Type__c = newString;
                counter++;
            }
        } else {
            for (Relationship__c r : rList) {
            	Relationship__c castedObject = (Relationship__c)rCopy[counter];
                castedObject.Type__c = r.Type__c;
                counter++; 
            }   
        }
    }
}
@isTest
private class REL_Relationships_TEST {

    private static Contact c1;//male
    private static Contact c2;//female
    private static Contact c3;//unknown

    /*********************************************************************************************************
    * @description Helper for test methods, creates a Auto Create Relationship settings and Relationship
    * Lookup settings.
    */
    private static void setupRelationshipTestData(Hierarchy_Settings__c rs) {

        //set running user to avoid dml issue
        System.runAs(new User(Id = UserInfo.getUserId())) {

            if (rs != null) {
                UTIL_CustomSettingsFacade.getSettingsForTests(rs);
            } else {
                UTIL_CustomSettingsFacade.getSettingsForTests(new Hierarchy_Settings__c(Reciprocal_Method__c = 'List Setting',
                												                        Store_Errors_On__c = true));
            }

            //add autocreate settings for CMs
            delete [SELECT Id FROM Relationship_Auto_Create__c];
            insert new Relationship_Auto_Create__c(Name = 'AutoCreate', Object__c = 'CampaignMember',
                                                    Field__c = 'ContactId', Relationship_Type__c = 'TestType',
                                                    Campaign_Types__c = 'Other;');

            Relationship_Auto_Create__c contactRelationshipAutoCreate = new Relationship_Auto_Create__c(Name = 'AutoCreate2', 
                                                                                                        Object__c = 'Contact',
                                                                                                        Field__c = 'ReportsToId', 
                                                                                                        Relationship_Type__c = 'TestType');
            insert contactRelationshipAutoCreate;
            
            //add Reciprocal Relationship
            delete [SELECT Id FROM Relationship_Lookup__c];
            insert new Relationship_Lookup__c(Name = 'TestLookupType', Male__c = 'TestMaleType',
                                                Female__c = 'TestFemaleType', Neutral__c = 'TestNeutralType');
            insert new Relationship_Lookup__c(Name = 'TestLookupType2', Male__c = 'TestMaleType2',
                                                Female__c = 'TestFemaleType2', Neutral__c = 'TestNeutralType2',
                                                Active__c = false);

            c1 = new Contact(Salutation = 'Mr.', FirstName = 'Walter_Test', LastName = 'Roosevelt_Test');
            c2 = new Contact(Salutation = 'Mrs.', FirstName = 'Jane_Test', LastName = 'Nixon_Test');
            c3 = new Contact(Salutation = 'Dr.', FirstName = 'Pat_Test', LastName = 'Cleveland_Test');
            insert new List<Contact> {c1, c2, c3};
        }
    }

    /*********************************************************************************************************
    * @description Tests relationships and mirroring
    */
    @isTest
    public static void testContactRel() {
        setupRelationshipTestData(null);

        Relationship__c rel = new Relationship__c(
              Contact__c = c1.Id,
              RelatedContact__c = c2.Id,
              Type__c = 'Friend',
              Status__c = 'Active',
              Description__c = 'notes');
        insert rel;

        System.assert(REL_Relationships_TDTM.reentrancyPrevented != true, 
            'Did not expect the reentrancy check to have prevented the REL_Relationships_TDTM trigger from processing again after an insert.');

        // check that rel gets created
        List<Relationship__c> relList = [SELECT Id, Contact__c, RelatedContact__c, Status__c,
                                          Type__c, ReciprocalRelationship__c
                                          FROM Relationship__c WHERE Id = :rel.Id LIMIT 1];
        // check for mirror rel
        List<Relationship__c> mirrorList = [SELECT Id, Contact__c, RelatedContact__c, Status__c,
                                              Type__c, ReciprocalRelationship__c
                                              FROM Relationship__c WHERE ReciprocalRelationship__c = :relList[0].Id LIMIT 1];


        //reference eachother
        System.assertEquals(relList[0].ReciprocalRelationship__c, mirrorList[0].Id);
        System.assertEquals(mirrorList[0].ReciprocalRelationship__c, relList[0].Id);

        //same types
        System.assertEquals(mirrorList[0].Type__c, 'Friend');
        System.assertEquals(relList[0].Type__c, 'Friend');

        // test changing the relationship
        relList[0].Type__c = 'Colleague';
        relList[0].Description__c = 'test desc';

        Test.startTest();
        update relList[0];
        Test.stopTest();

        System.assert(REL_Relationships_TDTM.reentrancyPrevented == true, 
            'Expected the reentrancy check to have prevented the REL_Relationships_TDTM trigger from processing again after an update.');

        // test change to the rel
        Relationship__c updated_original = [SELECT Id, Description__c, Type__c, ReciprocalRelationship__c
                                              FROM Relationship__c WHERE Id = :relList[0].Id LIMIT 1];

        //original should have updated relationship
        System.assertEquals('Colleague', updated_original.Type__c);
        //original should have updated notes
        System.assertEquals('test desc', updated_original.Description__c);

        Relationship__c updated_mirror = [SELECT Id, Type__c, Description__c, ReciprocalRelationship__c
                                              FROM Relationship__c WHERE ReciprocalRelationship__c = :relList[0].Id LIMIT 1];
        //mirror should have relationship set right
        System.assertEquals('Colleague', updated_mirror.Type__c);
        //mirror should have updated notes
        System.assertEquals('test desc', updated_mirror.Description__c);

        // test deleting the rel
        delete updated_original;
        List<Relationship__c> mirror_after_original_deleted = [SELECT Id
                                                           FROM Relationship__c
                                                           WHERE ReciprocalRelationship__c = :rel.Id];
        //mirror should be deleted as well
        System.assertEquals(0, mirror_after_original_deleted.size());
    }

    /*********************************************************************************************************
    * @description Test method for relationships and deleting the mirror record
    */
    @isTest
    public static void testOrphanedRelDelete() {
        setupRelationshipTestData(null);

        Relationship__c crel = new Relationship__c(Contact__c = c1.Id, RelatedContact__c = c2.Id, Type__c = 'Buddies');
        insert crel;

        // check that rel gets created
        Relationship__c crel_original = [SELECT Id, Description__c, Type__c, ReciprocalRelationship__c
                                        FROM Relationship__c WHERE Id = :crel.Id];
        //relationship should be set right
        System.assertEquals(crel_original.Type__c, 'Buddies');

        // check for mirror rel
        Relationship__c crel_mirror = [SELECT Id, Description__c, ReciprocalRelationship__c, Type__c
                                        FROM Relationship__c WHERE ReciprocalRelationship__c = :crel_original.Id];
        //mirror should reference the original
        System.assertEquals(crel_mirror.ReciprocalRelationship__c, crel_original.Id);
        Test.startTest();
        delete crel_mirror;
        Test.stopTest();

        //original relationship should have been automatically deleted
        List<Relationship__c> orphanedCrel = [SELECT Id FROM Relationship__c WHERE Id = :crel_original.Id];
        System.assertEquals(0, orphanedCrel.size());
    }

    /*********************************************************************************************************
    * @description Test method for deleting the original, should delete the reciprocal
    */
    @isTest
    public static void testRelationshipDelete() {
        setupRelationshipTestData(null);
        Relationship__c crel_original = new Relationship__c(Contact__c = c1.Id, RelatedContact__c = c2.Id,
                                                                Type__c = 'Buddies');
        insert crel_original;

        crel_original = [SELECT Id, Description__c, ReciprocalRelationship__c, Type__c
                                            FROM Relationship__c WHERE Id = :crel_original.Id];
        UTIL_Debug.debug('****Original relationship: ' + crel_original);

        // check mirror rel got created
        Relationship__c crel_mirror = [SELECT Id, Description__c, ReciprocalRelationship__c, Type__c
                                            FROM Relationship__c WHERE ReciprocalRelationship__c = :crel_original.Id];

        UTIL_Debug.debug('****Mirror relationship: ' + crel_mirror);

        //mirror should reference the original
        System.assertEquals(crel_original.Id, crel_mirror.ReciprocalRelationship__c);

        //original should reference mirror
        System.assertEquals(crel_mirror.Id, crel_original.ReciprocalRelationship__c);
        UTIL_Debug.debug('***Original successfully references mirror');

        Test.startTest();
        delete crel_original;
        Test.stopTest();
        system.assertEquals(0, [SELECT count() FROM Relationship__c WHERE Id = :crel_mirror.Id]);
    }

    /*********************************************************************************************************
    * @description Test method for campaign member auto create relationships - reentrancy is prevented
    */
    @isTest
    public static void testCampaignMemberReentrancyCheck() {
        setupRelationshipTestData(null);

        // Install Default HEDA TDTM Configuration
        List<TDTM_Global_API.TdtmToken> defaultTokens = TDTM_Global_API.getDefaultTdtmConfig();
        TDTM_Global_API.setTdtmConfig(defaultTokens, 'hed');

        // Add the Test TDTM for the Relationship object. This Test TDTM will simply update the campaign member that caused the relationship to be inserted.
        // So the flow would be: campaign member updated -> relationship updated -> campaign member updated again
        Trigger_Handler__c newTDTM = new Trigger_Handler__c(Active__c = true, Asynchronous__c = false,
            Class__c = 'UTIL_UnitTestData_TEST.Test_TDTM', Load_Order__c = 1, Object__c = 'Relationship__c',
            Owned_by_Namespace__c = 'hed', Trigger_Action__c = 'AfterInsert;AfterUpdate');
        insert newTDTM;

        //Insert a campaign
        Campaign campaign = new Campaign(Name = 'TestCampaign', IsActive = true, Type = 'Other');
        insert campaign;

        //Insert a campaign member
        CampaignMember cm = new CampaignMember(ContactId = c2.Id, CampaignId = campaign.Id);
        insert cm;

        // Ensure that the campaign member gets updated recursively
        UTIL_UnitTestData_TEST.sObjectsToUpdate = new List<SObject>{ cm };

        Test.startTest();
        // Turn the reentrancy flag on since the class won't actually insert any relationships, so the flag would remain off otherwise.
        TDTM_ProcessControl.setRecursionFlag(TDTM_ProcessControl.registeredTrigger.REL_Relationships_Cm_TDTM, true);
        cm.Status = 'SomethingDifferentForUpdate';
        update cm;
        Test.stopTest();

        System.assert(REL_Relationships_Cm_TDTM.reentrancyPrevented == true, 
            'Expected the reentrancy check to have prevented the REL_Relationships_Cm_TDTM trigger from processing again.');
    }

    /*********************************************************************************************************
    * @description Test method for campaign member auto create relationships on update.
    * We can't do a true test as ContactId is not updatable, but we'll hit the update for coverage.
    */
    @isTest
    public static void testAutoCreateCampaignMemberUpdate() {
        setupRelationshipTestData(null);
        //insert a campaignmember
        Campaign c = new Campaign(Name = 'TestCampaign', IsActive = true);
        insert c;
        CampaignMember cm = new CampaignMember(ContactId = c2.Id, CampaignId = c.Id);
        insert cm;
        //do an update and check that a second relationship set is created for the new Contact
        cm.Status = 'SomethingDifferentForUpdate';
        Test.startTest();
        update cm;
        Test.stopTest();

        System.assertNotEquals('We got here', 'Exception thrown on update');
    }

    /*********************************************************************************************************
    * @description Test method for auto creating relationships based on contact fields on contact insert.
    */
    @isTest
    public static void testAutoCreateContactInsert() {
        setupRelationshipTestData(null);

        //insert a new Contact
        Contact c = new Contact(LastName='ReportingIn', ReportsToId = c1.Id);

        Test.startTest();
        insert c;
        Test.stopTest();

        Relationship__c rel = [SELECT Id, Type__c, RelatedContact__c FROM Relationship__c WHERE Contact__c = :c.Id LIMIT 1];
        system.assertEquals('TestType', rel.Type__c);
        system.assertEquals(c1.Id, rel.RelatedContact__c);

        Relationship__c recRel = [SELECT Id, Type__c, RelatedContact__c, Contact__c FROM Relationship__c WHERE ReciprocalRelationship__c = :rel.Id];
        system.assertEquals('TestType', recRel.Type__c);
        system.assertEquals(c.Id, recRel.RelatedContact__c);
    }

    /*********************************************************************************************************
    * @description Test method for auto creating relationships based on contact fields on contact insert - synchronous.
    */
    @isTest
    public static void testAutoCreateContactInsertSynch() {
        setupRelationshipTestData(new Hierarchy_Settings__c(Reciprocal_Method__c = 'List Setting'));

        //insert a new Contact
        Contact c = new Contact(LastName = 'ReportingIn', ReportsToId = c1.Id);

        Test.startTest();
        insert c;
        Test.stopTest();

        Relationship__c rel = [SELECT Id, Type__c, RelatedContact__c FROM Relationship__c WHERE Contact__c = :c.Id LIMIT 1];
        system.assertEquals('TestType', rel.Type__c);
        system.assertEquals(c1.Id, rel.RelatedContact__c);

        Relationship__c recRel = [SELECT Id, Type__c, RelatedContact__c, Contact__c FROM Relationship__c WHERE ReciprocalRelationship__c = :rel.Id];
        system.assertEquals('TestType', recRel.Type__c);
        system.assertEquals(c.Id, recRel.RelatedContact__c);
    }

    /*********************************************************************************************************
    * @description Test method for auto creating relationships based on contact fields on contact update.
    */
    @isTest
    public static void testAutoCreateContactUpdate() {
        setupRelationshipTestData(null);

        //insert a new Contact
        Contact c = new Contact(LastName = 'ReportingIn', ReportsToId = c1.Id);
        insert c;
        c.ReportsToId = c2.Id;

        Test.startTest();
        update c;
        Test.stopTest();

        Relationship__c rel = [SELECT Id, Type__c, RelatedContact__c FROM Relationship__c WHERE Contact__c = :c.Id and RelatedContact__c = :c2.Id LIMIT 1];
        system.assertEquals('TestType', rel.Type__c);
        system.assertEquals(c2.Id, rel.RelatedContact__c);
    }

    /*********************************************************************************************************
    * @description Test method for auto creating relationships based on contact fields on contact update - reentrancy is prevented.
    */
    @isTest
    public static void testContactUpdateReentrancyPrevented() {
        setupRelationshipTestData(null);

        // Install Default HEDA TDTM Configuration
        List<TDTM_Global_API.TdtmToken> defaultTokens = TDTM_Global_API.getDefaultTdtmConfig();
        TDTM_Global_API.setTdtmConfig(defaultTokens, 'hed');

        // Add the Test TDTM for the Relationship object. This Test TDTM will simply update the contact that caused the relationship to be inserted.
        // So the flow would be: contact updated -> relationship updated -> contact updated again
        Trigger_Handler__c newTDTM = new Trigger_Handler__c(Active__c = true, Asynchronous__c = false,
            Class__c = 'UTIL_UnitTestData_TEST.Test_TDTM', Load_Order__c = 1, Object__c = 'Relationship__c',
            Owned_by_Namespace__c = 'hed', Trigger_Action__c = 'AfterInsert;AfterUpdate');
        insert newTDTM;

        //insert a new Contact
        Contact c = new Contact(LastName = 'ReportingIn', ReportsToId = c1.Id);
        insert c;
        c.ReportsToId = c2.Id;

        // Ensure that the contact gets updated recursively
        UTIL_UnitTestData_TEST.sObjectsToUpdate = new List<SObject>{ c };

        Test.startTest();
        update c;
        Test.stopTest();

        Relationship__c rel = [SELECT Id, Type__c, RelatedContact__c FROM Relationship__c WHERE Contact__c = :c.Id AND RelatedContact__c = :c2.Id LIMIT 1];
        system.assertEquals('TestType', rel.Type__c);
        system.assertEquals(c2.Id, rel.RelatedContact__c);

        System.assert(REL_Relationships_Con_TDTM.reentrancyPrevented == true, 
            'Expected the reentrancy check to have prevented the REL_Relationships_Con_TDTM trigger from processing again.');
    }

    /*********************************************************************************************************
    * @description Test value inversion reciprocal method, verify type.
    */
    @isTest
    public static void testInversionSettingsHaveType() {
        setupRelationshipTestData(new Hierarchy_Settings__c(Reciprocal_Method__c = 'Value Inversion'));

        List<Relationship__c> crel = new List<Relationship__c>{
            new Relationship__c(Contact__c = c1.Id, RelatedContact__c = c2.Id, Type__c = 'Buddies-Friends')
        };

        Test.startTest();
        insert crel;
        Test.stopTest();

        // check that rel gets created
        Relationship__c crel_original = [SELECT Id, Description__c, Type__c, ReciprocalRelationship__c FROM Relationship__c WHERE Id = :crel[0].Id];
        //relationship should be set right
        system.assertEquals(crel_original.Type__c, 'Buddies-Friends');

        // check for mirror rel
        Relationship__c crel_mirror = [SELECT Id, Description__c, ReciprocalRelationship__c, Type__c FROM Relationship__c WHERE ReciprocalRelationship__c = :crel_original.Id];
        //mirror should reference the original
        system.assertEquals(crel_mirror.ReciprocalRelationship__c, crel_original.Id);
        system.assertEquals('Friends-Buddies', crel_mirror.Type__c);
    }

    /*********************************************************************************************************
    * @description Test value inversion reciprocal method, verify type.
    */
    @isTest
    public static void testInversionSettingsNoType() {
        setupRelationshipTestData(new Hierarchy_Settings__c(Reciprocal_Method__c = 'Value Inversion'));

        List<Relationship__c> crel = new List<Relationship__c>{
            new Relationship__c(Contact__c = c1.Id, RelatedContact__c = c2.Id, Type__c = 'BuddiesFriends')
        };

        Test.startTest();
        insert crel;
        Test.stopTest();

        // check that rel gets created
        Relationship__c crel_original = [SELECT Id, Description__c, Type__c, ReciprocalRelationship__c FROM Relationship__c WHERE Id = :crel[0].Id];
        //relationship should be set right
        system.assertEquals(crel_original.Type__c, 'BuddiesFriends');

        // check for mirror rel
        Relationship__c crel_mirror = [SELECT Id, Description__c, ReciprocalRelationship__c, Type__c FROM Relationship__c WHERE ReciprocalRelationship__c = :crel_original.Id];
        //mirror should reference the original
        system.assertEquals(crel_mirror.ReciprocalRelationship__c, crel_original.Id);
        system.assertEquals('BuddiesFriends', crel_mirror.Type__c);
    }

    /*********************************************************************************************************
    * @description Test invalid settings config, verify mirror relationship works correctly
    */
    @isTest
    public static void testNoValidSettingsConfig() {
        setupRelationshipTestData(new Hierarchy_Settings__c(Reciprocal_Method__c = 'BAD_VALUE'));

        List<Relationship__c> crel = new List<Relationship__c>{
            new Relationship__c(Contact__c = c1.Id, RelatedContact__c = c2.Id, Type__c = 'BuddiesFriends')
        };

        Test.startTest();
        insert crel;
        Test.stopTest();

        // check that rel gets created
        Relationship__c crel_original = [SELECT Id, Description__c, Type__c, ReciprocalRelationship__c FROM Relationship__c WHERE Id = :crel[0].Id];
        //relationship should be set right
        system.assertEquals(crel_original.Type__c, 'BuddiesFriends');

        // check for mirror rel
        Relationship__c crel_mirror = [SELECT Id, Description__c, ReciprocalRelationship__c, Type__c FROM Relationship__c WHERE ReciprocalRelationship__c = :crel_original.Id];
        //mirror should reference the original
        system.assertEquals(crel_mirror.ReciprocalRelationship__c, crel_original.Id);
        system.assertEquals('BuddiesFriends', crel_mirror.Type__c);
    }

    /*********************************************************************************************************
    * @description Test male contact (by salutation) gets male relationship type
    */
    @isTest
    public static void testMaleSalutationReciprocal() {
        setupRelationshipTestData(null);
        List<Relationship__c> crel = new List<Relationship__c>{
            new Relationship__c(Contact__c = c1.Id, RelatedContact__c = c2.Id, Type__c = 'TestLookupType')
        };

        Test.startTest();
        insert crel;
        Test.stopTest();

        Relationship__c recRel = [SELECT Id, Type__c FROM Relationship__c WHERE ReciprocalRelationship__c = :crel[0].Id];
        system.assertEquals('TestMaleType', recRel.Type__c);
    }

    /*********************************************************************************************************
    * @description Test female contact (by salutation) gets female relationship type
    */
    @isTest
    public static void testFemaleSalutationReciprocal() {
        setupRelationshipTestData(null);
        List<Relationship__c> crel = new List<Relationship__c>{
            new Relationship__c(Contact__c = c2.Id, RelatedContact__c = c1.Id, Type__c = 'TestLookupType')
        };

        Test.startTest();
        insert crel;
        Test.stopTest();

        Relationship__c recRel = [SELECT Id, Type__c FROM Relationship__c WHERE ReciprocalRelationship__c = :crel[0].Id];
        system.assertEquals('TestFemaleType', recRel.Type__c);
    }

    /*********************************************************************************************************
    * @description Test neutral contact (by salutation) gets neutral relationship type
    */
    @isTest
    public static void testNeutralSalutationReciprocal() {
        setupRelationshipTestData(null);
        List<Relationship__c> crel = new List<Relationship__c>{
            new Relationship__c(Contact__c = c3.Id, RelatedContact__c = c2.Id, Type__c = 'TestLookupType')
        };

        Test.startTest();
        insert crel;
        Test.stopTest();

        Relationship__c recRel = [SELECT Id, Type__c FROM Relationship__c WHERE ReciprocalRelationship__c = :crel[0].Id];
        system.assertEquals('TestNeutralType', recRel.Type__c);
    }

    /*********************************************************************************************************
    * @description Test neutral contact (by gender field) gets neutral relationship type
    */
    @isTest
    public static void testNeutralGenderFieldReciprocal() {
        setupRelationshipTestData(new Hierarchy_Settings__c(Reciprocal_Method__c = 'List Setting'));
        List<Relationship__c> crel = new List<Relationship__c>{
            new Relationship__c(Contact__c = c3.Id, RelatedContact__c = c2.Id, Type__c = 'TestLookupType')
        };
        c3.Gender__c = 'Neutral';
        update c3;

        Test.startTest();
        insert crel;
        Test.stopTest();

        Relationship__c recRel = [SELECT Id, Type__c FROM Relationship__c WHERE ReciprocalRelationship__c = :crel[0].Id];
        system.assertEquals('TestNeutralType', recRel.Type__c);
    }

    /*********************************************************************************************************
    * @description Test male contact (by gender field) gets male relationship type
    */
    @isTest
    public static void testMaleGenderFieldReciprocal() {
        setupRelationshipTestData(new Hierarchy_Settings__c(Reciprocal_Method__c = 'List Setting'));
        c1.Gender__c = 'Male';
        update c1;
        List<Relationship__c> crel = new List<Relationship__c>{
            new Relationship__c(Contact__c = c1.Id, RelatedContact__c = c2.Id, Type__c = 'TestLookupType')
        };

        Test.startTest();
        insert crel;
        Test.stopTest();

        Relationship__c recRel = [SELECT Id, Type__c FROM Relationship__c WHERE ReciprocalRelationship__c = :crel[0].Id];
        system.assertEquals('TestMaleType', recRel.Type__c);
    }

    /*********************************************************************************************************
    * @description Test female contact (by gender field) gets female relationship type
    */
    @isTest
    public static void testFemaleGenderFieldReciprocal() {
        setupRelationshipTestData(new Hierarchy_Settings__c(Reciprocal_Method__c = 'List Setting'));
        c2.Gender__c = 'Female';
        update c2;

        List<Relationship__c> crel = new List<Relationship__c>{
            new Relationship__c(Contact__c = c2.Id, RelatedContact__c = c2.Id, Type__c = 'TestLookupType')
        };

        Test.startTest();
        insert crel;
        Test.stopTest();

        Relationship__c recRel = [SELECT Id, Type__c FROM Relationship__c WHERE ReciprocalRelationship__c = :crel[0].Id];
        system.assertEquals('TestFemaleType', recRel.Type__c);
    }

    /*********************************************************************************************************
    * @description For two contacts with no gender, manually set a gendered relationship. Verify that it stays
    * and that the reciprocal gets the neutral type by default.
    */
    static testMethod void testNoGenderManualRel() {
        setupRelationshipTestData(new Hierarchy_Settings__c(Reciprocal_Method__c = 'List Setting'));

        list<Contact> conList = new list<Contact>{
            new Contact(LastName = 'foo'),
            new Contact(LastName = 'foo2')
        };
        insert conList;

        List<Relationship__c> crel = new List<Relationship__c>{
            new Relationship__c(Contact__c = conList[0].Id, RelatedContact__c = conList[1].Id, Type__c = 'TestLookupType')
        };

        Test.startTest();
        insert crel;
        Test.stopTest();

        Relationship__c recRel = [SELECT Id, Type__c FROM Relationship__c WHERE ReciprocalRelationship__c = :crel[0].Id];
        system.assertEquals('TestNeutralType', recRel.Type__c);

        recRel = [SELECT Id, Type__c FROM Relationship__c WHERE Id = :crel[0].Id];
        system.assertEquals('TestLookupType', recRel.Type__c);
    }

    /*********************************************************************************************************
    * @description For two contacts with no gender, manually set a gendered relationship. Change the status,
    * verify gendered relationship type hasn't changed, but that the status has changed.
    */
    static testMethod void testNoGenderManualRelStatusChange() {
        setupRelationshipTestData(new Hierarchy_Settings__c(Reciprocal_Method__c = 'List Setting'));

        list<Contact> conList = new list<Contact>{
            new Contact(LastName = 'foo'),
            new Contact(LastName = 'foo2')
        };
        insert conList;

        List<Relationship__c> crel = new List<Relationship__c>{
            new Relationship__c(Contact__c = conList[0].Id, RelatedContact__c = conList[1].Id, Type__c = 'TestMaleType')
        };

        Test.startTest();
        insert crel;
        Test.stopTest();

        Relationship__c recRel = [SELECT Id, Type__c FROM Relationship__c WHERE Id = :crel[0].Id];
        system.assertEquals('TestMaleType', recRel.Type__c);

        crel[0].Status__c = 'Former';
        update crel;

        recRel = [SELECT Id, Type__c FROM Relationship__c WHERE Id = :crel[0].Id];
        system.assertEquals('TestMaleType', recRel.Type__c);

        recRel = [SELECT Id, Status__c FROM Relationship__c WHERE ReciprocalRelationship__c = :crel[0].Id];
        system.assertEquals('Former', recRel.Status__c);

        crel[0].Status__c = 'Current';
        update crel;

        recRel = [SELECT Id, Type__c FROM Relationship__c WHERE Id = :crel[0].Id];
        system.assertEquals('TestMaleType', recRel.Type__c);

        recRel = [SELECT Id, Status__c FROM Relationship__c WHERE ReciprocalRelationship__c = :crel[0].Id];
        system.assertEquals('Current', recRel.Status__c);
    }

    /*********************************************************************************************************
    * @description For two contacts with an established relationship, change the gender field of one of the
    * contacts. Verify the relationship's type has changed per the changed gender, and that the reciprocal
    * hasn't changed.
    */
    static testMethod void testGenderChange() {
        setupRelationshipTestData(new Hierarchy_Settings__c(Reciprocal_Method__c = 'List Setting'));

        list<Contact> conList = new list<Contact>{
            new Contact(LastName = 'foo', Gender__c = 'Female'),
            new Contact(LastName = 'foo2', Gender__c = 'Male')
        };
        insert conList;

        List<Relationship__c> crel = new List<Relationship__c>{
            new Relationship__c(Contact__c = conList[0].Id, RelatedContact__c = conList[1].Id, Type__c = 'TestLookupType')
        };

        insert crel;

        Relationship__c recRel = [SELECT Id, Type__c FROM Relationship__c WHERE Id = :crel[0].Id];
        system.assertEquals('TestLookupType', recRel.Type__c);

        recRel = [SELECT Id, Type__c FROM Relationship__c WHERE ReciprocalRelationship__c = :crel[0].Id];
        system.assertEquals('TestFemaleType', recRel.Type__c);

        conList[1].Gender__c='Female';

        Test.startTest();
        update conList[1];
        Test.stopTest();

        recRel = [SELECT Id, Type__c FROM Relationship__c WHERE Id = :crel[0].Id];
        system.assertEquals('TestFemaleType', recRel.Type__c);

        recRel = [SELECT Id, Type__c FROM Relationship__c WHERE ReciprocalRelationship__c = :crel[0].Id];
        system.assertEquals('TestFemaleType', recRel.Type__c);
    }

    /*********************************************************************************************************
    * @description Test error record creation when inserting a relationship with a required field missing.
    */
    @isTest
    public static void testErrorRecordCreation() {
        setupRelationshipTestData(null);

        List<Relationship__c> relationships = new List<Relationship__c>{
            new Relationship__c(Contact__c = c2.Id, Type__c = 'TestLookupType')
        };

        Test.startTest();
        Database.SaveResult[] insertResults = Database.insert(relationships, false);
        Test.stopTest();

        // We catch errors here because TDTM_TriggerHandler no loger processes errors.
        ERR_Handler.Errors errors = ERR_Handler.getErrors(insertResults,relationships);
        ERR_Handler.processErrors(errors.errorRecords, ERR_Handler.Context.REL.name());

        //assert an error - Required fields are missing: [Contact__c]
        //Contact__c is missing from the reciprocal relationship that gets automatically created.
        system.assertEquals(1, [SELECT count() from Error__c]);

        //update relationship - this will create the missing Contact__c field
        relationships[0].RelatedContact__c = c1.Id;
        Database.SaveResult[] updateResults = Database.update(relationships, false);
        system.assertNotEquals(null, relationships[0].Contact__c);

        //get errors
        errors = ERR_Handler.getErrors(updateResults, (List<SObject>)relationships);
        //we still get an error, because of the Related_Contact_Do_Not_Change validation rule on Relationship
        system.assertEquals(true, errors.errorsExist);
        system.assertEquals(1, errors.errorRecords.size());

        //assert no additional error record was created on update
        system.assertEquals(1, [SELECT count() FROM Error__c]);
    }

    /*********************************************************************************************************
    * @description Test method throws an exception for relationships and verifies an error is logged.
    */
    @isTest
    public static void testExceptionRecordCreation() {
        setupRelationshipTestData(null);

        ERR_Handler.processError(new MyException('TestException'), ERR_Handler.Context.REL);
        List<Error__c> errors = [SELECT Full_Message__c FROM Error__c];
        System.assertEquals(1, errors.size());
        System.assertEquals('TestException', errors[0].Full_Message__c);
    }

    /*********************************************************************************************************
    * @description Method to test the UTIL_CustomSettingsFacade class as a different user
    */
    @isTest
    public static void testRelationshipUTILS() {
        //to test the Relationship_Utils class
        System.runAs(new User(Id = UserInfo.getUserId())) {
           Boolean cAuto = REL_Utils.hasContactAutoCreate;
           Boolean cmAuto = REL_Utils.hasCMAutoCreate;
           System.assertEquals(false, cAuto);
           System.assertEquals(false, cmAuto);
        }
    }

    /*********************************************************************************************************
    * @description Test method for inserting two relationships in a single transaction.
    */
    @isTest
    public static void test2Rels1Transaction_v2() {
         // Create three contacts
        Contact mainClient = new Contact(FirstName = 'Main', LastName = 'AAAClient');
        Contact friend = new Contact(FirstName = 'Test', LastName = 'AAAFriend');
        Contact coworker = new Contact(FirstName = 'Test', LastName = 'AAACoworker');
        insert new List<Contact> {mainClient, friend, coworker};

        // Create two relationships
        Relationship__c r1 = new Relationship__c(Contact__c = mainClient.Id, RelatedContact__c = friend.Id, Type__c = 'Friend');
        Relationship__c r2 = new Relationship__c(Contact__c = mainClient.Id, RelatedContact__c = coworker.Id, Type__c = 'Coworker');

        Test.startTest();
        insert new List<Relationship__c> {r1, r2};
        Test.stopTest();

        Relationship__c nr = [SELECT Id, ReciprocalRelationship__c FROM Relationship__c WHERE Id = :r1.Id];
        system.assert(nr.ReciprocalRelationship__c != null);

        Relationship__c nr2 = [SELECT Id, ReciprocalRelationship__c FROM Relationship__c WHERE Id = :r2.Id];
        system.assert(nr2.ReciprocalRelationship__c != null);

        list<Relationship__c> rels = new list<Relationship__c>();
        rels.add(new Relationship__c(Contact__c = mainClient.Id, RelatedContact__c = friend.Id, Type__c = 'Friend2'));
        rels.add(new Relationship__c(Contact__c = mainClient.Id, RelatedContact__c = coworker.Id, Type__c = 'Coworker2'));
        insert rels;
        list<Relationship__c> rels2 = [SELECT Id, ReciprocalRelationship__c FROM Relationship__c WHERE Id = :rels[0].Id OR Id = :rels[1].Id];
        system.assertEquals(2, rels2.size());
        system.assert(rels2[0].ReciprocalRelationship__c != null);
        system.assert(rels2[1].ReciprocalRelationship__c != null);

    }

    /*********************************************************************************************************
    * @description Test method for deleting relationship and reciprocal relationship in a single transaction.
    */
    @isTest
    public static void deleteRelationshipAndReciRelationship() {
        setupRelationshipTestData(null);

        Relationship__c rel = new Relationship__c(Contact__c = c1.Id, relatedContact__c = c2.Id, Type__c = 'Friend');
        insert rel;

        //After insert the relationship, system should create the reciprocal relationship. So, we should have two relationships in the system.
        List<Relationship__c> relList = [SELECT Id FROM Relationship__c];
        system.assertEquals(2, relList.size());

        //now we delete the relationships, this will include relationship we inserted and the corresponding reciprocal relationship
        Test.startTest();
        delete relList;
        Test.stopTest();

        //We should be able to delete all relationship without error
        List<Relationship__c> relRemaining = [SELECT Id FROM Relationship__c];
        system.assertEquals(0, relRemaining.size());
    }

    /*********************************************************************************************************
    * @description Exception
    */
    public class MyException extends Exception{}


    /*********************************************************************************************************
    * @description Test method for campaign member auto create relationships
    */
    @isTest
    public static void testAutoCreateCampaignMemberInsert() {
        setupRelationshipTestData(null);

        //Insert a campaign
        Campaign campaign = new Campaign(Name = 'TestCampaign', IsActive = true, Type = 'Other');
        insert campaign;

        //Insert a campaign member
        CampaignMember cm = new CampaignMember(ContactId = c2.Id, CampaignId = campaign.Id);
        Test.startTest();
        insert cm;
        Test.stopTest();

        //Verify a relationship was automatically created when the campaign member was created
        List<Relationship__c> relationships = [SELECT Id, Type__c FROM Relationship__c
                                        WHERE Contact__c = :c2.Id];
        UTIL_Debug.debug('****Number of relationships after creating campaign member: ' + relationships.size());
        system.assertEquals(2, relationships.size());
        system.assertEquals('TestType', relationships[0].Type__c);

        //Verify a reciprocal relationship was also automatically created when the campaign member was created
        List<Relationship__c> reciprocalRelationships = [SELECT Id, Type__c FROM Relationship__c
                                        WHERE ReciprocalRelationship__c = :relationships[0].Id];
        UTIL_Debug.debug('****Number of reciprocal relationships: ' + reciprocalRelationships);
        system.assertEquals(1, reciprocalRelationships.size());
        system.assertEquals('TestType', reciprocalRelationships[0].Type__c);
    }

    /*********************************************************************************************************
    * @description Test method for campaign member auto create relationships - synchronous
    */
    @isTest
    public static void testAutoCreateCampaignMemberInsertSynch() {
        setupRelationshipTestData(new Hierarchy_Settings__c(Reciprocal_Method__c = 'List Setting'));

        //insert a campaignmember
        Campaign c = new Campaign(Name = 'TestCampaign', IsActive = true, Type = 'Other');
        insert c;
        CampaignMember cm = new CampaignMember(ContactId = c2.Id, CampaignId = c.Id);

        Test.startTest();
        insert cm;
        Test.stopTest();

        Relationship__c rel = [SELECT Id, Type__c FROM Relationship__c WHERE Contact__c = :c2.Id LIMIT 1];
        system.assertEquals('TestType', rel.Type__c);
        Relationship__c recRel = [SELECT Id, Type__c FROM Relationship__c WHERE ReciprocalRelationship__c = :rel.Id];
        system.assertEquals('TestType', recRel.Type__c);
    }

    /*********************************************************************************************************
    * @description Test method for verifying automatic relationship creation won't create a duplicate.
    */
    @isTest
    public static void testAutoCreateDupePrevention() {
        setupRelationshipTestData(null);

        List<Relationship__c> crel = new List<Relationship__c>{
            new Relationship__c(Contact__c = c1.Id, RelatedContact__c = c2.Id, Type__c = 'TestType')
        };
        crel.add(new Relationship__c(Contact__c = c1.Id, RelatedContact__c = c2.Id, Type__c = 'TestType2'));
        insert crel;

        //update the ReportsToId to trigger autocreation
        c1.ReportsToId = c2.Id;

        Test.startTest();
        update c1;
        Test.stopTest();

        //assert we only have one relationship since we've deduped the auto-created one
        List<Relationship__c> rel = [SELECT Id, Type__c, RelatedContact__c FROM Relationship__c WHERE Contact__c = :c1.Id AND Type__c = 'TestType'];
        system.assertEquals('TestType', rel[0].Type__c);
        system.assertEquals(rel.size(), 1);
    }

    /*********************************************************************************************************
    * @description Test method for REL_Utils class when auto create settings exist
    */
    @isTest
    public static void testRelationshipUTILSAutoCreate() {
        System.runAs(new User(Id = UserInfo.getUserId())) {
            insert new Relationship_Auto_Create__c(Name = 'contacttest'+ system.now(),
                                                    Object__c = 'Contact', Field__c = 'coworker__c',
                                                    Relationship_Type__c = 'coworker',
                                                    Campaign_Types__c = 'fun event');
            insert new Relationship_Auto_Create__c(Name = 'membertest'+ system.now(),
                                                    Object__c = 'CampaignMember', Field__c = 'member__c',
                                                    Relationship_Type__c = 'member',
                                                    Campaign_Types__c = 'fun event');

            Boolean cAuto = REL_Utils.hasContactAutoCreate;
            Boolean cmAuto = REL_Utils.hasCMAutoCreate;
            System.assertEquals(true, cAuto);
            System.assertEquals(true, cmAuto);
        }
    }

}
public virtual with sharing class ReciprocalRelHealthCheckVMapper {

    /***************************************************************************
    * @description Instance for Singleton Pattern
    ******************************************************************************/
    @TestVisible
    private static ReciprocalRelHealthCheckVMapper instance;

    /***************************************************************************
    * @description Empty constructor is not public for Singleton Pattern
    ***************************************************************************/
    protected ReciprocalRelHealthCheckVMapper() {}

    /***************************************************************************
    * @description Static method to get the current instance for Singleton
    * pattern
    * @return The instance of ReciprocalRelHealthCheckVMapper.
    ***************************************************************************/
    public static ReciprocalRelHealthCheckVMapper getInstance() {

        if (instance == null) {
            instance = new ReciprocalRelHealthCheckVMapper();
        }

        return instance;
    }

    /***************************************************************************
    * @description Provides comprehensive Health Check Group View Model for
    * Reciprocal Relationship Settings
    * @return The Health Check Group View Model for Reciprocal Relationship
    * Settings
    ***************************************************************************/
    public virtual HealthCheckGroupVModel getHealthCheckGroup() {
        HealthCheckGroupVModel healthCheckGroupVModel = new HealthCheckGroupVModel(
            Label.stgHealthCheckReciprocalRelTitle,
            Label.stgHealthCheckStatusPassed,
            0,
            0,
            new List<String>(),
            new List<HealthCheckItemVModel>()
        );

        List<RelationshipLookupModel> relationshipLookupModelList =
            this.locateRelationshipLookupSettingsService(
            ).getRelationshipLookupModels();

        Map<String,PicklistEntryModel> picklistEntryModelByName =
            this.locatePicklistEntryService(
            ).getModelsByNameForSObjectField(
                Relationship__c.SObjectType,
                Relationship__c.Type__c
            );

        Set<String> duplicateMappingKeys = this.locateRelationshipLookupSettingsService(
            ).getDuplicateRelationshipModelNamesFromList(relationshipLookupModelList);

        for(RelationshipLookupModel relationshipLookupModel : relationshipLookupModelList) {
            HealthCheckGroupVModel relationshipLookupCheckResult =
                this.getRelationshipLookupHealthCheckGroup(
                    relationshipLookupModel,
                    picklistEntryModelByName,
                    duplicateMappingKeys
                );

            healthCheckGroupVModel.passedChecks += 
                relationshipLookupCheckResult.passedChecks;
            healthCheckGroupVModel.totalChecks += 
                relationshipLookupCheckResult.totalChecks;
            
            healthCheckGroupVModel.expandedRowsList.addAll(
                relationshipLookupCheckResult.expandedRowsList
            );
            healthCheckGroupVModel.healthCheckItemList.addAll(
                relationshipLookupCheckResult.healthCheckItemList
            );
        }

        if(healthCheckGroupVModel.passedChecks < healthCheckGroupVModel.totalChecks) {
            healthCheckGroupVModel.status = Label.stgHealthCheckStatusFailed;
        }

        healthCheckGroupVModel.healthCheckItemList.sort();

        return healthCheckGroupVModel;
    }

    /***************************************************************************
    * @description Retrieves the health check for an individual Relationship
    * Lookup Model 
    * @param relationshipLookupModel The relationship lookup model to perform
    * the health check on.
    * @param picklistEntryModelByName The picklist entry model map by value for
    * Relationship__c.Type__c
    * @param duplicateMappingKeys The set of duplicate relationship mapping key
    * values
    * @return The health check for an individual Relationship Lookup Model 
    ***************************************************************************/
    @TestVisible
    protected virtual HealthCheckGroupVModel getRelationshipLookupHealthCheckGroup(
        RelationshipLookupModel relationshipLookupModel,
        Map<String,PicklistEntryModel> picklistEntryModelByName,
        Set<String> duplicateMappingKeys
    ) {
        HealthCheckGroupVModel healthCheckGroupVModel = new HealthCheckGroupVModel(
            '',
            '',
            0,
            0,
            new List<String>(),
            new List<HealthCheckItemVModel>()
        );

        PicklistEntryModel picklistEntryModel =
            picklistEntryModelByName.get(relationshipLookupModel.name);

        HealthCheckItemVModel healthCheckItemVModel =
            this.getHealthCheckItemVModelForRelationshipLookupModel(
                relationshipLookupModel,
                picklistEntryModel
            );

        List<HealthCheckGroupVModel> healthCheckGroupVModelList =
            new List<HealthCheckGroupVModel>();

        healthCheckGroupVModelList.add(
            this.getNameHealthCheckGroup(
                relationshipLookupModel,
                picklistEntryModel
            )
        );
        healthCheckGroupVModelList.add(
            this.getFemaleHealthCheckGroup(
                relationshipLookupModel,
                picklistEntryModelByName
            )
        );
        healthCheckGroupVModelList.add(
            this.getMaleHealthCheckGroup(
                relationshipLookupModel,
                picklistEntryModelByName
            )
        );
        healthCheckGroupVModelList.add(
            this.getNeutralHealthCheckGroup(
                relationshipLookupModel,
                picklistEntryModelByName
            )
        );

        healthCheckGroupVModelList.add(
            this.getUniquenessHealthCheckGroup(
                relationshipLookupModel,
                picklistEntryModel,
                duplicateMappingKeys
            )
        );

        for(HealthCheckGroupVModel healthCheckGroupVModelItem : healthCheckGroupVModelList) {
            healthCheckGroupVModel.passedChecks += healthCheckGroupVModelItem.passedChecks;
            healthCheckGroupVModel.totalChecks += healthCheckGroupVModelItem.totalChecks;
            healthCheckGroupVModel.expandedRowsList.addAll(healthCheckGroupVModelItem.expandedRowsList);
            healthCheckItemVModel.healthCheckItemList.addAll(healthCheckGroupVModelItem.healthCheckItemList);
        }

        if(healthCheckGroupVModel.passedChecks < healthCheckGroupVModel.totalChecks) {
            healthCheckItemVModel.status = 'Fail';
            healthCheckItemVModel.statusLabel = Label.stgHealthCheckStatusFailed;
            healthCheckGroupVModel.expandedRowsList.add(relationshipLookupModel.name);
        }

        healthCheckItemVModel.healthCheckItemList.sort();

        healthCheckGroupVModel.healthCheckItemList.add(healthCheckItemVModel);

        return healthCheckGroupVModel;
    }

    /***************************************************************************
    * @description Retrieves the health check for the Relationship Lookup Model
    * Name
    * @param relationshipLookupModel The relationship lookup model to perform
    * the health check on.
    * @param picklistEntryModel The picklist entry model for the Relationship
    * Lookup Model Name
    * @return The health check for the Relationship Lookup Model Name
    ***************************************************************************/
    @TestVisible
    protected virtual HealthCheckGroupVModel getNameHealthCheckGroup(
        RelationshipLookupModel relationshipLookupModel,
        PicklistEntryModel picklistEntryModel
    ) {
        return this.getHealthCheckGroupForPicklistSetting(
            picklistEntryModel,
            relationshipLookupModel.name,
            '01',
            Label.stgHCReciprocalRelNameTitle,
            Label.stgHCReciprocalRelNameNotFoundFix,
            Label.stgHCReciprocalRelNameInactiveFix
        );
    }

    /***************************************************************************
    * @description Retrieves the health check for the Relationship Lookup Model
    * Female Value
    * @param relationshipLookupModel The relationship lookup model to perform
    * the health check on.
    * @param picklistEntryModelByName The picklist entry model map by value for
    * Relationship__c.Type__c
    * @return The health check for the Relationship Lookup Model Female Value
    ***************************************************************************/
    @TestVisible
    protected virtual HealthCheckGroupVModel getFemaleHealthCheckGroup(
        RelationshipLookupModel relationshipLookupModel,
        Map<String,PicklistEntryModel> picklistEntryModelByName
    ) {

        PicklistEntryModel picklistEntryModel =
            picklistEntryModelByName.get(relationshipLookupModel.femaleValue);

        return this.getHealthCheckGroupForPicklistSetting(
            picklistEntryModel,
            relationshipLookupModel.femaleValue,
            '02',
            Label.stgHCReciprocalRelFemaleTitle,
            Label.stgHCReciprocalRelFemaleNotFoundFix,
            Label.stgHCReciprocalRelFemaleInactiveFix
        );
    }

    /***************************************************************************
    * @description Retrieves the health check for the Relationship Lookup Model
    * Male Value
    * @param relationshipLookupModel The relationship lookup model to perform
    * the health check on.
    * @param picklistEntryModelByName The picklist entry model map by value for
    * Relationship__c.Type__c
    * @return The health check for the Relationship Lookup Model Male Value
    ***************************************************************************/
    @TestVisible
    protected virtual HealthCheckGroupVModel getMaleHealthCheckGroup(
        RelationshipLookupModel relationshipLookupModel,
        Map<String,PicklistEntryModel> picklistEntryModelByName
    ) {
        PicklistEntryModel picklistEntryModel =
            picklistEntryModelByName.get(relationshipLookupModel.maleValue);

        return this.getHealthCheckGroupForPicklistSetting(
            picklistEntryModel,
            relationshipLookupModel.maleValue,
            '03',
            Label.stgHCReciprocalRelMaleTitle,
            Label.stgHCReciprocalRelMaleNotFoundFix,
            Label.stgHCReciprocalRelMaleInactiveFix
        );
    }

    /***************************************************************************
    * @description Retrieves the health check for the Relationship Lookup Model
    * Neutral Value
    * @param relationshipLookupModel The relationship lookup model to perform
    * the health check on.
    * @param picklistEntryModelByName The picklist entry model map by value for
    * Relationship__c.Type__c
    * @return The health check for the Relationship Lookup Model Neutral Value
    ***************************************************************************/
    @TestVisible
    protected virtual HealthCheckGroupVModel getNeutralHealthCheckGroup(
        RelationshipLookupModel relationshipLookupModel,
        Map<String,PicklistEntryModel> picklistEntryModelByName
    ) {
        PicklistEntryModel picklistEntryModel =
            picklistEntryModelByName.get(relationshipLookupModel.neutralValue);

        return this.getHealthCheckGroupForPicklistSetting(
            picklistEntryModel,
            relationshipLookupModel.neutralValue,
            '04',
            Label.stgHCReciprocalRelNeutralTitle,
            Label.stgHCReciprocalRelNeutralNotFoundFix,
            Label.stgHCReciprocalRelNeutralInactiveFix
        );
    }

    /***************************************************************************
    * @description Retrieves the health check for an arbitrary picklist entry
    * model
    * @param picklistEntryModel The picklist entry model to perform the check
    * against
    * @param relationshipLookupModelFieldValue The value from the relationship
    * lookup model to use for the key and label formatting
    * @param indexString The index to use for the key
    * @param settingsLabel The label for the setting of the Health Check
    * @param notFoundFix The fix label for when a picklist entry model is
    * unfound
    * @param inactiveFix The fix label for when a picklist entry model is
    * inactive
    * @return The health check for the picklist entry model
    ***************************************************************************/
    @TestVisible
    protected virtual HealthCheckGroupVModel getHealthCheckGroupForPicklistSetting(
        PicklistEntryModel picklistEntryModel,
        String relationshipLookupModelFieldValue,
        String indexString,
        String settingsLabel,
        String notFoundFix,
        String inactiveFix
    ) {
        HealthCheckGroupVModel healthCheckGroupVModel = new HealthCheckGroupVModel(
            '',
            '',
            0,
            0,
            new List<String>(),
            new List<HealthCheckItemVModel>()
        );
    
        List<String> modelNameListForFormat =
            new List<String>{relationshipLookupModelFieldValue};
    
        String key = relationshipLookupModelFieldValue + indexString;
    
        HealthCheckItemVModel healthCheckItemVModel =
            new healthCheckItemVModel(
                key,
                settingsLabel,
                'Fail',
                Label.stgHealthCheckStatusFailed,
                this.locateStringHandlingService().formatStringWithApostrophesAndParameters(
                    Label.stgHCPicklistValueNotFound,
                    modelNameListForFormat
                ),
                this.locateStringHandlingService().formatStringWithApostrophesAndParameters(
                    notFoundFix,
                    modelNameListForFormat
                ),
                new List<HealthCheckItemVModel>()
            );
    
        healthCheckGroupVModel.totalChecks++;
        healthCheckGroupVModel.healthCheckItemList.add(healthCheckItemVModel);
    
        if(picklistEntryModel == null) {
            return healthCheckGroupVModel;
        }
    
        List<String> picklistLabelAndNameForFormat =
            new List<String>{picklistEntryModel.label,picklistEntryModel.name};
    
        if(picklistEntryModel.isActive == false) {
            healthCheckItemVModel.description =
                this.locateStringHandlingService().formatStringWithApostrophesAndParameters(
                    Label.stgHCPicklistValueInactive, 
                    picklistLabelAndNameForFormat
                );
            healthCheckItemVModel.recommendedFix = 
                this.locateStringHandlingService().formatStringWithApostrophesAndParameters(
                    inactiveFix, 
                    picklistLabelAndNameForFormat
                );
            return healthCheckGroupVModel;
        }
    
        healthCheckItemVModel.status = 'Pass';
        healthCheckItemVModel.statusLabel = Label.stgHealthCheckStatusPassed;
        healthCheckItemVModel.description = this.locateStringHandlingService().formatStringWithApostrophesAndParameters(
                Label.stgHCPicklistValueValid,
                picklistLabelAndNameForFormat
            );
        healthCheckItemVModel.recommendedFix = Label.stgHealthCheckFixNotApplicable;
    
        healthCheckGroupVModel.passedChecks++;
    
        return healthCheckGroupVModel;
    }

    /***************************************************************************
    * @description Retrieves the health check for the Relationship Lookup Model
    * Name Uniqueness
    * @param relationshipLookupModel The relationship lookup model to perform
    * the health check on.
    * @param picklistEntryModelByName The picklist entry model map by value for
    * Relationship__c.Type__c
    * @param duplicateMappingKeys The set of duplicate relationship mapping key
    * values
    * @return The health check for the Relationship Lookup Model Name Uniqueness
    ***************************************************************************/
    @TestVisible
    protected virtual HealthCheckGroupVModel getUniquenessHealthCheckGroup(
        RelationshipLookupModel relationshipLookupModel,
        PicklistEntryModel picklistEntryModel,
        Set<String> duplicateNameSet
    ) {
        HealthCheckGroupVModel healthCheckGroupVModel = new HealthCheckGroupVModel(
            '',
            '',
            0,
            0,
            new List<String>(),
            new List<HealthCheckItemVModel>()
        );
    
        List<String> modelNameListForFormat =
            new List<String>{relationshipLookupModel.name,relationshipLookupModel.name};

        if(picklistEntryModel != null) {
            modelNameListForFormat =
                new List<String>{picklistEntryModel.label,picklistEntryModel.name};
        }
    
        String key = relationshipLookupModel.name + '05';
    
        HealthCheckItemVModel healthCheckItemVModel =
            new healthCheckItemVModel(
                key,
                Label.stgHCReciprocalRelNameUniqueTitle,
                'Fail',
                Label.stgHealthCheckStatusFailed,
                this.locateStringHandlingService().formatStringWithApostrophesAndParameters(
                    Label.stgHCReciprocalRelNameNotUniqueDesc,
                    modelNameListForFormat
                ),
                this.locateStringHandlingService().formatStringWithApostrophesAndParameters(
                    Label.stgHCReciprocalRelNameNotUniqueFix,
                    modelNameListForFormat
                ),
                new List<HealthCheckItemVModel>()
            );
    
        healthCheckGroupVModel.totalChecks++;
        healthCheckGroupVModel.healthCheckItemList.add(healthCheckItemVModel);
    
        if(duplicateNameSet.contains(relationshipLookupModel.name)) {
            return healthCheckGroupVModel;
        }
    
        healthCheckItemVModel.status = 'Pass';
        healthCheckItemVModel.statusLabel = Label.stgHealthCheckStatusPassed;
        healthCheckItemVModel.description = this.locateStringHandlingService().formatStringWithApostrophesAndParameters(
                Label.stgHCReciprocalRelNameUniqueDesc,
                modelNameListForFormat
            );
        healthCheckItemVModel.recommendedFix = Label.stgHealthCheckFixNotApplicable;
    
        healthCheckGroupVModel.passedChecks++;
    
        return healthCheckGroupVModel;
    }

    /***************************************************************************
    * @description Retrieves a formatted HealthCheckItemVModel. 
    * @return A formatted HealthCheckItemVModel.
    ***************************************************************************/
    @TestVisible
    protected virtual HealthCheckItemVModel getHealthCheckItemVModelForRelationshipLookupModel(
        RelationshipLookupModel relationshipLookupModel,
        PicklistEntryModel picklistEntryModel
    ){
        String picklistEntryModelName = relationshipLookupModel.name;

        if(picklistEntryModel != null) {
            picklistEntryModelName = picklistentryModel.name;
        }

        List<String> listForSettingsLabel =
            new List<String>{relationshipLookupModel.name};
        List<String> listForDescriptionLabel =
            new List<String>{relationshipLookupModel.name,picklistEntryModelName};

        return new HealthCheckItemVModel(
            relationshipLookupModel.name,
            this.locateStringHandlingService().formatStringWithApostrophesAndParameters(Label.stgHCReciprocalRelSetting,listForSettingsLabel),
            'Pass',
            Label.stgHealthCheckStatusPassed,
            '',
            '',
            new List<HealthCheckItemVModel>()
        );
    }

    /***************************************************************************
    * @description Retrieves an instance of PicklistEntryService. 
    * @return An instance of PicklistEntryService.
    ***************************************************************************/
    @TestVisible
    private PicklistEntryService locatePicklistEntryService(){
        return PicklistEntryService.getInstance();
    }

    /***************************************************************************
    * @description Retrieves an instance of RelationshipLookupSettingsService. 
    * @return An instance of RelationshipLookupSettingsService.
    ***************************************************************************/
    @TestVisible
    private RelationshipLookupSettingsService locateRelationshipLookupSettingsService(){
        return RelationshipLookupSettingsService.getInstance();
    }

    /***************************************************************************
    * @description Retrieves an instance of StringHandlingService. 
    * @return An instance of StringHandlingService.
    ***************************************************************************/
    @TestVisible
    private StringHandlingService locateStringHandlingService(){
        return StringHandlingService.getInstance();
    }
}
@isTest
private class ReciprocalRelHealthCheckVMapper_TEST {

    /***************************************************************************
    *******************************INSTANCE*************************************
    ***************************************************************************/

    /***************************************************************************
    * @description Test method to verify that the getInstance method returns a
    * new instance of the ReciprocalRelHealthCheckVMapper class when one does
    * not already exist.
    ***************************************************************************/
    @isTest
    private static void getInstanceNew() {

        Test.startTest();
        ReciprocalRelHealthCheckVMapper reciprocalRelHealthCheckVMapperInstance =
            ReciprocalRelHealthCheckVMapper.getInstance();
        Test.stopTest();

        System.assertNotEquals(
            null,
            reciprocalRelHealthCheckVMapperInstance,
            'Instance of view model mapper class should not be null.'
        );

        System.assertEquals(
            ReciprocalRelHealthCheckVMapper.instance,
            reciprocalRelHealthCheckVMapperInstance,
            'Instance of view model mapper class returned should match static instance variable.'
        );
    }

    /***************************************************************************
    * @description Test method to verify that the getInstance method returns the
    * existing instance of the ReciprocalRelHealthCheckVMapper class when one
    * already exists.
    ***************************************************************************/
    @isTest
    private static void getInstanceExisting() {
        ReciprocalRelHealthCheckVMapper expectedReciprocalRelHealthCheckVMapperInstance =
            ReciprocalRelHealthCheckVMapper.getInstance();

        Test.startTest();
            ReciprocalRelHealthCheckVMapper reciprocalRelHealthCheckVMapperInstance =
                ReciprocalRelHealthCheckVMapper.getInstance();
        Test.stopTest();

        System.assertEquals(
            expectedReciprocalRelHealthCheckVMapperInstance,
            reciprocalRelHealthCheckVMapperInstance,
            'Instance of mapper class returned should match cached value.'
        );
    }

    /***************************************************************************
    *************************HEALTH CHECK GROUP/ITEM****************************
    ***************************************************************************/

    /***************************************************************************
    * @description Test method to verify that getHealthCheckGroup handles all
    * passed health checks
    ***************************************************************************/
    @isTest
    private static void getHealthCheckGroupAllPassed() {
        RelationshipLookupSettingsService.instance = 
            new STUB_RelationshipLookupSettingsService();
        PicklistEntryService.instance =
            new STUB_PicklistEntryService();

        STUB_ReciprocalRelHealthCheckVMapper reciprocalRelHealthCheckVMapperStub =
            new STUB_ReciprocalRelHealthCheckVMapper();
        ReciprocalRelHealthCheckVMapper.instance = reciprocalRelHealthCheckVMapperStub;  

        ReciprocalRelHealthCheckVMapper reciprocalRelHealthCheckVMapper =
            ReciprocalRelHealthCheckVMapper.getInstance();

        Integer numberOfHealthChecks = 1;

        Test.startTest();
            HealthCheckGroupVModel healthCheckGroupVModel =
                reciprocalRelHealthCheckVMapperStub.getHealthCheckGroup();
        Test.stopTest();

        System.assertEquals(
            Label.stgHealthCheckReciprocalRelTitle,
            healthCheckGroupVModel.label,
            'Label of returned health check should match expected custom label.'
        );
        System.assertEquals(
            Label.stgHealthCheckStatusPassed,
            healthCheckGroupVModel.status,
            'Status of returned health check should match expected custom label.'
        );
        System.assertEquals(
            numberOfHealthChecks,
            healthCheckGroupVModel.passedChecks,
            'Number of passed checks of returned health check should match expected custom label.'
        );
        System.assertEquals(
            numberOfHealthChecks,
            healthCheckGroupVModel.totalChecks,
            'Number of total checks of returned health check should match expected custom label.'
        );
        System.assertEquals(
            0,
            healthCheckGroupVModel.expandedRowsList.size(),
            'No health checks should fail, making expanded rows list size 0.'
        );
        System.assertEquals(
            1,
            healthCheckGroupVModel.healthCheckItemList.size(),
            'Number of health check items of returned health check should be 1.'
        );
    }

    /***************************************************************************
    * @description Test method to verify that getHealthCheckGroup handles all
    * passed health checks
    ***************************************************************************/
    @isTest
    private static void getHealthCheckGroupAllFail() {
        RelationshipLookupSettingsService.instance = 
            new STUB_RelationshipLookupSettingsUnfound();
        PicklistEntryService.instance =
            new STUB_PicklistEntryService();

        STUB_ReciprocalRelHealthCheckVMapper reciprocalRelHealthCheckVMapperStub =
            new STUB_ReciprocalRelHealthCheckVMapper();
        ReciprocalRelHealthCheckVMapper.instance = reciprocalRelHealthCheckVMapperStub;  

        ReciprocalRelHealthCheckVMapper reciprocalRelHealthCheckVMapper =
            ReciprocalRelHealthCheckVMapper.getInstance();

        Integer numberOfHealthChecks = 1;

        Test.startTest();
            HealthCheckGroupVModel healthCheckGroupVModel =
            reciprocalRelHealthCheckVMapper.getHealthCheckGroup();
        Test.stopTest();

        System.assertEquals(
            Label.stgHealthCheckReciprocalRelTitle,
            healthCheckGroupVModel.label,
            'Label of returned health check should match expected custom label.'
        );
        System.assertEquals(
            Label.stgHealthCheckStatusFailed,
            healthCheckGroupVModel.status,
            'Status of returned health check should match expected custom label.'
        );
        System.assertEquals(
            0,
            healthCheckGroupVModel.passedChecks,
            'Number of passed checks should be 0.'
        );
        System.assertEquals(
            numberOfHealthChecks,
            healthCheckGroupVModel.totalChecks,
            'Number of total checks of returned health check should match expected custom label.'
        );
        System.assertEquals(
            1,
            healthCheckGroupVModel.expandedRowsList.size(),
            'All health checks should fail, making expanded rows list size 1.'
        );
        System.assertEquals(
            1,
            healthCheckGroupVModel.healthCheckItemList.size(),
            'Number of health check items of returned health check should be 1.'
        );
    }

    /***************************************************************************
    * @description Test method to verify that
    * getRelationshipLookupHealthCheckGroup returns the expected passed health
    * check
    ***************************************************************************/
    @isTest
    private static void getRelationshipLookupHealthCheckGroupPass() {
        STUB_RelationshipLookupSettingsService relationshipLookupSettingsServiceStub =
            new STUB_RelationshipLookupSettingsService();
        STUB_PicklistEntryService picklistEntryServiceStub =
            new STUB_PicklistEntryService();

        ReciprocalRelHealthCheckVMapper.instance =
            new STUB_ReciprocalRelHealthCheckVMapperSub();

        ReciprocalRelHealthCheckVMapper reciprocalRelHealthCheckVMapper =
            ReciprocalRelHealthCheckVMapper.getInstance();
 
        List<RelationshipLookupModel> relationshipLookupModelList =
            relationshipLookupSettingsServiceStub.getRelationshipLookupModels();

        Map<String,PicklistEntryModel> picklistEntryModelByName =
            picklistEntryServiceStub.getModelsByNameForSObjectField(
                Relationship__c.SObjectType,
                Relationship__c.Type__c
            );

        Set<String> duplicateMappingKeys = new Set<String>();

        Integer numberOfHealthChecks = 5;

        Test.startTest();
            HealthCheckGroupVModel healthCheckGroupVModel =
                reciprocalRelHealthCheckVMapper.getRelationshipLookupHealthCheckGroup(
                    relationshipLookupModelList[0],
                    picklistEntryModelByName,
                    duplicateMappingKeys
                );
        Test.stopTest();

        System.assertEquals(
            '',
            healthCheckGroupVModel.label,
            'Label should equal expected value of blank'
        );
        System.assertEquals(
            '',
            healthCheckGroupVModel.status,
            'Status should equal expected value of blank'
        );
        System.assertEquals(
            numberOfHealthChecks,
            healthCheckGroupVModel.passedChecks,
            'Passed checks should equal expected value of ' + numberOfHealthChecks
        );
        System.assertEquals(
            numberOfHealthChecks,
            healthCheckGroupVModel.totalChecks,
            'Total checks should equal expected value of ' + numberOfHealthChecks
        );
        System.assertEquals(
            0,
            healthCheckGroupVModel.expandedRowsList.size(),
            'Expanded rows list should have a size of 0'
        );
        System.assertEquals(
            1,
            healthCheckGroupVModel.healthCheckItemList.size(),
            'Health Check Item list should have a size of 1'
        );
    }

    /***************************************************************************
    * @description Test method to verify that
    * getRelationshipLookupHealthCheckGroup returns the expected failed health
    * check
    ***************************************************************************/
    @isTest
    private static void getRelationshipLookupHealthCheckGroupFail() {
        RelationshipLookupSettingsService.instance = 
            new STUB_RelationshipLookupSettingsService();
        PicklistEntryService.instance =
            new STUB_PicklistEntryService();

        ReciprocalRelHealthCheckVMapper.instance =
            new STUB_ReciprocalRelHealthCheckVMapperSub();  
        ReciprocalRelHealthCheckVMapper reciprocalRelHealthCheckVMapper =
            ReciprocalRelHealthCheckVMapper.getInstance();
 
        List<RelationshipLookupModel> relationshipLookupModelList =
            reciprocalRelHealthCheckVMapper.locateRelationshipLookupSettingsService(
            ).getRelationshipLookupModels();

        Map<String,PicklistEntryModel> picklistEntryModelByName =
            new Map<String,PicklistEntryModel>();

        Set<String> duplicateMappingKeys = new Set<String>();

        Integer numberOfHealthChecks = 5;

        Test.startTest();
            HealthCheckGroupVModel healthCheckGroupVModel =
                reciprocalRelHealthCheckVMapper.getRelationshipLookupHealthCheckGroup(
                    relationshipLookupModelList[0],
                    picklistEntryModelByName,
                    duplicateMappingKeys
                );
        Test.stopTest();

        System.assertEquals(
            '',
            healthCheckGroupVModel.label,
            'Label should equal expected value of blank'
        );
        System.assertEquals(
            '',
            healthCheckGroupVModel.status,
            'Status should equal expected value of blank'
        );
        System.assertEquals(
            0,
            healthCheckGroupVModel.passedChecks,
            'Passed checks should equal expected value of 0'
        );
        System.assertEquals(
            numberOfHealthChecks,
            healthCheckGroupVModel.totalChecks,
            'Total checks should equal expected value of ' + numberOfHealthChecks
        );
        System.assertEquals(
            1,
            healthCheckGroupVModel.expandedRowsList.size(),
            'Expanded rows list should have a size of 1'
        );
        System.assertEquals(
            1,
            healthCheckGroupVModel.healthCheckItemList.size(),
            'Health Check Item list should have a size of 1'
        );
    }

    /***************************************************************************
    **********************************NAME**************************************
    ***************************************************************************/

    /***************************************************************************
    * @description Test method to verify that getNameHealthCheckGroup
    * passes with an active picklist entry model for its relationship model's
    * name
    ***************************************************************************/
    @isTest
    private static void getNameHealthCheckGroupPass() {
        ReciprocalRelHealthCheckVMapper reciprocalRelHealthCheckVMapper =
            ReciprocalRelHealthCheckVMapper.getInstance();

        RelationshipLookupModel relationshipLookupModel = 
            new RelationshipLookupModel(
                'testvalue',
                true,
                'testfemalevalue',
                'testmalevalue',
                'testneutralvalue'
            );

        PicklistEntryModel picklistEntryModel = new PicklistEntryModel(
            'testvalue',
            'testlabel',
            true
        );

        Test.startTest();
            HealthCheckGroupVModel healthCheckGroupVModel =
                reciprocalRelHealthCheckVMapper.getNameHealthCheckGroup(
                    relationshipLookupModel,
                    picklistEntryModel
                );
        Test.stopTest();

        ReciprocalRelHealthCheckVMapper_TEST.healthCheckAssertionHelper(
            picklistEntryModel,
            healthCheckGroupVModel,
            1,
            relationshipLookupModel.name,
            '01',
            Label.stgHCReciprocalRelNameTitle,
            'Pass',
            Label.stgHealthCheckStatusPassed,
            Label.stgHCPicklistValueValid,
            Label.stgHealthCheckFixNotApplicable
        );
    }

    /***************************************************************************
    * @description Test method to verify that getNameHealthCheckGroupPass fails
    * with an inactive picklist entry model for its relationship model's name
    ***************************************************************************/
    @isTest
    private static void getNameHealthCheckGroupInactive() {
        ReciprocalRelHealthCheckVMapper reciprocalRelHealthCheckVMapper =
            ReciprocalRelHealthCheckVMapper.getInstance();

        RelationshipLookupModel relationshipLookupModel = 
            new RelationshipLookupModel(
                'testvalue',
                true,
                'testfemalevalue',
                'testmalevalue',
                'testneutralvalue'
            );

        PicklistEntryModel picklistEntryModel = new PicklistEntryModel(
            'testvalue',
            'testlabel',
            false
        );

        Test.startTest();
            HealthCheckGroupVModel healthCheckGroupVModel =
                reciprocalRelHealthCheckVMapper.getNameHealthCheckGroup(
                    relationshipLookupModel,
                    picklistEntryModel
                );
        Test.stopTest();

        ReciprocalRelHealthCheckVMapper_TEST.healthCheckAssertionHelper(
            picklistEntryModel,
            healthCheckGroupVModel,
            0,
            relationshipLookupModel.name,
            '01',
            Label.stgHCReciprocalRelNameTitle,
            'Fail',
            Label.stgHealthCheckStatusFailed,
            Label.stgHCPicklistValueInactive,
            Label.stgHCReciprocalRelNameInactiveFix
        );               
    }

    /***************************************************************************
    * @description Test method to verify that getNameHealthCheckGroupPass fails
    * with an unfound picklist entry model for its relationship model's name
    ***************************************************************************/
    @isTest
    private static void getNameHealthCheckGroupNotFound() {
        ReciprocalRelHealthCheckVMapper reciprocalRelHealthCheckVMapper =
            ReciprocalRelHealthCheckVMapper.getInstance();

        RelationshipLookupModel relationshipLookupModel = 
            new RelationshipLookupModel(
                'testvalue',
                true,
                'testfemalevalue',
                'testmalevalue',
                'testneutralvalue'
            );

        Test.startTest();
            HealthCheckGroupVModel healthCheckGroupVModel =
                reciprocalRelHealthCheckVMapper.getNameHealthCheckGroup(
                    relationshipLookupModel,
                    null
                );
        Test.stopTest();

        ReciprocalRelHealthCheckVMapper_TEST.healthCheckAssertionHelper(
            null,
            healthCheckGroupVModel,
            0,
            relationshipLookupModel.name,
            '01',
            Label.stgHCReciprocalRelNameTitle,
            'Fail',
            Label.stgHealthCheckStatusFailed,
            Label.stgHCPicklistValueNotFound,
            Label.stgHCReciprocalRelNameNotFoundFix
        );
    }

    /***************************************************************************
    *********************************FEMALE*************************************
    ***************************************************************************/

    /***************************************************************************
    * @description Test method to verify that getFemaleHealthCheckGroup
    * passes with an active picklist entry model for its relationship model's
    * female value
    ***************************************************************************/
    @isTest
    private static void getFemaleHealthCheckGroupPass() {
        STUB_PicklistEntryService picklistEntryServiceStub =
            new STUB_PicklistEntryService();

        ReciprocalRelHealthCheckVMapper reciprocalRelHealthCheckVMapper =
            ReciprocalRelHealthCheckVMapper.getInstance();

        Map<String,PicklistEntryModel> picklistEntryModelByName =
            picklistEntryServiceStub.getModelsByNameForSObjectField(
                Relationship__c.SObjectType,
                Relationship__c.Type__c
            );

        RelationshipLookupModel relationshipLookupModel = 
            new RelationshipLookupModel(
                'testvalue',
                true,
                'testfemalevalue',
                'testmalevalue',
                'testneutralvalue'
            );

        Test.startTest();
            HealthCheckGroupVModel healthCheckGroupVModel =
                reciprocalRelHealthCheckVMapper.getFemaleHealthCheckGroup(
                    relationshipLookupModel,
                    picklistEntryModelByName
                );
        Test.stopTest();

        ReciprocalRelHealthCheckVMapper_TEST.healthCheckAssertionHelper(
            picklistEntryModelByName.get('testfemalevalue'),
            healthCheckGroupVModel,
            1,
            relationshipLookupModel.femaleValue,
            '02',
            Label.stgHCReciprocalRelFemaleTitle,
            'Pass',
            Label.stgHealthCheckStatusPassed,
            Label.stgHCPicklistValueValid,
            Label.stgHealthCheckFixNotApplicable
        );
    }

    /***************************************************************************
    * @description Test method to verify that getFemaleHealthCheckGroupPass
    * fails with an inactive picklist entry model for its relationship model's
    * female value
    ***************************************************************************/
    @isTest
    private static void getFemaleHealthCheckGroupInactive() {
        STUB_PicklistEntryServiceInactive picklistEntryServiceStub =
            new STUB_PicklistEntryServiceInactive();

        ReciprocalRelHealthCheckVMapper reciprocalRelHealthCheckVMapper =
            ReciprocalRelHealthCheckVMapper.getInstance();

        Map<String,PicklistEntryModel> picklistEntryModelByName =
            picklistEntryServiceStub.getModelsByNameForSObjectField(
                Relationship__c.SObjectType,
                Relationship__c.Type__c
            );

        RelationshipLookupModel relationshipLookupModel = 
            new RelationshipLookupModel(
                'testvalue',
                true,
                'testfemalevalue',
                'testmalevalue',
                'testneutralvalue'
            );

        Test.startTest();
            HealthCheckGroupVModel healthCheckGroupVModel =
                reciprocalRelHealthCheckVMapper.getFemaleHealthCheckGroup(
                    relationshipLookupModel,
                    picklistEntryModelByName
                );
        Test.stopTest();

        ReciprocalRelHealthCheckVMapper_TEST.healthCheckAssertionHelper(
            picklistEntryModelByName.get('testfemalevalue'),
            healthCheckGroupVModel,
            0,
            relationshipLookupModel.femaleValue,
            '02',
            Label.stgHCReciprocalRelFemaleTitle,
            'Fail',
            Label.stgHealthCheckStatusFailed,
            Label.stgHCPicklistValueInactive,
            Label.stgHCReciprocalRelFemaleInactiveFix
        );               
    }

    /***************************************************************************
    * @description Test method to verify that getFemaleHealthCheckGroupPass
    * fails with an unfound picklist entry model for its relationship model's
    * female value
    ***************************************************************************/
    @isTest
    private static void getFemaleHealthCheckGroupNotFound() {
        ReciprocalRelHealthCheckVMapper reciprocalRelHealthCheckVMapper =
            ReciprocalRelHealthCheckVMapper.getInstance();

        RelationshipLookupModel relationshipLookupModel = 
            new RelationshipLookupModel(
                'testvalue',
                true,
                'testfemalevalue',
                'testmalevalue',
                'testneutralvalue'
            );

        Test.startTest();
            HealthCheckGroupVModel healthCheckGroupVModel =
                reciprocalRelHealthCheckVMapper.getFemaleHealthCheckGroup(
                    relationshipLookupModel,
                    new Map<String,PicklistEntryModel>()
                );
        Test.stopTest();

        ReciprocalRelHealthCheckVMapper_TEST.healthCheckAssertionHelper(
            null,
            healthCheckGroupVModel,
            0,
            relationshipLookupModel.femaleValue,
            '02',
            Label.stgHCReciprocalRelFemaleTitle,
            'Fail',
            Label.stgHealthCheckStatusFailed,
            Label.stgHCPicklistValueNotFound,
            Label.stgHCReciprocalRelFemaleNotFoundFix
        );
    }

    /***************************************************************************
    **********************************MALE**************************************
    ***************************************************************************/

    /***************************************************************************
    * @description Test method to verify that getMaleHealthCheckGroup
    * passes with an active picklist entry model for its relationship model's
    * male value
    ***************************************************************************/
    @isTest
    private static void getMaleHealthCheckGroupPass() {
        STUB_PicklistEntryService picklistEntryServiceStub =
            new STUB_PicklistEntryService();

        ReciprocalRelHealthCheckVMapper reciprocalRelHealthCheckVMapper =
            ReciprocalRelHealthCheckVMapper.getInstance();

        Map<String,PicklistEntryModel> picklistEntryModelByName =
            picklistEntryServiceStub.getModelsByNameForSObjectField(
                Relationship__c.SObjectType,
                Relationship__c.Type__c
            );

        RelationshipLookupModel relationshipLookupModel = 
            new RelationshipLookupModel(
                'testvalue',
                true,
                'testmalevalue',
                'testmalevalue',
                'testneutralvalue'
            );

        Test.startTest();
            HealthCheckGroupVModel healthCheckGroupVModel =
                reciprocalRelHealthCheckVMapper.getMaleHealthCheckGroup(
                    relationshipLookupModel,
                    picklistEntryModelByName
                );
        Test.stopTest();

        ReciprocalRelHealthCheckVMapper_TEST.healthCheckAssertionHelper(
            picklistEntryModelByName.get('testmalevalue'),
            healthCheckGroupVModel,
            1,
            relationshipLookupModel.maleValue,
            '03',
            Label.stgHCReciprocalRelMaleTitle,
            'Pass',
            Label.stgHealthCheckStatusPassed,
            Label.stgHCPicklistValueValid,
            Label.stgHealthCheckFixNotApplicable
        );
    }

    /***************************************************************************
    * @description Test method to verify that getMaleHealthCheckGroupPass
    * fails with an inactive picklist entry model for its relationship model's
    * male value
    ***************************************************************************/
    @isTest
    private static void getMaleHealthCheckGroupInactive() {
        STUB_PicklistEntryServiceInactive picklistEntryServiceStub =
            new STUB_PicklistEntryServiceInactive();

        ReciprocalRelHealthCheckVMapper reciprocalRelHealthCheckVMapper =
            ReciprocalRelHealthCheckVMapper.getInstance();

        Map<String,PicklistEntryModel> picklistEntryModelByName =
            picklistEntryServiceStub.getModelsByNameForSObjectField(
                Relationship__c.SObjectType,
                Relationship__c.Type__c
            );

        RelationshipLookupModel relationshipLookupModel = 
            new RelationshipLookupModel(
                'testvalue',
                true,
                'testmalevalue',
                'testmalevalue',
                'testneutralvalue'
            );

        Test.startTest();
            HealthCheckGroupVModel healthCheckGroupVModel =
                reciprocalRelHealthCheckVMapper.getMaleHealthCheckGroup(
                    relationshipLookupModel,
                    picklistEntryModelByName
                );
        Test.stopTest();

        ReciprocalRelHealthCheckVMapper_TEST.healthCheckAssertionHelper(
            picklistEntryModelByName.get('testmalevalue'),
            healthCheckGroupVModel,
            0,
            relationshipLookupModel.maleValue,
            '03',
            Label.stgHCReciprocalRelMaleTitle,
            'Fail',
            Label.stgHealthCheckStatusFailed,
            Label.stgHCPicklistValueInactive,
            Label.stgHCReciprocalRelMaleInactiveFix
        );               
    }

    /***************************************************************************
    * @description Test method to verify that getMaleHealthCheckGroupPass
    * fails with an unfound picklist entry model for its relationship model's
    * male value
    ***************************************************************************/
    @isTest
    private static void getMaleHealthCheckGroupNotFound() {
        ReciprocalRelHealthCheckVMapper reciprocalRelHealthCheckVMapper =
            ReciprocalRelHealthCheckVMapper.getInstance();

        RelationshipLookupModel relationshipLookupModel = 
            new RelationshipLookupModel(
                'testvalue',
                true,
                'testmalevalue',
                'testmalevalue',
                'testneutralvalue'
            );

        Test.startTest();
            HealthCheckGroupVModel healthCheckGroupVModel =
                reciprocalRelHealthCheckVMapper.getMaleHealthCheckGroup(
                    relationshipLookupModel,
                    new Map<String,PicklistEntryModel>()
                );
        Test.stopTest();

        ReciprocalRelHealthCheckVMapper_TEST.healthCheckAssertionHelper(
            null,
            healthCheckGroupVModel,
            0,
            relationshipLookupModel.maleValue,
            '03',
            Label.stgHCReciprocalRelMaleTitle,
            'Fail',
            Label.stgHealthCheckStatusFailed,
            Label.stgHCPicklistValueNotFound,
            Label.stgHCReciprocalRelMaleNotFoundFix
        );
    }

    /***************************************************************************
    ********************************NEUTRAL*************************************
    ***************************************************************************/

    /***************************************************************************
    * @description Test method to verify that getNeutralHealthCheckGroup
    * passes with an active picklist entry model for its relationship model's
    * neutral value
    ***************************************************************************/
    @isTest
    private static void getNeutralHealthCheckGroupPass() {
        STUB_PicklistEntryService picklistEntryServiceStub =
            new STUB_PicklistEntryService();

        ReciprocalRelHealthCheckVMapper reciprocalRelHealthCheckVMapper =
            ReciprocalRelHealthCheckVMapper.getInstance();

        Map<String,PicklistEntryModel> picklistEntryModelByName =
            picklistEntryServiceStub.getModelsByNameForSObjectField(
                Relationship__c.SObjectType,
                Relationship__c.Type__c
            );

        RelationshipLookupModel relationshipLookupModel = 
            new RelationshipLookupModel(
                'testvalue',
                true,
                'testneutralvalue',
                'testmalevalue',
                'testneutralvalue'
            );

        Test.startTest();
            HealthCheckGroupVModel healthCheckGroupVModel =
                reciprocalRelHealthCheckVMapper.getNeutralHealthCheckGroup(
                    relationshipLookupModel,
                    picklistEntryModelByName
                );
        Test.stopTest();

        ReciprocalRelHealthCheckVMapper_TEST.healthCheckAssertionHelper(
            picklistEntryModelByName.get('testneutralvalue'),
            healthCheckGroupVModel,
            1,
            relationshipLookupModel.neutralValue,
            '04',
            Label.stgHCReciprocalRelNeutralTitle,
            'Pass',
            Label.stgHealthCheckStatusPassed,
            Label.stgHCPicklistValueValid,
            Label.stgHealthCheckFixNotApplicable
        );
    }

    /***************************************************************************
    * @description Test method to verify that getNeutralHealthCheckGroupPass
    * fails with an inactive picklist entry model for its relationship model's
    * neutral value
    ***************************************************************************/
    @isTest
    private static void getNeutralHealthCheckGroupInactive() {
        STUB_PicklistEntryServiceInactive picklistEntryServiceStub =
            new STUB_PicklistEntryServiceInactive();

        ReciprocalRelHealthCheckVMapper reciprocalRelHealthCheckVMapper =
            ReciprocalRelHealthCheckVMapper.getInstance();

        Map<String,PicklistEntryModel> picklistEntryModelByName =
            picklistEntryServiceStub.getModelsByNameForSObjectField(
                Relationship__c.SObjectType,
                Relationship__c.Type__c
            );

        RelationshipLookupModel relationshipLookupModel = 
            new RelationshipLookupModel(
                'testvalue',
                true,
                'testneutralvalue',
                'testmalevalue',
                'testneutralvalue'
            );

        Test.startTest();
            HealthCheckGroupVModel healthCheckGroupVModel =
                reciprocalRelHealthCheckVMapper.getNeutralHealthCheckGroup(
                    relationshipLookupModel,
                    picklistEntryModelByName
                );
        Test.stopTest();

        ReciprocalRelHealthCheckVMapper_TEST.healthCheckAssertionHelper(
            picklistEntryModelByName.get('testneutralvalue'),
            healthCheckGroupVModel,
            0,
            relationshipLookupModel.neutralValue,
            '04',
            Label.stgHCReciprocalRelNeutralTitle,
            'Fail',
            Label.stgHealthCheckStatusFailed,
            Label.stgHCPicklistValueInactive,
            Label.stgHCReciprocalRelNeutralInactiveFix
        );               
    }

    /***************************************************************************
    * @description Test method to verify that getNeutralHealthCheckGroupPass
    * fails with an unfound picklist entry model for its relationship model's
    * neutral value
    ***************************************************************************/
    @isTest
    private static void getNeutralHealthCheckGroupNotFound() {
        ReciprocalRelHealthCheckVMapper reciprocalRelHealthCheckVMapper =
            ReciprocalRelHealthCheckVMapper.getInstance();

        RelationshipLookupModel relationshipLookupModel = 
            new RelationshipLookupModel(
                'testvalue',
                true,
                'testneutralvalue',
                'testmalevalue',
                'testneutralvalue'
            );

        Test.startTest();
            HealthCheckGroupVModel healthCheckGroupVModel =
                reciprocalRelHealthCheckVMapper.getNeutralHealthCheckGroup(
                    relationshipLookupModel,
                    new Map<String,PicklistEntryModel>()
                );
        Test.stopTest();

        ReciprocalRelHealthCheckVMapper_TEST.healthCheckAssertionHelper(
            null,
            healthCheckGroupVModel,
            0,
            relationshipLookupModel.neutralValue,
            '04',
            Label.stgHCReciprocalRelNeutralTitle,
            'Fail',
            Label.stgHealthCheckStatusFailed,
            Label.stgHCPicklistValueNotFound,
            Label.stgHCReciprocalRelNeutralNotFoundFix
        );
    }

    /***************************************************************************
    ******************************PICKLIST HELPER*******************************
    ***************************************************************************/

    /***************************************************************************
    * @description Test method to verify that
    * getHealthCheckGroupForPicklistSetting passes with an active picklist entry
    * model
    ***************************************************************************/
    @isTest
    private static void getHealthCheckGroupForPicklistSettingPass() {
        ReciprocalRelHealthCheckVMapper reciprocalRelHealthCheckVMapper =
            ReciprocalRelHealthCheckVMapper.getInstance();

        PicklistEntryModel picklistEntryModel = new PicklistEntryModel(
            'testvalue',
            'testlabel',
            true
        );

        Test.startTest();
            HealthCheckGroupVModel healthCheckGroupVModel =
                reciprocalRelHealthCheckVMapper.getHealthCheckGroupForPicklistSetting(
                    picklistEntryModel,
                    'value',
                    '01',
                    'settingsLabel',
                    'notFoundFix {0}',
                    'inactiveFix {0} {1}'
                );
        Test.stopTest();

        ReciprocalRelHealthCheckVMapper_TEST.healthCheckAssertionHelper(
            picklistEntryModel,
            healthCheckGroupVModel,
            1,
            'value',
            '01',
            'settingsLabel',
            'Pass',
            Label.stgHealthCheckStatusPassed,
            Label.stgHCPicklistValueValid,
            Label.stgHealthCheckFixNotApplicable
        );
    }

    /***************************************************************************
    * @description Test method to verify that
    * getHealthCheckGroupForPicklistSetting fails with an inactive picklist
    * entry model
    ***************************************************************************/
    @isTest
    private static void getHealthCheckGroupForPicklistSettingInactive() {
        ReciprocalRelHealthCheckVMapper reciprocalRelHealthCheckVMapper =
            ReciprocalRelHealthCheckVMapper.getInstance();

        PicklistEntryModel picklistEntryModel = new PicklistEntryModel(
            'testvalue',
            'testlabel',
            false
        );

        Test.startTest();
            HealthCheckGroupVModel healthCheckGroupVModel =
                reciprocalRelHealthCheckVMapper.getHealthCheckGroupForPicklistSetting(
                    picklistEntryModel,
                    'value',
                    '01',
                    'settingsLabel',
                    'notFoundFix {0}',
                    'inactiveFix {0} {1}'
                );
        Test.stopTest();

        ReciprocalRelHealthCheckVMapper_TEST.healthCheckAssertionHelper(
            picklistEntryModel,
            healthCheckGroupVModel,
            0,
            'value',
            '01',
            'settingsLabel',
            'Fail',
            Label.stgHealthCheckStatusFailed,
            Label.stgHCPicklistValueInactive,
            'inactiveFix {0} {1}'
        );               
    }

    /***************************************************************************
    * @description Test method to verify that
    * getHealthCheckGroupForPicklistSetting fails with an unfound picklist
    * entry model
    ***************************************************************************/
    @isTest
    private static void getHealthCheckGroupForPicklistSettingNotFound() {
        ReciprocalRelHealthCheckVMapper reciprocalRelHealthCheckVMapper =
            ReciprocalRelHealthCheckVMapper.getInstance();

        Test.startTest();
            HealthCheckGroupVModel healthCheckGroupVModel =
                reciprocalRelHealthCheckVMapper.getHealthCheckGroupForPicklistSetting(
                    null,
                    'value',
                    '01',
                    'settingsLabel',
                    'notFoundFix {0}',
                    'inactiveFix {0} {1}'
                );
        Test.stopTest();

        ReciprocalRelHealthCheckVMapper_TEST.healthCheckAssertionHelper(
            null,
            healthCheckGroupVModel,
            0,
            'value',
            '01',
            'settingsLabel',
            'Fail',
            Label.stgHealthCheckStatusFailed,
            Label.stgHCPicklistValueNotFound,
            'notFoundFix {0}'
        );
    }

    /***************************************************************************
    ********************************UNIQUENESS**********************************
    ***************************************************************************/

    /***************************************************************************
    * @description Test method to verify that getUniquenessHealthCheckGroup
    * passes with a unique name
    ***************************************************************************/
    @isTest
    private static void getUniquenessHealthCheckGroupUnique() {
        ReciprocalRelHealthCheckVMapper reciprocalRelHealthCheckVMapper =
            ReciprocalRelHealthCheckVMapper.getInstance();

        RelationshipLookupModel relationshipLookupModel = 
            new RelationshipLookupModel(
                'testvalue',
                true,
                'testfemalevalue',
                'testmalevalue',
                'testneutralvalue'
            );

        PicklistEntryModel picklistEntryModel = new PicklistEntryModel(
            'testvalue',
            'testlabel',
            true
        );

        Set<String> duplicateNameSet = new Set<String>();

        Test.startTest();
            HealthCheckGroupVModel healthCheckGroupVModel =
                reciprocalRelHealthCheckVMapper.getUniquenessHealthCheckGroup(
                    relationshipLookupModel,
                    picklistEntryModel,
                    duplicateNameSet
                );
        Test.stopTest();

        ReciprocalRelHealthCheckVMapper_TEST.healthCheckAssertionHelper(
            picklistEntryModel,
            healthCheckGroupVModel,
            1,
            relationshipLookupModel.name,
            '05',
            Label.stgHCReciprocalRelNameUniqueTitle,
            'Pass',
            Label.stgHealthCheckStatusPassed,
            Label.stgHCReciprocalRelNameUniqueDesc,
            Label.stgHealthCheckFixNotApplicable
        );
    }

    /***************************************************************************
    * @description Test method to verify that getUniquenessHealthCheckGroup
    * passes with a unique name and unfound picklist entry model
    ***************************************************************************/
    @isTest
    private static void getUniquenessHealthCheckGroupUniqueUnfoundPicklist() {
        ReciprocalRelHealthCheckVMapper reciprocalRelHealthCheckVMapper =
            ReciprocalRelHealthCheckVMapper.getInstance();

        RelationshipLookupModel relationshipLookupModel = 
            new RelationshipLookupModel(
                'testvalue',
                true,
                'testfemalevalue',
                'testmalevalue',
                'testneutralvalue'
            );

        Set<String> duplicateNameSet = new Set<String>();

        Test.startTest();
            HealthCheckGroupVModel healthCheckGroupVModel =
                reciprocalRelHealthCheckVMapper.getUniquenessHealthCheckGroup(
                    relationshipLookupModel,
                    null,
                    duplicateNameSet
                );
        Test.stopTest();

        ReciprocalRelHealthCheckVMapper_TEST.healthCheckAssertionHelper(
            null,
            healthCheckGroupVModel,
            1,
            relationshipLookupModel.name,
            '05',
            Label.stgHCReciprocalRelNameUniqueTitle,
            'Pass',
            Label.stgHealthCheckStatusPassed,
            Label.stgHCReciprocalRelNameUniqueDesc,
            Label.stgHealthCheckFixNotApplicable
        );
    }

    /***************************************************************************
    * @description Test method to verify that getUniquenessHealthCheckGroup
    * fails with a duplicate name
    ***************************************************************************/
    @isTest
    private static void getUniquenessHealthCheckGroupDuplicate() {
        ReciprocalRelHealthCheckVMapper reciprocalRelHealthCheckVMapper =
            ReciprocalRelHealthCheckVMapper.getInstance();

        RelationshipLookupModel relationshipLookupModel = 
            new RelationshipLookupModel(
                'testvalue',
                true,
                'testfemalevalue',
                'testmalevalue',
                'testneutralvalue'
            );

        PicklistEntryModel picklistEntryModel = new PicklistEntryModel(
            'testvalue',
            'testlabel',
            true
        );

        Set<String> duplicateNameSet = new Set<String>{'testvalue'};

        Test.startTest();
            HealthCheckGroupVModel healthCheckGroupVModel =
                reciprocalRelHealthCheckVMapper.getUniquenessHealthCheckGroup(
                    relationshipLookupModel,
                    picklistEntryModel,
                    duplicateNameSet
                );
        Test.stopTest();

        ReciprocalRelHealthCheckVMapper_TEST.healthCheckAssertionHelper(
            picklistEntryModel,
            healthCheckGroupVModel,
            0,
            relationshipLookupModel.name,
            '05',
            Label.stgHCReciprocalRelNameUniqueTitle,
            'Fail',
            Label.stgHealthCheckStatusFailed,
            Label.stgHCReciprocalRelNameNotUniqueDesc,
            Label.stgHCReciprocalRelNameNotUniqueFix
        );
    }

    /***************************************************************************
    * @description Test method to verify that getUniquenessHealthCheckGroup
    * fails with a duplicate name and unfound picklist entry model
    ***************************************************************************/
    @isTest
    private static void getUniquenessHealthCheckGroupDuplicateUnfoundPicklist() {
        ReciprocalRelHealthCheckVMapper reciprocalRelHealthCheckVMapper =
            ReciprocalRelHealthCheckVMapper.getInstance();

        RelationshipLookupModel relationshipLookupModel = 
            new RelationshipLookupModel(
                'testvalue',
                true,
                'testfemalevalue',
                'testmalevalue',
                'testneutralvalue'
            );

        Set<String> duplicateNameSet = new Set<String>{'testvalue'};

        Test.startTest();
            HealthCheckGroupVModel healthCheckGroupVModel =
                reciprocalRelHealthCheckVMapper.getUniquenessHealthCheckGroup(
                    relationshipLookupModel,
                    null,
                    duplicateNameSet
                );
        Test.stopTest();

        ReciprocalRelHealthCheckVMapper_TEST.healthCheckAssertionHelper(
            null,
            healthCheckGroupVModel,
            0,
            relationshipLookupModel.name,
            '05',
            Label.stgHCReciprocalRelNameUniqueTitle,
            'Fail',
            Label.stgHealthCheckStatusFailed,
            Label.stgHCReciprocalRelNameNotUniqueDesc,
            Label.stgHCReciprocalRelNameNotUniqueFix
        );
    }

    /***************************************************************************
    ****************************LOCATORS AND HELPERS***************************
    ***************************************************************************/

    /***************************************************************************
    * @description Test method to verify that a formatted HealthCheckItemVModel
    * is returned
    ***************************************************************************/
    @isTest 
    private static void getHealthCheckItemVModelForRelationshipLookupModel(){
        ReciprocalRelHealthCheckVMapper reciprocalRelHealthCheckVMapper =
            ReciprocalRelHealthCheckVMapper.getInstance();

        RelationshipLookupModel relationshipLookupModel = 
            new RelationshipLookupModel(
                'testvalue',
                true,
                'testfemalevalue',
                'testmalevalue',
                'testneutralvalue'
            );

        PicklistEntryModel picklistEntryModel = new PicklistEntryModel(
            'testvalue',
            'testlabel',
            false
        );

        Test.startTest();
            HealthCheckItemVModel healthCheckItemVModel =
                reciprocalRelHealthCheckVMapper.getHealthCheckItemVModelForRelationshipLookupModel(
                    relationshipLookupModel,
                    picklistEntryModel
                );
        Test.stopTest();

        List<String> listForSettingsLabel =
            new List<String>{relationshipLookupModel.name,relationshipLookupModel.name};
        List<String> listForDescriptionLabel =
            new List<String>{relationshipLookupModel.name,picklistEntryModel.name};

        System.assertEquals(
            relationshipLookupModel.name,
            healthCheckItemVModel.key,
            'Health Check Item View Model key should equal the relationship lookup model name.'
        );
        System.assertEquals(
            String.format(Label.stgHCReciprocalRelSetting,listForSettingsLabel),
            healthCheckItemVModel.setting,
            'Health Check Item View Model setting should equal the formatted expected label.'
            );
        System.assertEquals(
            'Pass',
            healthCheckItemVModel.status,
            'The Health Check Item\'s status should status should be Pass.'
        );
        System.assertEquals(
            Label.stgHealthCheckStatusPassed,
            healthCheckItemVModel.statusLabel,
            'Health Check Item View Model status should equal the expected label.'
        );
        System.assertEquals(
            '',
            healthCheckItemVModel.description,
            'Health Check Item View Model description should equal the expected formatted label.'
        );
        System.assertEquals(
            '',
            healthCheckItemVModel.recommendedFix,
            'Health Check Item View Model recommended fix should be blank.'
        );
        System.assertEquals(
            true,
            healthCheckItemVModel.healthCheckItemList.isEmpty(),
            'Health Check Item View Model health check item list should be empty.'
        );
    }

    /***************************************************************************
    * @description Test method to verify that a PicklistEntryService is
    * retrieved by the locator method.
    ***************************************************************************/
    @isTest 
    private static void locatePicklistEntryService(){
        PicklistEntryService expectedPicklistEntryService
            = PicklistEntryService.getInstance();

        ReciprocalRelHealthCheckVMapper reciprocalRelHealthCheckVMapper =
            ReciprocalRelHealthCheckVMapper.getInstance();

        Test.startTest();
            PicklistEntryService picklistEntryService
                = reciprocalRelHealthCheckVMapper.locatePicklistEntryService();
        Test.stopTest();

        System.assertNotEquals(
            null,
            picklistEntryService,
            'Instance of service class should not be null.'
        );

        System.assertEquals(
            expectedPicklistEntryService,
            picklistEntryService,
            'Instance of service class from view model mapper should match the singleton instance.'
        );
    }

    /***************************************************************************
    * @description Test method to verify that a
    * RelationshipLookupSettingsService is retrieved by the locator method.
    ***************************************************************************/
    @isTest 
    private static void locateRelationshipLookupSettingsService(){
        RelationshipLookupSettingsService expectedRelationshipLookupSettingsService
            = RelationshipLookupSettingsService.getInstance();

        ReciprocalRelHealthCheckVMapper reciprocalRelHealthCheckVMapper =
            ReciprocalRelHealthCheckVMapper.getInstance();

        Test.startTest();
            RelationshipLookupSettingsService relationshipLookupSettingsService
                = reciprocalRelHealthCheckVMapper.locateRelationshipLookupSettingsService();
        Test.stopTest();

        System.assertNotEquals(
            null,
            relationshipLookupSettingsService,
            'Instance of service class should not be null.'
        );

        System.assertEquals(
            expectedRelationshipLookupSettingsService,
            relationshipLookupSettingsService,
            'Instance of service class from view model mapper should match the singleton instance.'
        );
    }

    /***************************************************************************
    * @description Test method to verify that a
    * StringHandlingService is retrieved by the locator method.
    ***************************************************************************/
    @isTest 
    private static void locateStringHandlingService(){
        StringHandlingService expectedStringHandlingService
            = StringHandlingService.getInstance();

        ReciprocalRelHealthCheckVMapper reciprocalRelHealthCheckVMapper =
            ReciprocalRelHealthCheckVMapper.getInstance();

        Test.startTest();
            StringHandlingService StringHandlingService
                = reciprocalRelHealthCheckVMapper.locateStringHandlingService();
        Test.stopTest();

        System.assertNotEquals(
            null,
            StringHandlingService,
            'Instance of service class should not be null.'
        );

        System.assertEquals(
            expectedStringHandlingService,
            StringHandlingService,
            'Instance of service class from view model mapper should match the singleton instance.'
        );
    }

    /***************************************************************************
    *******************************TEST HELPERS*********************************
    ***************************************************************************/

    /***************************************************************************
    * @description A helper method to steamline standardized picklist value
    * assertions and reduce eye strain.
    ***************************************************************************/
    private static void healthCheckAssertionHelper(
        PicklistEntryModel picklistEntryModel,
        HealthCheckGroupVModel healthCheckGroupVModel,
        Integer passedChecks,
        String picklistName,
        String picklistIndex,
        String setting,
        String status,
        String statusLabel,
        String description,
        String recommendedFix
    ) {
        System.assertEquals(
            passedChecks,
            healthCheckGroupVModel.passedChecks,
            'The Health Check Group View Model should have ' + passedChecks + ' passed check(s).'
        );
        System.assertEquals(
            1,
            healthCheckGroupVModel.totalChecks,
            'The Health Check Group View Model should have 1 total check.'
        );
        System.assertEquals(
            0,
            healthCheckGroupVModel.expandedRowsList.size(),
            'The Health Check Group View Model should have 0 expanded rows.'
        );
        System.assertEquals(
            1,
            healthCheckGroupVModel.healthCheckItemList.size(),
            'The Health Check Group View Model should have 1 health check item.'
        );

        HealthCheckItemVModel healthCheckItemVModel =
            healthCheckGroupVModel.healthCheckItemList[0];
        List<String> labelAndNameForFormat = new List<String>{picklistName,picklistName};

        if(picklistEntryModel != null) {
            labelAndNameForFormat = new List<String>{picklistEntryModel.label,picklistEntryModel.name};
        }

        System.assertEquals(
            picklistName + picklistIndex,
            healthCheckItemVModel.key,
            'The Health Check Item\'s key should match the relationship lookup model\'s name.'
        );
        System.assertEquals(
            setting,
            healthCheckItemVModel.setting,
            'The Health Check Item\'s setting should match the specified label.'
            );
        System.assertEquals(
            status,
            healthCheckItemVModel.status,
            'The Health Check Item\'s status should status should be ' + status + '.'
        );
        System.assertEquals(
            statusLabel,
            healthCheckItemVModel.statusLabel,
            'The Health Check Item\'s status label should match the specified label.'
        );
        System.assertEquals(
            StringHandlingService.getInstance().formatStringWithApostrophesAndParameters(
                description,
                labelAndNameForFormat
            ),
            healthCheckItemVModel.description,
            'The Health Check Item\'s description should match the specified label.'
        );
        System.assertEquals(
            StringHandlingService.getInstance().formatStringWithApostrophesAndParameters(
                recommendedFix,
                labelAndNameForFormat
            ),
            healthCheckItemVModel.recommendedFix,
            'The Health Check Item\'s recommended fix should match the specified label.'
        );
    }

    /***************************************************************************
    *********************************STUBS**************************************
    ***************************************************************************/

    /***************************************************************************
    * @description Stub class to simulate the response from
    * ReciprocalRelHealthCheckVMapper to control
    * getRelationshipLookupHealthCheckGroup
    ***************************************************************************/
    private class STUB_ReciprocalRelHealthCheckVMapper extends ReciprocalRelHealthCheckVMapper {
        protected override HealthCheckGroupVModel getRelationshipLookupHealthCheckGroup(
            RelationshipLookupModel relationshipLookupModel,
            Map<String,PicklistEntryModel> picklistEntryModelByName,
            Set<String> duplicateMappingKeys
        ) {
            HealthCheckGroupVModel healthCheckGroupVModel = new HealthCheckGroupVModel(
                '',
                '',
                0,
                0,
                new List<String>(),
                new List<HealthCheckItemVModel>()
            );

            PicklistEntryModel picklistEntryModel =
                picklistEntryModelByName.get(relationshipLookupModel.name);
    
            HealthCheckItemVModel healthCheckItemVModel = 
                this.getHealthCheckItemVModelForRelationshipLookupModel(
                    relationshipLookupModel,
                    picklistEntryModel
                );

            healthCheckGroupVModel.totalChecks += 1;

            if(picklistEntryModel != null) {
                healthCheckGroupVModel.passedChecks += 1;
            }

            if(healthCheckGroupVModel.passedChecks < healthCheckGroupVModel.totalChecks) {
                healthCheckItemVModel.status = 'Fail';
                healthCheckItemVModel.statusLabel = Label.stgHealthCheckStatusFailed;
                healthCheckGroupVModel.expandedRowsList.add(relationshipLookupModel.name);
            }
    
            healthCheckItemVModel.healthCheckItemList.sort();
    
            healthCheckGroupVModel.healthCheckItemList.add(healthCheckItemVModel);

            return healthCheckGroupVModel;
        }
    }

    /***************************************************************************
    * @description Stub class to simulate the response from
    * ReciprocalRelHealthCheckVMapper to control individual health check methods
    * for success or failure
    ***************************************************************************/
    private class STUB_ReciprocalRelHealthCheckVMapperSub extends ReciprocalRelHealthCheckVMapper {
        protected override HealthCheckGroupVModel getHealthCheckGroupForPicklistSetting(
            PicklistEntryModel picklistEntryModel,
            String relationshipLookupModelFieldValue,
            String indexString,
            String settingsLabel,
            String notFoundFix,
            String inactiveFix
        ) {
            return this.mockCheck(picklistEntryModel);
        }

        protected override HealthCheckGroupVModel getUniquenessHealthCheckGroup(
            RelationshipLookupModel relationshipLookupModel,
            PicklistEntryModel picklistEntryModel,
            Set<String> duplicateNameSet
        ) {
            return this.mockCheck(picklistEntryModel);
        }

        private HealthCheckGroupVModel mockCheck(PicklistEntryModel picklistEntryModel) {
            HealthCheckGroupVModel healthCheckGroupVModel = new HealthCheckGroupVModel(
                '',
                '',
                0,
                0,
                new List<String>(),
                new List<HealthCheckItemVModel>()
            );
    
            HealthCheckItemVModel healthCheckItemVModel =
                new healthCheckItemVModel(
                    'Mock',
                    'MockSetting',
                    'Pass',
                    'MockStatusLabel',
                    'MockDescription',
                    'MockRecommendedFix',
                    new List<HealthCheckItemVModel>()
                );

            healthCheckGroupVModel.totalChecks += 1;

            if(picklistEntryModel != null) {
                healthCheckGroupVModel.passedChecks += 1;
            }

            if(healthCheckGroupVModel.passedChecks < healthCheckGroupVModel.totalChecks) {
                healthCheckItemVModel.status = 'Fail';
                healthCheckItemVModel.statusLabel = Label.stgHealthCheckStatusFailed;
            }
    
            healthCheckGroupVModel.healthCheckItemList.add(healthCheckItemVModel);
            return healthCheckGroupVModel;
        }
    }
    
    /***************************************************************************
    * @description Stub class to simulate the response from
    * RelationshipLookupSettingsService to return a predetermined set of models.
    ***************************************************************************/
    private class STUB_RelationshipLookupSettingsService extends RelationshipLookupSettingsService {

        public override List<RelationshipLookupModel> getRelationshipLookupModels() {
            List<RelationshipLookupModel> relationshipLookupModelList =
                new List<RelationshipLookupModel>();
            
            RelationshipLookupModel relationshipLookupModel = 
                new RelationshipLookupModel(
                    'testvalue',
                    true,
                    'testfemalevalue',
                    'testmalevalue',
                    'testneutralvalue'
                );

            relationshipLookupModelList.add(relationshipLookupModel);

            return relationshipLookupModelList;
        }
    }

    /***************************************************************************
    * @description Stub class to simulate the response from
    * RelationshipLookupSettingsService to return a predetermined set of unfound
    * models.
    ***************************************************************************/
    private class STUB_RelationshipLookupSettingsUnfound extends RelationshipLookupSettingsService {

        public override List<RelationshipLookupModel> getRelationshipLookupModels() {
            List<RelationshipLookupModel> relationshipLookupModelList =
                new List<RelationshipLookupModel>();
            
            RelationshipLookupModel relationshipLookupModel = 
                new RelationshipLookupModel(
                    'unfoundvalue',
                    true,
                    'unfoundfemalevalue',
                    'unfoundmalevalue',
                    'unfoundneutralvalue'
                );

            relationshipLookupModelList.add(relationshipLookupModel);

            return relationshipLookupModelList;
        }
    }



    /***************************************************************************
    * @description Stub class to simulate the response from
    * PicklistEntryService to return a predetermined set of active models.
    ***************************************************************************/
    private class STUB_PicklistEntryService extends PicklistEntryService {
        public override Map<String,PicklistEntryModel> getModelsByNameForSObjectField(
            SObjectType sObjectTypeName,
            SObjectField SObjectFieldName
        ) {
            Map<String,PicklistEntryModel> picklistEntryModelByName =
                new Map<String,PicklistEntryModel>();
            
            picklistEntryModelByName.put('testvalue',new PicklistEntryModel(
                'testvalue',
                'testlabel',
                true
            ));            
            picklistEntryModelByName.put('testfemalevalue',new PicklistEntryModel(
                'testfemalevalue',
                'testfemalelabel',
                true
            ));            
            picklistEntryModelByName.put('testmalevalue',new PicklistEntryModel(
                'testmalevalue',
                'testmalelabel',
                true
            ));            
            picklistEntryModelByName.put('testneutralvalue',new PicklistEntryModel(
                'testneutralvalue',
                'testneutrallabel',
                true
            ));

            return picklistEntryModelByName;
        }
    }

    /***************************************************************************
    * @description Stub class to simulate the response from
    * PicklistEntryService to return a predetermined set of inactive models.
    ***************************************************************************/
    private class STUB_PicklistEntryServiceInactive extends PicklistEntryService {
        public override Map<String,PicklistEntryModel> getModelsByNameForSObjectField(
            SObjectType sObjectTypeName,
            SObjectField SObjectFieldName
        ) {
            Map<String,PicklistEntryModel> picklistEntryModelByName =
                new Map<String,PicklistEntryModel>();
            
            picklistEntryModelByName.put('testvalue',new PicklistEntryModel(
                'testvalue',
                'testlabel',
                false
            ));            
            picklistEntryModelByName.put('testfemalevalue',new PicklistEntryModel(
                'testfemalevalue',
                'testfemalelabel',
                false
            ));            
            picklistEntryModelByName.put('testmalevalue',new PicklistEntryModel(
                'testmalevalue',
                'testmalelabel',
                false
            ));            
            picklistEntryModelByName.put('testneutralvalue',new PicklistEntryModel(
                'testneutralvalue',
                'testneutrallabel',
                false
            ));

            return picklistEntryModelByName;
        }
    }
}
@isTest
private class RecordTypeMapper_TEST {
    /**************************************************************************************************************************
    * @description Test method to verify that the getInstance method returns a new instance of the 
    * RecordTypeMapper class when one does not already exist.
    ***************************************************************************************************************************/
    @isTest
    private static void getInstanceNew() {
        Test.startTest();
        RecordTypeMapper recordTypeMapperInstance = RecordTypeMapper.getInstance();
        Test.stopTest();

        System.assertEquals(RecordTypeMapper.instance, recordTypeMapperInstance, 'Instance of service class returned should match static instance variable.');
        System.assertEquals(true, recordTypeMapperInstance != null, 'Instance of service class should not be null.');
    }

    /**************************************************************************************************************************
    * @description Test method to verify that the getInstance method returns the existing instance of the 
    * RecordTypeMapper class when one already exists.
    ***************************************************************************************************************************/
    @isTest
    private static void getInstanceExisting() {
        RecordTypeMapper recordTypeMapperInstance1 = RecordTypeMapper.getInstance();

        Test.startTest();
            RecordTypeMapper recordTypeMapperInstance2 = RecordTypeMapper.getInstance();
        Test.stopTest();

        System.assertEquals(RecordTypeMapper.instance, recordTypeMapperInstance1, 'Instance of service class returned should match static instance variable.');
        System.assertEquals(recordTypeMapperInstance1, recordTypeMapperInstance2, 'Subsequent retrievals of service class instance should return existing instance.');
        System.assertEquals(true, recordTypeMapperInstance1 != null, 'Instance of service class should not be null.');
    }

    /**************************************************************************************************************************
    * @description Test method to verify that the getModelByIdMapForSObjectType returns correct record type model by id map.
    * Since unit tests have access to record types in the org, we will only check if admin record type exists.
    ***************************************************************************************************************************/
    @isTest
    private static void getModelByIdMapForSObjectTypeAccountTest() {
        UTIL_Describe.populateRecordTypeInfoForSObject('Account');

        Map<String, Schema.RecordTypeInfo> accountDeveloperNameMap =
            UTIL_Describe.recordTypeInfoByDeveloperName.get('Account');

        Test.startTest();
            Map<Id, RecordTypeModel> recordTypeModelById = RecordTypeMapper.getInstance().getModelByIdMapForSObjectType(Account.getSobjectType());
        Test.stopTest();

        System.assertEquals(
            accountDeveloperNameMap.size(),
            recordTypeModelById.size(),
            'The number of record types for an object and the number of record type models for an object should be the same.'
        );

        for(Schema.RecordTypeInfo recordTypeInfo : accountDeveloperNameMap.values()) {
            RecordTypeModel recordTypeModel = recordTypeModelById.get(recordTypeInfo.getRecordTypeId());

            System.assertNotEquals(null,recordTypeModel,'All record types for an object should have a corresponding record type model.');
            System.assertEquals(recordTypeInfo.getRecordTypeId(),recordTypeModel.id,'The record type model for a record type should have the same Id.');
            System.assertEquals(recordTypeInfo.getName(),recordTypeModel.name,'The record type model for a record type should have the same name.');
            System.assertEquals(recordTypeInfo.getDeveloperName(),recordTypeModel.developerName,'The record type model for a record type should have the same developer name.');
            System.assertEquals(recordTypeInfo.isActive(),recordTypeModel.isActive,'The record type model for a record type should have the same is active flag.');
        }
    }

    /**************************************************************************************************************************
    * @description Test method to verify that the getRecordTypeModelFromRecTypeDevName returns a recordtype model for a valid
    * object and its record type.
    ***************************************************************************************************************************/
    @isTest
    private static void getRecordTypeModelFromRecTypeDevNamePositiveTest() {
        UTIL_Describe.populateRecordTypeInfoForSObject('Account');
        Test.startTest();
            RecordTypeModel accRecTypeMdl = RecordTypeMapper.getInstance().getRecordTypeModelFromRecTypeDevName('Account', 'Academic_Program');
        Test.stopTest();
        
        System.assert(accRecTypeMdl.Id != null, 'The id of the account recordtype in the model should have a value');
        System.assertEquals('Academic Program', accRecTypeMdl.name, 'The name of the account recordtype in the model should have a value');
        System.assertEquals('Academic_Program', accRecTypeMdl.developerName, 'The developer name of the account recordtype in the model should have a value');
        System.assertEquals(true, accRecTypeMdl.isActive, 'The account record type should be active.');

    } 

    /**************************************************************************************************************************
    * @description Test method to verify that the getRecordTypeModelFromRecTypeDevName returns null for an invalid
    * object or record type.
    ***************************************************************************************************************************/
    @isTest
    private static void getRecordTypeModelFromRecTypeDevNameNegativeTest() {
        UTIL_Describe.populateRecordTypeInfoForSObject('Account');
        Test.startTest();
            RecordTypeModel accRecTypeMdl = RecordTypeMapper.getInstance().getRecordTypeModelFromRecTypeDevName('Account', 'test only rec type');
        Test.stopTest();
        
        System.assertEquals(null, accRecTypeMdl, 'A model should not be retireved for invalid recordtype');

        
    }
}
public virtual with sharing class RecordTypeService {
    /*********************************************
     * @description Instance for Singleton Pattern
     **********************************************/
    @TestVisible
    private static RecordTypeService instance;

    /*********************************************************************
     * @description Empty constructor is not public for Singleton Pattern
     **********************************************************************/
    protected RecordTypeService() {
    }

    /******************************************************************************
     * @description Static method to get the current instance for Singleton pattern
     * @return The instance of RecordTypeService.
     ******************************************************************************/
    public static RecordTypeService getInstance() {
        if (instance == null) {
            instance = new RecordTypeService();
        }

        return instance;
    }

    /******************************************************************************
     * @description Get a map of Record Type Model By Id for specified SObjectType
     * @param SObjectype An SObject from which to retrieve associated record types
     * @return A map of Record Type Models By Id
     ******************************************************************************/
    public virtual Map<Id, RecordTypeModel> getModelByIdMapForSObjectType(Schema.SObjectType sObjectType) {
        return this.locateRecordTypeMapper().getModelByIdMapForSObjectType(sObjectType);
    }

    /******************************************************************************
     * @description Returns a recordtype model for an Object and it's recordtype
     * @param objectAPI The API name for object to get the record type model for
     * @param recTypeDevName The record type dev name to get the record typpe model for
     * for the given object
     * @return A recordtype model
     ******************************************************************************/
    public virtual RecordTypeModel getRecordTypeModelFromRecTypeDevName(String objectAPI, String recTypeDevName) {
        return this.locateRecordTypeMapper().getRecordTypeModelFromRecTypeDevName(objectAPI, recTypeDevName);
    }

    /***********************************************************************************************************************
     * @description Retrieve a map of active record types by Id from a list of all record types associated with an SObject.
     * @param allRecordTypeModelsList A list containing all record type models in an org.
     * @return A map of Active Record Type Models By Id.
     ***********************************************************************************************************************/
    public virtual Map<Id, RecordTypeModel> getActiveRecordTypeModelsById(
        List<RecordTypeModel> allRecordTypeModelsList
    ) {
        Map<Id, RecordTypeModel> activeRecordTypeModelsById = new Map<Id, RecordTypeModel>();

        for (RecordTypeModel recordTypeModel : allRecordTypeModelsList) {
            if (recordTypeModel.isActive == false) {
                continue;
            }

            activeRecordTypeModelsById.put(recordTypeModel.id, recordTypeModel);
        }

        return activeRecordTypeModelsById;
    }

    /***********************************************************************************************************************
     * @description Filter through a map of valid Record Type models to retrieve a list of Ids corresponding to values in a specified list.
     * @param  idsToFindList A list of Id strings corresponding to Record Types
     * @param  validRecordTypeIdsSet A set of Ids associated with valid Record Types
     * @return A List<Id> containing Ids that correspond to valid Record Types and match a value in the specified list of Ids to find.
     ***********************************************************************************************************************/
    public virtual List<Id> filterListForValidIds(List<String> idsToFindList, Set<Id> validRecordTypeIdsSet) {
        List<String> validIdsList = new List<String>();

        for (String idToFind : idsToFindList) {
            if ((idToFind instanceof Id) == false) {
                // Id to find is not a valid Id string => omit
                continue;
            }
            if (validRecordTypeIdsSet.contains((Id) idToFind) == false) {
                // Id to find has no match to a valid record type model => omit
                continue;
            }

            validIdsList.add(idToFind);
        }

        return validIdsList;
    }

    /******************************************************************************
     * @description Get the Record Type Model from the map of record type model by id
     * @param recordTypeId string of Record Type Id
     * @param recordTypeModelById map of Record Type Model By Id
     * @return An instance of Record Type Model
     ******************************************************************************/
    public virtual RecordTypeModel getRecordTypeModelFromMap(
        String recordTypeId,
        Map<Id, RecordTypeModel> recordTypeModelById
    ) {
        try {
            return recordTypeModelById.get(Id.valueOf(recordTypeId));
        } catch (System.StringException ex) {
            return null;
        }
    }

    /******************************************************************************
     * @description Retrieve a record type model for a specified record type name or label.
     * @param recordTypeNameOrLabel A string representing the name or label for a record type
     * @param recordTypeModelByName A map of record type models by name
     * @param recordTypeModelByLabel A map of record type models by label
     * @return A Record Type Model corresponding to the specified record type label or name
     ******************************************************************************/
    public virtual RecordTypeModel getRecordTypeModelFromNameAndLabelMaps(
        String recordTypeNameOrLabel,
        Map<String, RecordTypeModel> recordTypeModelByName,
        Map<String, RecordTypeModel> recordTypeModelByLabel
    ) {
        RecordTypeModel recordTypeModel = recordTypeModelByName.get(recordTypeNameOrLabel);

        if (recordTypeModel == null) {
            recordTypeModel = recordTypeModelByLabel.get(recordTypeNameOrLabel);
        }

        return recordTypeModel;
    }

    /******************************************************************************
     * @description Generate a map of Record Type Models By developer name.
     * @param recordTypeModelById A map of recordTypeModels by Id
     * @return A map of Record Type Model By Name
     ******************************************************************************/
    public Map<String, RecordTypeModel> getRecordTypeModelMapByName(Map<Id, RecordTypeModel> recordTypeModelById) {
        Map<String, RecordTypeModel> recordTypeModelsByName = new Map<String, RecordTypeModel>();

        for (RecordTypeModel recordTypeModel : recordTypeModelById.values()) {
            recordTypeModelsByName.put(recordTypeModel.developerName, recordTypeModel);
        }

        return recordTypeModelsByName;
    }

    /******************************************************************************
     * @description Generate a map of Record Type Models By developer label.
     * @param recordTypeModelById A map of recordTypeModels by Id
     * @return A map of Record Type Model By Label
     ******************************************************************************/
    public Map<String, RecordTypeModel> getRecordTypeModelMapByLabel(Map<Id, RecordTypeModel> recordTypeModelById) {
        Map<String, RecordTypeModel> recordTypeModelsByLabel = new Map<String, RecordTypeModel>();

        for (RecordTypeModel recordTypeModel : recordTypeModelById.values()) {
            recordTypeModelsByLabel.put(recordTypeModel.name, recordTypeModel);
        }

        return recordTypeModelsByLabel;
    }

    /******************************************************************************
     * @description Retrieves an instance of the RecordTypeMapper class.
     * @return An instance of RecordTypeMapper.
     ******************************************************************************/
    @TestVisible
    private RecordTypeMapper locateRecordTypeMapper() {
        return RecordTypeMapper.getInstance();
    }
}
@isTest
private class RecordTypeService_TEST {
    /**************************************************************************************************************************
     * @description Test method to verify that the getInstance method returns a new instance of the
     * RecordTypeService class when one does not already exist.
     ***************************************************************************************************************************/
    @isTest
    private static void getInstanceNew() {
        Test.startTest();
        RecordTypeService recordTypeServiceInstance = RecordTypeService.getInstance();
        Test.stopTest();

        System.assertEquals(
            RecordTypeService.instance,
            recordTypeServiceInstance,
            'Instance of service class returned should match static instance variable.'
        );
        System.assertEquals(true, recordTypeServiceInstance != null, 'Instance of service class should not be null.');
    }

    /**************************************************************************************************************************
     * @description Test method to verify that the getInstance method returns the existing instance of the
     * RecordTypeService class when one already exists.
     ***************************************************************************************************************************/
    @isTest
    private static void getInstanceExisting() {
        RecordTypeService recordTypeServiceInstance1 = RecordTypeService.getInstance();

        Test.startTest();
        RecordTypeService recordTypeServiceInstance2 = RecordTypeService.getInstance();
        Test.stopTest();

        System.assertEquals(
            RecordTypeService.instance,
            recordTypeServiceInstance1,
            'Instance of service class returned should match static instance variable.'
        );
        System.assertEquals(
            recordTypeServiceInstance1,
            recordTypeServiceInstance2,
            'Subsequent retrievals of service class instance should return existing instance.'
        );
        System.assertNotEquals(null, recordTypeServiceInstance1, 'Instance of service class should not be null.');
    }

    /**************************************************************************************************************************
     * @description Test method to verify that a map of Record Type model by Id is returned by getModelByIdMapForSObjectType correctly
     ***************************************************************************************************************************/
    @isTest
    private static void getModelByIdMapForSObjectTypeTest() {
        RecordTypeMapper.instance = new STUB_RecordTypeMapper();

        Test.startTest();
        Map<Id, RecordTypeModel> recordTypeModelById = RecordTypeService.getInstance()
            .getModelByIdMapForSObjectType(Account.getSobjectType());
        Test.stopTest();

        RecordTypeModel recordTypeModel = recordTypeModelById.get('000000000000000000');

        System.assertNotEquals(
            null,
            recordTypeModel,
            'A record type model should be retrieved for a valid record type Id.'
        );
        System.assertEquals(
            Id.valueOf('000000000000000000'),
            recordTypeModel.id,
            'The record type model for a record type should have the specified Id.'
        );
        System.assertEquals(
            'Household',
            recordTypeModel.name,
            'The record type model for a record type should have the specified name.'
        );
        System.assertEquals(
            'Household Account',
            recordTypeModel.developerName,
            'The record type model for a record type should have the specified developer name.'
        );
        System.assertEquals(
            true,
            recordTypeModelById.get('000000000000000000').isActive,
            'The record type model for a record type should have the specified is active flag.'
        );
    }

    /**************************************************************************************************************************
     * @description Test method to verify that null is returned for valid id not in the map
     ***************************************************************************************************************************/
    @isTest
    private static void getRecordTypeModelFromMapValidIdNotInMapTest() {
        RecordTypeMapper.instance = new STUB_RecordTypeMapper();
        Map<Id, RecordTypeModel> recordTypeModelById = RecordTypeService.getInstance()
            .getModelByIdMapForSObjectType(Account.getSobjectType());

        Test.startTest();
        RecordTypeModel recordTypeModel = RecordTypeService.getInstance()
            .getRecordTypeModelFromMap('000000000000000001', recordTypeModelById);
        Test.stopTest();

        System.assertEquals(
            null,
            recordTypeModel,
            'A record type model should not be returned for a record type that does not exist.'
        );
    }

    /**************************************************************************************************************************
     * @description Test method to verify that null is returned for invalid id
     ***************************************************************************************************************************/
    @isTest
    private static void getRecordTypeModelFromMapInvalidIdTest() {
        RecordTypeMapper.instance = new STUB_RecordTypeMapper();
        Map<Id, RecordTypeModel> recordTypeModelById = RecordTypeService.getInstance()
            .getModelByIdMapForSObjectType(Account.getSobjectType());

        Test.startTest();
        RecordTypeModel recordTypeModel = RecordTypeService.getInstance()
            .getRecordTypeModelFromMap('invalid', recordTypeModelById);
        Test.stopTest();

        System.assertEquals(
            null,
            recordTypeModel,
            'A record type model should not be returned for a non-id string value.'
        );
    }

    /**************************************************************************************************************************
     * @description Test method to verify that a valid record type model is returned.
     ***************************************************************************************************************************/
    @isTest
    private static void getRecordTypeModelFromMapValidIdInMapTest() {
        RecordTypeMapper.instance = new STUB_RecordTypeMapper();

        Map<Id, RecordTypeModel> recordTypeModelById = RecordTypeService.getInstance()
            .getModelByIdMapForSObjectType(Account.getSobjectType());

        Test.startTest();
        RecordTypeModel recordTypeModel = RecordTypeService.getInstance()
            .getRecordTypeModelFromMap('000000000000000000', recordTypeModelById);
        Test.stopTest();

        System.assertNotEquals(
            null,
            recordTypeModel,
            'A record type model should be retrieved for a valid record type Id.'
        );
        System.assertEquals(
            Id.valueOf('000000000000000000'),
            recordTypeModel.id,
            'The record type model for a record type should have the specified Id.'
        );
        System.assertEquals(
            'Household',
            recordTypeModel.name,
            'The record type model for a record type should have the specified name.'
        );
        System.assertEquals(
            'Household Account',
            recordTypeModel.developerName,
            'The record type model for a record type should have the specified developer name.'
        );
        System.assertEquals(
            true,
            recordTypeModelById.get('000000000000000000').isActive,
            'The record type model for a record type should have the specified is active flag.'
        );
    }

    /**************************************************************************************************************************
     * @description Test method to verify that getRecordTypeModelFromNameAndLabelMaps returns a valid record type model when a match is found
     * for a specified developer name.
     ***************************************************************************************************************************/
    @isTest
    private static void getRecordTypeModelFromNameAndLabelMapsByName() {
        Map<String, RecordTypeModel> recordTypeModelsByName = new Map<String, RecordTypeModel>{
            'Record_Type_1' => new RecordTypeModel('000000000000000001', 'Record Type 1', 'Record_Type_1', true)
        };

        Map<String, RecordTypeModel> recordTypeModelsByLabel = new Map<String, RecordTypeModel>{
            'Record Type Label' => new RecordTypeModel(
                '000000000000000001',
                'Record Type Label',
                'Record_Type_Label',
                false
            )
        };

        RecordTypeService recordTypeServiceInstance = RecordTypeService.getInstance();

        Test.startTest();
        RecordTypeModel recordTypeModelResult = recordTypeServiceInstance.getRecordTypeModelFromNameAndLabelMaps(
            'Record_Type_1',
            recordTypeModelsByName,
            recordTypeModelsByLabel
        );
        Test.stopTest();

        System.assertEquals(
            '000000000000000001',
            recordTypeModelResult.id,
            'Record type model name should be \'000000000000000001\'.'
        );
        System.assertEquals(
            'Record Type 1',
            recordTypeModelResult.name,
            'Record type model name should be \'Record Type 1\'.'
        );
        System.assertEquals(
            'Record_Type_1',
            recordTypeModelResult.developerName,
            'Record type model name should be \'Record_Type_1\'.'
        );
        System.assertEquals(true, recordTypeModelResult.isActive, 'Record type model name should be \'true\'.');
    }

    /**************************************************************************************************************************
     * @description Test method to verify that getRecordTypeModelFromNameAndLabelMaps returns a valid record type model when a match is found
     * for a specified label name.
     ***************************************************************************************************************************/
    @isTest
    private static void getRecordTypeModelFromNameAndLabelMapsByLabel() {
        Map<String, RecordTypeModel> recordTypeModelsByName = new Map<String, RecordTypeModel>{
            'Record_Type_1' => new RecordTypeModel('000000000000000001', 'Record Type 1', 'Record_Type_1', true)
        };

        Map<String, RecordTypeModel> recordTypeModelsByLabel = new Map<String, RecordTypeModel>{
            'Record Type Label' => new RecordTypeModel(
                '123000000000000000',
                'Record Type Label',
                'Record_Type_Label',
                false
            )
        };

        RecordTypeService recordTypeServiceInstance = RecordTypeService.getInstance();

        Test.startTest();
        RecordTypeModel recordTypeModelResult = recordTypeServiceInstance.getRecordTypeModelFromNameAndLabelMaps(
            'Record Type Label',
            recordTypeModelsByName,
            recordTypeModelsByLabel
        );
        Test.stopTest();

        System.assertEquals(
            '123000000000000000',
            recordTypeModelResult.id,
            'Record type model name should be \'123000000000000000\'.'
        );
        System.assertEquals(
            'Record Type Label',
            recordTypeModelResult.name,
            'Record type model name should be \'Record Type Label\'.'
        );
        System.assertEquals(
            'Record_Type_Label',
            recordTypeModelResult.developerName,
            'Record type model name should be \'Record_Type_Label\'.'
        );
        System.assertEquals(false, recordTypeModelResult.isActive, 'Record type model name should be \'false\'.');
    }

    /**************************************************************************************************************************
     * @description Test method to verify that getRecordTypeModelFromNameAndLabelMaps returns a null record type model when no match is found
     * for a specified developer or label name.
     ***************************************************************************************************************************/
    @isTest
    private static void getRecordTypeModelFromNameAndLabelMapsNull() {
        Map<String, RecordTypeModel> recordTypeModelsByName = new Map<String, RecordTypeModel>{
            'Record_Type_1' => new RecordTypeModel('000000000000000001', 'Record Type 1', 'Record_Type_1', true)
        };

        Map<String, RecordTypeModel> recordTypeModelsByLabel = new Map<String, RecordTypeModel>{
            'Record Type Label' => new RecordTypeModel(
                '123000000000000000',
                'Record Type Label',
                'Record_Type_Label',
                false
            )
        };

        RecordTypeService recordTypeServiceInstance = RecordTypeService.getInstance();

        Test.startTest();
        RecordTypeModel recordTypeModelResult = recordTypeServiceInstance.getRecordTypeModelFromNameAndLabelMaps(
            'Non Existent Record Type Name',
            recordTypeModelsByName,
            recordTypeModelsByLabel
        );
        Test.stopTest();

        System.assertEquals(null, recordTypeModelResult, 'Record type model should be null.');
    }

    /**************************************************************************************************************************
     * @description Test method to verify that getRecordTypeModelMapByLabelPositive returns a map of record type models by label.
     ***************************************************************************************************************************/
    @isTest
    private static void getRecordTypeModelMapByLabelPositive() {
        Map<Id, RecordTypeModel> recordTypeModelsById = new Map<Id, RecordTypeModel>{
            '000000000000000001' => new RecordTypeModel('000000000000000001', 'Record Type 1', 'Record_Type_1', true),
            '000000000000000002' => new RecordTypeModel('000000000000000002', 'Record Type 2', 'Record_Type_2', false)
        };

        RecordTypeService recordTypeServiceInstance = RecordTypeService.getInstance();

        Test.startTest();
        Map<String, RecordTypeModel> recordTypeModelsByLabelResult = recordTypeServiceInstance.getRecordTypeModelMapByLabel(
            recordTypeModelsById
        );
        Test.stopTest();

        System.assertEquals(
            true,
            recordTypeModelsByLabelResult.keySet().contains('Record Type 1'),
            'Record type should be mapped by label name.'
        );
        System.assertEquals(
            true,
            recordTypeModelsByLabelResult.keySet().contains('Record Type 2'),
            'Record type should be mapped by label name.'
        );
    }

    /**************************************************************************************************************************
     * @description Test method to verify that getRecordTypeModelMapByLabelPositive returns a map of record type models by name.
     ***************************************************************************************************************************/
    @isTest
    private static void getRecordTypeModelMapByNamePositive() {
        Map<Id, RecordTypeModel> recordTypeModelsById = new Map<Id, RecordTypeModel>{
            '000000000000000001' => new RecordTypeModel('000000000000000001', 'Record Type 1', 'Record_Type_1', true),
            '000000000000000002' => new RecordTypeModel('000000000000000002', 'Record Type 2', 'Record_Type_2', false)
        };

        RecordTypeService recordTypeServiceInstance = RecordTypeService.getInstance();

        Test.startTest();
        Map<String, RecordTypeModel> recordTypeModelsByNameResult = recordTypeServiceInstance.getRecordTypeModelMapByName(
            recordTypeModelsById
        );
        Test.stopTest();

        System.assertEquals(
            true,
            recordTypeModelsByNameResult.keySet().contains('Record_Type_1'),
            'Record type should be mapped by developer name.'
        );
        System.assertEquals(
            true,
            recordTypeModelsByNameResult.keySet().contains('Record_Type_2'),
            'Record type should be mapped by developer name.'
        );
    }

    /***********************************************************************************************************************************
     * @description Test method to verify that the getActiveRecordTypeModelsById returns a list containing only active Account Record Types.
     ***********************************************************************************************************************************/
    @isTest
    private static void getActiveRecordTypeModelsByIdValid() {
        // active and inactive RTs exist
        List<RecordTypeModel> recordTypeModelsList = new List<RecordTypeModel>();

        recordTypeModelsList.add(
            new RecordTypeModel('000000000000000000', 'Active RecordType 1', 'Active_RecordType_1', true)
        );
        recordTypeModelsList.add(
            new RecordTypeModel('000000000000000001', 'Active RecordType 2', 'Active_RecordType_2', true)
        );
        recordTypeModelsList.add(
            new RecordTypeModel('000000000000000002', 'Inactive RecordType 1', 'Inactive_RecordType_1', false)
        );

        RecordTypeService recordTypeServiceInstance = RecordTypeService.getInstance();
        Test.startTest();
        Map<Id, RecordTypeModel> activeRecordTypeModelsById = recordTypeServiceInstance.getActiveRecordTypeModelsById(
            recordTypeModelsList
        );
        Test.stopTest();

        System.assertEquals(
            2,
            activeRecordTypeModelsById.values().size(),
            'Should contain 2 active record type models.'
        );

        for (RecordTypeModel recordTypeModel : activeRecordTypeModelsById.values()) {
            System.assertEquals(true, recordTypeModel.isActive, 'Record Type Model should be active.');
        }
    }

    /***********************************************************************************************************************************
     * @description Test method to verify that the getActiveRecordTypeModelsById returns an empty list when no active Account Record Types exist.
     ***********************************************************************************************************************************/
    @isTest
    private static void getActiveRecordTypeModelsByIdWithoutActive() {
        // only inactive RTs exist
        List<RecordTypeModel> recordTypeModelsList = new List<RecordTypeModel>();

        recordTypeModelsList.add(
            new RecordTypeModel('000000000000000000', 'Inactive RecordType 1', 'Inactive_RecordType_1', false)
        );
        recordTypeModelsList.add(
            new RecordTypeModel('000000000000000001', 'Inactive RecordType 2', 'Inactive_RecordType_2', false)
        );
        recordTypeModelsList.add(
            new RecordTypeModel('000000000000000002', 'Inactive RecordType 1', 'Inactive_RecordType_1', false)
        );

        RecordTypeService recordTypeServiceInstance = RecordTypeService.getInstance();
        Test.startTest();
        Map<Id, RecordTypeModel> activeRecordTypeModelsById = recordTypeServiceInstance.getActiveRecordTypeModelsById(
            recordTypeModelsList
        );
        Test.stopTest();

        System.assertEquals(
            0,
            activeRecordTypeModelsById.values().size(),
            'Should contain 0 active record type models.'
        );
    }

    /***********************************************************************************************************************************
     * @description Test method to verify that the filterListForValidIds correctly removes values from the specified list of Ids to find
     * that do not match a value in the set of valid Ids.
     ***********************************************************************************************************************************/
    @isTest
    private static void filterListForValidIdsValid() {
        List<String> idsToFindList = new List<String>{
            '000000000000000001',
            '000000000000000002',
            '000000000000000003',
            'Not an Id String'
        };
        Set<Id> validRecordTypeIdsSet = new Set<Id>{ '000000000000000001', '000000000000000003' };

        RecordTypeService recordTypeServiceInstance = RecordTypeService.getInstance();
        Test.startTest();
        List<Id> validIdsList = recordTypeServiceInstance.filterListForValidIds(idsToFindList, validRecordTypeIdsSet);
        Test.stopTest();

        System.assertEquals(2, validIdsList.size(), 'Should only contain ids matching valid record type Ids.');
        System.assertEquals(
            '000000000000000001',
            validIdsList[0],
            'Should contain valid Ids specified in list of Ids to find.'
        );
        System.assertEquals(
            '000000000000000003',
            validIdsList[1],
            'Should contain valid Ids specified in list of Ids to find.'
        );
    }

    /***********************************************************************************************************************************
     * @description Test method to verify that the filterListForValidIds returns an empty list of when no Ids are included in list of
     * Ids to find.
     ***********************************************************************************************************************************/
    @isTest
    private static void filterListForValidIdsNoIdsToFind() {
        List<String> idsToFindList = new List<String>();
        Set<Id> validRecordTypeIdsSet = new Set<Id>{ '000000000000000001', '000000000000000003' };

        RecordTypeService recordTypeServiceInstance = RecordTypeService.getInstance();

        Test.startTest();
        List<Id> validIdsList = recordTypeServiceInstance.filterListForValidIds(idsToFindList, validRecordTypeIdsSet);
        Test.stopTest();

        System.assertEquals(
            0,
            validIdsList.size(),
            'No Ids to find should return an empty list of matching valid Ids.'
        );
    }

    /***********************************************************************************************************************************
     * @description Test method to verify that the filterListForValidIds returns an empty list of when no valid record type Ids are
     * specified.
     ***********************************************************************************************************************************/
    @isTest
    private static void filterListForValidIdsNoValidIds() {
        List<String> idsToFindList = new List<String>{
            '000000000000000001',
            '000000000000000002',
            '000000000000000003'
        };
        Set<Id> validRecordTypeIdsSet = new Set<Id>();

        RecordTypeService recordTypeServiceInstance = RecordTypeService.getInstance();

        Test.startTest();
        List<Id> validIdsList = recordTypeServiceInstance.filterListForValidIds(idsToFindList, validRecordTypeIdsSet);
        Test.stopTest();

        System.assertEquals(
            0,
            validIdsList.size(),
            'No valid Ids in map should return an empty list of matching valid Ids.'
        );
    }

    /***********************************************************************************************************************************
     * @description Test method to verify getRecordTypeModelFromRecTypeDevName retrieves a recordtype model for given object and a record
     * type
     ***********************************************************************************************************************************/
    @isTest
    private static void getRecordTypeModelFromRecTypeDevName() {
        RecordTypeMapper.instance = new STUB_RecordTypeMapperModel();
        Test.startTest();
        RecordTypeModel recTypeMdl = RecordTypeService.getInstance()
            .getRecordTypeModelFromRecTypeDevName('Account', 'Household_Account');
        Test.stopTest();

        System.assert(recTypeMdl.Id != null, 'The id of the account recordtype in the model should have a value');
        System.assertEquals(
            'Household',
            recTypeMdl.name,
            'The name of the account recordtype in the model should have a value'
        );
        System.assertEquals(
            'Household Account',
            recTypeMdl.developerName,
            'The developer name of the account recordtype in the model should have a value'
        );
        System.assertEquals(true, recTypeMdl.isActive, 'The account record type should be active.');
    }

    /**************************************************************************************************************************
     ****************************************************** STUB CLASS *********************************************************
     **************************************************************************************************************************/

    /*************************************************************************************************************
     * @description Stub class to simulate the response from RecordTypeMapper to return a map of Record Type model by Id
     */
    private class STUB_RecordTypeMapper extends RecordTypeMapper {
        public override Map<Id, RecordTypeModel> getModelByIdMapForSObjectType(Schema.SObjectType sObjectType) {
            Map<Id, RecordTypeModel> stubRecordTypeModelById = new Map<Id, RecordTypeModel>();

            RecordTypeModel recordTypeModel = new RecordTypeModel(
                '000000000000000000',
                'Household',
                'Household Account',
                true
            );

            stubRecordTypeModelById.put('000000000000000000', recordTypeModel);

            return stubRecordTypeModelById;
        }
    }

    /*************************************************************************************************************
     * @description Stub class to simulate the response from RecordTypeMapper to return a recordtype model
     */
    private class STUB_RecordTypeMapperModel extends RecordTypeMapper {
        public override RecordTypeModel getRecordTypeModelFromRecTypeDevName(String objectAPI, String recTypeDevName) {
            RecordTypeModel recordTypeModel = new RecordTypeModel(
                '000000000000000000',
                'Household',
                'Household Account',
                true
            );

            return recordTypeModel;
        }
    }
}
@isTest
public with sharing class RelAutoCreateSettingsMapperService_TEST {
    
    /**************************************************************************************************************************
    * @description Test method to verify that the getInstance method returns a new instance of the 
    * RelAutoCreateSettingsMapperService class when one does not already exist.
    ***************************************************************************************************************************/
    @isTest
    private static void getInstanceNew() {
        RelAutoCreateSettingsMapperService srvcRelAutoCreateSettingMapper = RelAutoCreateSettingsMapperService.getInstance();
        System.assertEquals(RelAutoCreateSettingsMapperService.instance, srvcRelAutoCreateSettingMapper, 'Instance of service class returned should match static instance variable.');
        System.assertEquals(true, srvcRelAutoCreateSettingMapper != null, 'Instance of service class should not be null.');
    }

    /**************************************************************************************************************************
    * @description Test method to verify that the getInstance method returns the existing instance of the 
    * RelAutoCreateSettingsMapperService class when one already exists.
    ***************************************************************************************************************************/
    @isTest
    private static void getInstanceExisting() {
        RelAutoCreateSettingsMapperService srvcRelAutoCreateSettingsMapperInstance1 = RelAutoCreateSettingsMapperService.getInstance();
        RelAutoCreateSettingsMapperService srvcRelAutoCreateSettingsMapperInstance2 = RelAutoCreateSettingsMapperService.getInstance();
 
        System.assertEquals(RelAutoCreateSettingsMapperService.instance, srvcRelAutoCreateSettingsMapperInstance1, 'Instance of service class returned should match static instance variable.');
        System.assertEquals(srvcRelAutoCreateSettingsMapperInstance1, srvcRelAutoCreateSettingsMapperInstance2, 'Subsequent retrievals of service class instance should return existing instance.');
        System.assertEquals(true, srvcRelAutoCreateSettingsMapperInstance1 != null, 'Instance of service class should not be null.');
    }

    /***************************************************************************************************************************
    * @description Test method to verify that getContactMappingModelsFromSettings() returns only the models for Relationship 
    * Auto Create mappings associated with the Contact object.
    ***************************************************************************************************************************/ 
    @isTest 
    private static void getContactMappingModelsFromSettingsTrue(){
        List<Relationship_Auto_Create__c> relAutoCreateList = new List<Relationship_Auto_Create__c>();
        Relationship_Auto_Create__c contactRelAutoCreate;
        Relationship_Auto_Create__c accountRelAutoCreate;

        for (Integer i = 0; i < 5; i++){
            contactRelAutoCreate = new Relationship_Auto_Create__c(Name = 'ConReportToAutoCreate' + i, 
                                                                                               Object__c = 'Contact',
                                                                                               Field__c = 'ReportsToId', 
                                                                                               Relationship_Type__c = 'ContactTester' + i,
                                                                                               Campaign_Types__c = '');

            accountRelAutoCreate = new Relationship_Auto_Create__c(Name = 'AccountReportToAutoCreate' + i, 
                                                                                               Object__c = 'Account',
                                                                                               Field__c = 'Name', 
                                                                                               Relationship_Type__c = 'AccountTester' + i,
                                                                                               Campaign_Types__c = '');
            relAutoCreateList.add(contactRelAutoCreate);
            relAutoCreateList.add(accountRelAutoCreate);
        }

        insert relAutoCreateList;

        Test.startTest();
        List<ContactRelAutoCreateMappingModel> conRelAutoCreateMappingList = RelAutoCreateSettingsMapperService.getInstance().getContactMappingModelsFromSettings();
        Test.stopTest();

        System.assertEquals(5, conRelAutoCreateMappingList.size(), 'There should be 5 Relationship Auto Create Mapping models for Contact.');

        for (Integer i = 0; i < conRelAutoCreateMappingList.size(); i++){
            System.assertEquals('ReportsToId', conRelAutoCreateMappingList[i].contactFieldApiName, 'The contact field name set on model should correspond to the Relationship_Type__c for the Contact Relationship Auto Create mapping.');
            System.assertEquals('Reports To ID', conRelAutoCreateMappingList[i].contactFieldLabel, 'The contact field label set on model should correspond to the Relationship_Type__c for the Contact Relationship Auto Create mapping.');
            System.assertEquals('ContactTester' + i, conRelAutoCreateMappingList[i].relationshipType, 'The relationship type set on model should correspond to the Relationship_Type__c for the Contact Relationship Auto Create mapping.');
        }
    }

    /***************************************************************************************************************************
    * @description Test method to verify that getContactMappingModelsFromSettings() returns an empty list
    * when there are no Relationship Auto Create mappings for the Contact object set.
    ***************************************************************************************************************************/ 
    @isTest 
    private static void getContactMappingModelsFromSettingsFalse(){
        List<Relationship_Auto_Create__c> relAutoCreateList = [SELECT Id 
                                                               FROM Relationship_Auto_Create__c];

        delete relAutoCreateList;

        Test.startTest();
        System.assertEquals(true, RelAutoCreateSettingsMapperService.getInstance().getContactMappingModelsFromSettings().isEmpty(), 'There should be no Relationship Auto Create Mapping models for Contact.');
        Test.stopTest();
    }

    /***************************************************************************************************************************
    * @description Test method to verify that getContactMappingModelsFromMappings() returns a list of models representing
    * the Relationship Auto Create mappings provided as input (regardless of Object).
    ***************************************************************************************************************************/ 
    @isTest 
    private static void getContactMappingModelsFromMappingsTrue(){
        List<Relationship_Auto_Create__c> relAutoCreateList = new List<Relationship_Auto_Create__c>();

        for (Integer i = 0; i < 5; i++){
            Relationship_Auto_Create__c contactRelAutoCreate = new Relationship_Auto_Create__c(Id = UTIL_UnitTestData_TEST.getFakeId(Relationship_Auto_Create__c.SObjectType),
                                                                                               Name = 'ConReportToAutoCreate' + i, 
                                                                                               Object__c = 'Contact',
                                                                                               Field__c = 'reportsToId', 
                                                                                               Relationship_Type__c = 'ContactTester' + i,
                                                                                               Campaign_Types__c = '');

            Relationship_Auto_Create__c accountRelAutoCreate = new Relationship_Auto_Create__c(Id = UTIL_UnitTestData_TEST.getFakeId(Relationship_Auto_Create__c.SObjectType),
                                                                                               Name = 'AccountReportToAutoCreate' + i, 
                                                                                               Object__c = 'Account',
                                                                                               Field__c = 'Name', 
                                                                                               Relationship_Type__c = 'AccountTester' + i,
                                                                                               Campaign_Types__c = '');
            relAutoCreateList.add(contactRelAutoCreate);
            relAutoCreateList.add(accountRelAutoCreate);
        }

        Test.startTest();
        List<ContactRelAutoCreateMappingModel> conRelAutoCreateMappingsList = RelAutoCreateSettingsMapperService.getInstance().getContactMappingModelsFromMappings(relAutoCreateList);
        Test.stopTest();

        System.assertEquals(10, conRelAutoCreateMappingsList.size(), 'There should be 10 ContactRelAutoCreateMappingModel returned.');
    }

    /***************************************************************************************************************************
    * @description Test method to verify that getContactMappingModelsFromMappings() returns an empty list of when no 
    * Relationships Auto Create mappings are provided as input.
    ***************************************************************************************************************************/ 
    @isTest 
    private static void getContactMappingModelsFromMappingsFalse(){
        List<Relationship_Auto_Create__c> relAutoCreateList = new List<Relationship_Auto_Create__c>();

        Test.startTest();
        List<ContactRelAutoCreateMappingModel> conRelAutoCreateMappingsList = RelAutoCreateSettingsMapperService.getInstance().getContactMappingModelsFromMappings(relAutoCreateList);
        Test.stopTest();

        System.assertEquals(true, conRelAutoCreateMappingsList.isEmpty(), 'There should be no ContactRelAutoCreateMappingModel returned.');
    }

    /***************************************************************************************************************************
    * @description Test method to verify that getModelFromMapping() returns a model representing the Relationship Auto Create 
    * mapping provided as input (regardless of Object).
    ***************************************************************************************************************************/ 
    @isTest 
    private static void getModelFromMappingTrue(){
        List<Relationship_Auto_Create__c> relAutoCreateList = new List<Relationship_Auto_Create__c>();

        for (Integer i = 0; i < 5; i++){
            Relationship_Auto_Create__c contactRelAutoCreate = new Relationship_Auto_Create__c(Id = UTIL_UnitTestData_TEST.getFakeId(Relationship_Auto_Create__c.SObjectType),
                                                                                               Name = 'ConReportToAutoCreate' + i, 
                                                                                               Object__c = 'Contact',
                                                                                               Field__c = 'ReportsToId', 
                                                                                               Relationship_Type__c = 'ContactTester' + i,
                                                                                               Campaign_Types__c = '');

            Relationship_Auto_Create__c accountRelAutoCreate = new Relationship_Auto_Create__c(Id = UTIL_UnitTestData_TEST.getFakeId(Relationship_Auto_Create__c.SObjectType),
                                                                                               Name = 'AccountReportToAutoCreate' + i, 
                                                                                               Object__c = 'Account',
                                                                                               Field__c = 'Name', 
                                                                                               Relationship_Type__c = 'AccountTester' + i,
                                                                                               Campaign_Types__c = '');
            relAutoCreateList.add(contactRelAutoCreate);
            relAutoCreateList.add(accountRelAutoCreate);
        }

        Test.startTest();
        for (Relationship_Auto_Create__c relAutoCreate : relAutoCreateList){
            ContactRelAutoCreateMappingModel conRelAutoCreateMapping = RelAutoCreateSettingsMapperService.getInstance().getModelFromMapping(relAutoCreate);
            if (conRelAutoCreateMapping.relationshipType.contains('ContactTester')){
                System.assertEquals(true, conRelAutoCreateMapping.contactFieldApiName.contains('ReportsToId'));
                System.assertEquals(true, conRelAutoCreateMapping.contactFieldLabel.contains('Reports To ID'));
            } else {
                System.assertEquals(true, conRelAutoCreateMapping.settingsContactFieldValue.contains('Name'));
                System.assertEquals(true, conRelAutoCreateMapping.relationshipType.contains('AccountTester'));
            }
        }
        Test.stopTest();
    }

    /***************************************************************************************************************************
    * @description Test method to verify that getModelFromMapping() returns a model with default settings applied when an empty 
    * Relationship Auto Create mapping is provided as input.
    ***************************************************************************************************************************/ 
    @isTest 
    private static void getModelFromMappingFalse(){
        RelAutoCreateSettingsMapperService.instance = new STUB_NoRelAutoCreateMappingModel();

        Test.startTest();
        System.assertEquals(null, RelAutoCreateSettingsMapperService.getInstance().getModelFromMapping(new Relationship_Auto_Create__c()), 'Empty Relationship Auto Create record should return null');
        Test.stopTest();
    }

    /**************************************************************************************************************************
    ****************************************************** STUBS **************************************************************
    **************************************************************************************************************************/

    /************************************************************************************************************
    * @description Stub class to simulate a null response from the getModelFromMapping method in the
    * RelAutoCreateSettingsMapperService.
    *************************************************************************************************************/ 
    private class STUB_NoRelAutoCreateMappingModel extends RelAutoCreateSettingsMapperService {
        @TestVisible
        public override ContactRelAutoCreateMappingModel getModelFromMapping(Relationship_Auto_Create__c relAutoCreate){
            return null;
        }
    }
}
@isTest
private with sharing class RelAutoCreateSettingsMapper_TEST {
    
    /**************************************************************************************************************************
    * @description Test method to verify that the getInstance method returns a new instance of the 
    * RelAutoCreateSettingsMapper class when one does not already exist.
    ***************************************************************************************************************************/
    @isTest
    private static void getInstanceNew() {
        RelAutoCreateSettingsMapper srvcRelAutoCreateSettingMapper = RelAutoCreateSettingsMapper.getInstance();
        System.assertEquals(RelAutoCreateSettingsMapper.instance, srvcRelAutoCreateSettingMapper, 'Instance of service class returned should match static instance variable.');
        System.assertEquals(true, srvcRelAutoCreateSettingMapper != null, 'Instance of service class should not be null.');
    }

    /**************************************************************************************************************************
    * @description Test method to verify that the getInstance method returns the existing instance of the 
    * RelAutoCreateSettingsMapper class when one already exists.
    ***************************************************************************************************************************/
    @isTest
    private static void getInstanceExisting() {
        RelAutoCreateSettingsMapper srvcRelAutoCreateSettingsMapperInstance1 = RelAutoCreateSettingsMapper.getInstance();
        RelAutoCreateSettingsMapper srvcRelAutoCreateSettingsMapperInstance2 = RelAutoCreateSettingsMapper.getInstance();
 
        System.assertEquals(RelAutoCreateSettingsMapper.instance, srvcRelAutoCreateSettingsMapperInstance1, 'Instance of service class returned should match static instance variable.');
        System.assertEquals(srvcRelAutoCreateSettingsMapperInstance1, srvcRelAutoCreateSettingsMapperInstance2, 'Subsequent retrievals of service class instance should return existing instance.');
        System.assertEquals(true, srvcRelAutoCreateSettingsMapperInstance1 != null, 'Instance of service class should not be null.');
    }

    /***************************************************************************************************************************
    * @description Test method to verify that getContactMappingModelsFromSettings() returns only the models for Relationship 
    * Auto Create mappings associated with the Contact object.
    ***************************************************************************************************************************/ 
    @isTest 
    private static void getContactMappingModelsFromSettingsTrue(){
        List<Relationship_Auto_Create__c> relAutoCreateList = new List<Relationship_Auto_Create__c>();
        Relationship_Auto_Create__c contactRelAutoCreate;
        Relationship_Auto_Create__c accountRelAutoCreate;

        for (Integer i = 0; i < 5; i++){
            contactRelAutoCreate = new Relationship_Auto_Create__c(Name = 'ConReportToAutoCreate' + i, 
                                                                                               Object__c = 'Contact',
                                                                                               Field__c = 'ReportsToId', 
                                                                                               Relationship_Type__c = 'ContactTester' + i,
                                                                                               Campaign_Types__c = '');

            accountRelAutoCreate = new Relationship_Auto_Create__c(Name = 'AccountReportToAutoCreate' + i, 
                                                                                               Object__c = 'Account',
                                                                                               Field__c = 'Name', 
                                                                                               Relationship_Type__c = 'AccountTester' + i,
                                                                                               Campaign_Types__c = '');
            relAutoCreateList.add(contactRelAutoCreate);
            relAutoCreateList.add(accountRelAutoCreate);
        }

        insert relAutoCreateList;

        Test.startTest();
        List<ContactRelAutoCreateMappingModel> conRelAutoCreateMappingList = RelAutoCreateSettingsMapper.getInstance().getContactMappingModelsFromSettings();
        Test.stopTest();

        System.assertEquals(5, conRelAutoCreateMappingList.size(), 'There should be 5 Relationship Auto Create Mapping models for Contact.');

        for (Integer i = 0; i < conRelAutoCreateMappingList.size(); i++){
            System.assertEquals('ReportsToId', conRelAutoCreateMappingList[i].contactFieldApiName, 'The contact field name set on model should correspond to the Relationship_Type__c for the Contact Relationship Auto Create mapping.');
            System.assertEquals('Reports To ID', conRelAutoCreateMappingList[i].contactFieldLabel, 'The contact field label set on model should correspond to the Relationship_Type__c for the Contact Relationship Auto Create mapping.');
            System.assertEquals('ContactTester' + i, conRelAutoCreateMappingList[i].relationshipType, 'The relationship type set on model should correspond to the Relationship_Type__c for the Contact Relationship Auto Create mapping.');
        }
    }

    /***************************************************************************************************************************
    * @description Test method to verify that getContactMappingModelsFromSettings() returns its cached value
    ***************************************************************************************************************************/ 
    @isTest 
    private static void getContactMappingModelsFromSettingsCached(){
        List<Relationship_Auto_Create__c> relAutoCreateList = new List<Relationship_Auto_Create__c>();
        Relationship_Auto_Create__c contactRelAutoCreate;
        Relationship_Auto_Create__c accountRelAutoCreate;

        for (Integer i = 0; i < 5; i++){
            contactRelAutoCreate = new Relationship_Auto_Create__c(Name = 'ConReportToAutoCreate' + i, 
                                                                                               Object__c = 'Contact',
                                                                                               Field__c = 'ReportsToId', 
                                                                                               Relationship_Type__c = 'ContactTester' + i,
                                                                                               Campaign_Types__c = '');

            accountRelAutoCreate = new Relationship_Auto_Create__c(Name = 'AccountReportToAutoCreate' + i, 
                                                                                               Object__c = 'Account',
                                                                                               Field__c = 'Name', 
                                                                                               Relationship_Type__c = 'AccountTester' + i,
                                                                                               Campaign_Types__c = '');
            relAutoCreateList.add(contactRelAutoCreate);
            relAutoCreateList.add(accountRelAutoCreate);
        }

        insert relAutoCreateList;

        List<ContactRelAutoCreateMappingModel> conRelAutoCreateMappingList = RelAutoCreateSettingsMapper.getInstance().getContactMappingModelsFromSettings();

        Test.startTest();
        List<ContactRelAutoCreateMappingModel> conRelAutoCreateMappingList2 = RelAutoCreateSettingsMapper.getInstance().getContactMappingModelsFromSettings();
        Test.stopTest();

        System.assertEquals(conRelAutoCreateMappingList, conRelAutoCreateMappingList2, 'The relationship autocreate mapping models should be cached.');
    }

    /***************************************************************************************************************************
    * @description Test method to verify that getContactMappingModelsFromSettings() returns an empty list
    * when there are no Relationship Auto Create mappings for the Contact object set.
    ***************************************************************************************************************************/ 
    @isTest 
    private static void getContactMappingModelsFromSettingsFalse(){
        List<Relationship_Auto_Create__c> relAutoCreateList = [SELECT Id 
                                                               FROM Relationship_Auto_Create__c];

        delete relAutoCreateList;

        Test.startTest();
        System.assertEquals(true, RelAutoCreateSettingsMapper.getInstance().getContactMappingModelsFromSettings().isEmpty(), 'There should be no Relationship Auto Create Mapping models for Contact.');
        Test.stopTest();
    }

    /***************************************************************************************************************************
    * @description Test method to verify that getContactMappingModelsFromMappings() returns a list of models representing
    * the Relationship Auto Create mappings provided as input (regardless of Object).
    ***************************************************************************************************************************/ 
    @isTest 
    private static void getContactMappingModelsFromMappingsTrue(){
        List<Relationship_Auto_Create__c> relAutoCreateList = new List<Relationship_Auto_Create__c>();

        for (Integer i = 0; i < 5; i++){
            Relationship_Auto_Create__c contactRelAutoCreate = new Relationship_Auto_Create__c(Id = UTIL_UnitTestData_TEST.getFakeId(Relationship_Auto_Create__c.SObjectType),
                                                                                               Name = 'ConReportToAutoCreate' + i, 
                                                                                               Object__c = 'Contact',
                                                                                               Field__c = 'reportsToId', 
                                                                                               Relationship_Type__c = 'ContactTester' + i,
                                                                                               Campaign_Types__c = '');

            Relationship_Auto_Create__c accountRelAutoCreate = new Relationship_Auto_Create__c(Id = UTIL_UnitTestData_TEST.getFakeId(Relationship_Auto_Create__c.SObjectType),
                                                                                               Name = 'AccountReportToAutoCreate' + i, 
                                                                                               Object__c = 'Account',
                                                                                               Field__c = 'Name', 
                                                                                               Relationship_Type__c = 'AccountTester' + i,
                                                                                               Campaign_Types__c = '');
            relAutoCreateList.add(contactRelAutoCreate);
            relAutoCreateList.add(accountRelAutoCreate);
        }

        Test.startTest();
        List<ContactRelAutoCreateMappingModel> conRelAutoCreateMappingsList = RelAutoCreateSettingsMapper.getInstance().getContactMappingModelsFromMappings(relAutoCreateList);
        Test.stopTest();

        System.assertEquals(10, conRelAutoCreateMappingsList.size(), 'There should be 10 ContactRelAutoCreateMappingModel returned.');
    }

    /***************************************************************************************************************************
    * @description Test method to verify that getContactMappingModelsFromMappings() returns an empty list of when no 
    * Relationships Auto Create mappings are provided as input.
    ***************************************************************************************************************************/ 
    @isTest 
    private static void getContactMappingModelsFromMappingsFalse(){
        List<Relationship_Auto_Create__c> relAutoCreateList = new List<Relationship_Auto_Create__c>();

        Test.startTest();
        List<ContactRelAutoCreateMappingModel> conRelAutoCreateMappingsList = RelAutoCreateSettingsMapper.getInstance().getContactMappingModelsFromMappings(relAutoCreateList);
        Test.stopTest();

        System.assertEquals(true, conRelAutoCreateMappingsList.isEmpty(), 'There should be no ContactRelAutoCreateMappingModel returned.');
    }

    /***************************************************************************************************************************
    * @description Test method to verify that getModelFromMapping() returns a model representing the Relationship Auto Create 
    * mapping provided as input (regardless of Object).
    ***************************************************************************************************************************/ 
    @isTest 
    private static void getModelFromMappingTrue(){
        List<Relationship_Auto_Create__c> relAutoCreateList = new List<Relationship_Auto_Create__c>();

        for (Integer i = 0; i < 5; i++){
            Relationship_Auto_Create__c contactRelAutoCreate = new Relationship_Auto_Create__c(Id = UTIL_UnitTestData_TEST.getFakeId(Relationship_Auto_Create__c.SObjectType),
                                                                                               Name = 'ConReportToAutoCreate' + i, 
                                                                                               Object__c = 'Contact',
                                                                                               Field__c = 'ReportsToId', 
                                                                                               Relationship_Type__c = 'ContactTester' + i,
                                                                                               Campaign_Types__c = '');

            Relationship_Auto_Create__c accountRelAutoCreate = new Relationship_Auto_Create__c(Id = UTIL_UnitTestData_TEST.getFakeId(Relationship_Auto_Create__c.SObjectType),
                                                                                               Name = 'AccountReportToAutoCreate' + i, 
                                                                                               Object__c = 'Account',
                                                                                               Field__c = 'Name', 
                                                                                               Relationship_Type__c = 'AccountTester' + i,
                                                                                               Campaign_Types__c = '');
            relAutoCreateList.add(contactRelAutoCreate);
            relAutoCreateList.add(accountRelAutoCreate);
        }

        Test.startTest();
        for (Relationship_Auto_Create__c relAutoCreate : relAutoCreateList){
            ContactRelAutoCreateMappingModel conRelAutoCreateMapping = RelAutoCreateSettingsMapper.getInstance().getModelFromMapping(relAutoCreate);
            if (conRelAutoCreateMapping.relationshipType.contains('ContactTester')){
                System.assertEquals(true, conRelAutoCreateMapping.contactFieldApiName.contains('ReportsToId'));
                System.assertEquals(true, conRelAutoCreateMapping.contactFieldLabel.contains('Reports To ID'));
            } else {
                System.assertEquals(true, conRelAutoCreateMapping.settingsContactFieldValue.contains('Name'));
                System.assertEquals(true, conRelAutoCreateMapping.relationshipType.contains('AccountTester'));
            }
        }
        Test.stopTest();
    }

    /***************************************************************************************************************************
    * @description Test method to verify that getModelFromMapping() returns a model with default settings applied when an empty 
    * Relationship Auto Create mapping is provided as input.
    ***************************************************************************************************************************/ 
    @isTest 
    private static void getModelFromMappingFalse(){
        RelAutoCreateSettingsMapper.instance = new STUB_NoRelAutoCreateMappingModel();

        Test.startTest();
        System.assertEquals(null, RelAutoCreateSettingsMapper.getInstance().getModelFromMapping(new Relationship_Auto_Create__c()), 'Empty Relationship Auto Create record should return null');
        Test.stopTest();
    }

    /**************************************************************************************************************************
    ****************************************************** STUBS **************************************************************
    **************************************************************************************************************************/

    /************************************************************************************************************
    * @description Stub class to simulate a null response from the getModelFromMapping method in the
    * RelAutoCreateSettingsMapper.
    *************************************************************************************************************/ 
    private class STUB_NoRelAutoCreateMappingModel extends RelAutoCreateSettingsMapper {
        @TestVisible
        public override ContactRelAutoCreateMappingModel getModelFromMapping(Relationship_Auto_Create__c relAutoCreate){
            return null;
        }
    }
}
@isTest
private class RelationshipLookupMapper_TEST {
    /**************************************************************************************************************************
     * @description Test method to verify that the getInstance method returns a new instance of the
     * RelationshipLookupMapper class when one does not already exist.
     ***************************************************************************************************************************/
    @isTest
    private static void getInstanceNew() {
        Test.startTest();
        RelationshipLookupMapper relationshipLookupMapperInstance = RelationshipLookupMapper.getInstance();
        Test.stopTest();

        System.assertEquals(
            RelationshipLookupMapper.instance,
            relationshipLookupMapperInstance,
            'Instance of mapper class returned should match static instance variable.'
        );
        System.assertEquals(
            true,
            relationshipLookupMapperInstance != null,
            'Instance of mapper class should not be null.'
        );
    }

    /**************************************************************************************************************************
     * @description Test method to verify that the getInstance method returns the existing instance of the
     * RelationshipLookupMapper class when one already exists.
     ***************************************************************************************************************************/
    @isTest
    private static void getInstanceExisting() {
        Test.startTest();
        RelationshipLookupMapper relationshipLookupMapperInstance1 = RelationshipLookupMapper.getInstance();
        RelationshipLookupMapper relationshipLookupMapperInstance2 = RelationshipLookupMapper.getInstance();
        Test.stopTest();

        System.assertEquals(
            RelationshipLookupMapper.instance,
            relationshipLookupMapperInstance1,
            'Instance of mapper class returned should match static instance variable.'
        );
        System.assertEquals(
            relationshipLookupMapperInstance1,
            relationshipLookupMapperInstance2,
            'Subsequent retrievals of mapper class instance should return existing instance.'
        );
        System.assertEquals(
            true,
            relationshipLookupMapperInstance1 != null,
            'Instance of mapper class should not be null.'
        );
    }

    /****************************************************************************************************************************
     * @description Test method to verify that the getRelationshipLookupModels method returns a list of relationship lookup models
     *****************************************************************************************************************************/
    @isTest
    private static void getRelationshipLookupModels() {
        RelationshipLookupMapper relationshipLookupMapperInstance = RelationshipLookupMapper.getInstance();

        insert new Relationship_Lookup__c(
            Name = 'test' + system.now(),
            Active__c = true,
            Female__c = 'wife',
            Male__c = 'husband',
            Neutral__c = 'spouse'
        );

        Test.startTest();
        List<RelationshipLookupModel> relationshipLookupModelsList = relationshipLookupMapperInstance.getRelationshipLookupModels();
        Test.stopTest();

        List<Relationship_Lookup__c> relationshipLookupList = UTIL_CustomSettingsFacade.getReciprocalSettings();

        System.assertEquals(1, relationshipLookupList.size(), 'Only one item should be available in the list');
        System.assertEquals(
            relationshipLookupList[0].Name,
            relationshipLookupModelsList[0].name,
            'Retrieved model\'s name should be same as Name from settings'
        );
        System.assertEquals(
            relationshipLookupList[0].Active__c,
            relationshipLookupModelsList[0].isActive,
            'Retrieved model\'s isActive should be same as isActive__c from settings'
        );
        System.assertEquals(
            relationshipLookupList[0].Female__c,
            relationshipLookupModelsList[0].femaleValue,
            'Retrieved model\'s femaleValue should be same as Female__c from settings'
        );
        System.assertEquals(
            relationshipLookupList[0].Male__c,
            relationshipLookupModelsList[0].maleValue,
            'Retrieved model\'s maleValue should be same as Male__c from settings'
        );
        System.assertEquals(
            relationshipLookupList[0].Neutral__c,
            relationshipLookupModelsList[0].neutralValue,
            'Retrieved model\'s neutralValue should be same as Neutral__c from settings'
        );
    }

    /****************************************************************************************************************************
     * @description Test method to verify that the insertRelationshipLookupModel inserts a record into Relationship_Lookup__c
     *****************************************************************************************************************************/
    @isTest
    private static void insertRelationshipLookupModel() {
        String relationshipLookupName = 'Father';
        String femaleValue = 'Daughter';
        String maleValue = 'Son';
        String neutralValue = 'Child';
        Boolean isActive = false;
        RelationshipLookupMapper relationshipLookupMapperInstance = RelationshipLookupMapper.getInstance();

        Test.startTest();
        relationshipLookupMapperInstance.insertRelationshipLookupModel(
            new RelationshipLookupModel(relationshipLookupName, isActive, femaleValue, maleValue, neutralValue)
        );
        Test.stopTest();

        Relationship_Lookup__c insertedRelationshipLookup = Relationship_Lookup__c.getInstance(relationshipLookupName);
        System.assertEquals(
            relationshipLookupName,
            insertedRelationshipLookup.Name,
            'Inserted record\'s name should be ' + relationshipLookupName
        );
        System.assertEquals(
            isActive,
            insertedRelationshipLookup.Active__c,
            'Inserted record\'s isActive__c should be ' + isActive
        );
        System.assertEquals(
            femaleValue,
            insertedRelationshipLookup.Female__c,
            'Inserted record\'s Female__c should be ' + femaleValue
        );
        System.assertEquals(
            maleValue,
            insertedRelationshipLookup.Male__c,
            'Inserted record\'s Male__c should be ' + maleValue
        );
        System.assertEquals(
            neutralValue,
            insertedRelationshipLookup.Neutral__c,
            'Inserted record\'s Neutral__c should be ' + neutralValue
        );
    }

    /****************************************************************************************************************************
     * @description Test method to verify that the updateRelationshipLookupModel updates a record in Relationship_Lookup__c
     *****************************************************************************************************************************/
    @isTest
    private static void updateRelationshipLookupModel() {
        String oldRelationshipLookupName = 'Test';
        String newRelationshipLookupName = 'Father';
        String femaleValue = 'Daughter';
        String maleValue = 'Son';
        String neutralValue = 'Child';
        Boolean isActive = true;
        RelationshipLookupMapper relationshipLookupMapperInstance = RelationshipLookupMapper.getInstance();

        insert new Relationship_Lookup__c(
            Name = oldRelationshipLookupName,
            Active__c = false,
            Female__c = 'wife',
            Male__c = 'husband',
            Neutral__c = 'spouse'
        );

        Test.startTest();
        relationshipLookupMapperInstance.updateRelationshipLookupModel(
            oldRelationshipLookupName,
            new RelationshipLookupModel(newRelationshipLookupName, isActive, femaleValue, maleValue, neutralValue)
        );
        Test.stopTest();

        Relationship_Lookup__c updatedOldRelationshipLookup = Relationship_Lookup__c.getInstance(
            oldRelationshipLookupName
        );
        Relationship_Lookup__c updatedRelationshipLookup = Relationship_Lookup__c.getInstance(
            newRelationshipLookupName
        );

        System.assertEquals(
            null,
            updatedOldRelationshipLookup,
            'A relationship record with old name should not exist: ' + oldRelationshipLookupName
        );
        System.assertEquals(
            newRelationshipLookupName,
            updatedRelationshipLookup.Name,
            'Inserted record\'s name should be ' + newRelationshipLookupName
        );
        System.assertEquals(
            isActive,
            updatedRelationshipLookup.Active__c,
            'Inserted record\'s isActive__c should be ' + isActive
        );
        System.assertEquals(
            femaleValue,
            updatedRelationshipLookup.Female__c,
            'Inserted record\'s Female__c should be ' + femaleValue
        );
        System.assertEquals(
            maleValue,
            updatedRelationshipLookup.Male__c,
            'Inserted record\'s Male__c should be ' + maleValue
        );
        System.assertEquals(
            neutralValue,
            updatedRelationshipLookup.Neutral__c,
            'Inserted record\'s Neutral__c should be ' + neutralValue
        );
    }

    /****************************************************************************************************************************
     * @description Test method to verify that the deleteRelationshipLookupModel deletes a record in Relationship_Lookup__c
     *****************************************************************************************************************************/
    @isTest
    private static void deleteRelationshipLookupModel() {
        String relationshipLookupName = 'Father';
        String femaleValue = 'Daughter';
        String maleValue = 'Son';
        String neutralValue = 'Child';
        Boolean isActive = true;
        RelationshipLookupMapper relationshipLookupMapperInstance = RelationshipLookupMapper.getInstance();

        insert new Relationship_Lookup__c(
            Name = relationshipLookupName,
            Active__c = isActive,
            Female__c = femaleValue,
            Male__c = maleValue,
            Neutral__c = neutralValue
        );
        Relationship_Lookup__c existingRelationshipLookup = Relationship_Lookup__c.getInstance(relationshipLookupName);

        Test.startTest();
        relationshipLookupMapperInstance.deleteRelationshipLookupModel(
            new RelationshipLookupModel(relationshipLookupName, isActive, femaleValue, maleValue, neutralValue)
        );
        Test.stopTest();

        Relationship_Lookup__c deletedRelationshipLookup = Relationship_Lookup__c.getInstance(relationshipLookupName);

        System.assertNotEquals(
            null,
            existingRelationshipLookup,
            'Inserted relationship record with name \'' +
            relationshipLookupName +
            '\' should exist prior to delete'
        );
        System.assertEquals(
            relationshipLookupName,
            existingRelationshipLookup.Name,
            'Inserted record\'s name should be ' + relationshipLookupName
        );
        System.assertEquals(
            null,
            deletedRelationshipLookup,
            'A relationship record with name \'' +
            relationshipLookupName +
            '\' should not exist'
        );
    }
}
@isTest
private class RelationshipLookupSettingsService_TEST {
    /**************************************************************************************************************************
     * @description Test method to verify that the getInstance method returns a new instance of the
     * RelationshipLookupSettingsService class when one does not already exist.
     ***************************************************************************************************************************/
    @isTest
    private static void getInstanceNew() {
        Test.startTest();
        RelationshipLookupSettingsService relationshipLookupSettingsServiceInstance = RelationshipLookupSettingsService.getInstance();
        Test.stopTest();

        System.assertEquals(
            RelationshipLookupSettingsService.instance,
            relationshipLookupSettingsServiceInstance,
            'Instance of service class returned should match static instance variable.'
        );
        System.assertEquals(
            true,
            relationshipLookupSettingsServiceInstance != null,
            'Instance of service class should not be null.'
        );
    }

    /**************************************************************************************************************************
     * @description Test method to verify that the getInstance method returns the existing instance of the
     * RelationshipLookupSettingsService class when one already exists.
     ***************************************************************************************************************************/
    @isTest
    private static void getInstanceExisting() {
        Test.startTest();
        RelationshipLookupSettingsService relationshipLookupSettingsServiceInstance1 = RelationshipLookupSettingsService.getInstance();
        RelationshipLookupSettingsService relationshipLookupSettingsServiceInstance2 = RelationshipLookupSettingsService.getInstance();
        Test.stopTest();

        System.assertEquals(
            RelationshipLookupSettingsService.instance,
            relationshipLookupSettingsServiceInstance1,
            'Instance of service class returned should match static instance variable.'
        );
        System.assertEquals(
            relationshipLookupSettingsServiceInstance1,
            relationshipLookupSettingsServiceInstance2,
            'Subsequent retrievals of service class instance should return existing instance.'
        );
        System.assertEquals(
            true,
            relationshipLookupSettingsServiceInstance1 != null,
            'Instance of service class should not be null.'
        );
    }

    /***********************************************************************************************************************************
     * @description Test method to verify that the locateRelationshipLookupMapper method returns instance of RelationshipLookupMapper
     ***********************************************************************************************************************************/
    @isTest
    private static void locateRelationshipLookupMapper() {
        Test.startTest();
        RelationshipLookupMapper relLookupMapper = RelationshipLookupSettingsService.getInstance()
            .locateRelationshipLookupMapper();
        Test.stopTest();

        System.assertEquals(
            RelationshipLookupMapper.getInstance(),
            relLookupMapper,
            'Should return the instance of RelationshipLookupMapper'
        );
    }

    /***********************************************************************************************************************************
     * @description Test method to verify that the getRelationshipLookupModels method returns instance of getRelationshipLookup Models
     ***********************************************************************************************************************************/
    @isTest
    private static void getRelationshipLookupModels() {
        RelationshipLookupMapper.instance = new STUB_RelationshipLookupMapper();

        Test.startTest();
        List<RelationshipLookupModel> relationshipLookupModelList = RelationshipLookupSettingsService.getInstance()
            .getRelationshipLookupModels();
        Test.stopTest();

        System.assertEquals(
            1,
            relationshipLookupModelList.size(),
            'Only 1 record should be availabel in the list as we are adding only one settings to the model'
        );
        System.assertEquals(
            'Father',
            relationshipLookupModelList[0].Name,
            'Retrieved model\'s name should be same as Name from settings'
        );
        System.assertEquals(
            true,
            relationshipLookupModelList[0].isActive,
            'Retrieved model\'s isActive should be same as isActive__c from settings'
        );
        System.assertEquals(
            'Daughter',
            relationshipLookupModelList[0].femaleValue,
            'Retrieved model\'s femaleValue should be same as Female__c from settings'
        );
        System.assertEquals(
            'Son',
            relationshipLookupModelList[0].maleValue,
            'Retrieved model\'s maleValue should be same as Male__c from settings'
        );
        System.assertEquals(
            'Child',
            relationshipLookupModelList[0].neutralValue,
            'Retrieved model\'s neutralValue should be same as Neutral__c from settings'
        );
    }

    /***************************************************************************
     * @description Test Method to verify that duplicate relationship model names
     * are retrieved.
     ***************************************************************************/
    @isTest
    private static void getDuplicateRelationshipModelNamesFromList() {
        RelationshipLookupModel uniqueRelationshipLookupModel = new RelationshipLookupModel(
            'unique',
            true,
            'uniquefemale',
            'uniquemale',
            'uniqueneutral'
        );

        RelationshipLookupModel duplicateRelationshipLookupModel1 = new RelationshipLookupModel(
            'duplicate',
            true,
            'duplicatefemale1',
            'duplicatemale1',
            'duplicateneutral1'
        );
        RelationshipLookupModel duplicateRelationshipLookupModel2 = new RelationshipLookupModel(
            'duplicate',
            true,
            'duplicatefemale2',
            'duplicatemale2',
            'duplicateneutral2'
        );

        List<RelationshipLookupModel> relationshipLookupModelList = new List<RelationshipLookupModel>{
            uniqueRelationshipLookupModel,
            duplicateRelationshipLookupModel1,
            duplicateRelationshipLookupModel2
        };

        RelationshipLookupSettingsService relationshipLookupSettingsService = RelationshipLookupSettingsService.getInstance();

        Test.startTest();
        Set<String> duplicateNameSet = relationshipLookupSettingsService.getDuplicateRelationshipModelNamesFromList(
            relationshipLookupModelList
        );
        Test.stopTest();

        System.assertEquals(1, duplicateNameSet.size(), 'Duplicate name set size should equal 1');
        System.assertEquals(
            true,
            duplicateNameSet.contains('duplicate'),
            'Duplicate name set should contain name for duplicate'
        );
        System.assertNotEquals(
            true,
            duplicateNameSet.contains('unique'),
            'Duplicate name set should not contain name for unique.'
        );
    }

    /***************************************************************************
     * @description Test Method to verify that insertRelationshipLookup returns
     * a valid RelationshipLookupModel model
     ***************************************************************************/
    @isTest
    private static void insertRelationshipLookup() {
        UserPermissionService.instance = new STUB_UserPermissionServiceTrue();
        RelationshipLookupMapper.instance = new STUB_RelationshipLookupMapper();
        String relationshipLookupName = 'TestRelationshipLookupName';
        String femaleValue = 'TestFemaleValue';
        String maleValue = 'TestMaleValue';
        String neutralValue = 'TestNeutralValue';
        Boolean isActive = false;

        Test.startTest();
        RelationshipLookupModel insertRelationshipLookupModel = RelationshipLookupSettingsService.getInstance()
            .insertRelationshipLookup(relationshipLookupName, femaleValue, maleValue, neutralValue, isActive);
        Test.stopTest();

        System.assertNotEquals(null, insertRelationshipLookupModel, 'Should return a RelationshipLookupModel instance');
        System.assertEquals(
            relationshipLookupName,
            insertRelationshipLookupModel.name,
            'Inserted model\'s name should be ' + relationshipLookupName
        );
        System.assertEquals(
            isActive,
            insertRelationshipLookupModel.isActive,
            'Inserted model\'s isActive should be ' + isActive
        );
        System.assertEquals(
            femaleValue,
            insertRelationshipLookupModel.femaleValue,
            'Inserted model\'s femaleValue should ' + femaleValue
        );
        System.assertEquals(
            maleValue,
            insertRelationshipLookupModel.maleValue,
            'Inserted model\'s maleValue should be ' + maleValue
        );
        System.assertEquals(
            neutralValue,
            insertRelationshipLookupModel.neutralValue,
            'Inserted model\'s neutralValue should be ' + neutralValue
        );
    }

    /***************************************************************************
     * @description Test Method to verify that updateRelationshipLookup returns
     * a valid RelationshipLookupModel model
     ***************************************************************************/
    @isTest
    private static void updateRelationshipLookup() {
        UserPermissionService.instance = new STUB_UserPermissionServiceTrue();
        RelationshipLookupMapper.instance = new STUB_RelationshipLookupMapper();
        String newRelationshipLookupName = 'TestNewRelationshipLookupName';
        String oldRelationshipLookupName = 'TestOldRelationshipLookupName';
        String femaleValue = 'TestFemaleValue';
        String maleValue = 'TestMaleValue';
        String neutralValue = 'TestNeutralValue';
        Boolean isActive = false;

        Test.startTest();
        RelationshipLookupModel updateRelationshipLookupModel = RelationshipLookupSettingsService.getInstance()
            .updateRelationshipLookup(
                oldRelationshipLookupName,
                newRelationshipLookupName,
                femaleValue,
                maleValue,
                neutralValue,
                isActive
            );
        Test.stopTest();

        System.assertNotEquals(null, updateRelationshipLookupModel, 'Should return a RelationshipLookupModel instance');
        System.assertEquals(
            newRelationshipLookupName,
            updateRelationshipLookupModel.name,
            'Updated model\'s name should be ' + newRelationshipLookupName
        );
        System.assertEquals(
            isActive,
            updateRelationshipLookupModel.isActive,
            'Updated model\'s isActive should be ' + isActive
        );
        System.assertEquals(
            femaleValue,
            updateRelationshipLookupModel.femaleValue,
            'Updated model\'s femaleValue should ' + femaleValue
        );
        System.assertEquals(
            maleValue,
            updateRelationshipLookupModel.maleValue,
            'Updated model\'s maleValue should be ' + maleValue
        );
        System.assertEquals(
            neutralValue,
            updateRelationshipLookupModel.neutralValue,
            'Updated model\'s neutralValue should be ' + neutralValue
        );
    }

    /***************************************************************************
     * @description Test Method to verify that deleteRelationshipLookup returns
     * a valid RelationshipLookupModel model
     ***************************************************************************/
    @isTest
    private static void deleteRelationshipLookup() {
        UserPermissionService.instance = new STUB_UserPermissionServiceTrue();
        RelationshipLookupMapper.instance = new STUB_RelationshipLookupMapper();
        String relationshipLookupName = 'Father';
        String femaleValue = 'Daughter';
        String maleValue = 'Son';
        String neutralValue = 'Child';
        Boolean isActive = false;

        Test.startTest();
        Relationship_Lookup__c relLookupRecord = new Relationship_Lookup__c(
            Name = relationshipLookupName,
            Female__c = femaleValue,
            Male__c = maleValue,
            Neutral__c = neutralValue,
            Active__c = isActive
        );

        insert relLookupRecord;

        RelationshipLookupModel deleteRelationshipLookupModel = RelationshipLookupSettingsService.getInstance()
            .deleteRelationshipLookup(relationshipLookupName);
        Test.stopTest();

        System.assertNotEquals(null, deleteRelationshipLookupModel, 'Should return a RelationshipLookupModel instance');
        System.assertEquals(
            relationshipLookupName,
            deleteRelationshipLookupModel.name,
            'Deleted model\'s name should be ' + relationshipLookupName
        );
        System.assertEquals(
            isActive,
            deleteRelationshipLookupModel.isActive,
            'Deleted model\'s isActive should be ' + isActive
        );
        System.assertEquals(
            femaleValue,
            deleteRelationshipLookupModel.femaleValue,
            'Deleted model\'s femaleValue should ' + femaleValue
        );
        System.assertEquals(
            maleValue,
            deleteRelationshipLookupModel.maleValue,
            'Deleted model\'s maleValue should be ' + maleValue
        );
        System.assertEquals(
            neutralValue,
            deleteRelationshipLookupModel.neutralValue,
            'Deleted model\'s neutralValue should be ' + neutralValue
        );
    }

    /***************************************************************************
     * @description Test Method to verify that deleteRelationshipLookup returns
     * null if relationship lookup record doesn't exist
     ***************************************************************************/
    @isTest
    private static void deleteRelationshipLookupNonExistent() {
        UserPermissionService.instance = new STUB_UserPermissionServiceTrue();
        RelationshipLookupMapper.instance = new STUB_RelationshipLookupMapper();
        String relationshipLookupName = 'Father';

        Test.startTest();
        RelationshipLookupModel deleteRelationshipLookupModel = RelationshipLookupSettingsService.getInstance()
            .deleteRelationshipLookup(relationshipLookupName);
        Test.stopTest();

        System.assertEquals(
            null,
            deleteRelationshipLookupModel,
            'Should return null for non existent relationship lookup'
        );
    }

    /**************************************************************************************************************************
     * @description Test method to verify deleteRelationshipLookup does not delete a reltionship lookup without sufficient
     * user permissions.
     **************************************************************************************************************************/
    @isTest
    private static void deleteRelationshipLookupNoPermission() {
        UserPermissionService.instance = new STUB_UserPermissionServiceFalse();
        RelationshipLookupMapper.instance = new STUB_RelationshipLookupMapper();
        String relationshipLookupName = 'Father';
        String femaleValue = 'Daughter';
        String maleValue = 'Son';
        String neutralValue = 'Child';
        Boolean isActive = false;

        Test.startTest();
        Relationship_Lookup__c relLookupRecord = new Relationship_Lookup__c(
            Name = relationshipLookupName,
            Female__c = femaleValue,
            Male__c = maleValue,
            Neutral__c = neutralValue,
            Active__c = isActive
        );
        insert relLookupRecord;

        RelationshipLookupModel deleteRelationshipLookupModel = RelationshipLookupSettingsService.getInstance()
            .deleteRelationshipLookup(relationshipLookupName);
        Test.stopTest();

        List<Relationship_Lookup__c> relationshipLookupResultsList = [
            SELECT Name
            FROM Relationship_Lookup__c
            WHERE Name = :relationshipLookupName
        ];

        System.assertEquals(
            1,
            relationshipLookupResultsList.size(),
            'Relationship lookup should not be deleted due to insufficient user permissions.'
        );

        System.assertEquals(
            null,
            deleteRelationshipLookupModel,
            'Deleting relationship lookup without appropriate permissions should return null value.'
        );
    }

    /***********************************************************************************************************************************
     ****************************************************** STUBS ***********************************************************************
     ***********************************************************************************************************************************/

    /**************************************************************************************************************************************
     * @description Stub class to simulate the response from RelationshipLookupMapper to return a RelationshipLookup model
     **************************************************************************************************************************************/
    private class STUB_RelationshipLookupMapper extends RelationshipLookupMapper {
        public override List<RelationshipLookupModel> getRelationshipLookupModels() {
            List<RelationshipLookupModel> RelationshipLookupModelList = new List<RelationshipLookupModel>();

            RelationshipLookupModel accModelSettingsModel = new RelationshipLookupModel(
                'Father',
                true,
                'Daughter',
                'Son',
                'Child'
            );
            RelationshipLookupModelList.add(accModelSettingsModel);

            return RelationshipLookupModelList;
        }

        public override void insertRelationshipLookupModel(RelationshipLookupModel relLookupModel) {
            System.assertEquals(
                'TestRelationshipLookupName',
                relLookupModel.name,
                'Inserted model\'s name should be \'TestRelationshipLookupName\''
            );
        }

        public override void updateRelationshipLookupModel(
            String relationshipLookupName,
            RelationshipLookupModel relLookupModel
        ) {
            System.assertEquals(
                'TestOldRelationshipLookupName',
                relationshipLookupName,
                'Updated model\'s old name should be \'TestOldRelationshipLookupName\''
            );
            System.assertEquals(
                'TestNewRelationshipLookupName',
                relLookupModel.name,
                'Updated model\'s new name should be \'TestNewRelationshipLookupName\''
            );
        }

        public override void deleteRelationshipLookupModel(RelationshipLookupModel relLookupModel) {
            System.assertEquals('Father', relLookupModel.name, 'Deleted model\'s name should be Father');
        }
    }

    /**************************************************************************************************************************************
     * @description Stub class to simulate the response from UserPermissionService to return true
     **************************************************************************************************************************************/
    private class STUB_UserPermissionServiceTrue extends UserPermissionService {
        public override Boolean checkCustomizeApplicationForCurrentUser() {
            return true;
        }
    }

    /**************************************************************************************************************************************
     * @description Stub class to simulate the response from UserPermissionService to return false
     **************************************************************************************************************************************/
    private class STUB_UserPermissionServiceFalse extends UserPermissionService {
        public override Boolean checkCustomizeApplicationForCurrentUser() {
            return false;
        }
    }
}
public virtual with sharing class RelationshipLookupsVMapper {
    /*********************************************
     * @description Instance for Singleton Pattern
     **********************************************/
    @TestVisible
    private static RelationshipLookupsVMapper instance;

    /*********************************************************************
     * @description Empty constructor is not public for Singleton Pattern
     **********************************************************************/
    protected RelationshipLookupsVMapper() {
    }

    /*****************************************************************************
     * @description Static method to get the current instance for Singleton pattern
     * @return The instance of RelationshipLookupsVMapper.
     ******************************************************************************/
    public static RelationshipLookupsVMapper getInstance() {
        if (instance == null) {
            instance = new RelationshipLookupsVMapper();
        }

        return instance;
    }

    /**
     * @description Retrieve a RelationshipLookupsVModel represeting the current values specified for Reciprocal Relationship mappings.
     * @return   A RelationshipLookupsVModel instance
     */
    public virtual RelationshipLookupsVModel getRelationshipLookupsVModel() {
        List<RelationshipLookupModel> relationshipLookupModelList = this.locateRelationshipLookupSettingsService()
            .getRelationshipLookupModels();
        List<RelationshipLookupVModel> relationshipLookupVModelList = new List<RelationshipLookupVModel>();
        for (RelationshipLookupModel relLookupModel : relationshipLookupModelList) {
            relationshipLookupVModelList.add(
                new RelationshipLookupVModel(
                    relLookupModel.name,
                    relLookupModel.femaleValue,
                    relLookupModel.maleValue,
                    relLookupModel.neutralValue,
                    relLookupModel.isActive
                )
            );
        }
        return new RelationshipLookupsVModel(relationshipLookupVModelList);
    }

    /**
     * @description Gets Relationship Type picklist values for FemaleValue, MaleValue and NeutralValue
     * @param  relationshipLookupName Specifies an existing relationship lookup name.
     * @return                        A ComboBoxVModel
     */
    public virtual ComboBoxVModel getRelationshipLookupComboboxVModel(String relationshipLookupName) {
        return this.getActiveRelationshipTypesComboboxVModel(relationshipLookupName);
    }

    /**
     * @description gets all active Relationship Type picklist values
     * @param  relationshipLookupName Specifies an existing relationship lookup name.
     * @return                        A ComboBoxVModel
     */
    public virtual ComboBoxVModel getActiveRelationshipTypesComboboxVModel(String relationshipLookupName) {
        Map<String, PicklistEntryModel> picklistEntryModelsByName = this.locatePicklistEntryService()
            .getModelsByNameForSObjectField(Relationship__c.SObjectType, Relationship__c.Type__c);
        Map<String, PicklistEntryModel> activePicklistEntryModelsByName = new Map<String, PicklistEntryModel>();
        Boolean nameExists = false;
        for (PicklistEntryModel picklistEntryModel : picklistEntryModelsByName.values()) {
            if (picklistEntryModel.isActive == true || picklistEntryModel.name == relationshipLookupName) {
                nameExists |= picklistEntryModel.name == relationshipLookupName;
                activePicklistEntryModelsByName.put(picklistEntryModel.name, picklistEntryModel);
            }
        }
        List<ComboboxValueVModel> activePicklistEntryModelList = this.getComboboxValueVModelListFromPicklist(
            activePicklistEntryModelsByName
        );
        if (!nameExists && String.isNotBlank(relationshipLookupName)) {
            //if relationshipLookupName doesn't exist in picklistEntryModelsByName (for example if it is inactive or missing)
            //insert it explicitly so the dropdown control could show the current value
            activePicklistEntryModelList.add(
                0,
                new ComboboxValueVModel(relationshipLookupName, relationshipLookupName)
            );
        }
        return new ComboboxVModel(relationshipLookupName, activePicklistEntryModelList);
    }

    /**
     * @description Gets Relationship Type picklist values for the name field
     * @param  relationshipLookupName Specifies an existing relationship lookup name. Should be an empty string for a new record
     * @return                        A ComboBoxVModel model with populated active unmapped picklist items
     */
    public virtual ComboBoxVModel getRelationshipLookupNameComboboxVModel(String relationshipLookupName) {
        //For relationship lookup name field we return the active unmapped values
        return this.getActiveUnmappedRelationshipTypesComboboxVModel(relationshipLookupName);
    }

    /**
     * @description gets all active unmapped Relationship Type picklist values
     * @return   A ComboBoxVModel
     */
    public virtual ComboBoxVModel getActiveUnmappedRelationshipTypesComboboxVModel(String relationshipLookupName) {
        PicklistEntryService picklistEntryServiceInstance = this.locatePicklistEntryService();

        Map<String, PicklistEntryModel> picklistEntryModelByName = picklistEntryServiceInstance.getActivePicklistEntryModelsByName(
            picklistEntryServiceInstance.getModelsByNameForSObjectField(
                Relationship__c.SObjectType,
                Relationship__c.Type__c
            )
        );

        //filtering out mapped values
        List<RelationshipLookupModel> relationshipLookupModelList = this.locateRelationshipLookupSettingsService()
            .getRelationshipLookupModels();
        for (RelationshipLookupModel relLookupModel : relationshipLookupModelList) {
            if (relLookupModel.name != relationshipLookupName) {
                picklistEntryModelByName.remove(relLookupModel.name);
            }
        }

        List<ComboboxValueVModel> comboboxValues = this.getComboboxValueVModelListFromPicklist(
            picklistEntryModelByName
        );
        if (
            String.isNotBlank(relationshipLookupName) && !picklistEntryModelByName.containsKey(relationshipLookupName)
        ) {
            //if relationshipLookupName doesn't exist in picklistEntryModelsByName (for example if it is inactive or missing)
            //insert it explicitly so the dropdown control could show the current value
            comboboxValues.add(0, new ComboboxValueVModel(relationshipLookupName, relationshipLookupName));
        }

        return new ComboboxVModel(relationshipLookupName, comboboxValues);
    }

    /**
     * @description Maps PicklistEntryModel map to ComboboxValueVModel list
     * @param  picklistEntryModelByName a map of PicklistEntryModel items
     * @return                          a list of ComboboxValueVModel view models
     */
    @TestVisible
    private List<ComboboxValueVModel> getComboboxValueVModelListFromPicklist(
        Map<String, PicklistEntryModel> picklistEntryModelByName
    ) {
        List<ComboboxValueVModel> comboBoxValueVModelList = new List<ComboboxValueVModel>();
        for (PicklistEntryModel pickListEntry : picklistEntryModelByName.values()) {
            comboBoxValueVModelList.add(new ComboboxValueVModel(pickListEntry.label, pickListEntry.name));
        }

        return comboBoxValueVModelList;
    }

    /***************************************************************************
     * @description Retrieves an instance of PicklistEntryService.
     * @return An instance of PicklistEntryService.
     ***************************************************************************/
    @TestVisible
    private PicklistEntryService locatePicklistEntryService() {
        return PicklistEntryService.getInstance();
    }

    /*****************************************************************************
     * @description Retrieve an instance of the RelationshipLookupSettingsService class.
     * @return An instance of RelationshipLookupSettingsService.
     *****************************************************************************/
    @TestVisible
    private RelationshipLookupSettingsService locateRelationshipLookupSettingsService() {
        return RelationshipLookupSettingsService.getInstance();
    }
}
@isTest
private with sharing class RelationshipLookupsVMapper_TEST {
    /**************************************************************************************************
     * @description Test method to verify that the getInstance method returns a new instance of the
     * RelationshipLookupsVMapper class when one does not already exist.
     **************************************************************************************************/
    @isTest
    private static void getInstanceNew() {
        Test.startTest();
        RelationshipLookupsVMapper relationshipLookupsVMapperInstance = RelationshipLookupsVMapper.getInstance();
        Test.stopTest();

        System.assertEquals(
            RelationshipLookupsVMapper.instance,
            relationshipLookupsVMapperInstance,
            'Instance of mapper class returned should match static instance variable.'
        );
        System.assertEquals(
            true,
            relationshipLookupsVMapperInstance != null,
            'Instance of mapper class should not be null.'
        );
    }

    /**************************************************************************************************
     * @description Test method to verify that the getInstance method returns the existing instance of the
     * RelationshipLookupsVMapper class when one already exists.
     **************************************************************************************************/
    @isTest
    private static void getInstanceExisting() {
        Test.startTest();
        RelationshipLookupsVMapper relationshipLookupsVMapperInstance1 = RelationshipLookupsVMapper.getInstance();
        RelationshipLookupsVMapper relationshipLookupsVMapperInstance2 = RelationshipLookupsVMapper.getInstance();
        Test.stopTest();

        System.assertEquals(
            RelationshipLookupsVMapper.instance,
            relationshipLookupsVMapperInstance1,
            'Instance of mapper class returned should match static instance variable.'
        );
        System.assertEquals(
            relationshipLookupsVMapperInstance1,
            relationshipLookupsVMapperInstance2,
            'Subsequent retrievals of mapper class instance should return existing instance.'
        );
        System.assertEquals(
            true,
            relationshipLookupsVMapperInstance1 != null,
            'Instance of mapper class should not be null.'
        );
    }

    /****************************************************************************************
     * @description Test method to verify locateRelationshipLookupSettingsService() returns an instance of
     * the RelationshipLookupSettingsService class.
     ****************************************************************************************/
    @isTest
    private static void locatePicklistEntryServiceValid() {
        RelationshipLookupsVMapper relationshipLookupsVMapperInstance = RelationshipLookupsVMapper.getInstance();

        Test.startTest();
        PicklistEntryService picklistEntryServiceInstance = relationshipLookupsVMapperInstance.locatePicklistEntryService();
        Test.stopTest();

        System.assertEquals(
            PicklistEntryService.getInstance(),
            picklistEntryServiceInstance,
            'Should return instance of PicklistEntryService class.'
        );
    }

    /****************************************************************************************
     * @description Test method to verify locateRelationshipLookupSettingsService() returns an instance of
     * the RelationshipLookupSettingsService class.
     ****************************************************************************************/
    @isTest
    private static void locateRelationshipLookupSettingsServiceValid() {
        RelationshipLookupsVMapper relationshipLookupsVMapperInstance = RelationshipLookupsVMapper.getInstance();

        Test.startTest();
        RelationshipLookupSettingsService relationshipLookupSettingsServiceInstance = relationshipLookupsVMapperInstance.locateRelationshipLookupSettingsService();
        Test.stopTest();

        System.assertEquals(
            RelationshipLookupSettingsService.getInstance(),
            relationshipLookupSettingsServiceInstance,
            'Should return instance of RelationshipLookupSettingsService class.'
        );
    }

    /****************************************************************************************
     * @description Test method to verify getComboboxValueVModelListFromPicklist()
     * returns a list of ComboboxValueVModels representing the relationship lookup picklist values
     ****************************************************************************************/
    @isTest
    private static void getComboboxValueVModelListFromPicklistValid() {
        STUB_PicklistEntryService picklistEntryServiceStub = new STUB_PicklistEntryService();

        RelationshipLookupsVMapper relationshipLookupsVMapperInstance = RelationshipLookupsVMapper.getInstance();

        Test.startTest();
        List<ComboboxValueVModel> lookupComboboxValueVModelsList = relationshipLookupsVMapperInstance.getComboboxValueVModelListFromPicklist(
            picklistEntryServiceStub.getModelsByNameForSObjectField(null, null)
        );
        Test.stopTest();

        System.assertEquals(7, lookupComboboxValueVModelsList.size(), 'Should return 7 ComboboxValueVModels.');

        for (Integer i = 0; i < lookupComboboxValueVModelsList.size(); i++) {
            System.assertEquals(
                'TestRelationshipName' + String.valueOf(i + 1),
                lookupComboboxValueVModelsList[i].value,
                'ComoboboxValueVModel value should match lookup field model name.'
            );

            System.assertEquals(
                'TestRelationshipLabel' + String.valueOf(i + 1),
                lookupComboboxValueVModelsList[i].label,
                'ComoboboxValueVModel label should match lookup field model label.'
            );
        }
    }

    /****************************************************************************************
     * @description Test method to verify getRelationshipLookupsVModel()
     * returns a RelationshipLookupsVModel representing existing relationship lookups
     ****************************************************************************************/
    @isTest
    private static void getRelationshipLookupsVModelValid() {
        PicklistEntryService.instance = new STUB_PicklistEntryService();
        RelationshipLookupSettingsService.instance = new STUB_RelationshipLookupSettingsService();

        RelationshipLookupsVMapper relationshipLookupsVMapperInstance = RelationshipLookupsVMapper.getInstance();

        Test.startTest();
        RelationshipLookupsVModel relLookupVModel = relationshipLookupsVMapperInstance.getRelationshipLookupsVModel();
        Test.stopTest();

        System.assertEquals(
            5,
            relLookupVModel.relationshipLookups.size(),
            'Should return 5 RelationshipLookupVModel items'
        );

        System.assertEquals(
            'TestRelationshipName1',
            relLookupVModel.relationshipLookups[0].name,
            'Relationship lookup name should be \'TestRelationshipName1\''
        );
        System.assertEquals(
            'TestFemaleValue1',
            relLookupVModel.relationshipLookups[0].femaleValue,
            'Female value should be \'TestFemaleValue1\''
        );
        System.assertEquals(
            'TestMaleValue1',
            relLookupVModel.relationshipLookups[0].maleValue,
            'Male value should be \'TestMaleValue1\''
        );
        System.assertEquals(
            'TestNeutralValue1',
            relLookupVModel.relationshipLookups[0].neutralValue,
            'Neutral value should be \'TestNeutralValue1\''
        );
        System.assertEquals(true, relLookupVModel.relationshipLookups[0].isActive, 'isActive should be \'true\'');
    }

    /****************************************************************************************
     * @description Test method to verify getRelationshipLookupComboboxVModel()
     * returns a ComboboxVModel representing active picklist items
     ****************************************************************************************/
    @isTest
    private static void getRelationshipLookupComboboxVModelValid() {
        PicklistEntryService.instance = new STUB_PicklistEntryService();
        RelationshipLookupSettingsService.instance = new STUB_RelationshipLookupSettingsService();

        RelationshipLookupsVMapper relationshipLookupsVMapperInstance = RelationshipLookupsVMapper.getInstance();

        Test.startTest();
        ComboBoxVModel relationshipLookupComboBoxVModel = relationshipLookupsVMapperInstance.getRelationshipLookupComboboxVModel(
            ''
        );
        ComboBoxVModel missingRelationshipLookupComboBoxVModel = relationshipLookupsVMapperInstance.getRelationshipLookupComboboxVModel(
            'MissingValue'
        );
        Test.stopTest();

        System.assertEquals(
            5,
            relationshipLookupComboBoxVModel.options.size(),
            'Should return 5 active relationship types'
        );

        System.assertEquals(
            'TestRelationshipName1',
            relationshipLookupComboBoxVModel.options[0].value,
            'Relationship type value should be \'TestRelationshipName1\''
        );
        System.assertEquals(
            'TestRelationshipLabel1',
            relationshipLookupComboBoxVModel.options[0].label,
            'Relationship type label should be \'TestRelationshipLabel1\''
        );
        System.assertEquals(
            'TestRelationshipName7',
            relationshipLookupComboBoxVModel.options[4].value,
            'Relationship type value should be \'TestRelationshipName7\''
        );
        System.assertEquals(
            'TestRelationshipLabel7',
            relationshipLookupComboBoxVModel.options[4].label,
            'Relationship type label should be \'TestRelationshipLabel7\''
        );

        System.assertEquals(
            6,
            missingRelationshipLookupComboBoxVModel.options.size(),
            'Should return 6 relationship types (5 active, 1 missing)'
        );
        System.assertEquals(
            'MissingValue',
            missingRelationshipLookupComboBoxVModel.options[0].value,
            'Relationship type value should be \'TestRelationshipName1\''
        );
        System.assertEquals(
            'MissingValue',
            missingRelationshipLookupComboBoxVModel.options[0].label,
            'Relationship type label should be \'TestRelationshipLabel1\''
        );
    }

    /****************************************************************************************
     * @description Test method to verify getRelationshipLookupsVModel()
     * returns a ComboboxVModel representing active unmapped picklist items
     ****************************************************************************************/
    @isTest
    private static void getActiveUnmappedRelationshipTypesComboboxVModelValid() {
        PicklistEntryService.instance = new STUB_PicklistEntryService();
        RelationshipLookupSettingsService.instance = new STUB_RelationshipLookupSettingsService();

        RelationshipLookupsVMapper relationshipLookupsVMapperInstance = RelationshipLookupsVMapper.getInstance();

        Test.startTest();
        ComboBoxVModel activeUnmappedRelTypesComboBoxVModel = relationshipLookupsVMapperInstance.getActiveUnmappedRelationshipTypesComboboxVModel(
            ''
        );
        Test.stopTest();

        System.assertEquals(
            2,
            activeUnmappedRelTypesComboBoxVModel.options.size(),
            'Should return 2 active unmapped relationship types'
        );

        System.assertEquals(
            'TestRelationshipName6',
            activeUnmappedRelTypesComboBoxVModel.options[0].value,
            'Relationship type value should be \'TestRelationshipName6\''
        );
        System.assertEquals(
            'TestRelationshipLabel6',
            activeUnmappedRelTypesComboBoxVModel.options[0].label,
            'Relationship type label should be \'TestRelationshipLabel6\''
        );

        System.assertEquals(
            'TestRelationshipName7',
            activeUnmappedRelTypesComboBoxVModel.options[1].value,
            'Relationship type value should be \'TestRelationshipName7\''
        );
        System.assertEquals(
            'TestRelationshipLabel7',
            activeUnmappedRelTypesComboBoxVModel.options[1].label,
            'Relationship type label should be \'TestRelationshipLabel7\''
        );
    }

    /****************************************************************************************
     * @description Test method to verify getRelationshipLookupNameComboboxVModel()
     * returns a ComboboxVModel representing active unmapped picklist items for a new record
     ****************************************************************************************/
    @isTest
    private static void getRelationshipLookupNameComboboxVModelValidNew() {
        PicklistEntryService.instance = new STUB_PicklistEntryService();
        RelationshipLookupSettingsService.instance = new STUB_RelationshipLookupSettingsService();

        RelationshipLookupsVMapper relationshipLookupsVMapperInstance = RelationshipLookupsVMapper.getInstance();

        Test.startTest();
        ComboBoxVModel activeUnmappedRelTypesComboBoxVModel = relationshipLookupsVMapperInstance.getRelationshipLookupNameComboboxVModel(
            ''
        );
        Test.stopTest();

        System.assertEquals(
            2,
            activeUnmappedRelTypesComboBoxVModel.options.size(),
            'Should return 2 active unmapped relationship types'
        );

        System.assertEquals(
            'TestRelationshipName6',
            activeUnmappedRelTypesComboBoxVModel.options[0].value,
            'Relationship type value should be \'TestRelationshipName6\''
        );
        System.assertEquals(
            'TestRelationshipLabel6',
            activeUnmappedRelTypesComboBoxVModel.options[0].label,
            'Relationship type label should be \'TestRelationshipLabel6\''
        );

        System.assertEquals(
            'TestRelationshipName7',
            activeUnmappedRelTypesComboBoxVModel.options[1].value,
            'Relationship type value should be \'TestRelationshipName7\''
        );
        System.assertEquals(
            'TestRelationshipLabel7',
            activeUnmappedRelTypesComboBoxVModel.options[1].label,
            'Relationship type label should be \'TestRelationshipLabel7\''
        );
    }

    /****************************************************************************************
     * @description Test method to verify getRelationshipLookupNameComboboxVModel()
     * returns a ComboboxVModel representing active picklist items
     * for an existing record (edit mode)
     ****************************************************************************************/
    @isTest
    private static void getRelationshipLookupNameComboboxVModelValidEdit() {
        PicklistEntryService.instance = new STUB_PicklistEntryService();
        RelationshipLookupSettingsService.instance = new STUB_RelationshipLookupSettingsService();

        RelationshipLookupsVMapper relationshipLookupsVMapperInstance = RelationshipLookupsVMapper.getInstance();

        Test.startTest();
        ComboBoxVModel activeItemRelTypesComboBoxVModel = relationshipLookupsVMapperInstance.getRelationshipLookupNameComboboxVModel(
            'TestRelationshipName1'
        );
        ComboBoxVModel inactiveItemRelTypesComboBoxVModel = relationshipLookupsVMapperInstance.getRelationshipLookupNameComboboxVModel(
            'TestRelationshipName6'
        );
        ComboBoxVModel missingItemRelTypesComboBoxVModel = relationshipLookupsVMapperInstance.getRelationshipLookupNameComboboxVModel(
            'TestRelationshipName8'
        );

        Test.stopTest();

        System.assertEquals(
            3,
            activeItemRelTypesComboBoxVModel.options.size(),
            'Should return 3 active unmapped relationship types (2 active unmapped + 1 current)'
        );

        System.assertEquals(
            2,
            inactiveItemRelTypesComboBoxVModel.options.size(),
            'Should return 2 active unmapped relationship types'
        );

        System.assertEquals(
            'TestRelationshipName1',
            activeItemRelTypesComboBoxVModel.options[0].value,
            'Relationship type value should be \'TestRelationshipName1\''
        );
        System.assertEquals(
            'TestRelationshipLabel1',
            activeItemRelTypesComboBoxVModel.options[0].label,
            'Relationship type label should be \'TestRelationshipLabel1\''
        );

        System.assertEquals(
            3,
            missingItemRelTypesComboBoxVModel.options.size(),
            'Should return 3 active unmapped relationship types'
        );

        //Checking if the mapper returns inactive item because this is the current record's value
        Boolean hasInactiveItemValue = false;
        for (ComboboxValueVModel inactiveItemVModel : inactiveItemRelTypesComboBoxVModel.options) {
            if (inactiveItemVModel.value == 'TestRelationshipName6') {
                hasInactiveItemValue = true;
                break;
            }
        }
        System.assertEquals(
            true,
            hasInactiveItemValue,
            'getRelationshipLookupNameComboboxVModel should return \'TestRelationshipName6\''
        );

        //Checking if the mapper returns missing item because this is the current record's value
        Boolean hasMissingItemValue = false;
        for (ComboboxValueVModel missingItemVModel : missingItemRelTypesComboBoxVModel.options) {
            if (missingItemVModel.value == 'TestRelationshipName8') {
                hasMissingItemValue = true;
                break;
            }
        }
        System.assertEquals(
            true,
            hasMissingItemValue,
            'getRelationshipLookupNameComboboxVModel should return \'TestRelationshipName8\''
        );
    }

    /***********************************************************************************************************************************
     ****************************************************** STUBS ***********************************************************************
     ***********************************************************************************************************************************/

    /**************************************************************************************************************************************
     * @description Stub class to simulate valid responses from RelationshipLookupSettingsService
     **************************************************************************************************************************************/
    private class STUB_RelationshipLookupSettingsService extends RelationshipLookupSettingsService {
        public override List<RelationshipLookupModel> getRelationshipLookupModels() {
            List<RelationshipLookupModel> relLookupModelList = new List<RelationshipLookupModel>();
            relLookupModelList.add(
                new RelationshipLookupModel(
                    'TestRelationshipName1',
                    true,
                    'TestFemaleValue1',
                    'TestMaleValue1',
                    'TestNeutralValue1'
                )
            );
            relLookupModelList.add(
                new RelationshipLookupModel(
                    'TestRelationshipName2',
                    false,
                    'TestFemaleValue2',
                    'TestMaleValue2',
                    'TestNeutralValue2'
                )
            );
            relLookupModelList.add(
                new RelationshipLookupModel(
                    'TestRelationshipName3',
                    true,
                    'TestFemaleValue3',
                    'TestMaleValue3',
                    'TestNeutralValue3'
                )
            );
            relLookupModelList.add(
                new RelationshipLookupModel(
                    'TestRelationshipName4',
                    true,
                    'TestFemaleValue4',
                    'TestMaleValue4',
                    'TestNeutralValue4'
                )
            );
            relLookupModelList.add(
                new RelationshipLookupModel(
                    'TestRelationshipName5',
                    false,
                    'TestFemaleValue5',
                    'TestMaleValue5',
                    'TestNeutralValue5'
                )
            );
            return relLookupModelList;
        }
    }

    /**************************************************************************************************************************************
     * @description Stub class to simulate valid responses from PicklistEntryService
     **************************************************************************************************************************************/
    private class STUB_PicklistEntryService extends PicklistEntryService {
        public override Map<String, PicklistEntryModel> getModelsByNameForSObjectField(
            SObjectType sObjectTypeName,
            SObjectField SObjectFieldName
        ) {
            Map<String, PicklistEntryModel> picklistModelsMap = new Map<String, PicklistEntryModel>();
            picklistModelsMap.put(
                'TestRelationshipName1',
                new PicklistEntryModel('TestRelationshipName1', 'TestRelationshipLabel1', true)
            );
            picklistModelsMap.put(
                'TestRelationshipName2',
                new PicklistEntryModel('TestRelationshipName2', 'TestRelationshipLabel2', true)
            );
            picklistModelsMap.put(
                'TestRelationshipName3',
                new PicklistEntryModel('TestRelationshipName3', 'TestRelationshipLabel3', true)
            );
            picklistModelsMap.put(
                'TestRelationshipName4',
                new PicklistEntryModel('TestRelationshipName4', 'TestRelationshipLabel4', false)
            );
            picklistModelsMap.put(
                'TestRelationshipName5',
                new PicklistEntryModel('TestRelationshipName5', 'TestRelationshipLabel5', false)
            );
            picklistModelsMap.put(
                'TestRelationshipName6',
                new PicklistEntryModel('TestRelationshipName6', 'TestRelationshipLabel6', true)
            );
            picklistModelsMap.put(
                'TestRelationshipName7',
                new PicklistEntryModel('TestRelationshipName7', 'TestRelationshipLabel7', true)
            );
            return picklistModelsMap;
        }
    }
}
public with sharing class RelationshipSettingsController {
    /************************************************************************************
     * @description Retrieve an RelationshipSettingsVModel represeting the current values
     * specified for Relationship Settings fields in Hierarchy Settings.
     * @return An RelationshipSettingsVModel
     ************************************************************************************/
    @AuraEnabled(cacheable=true)
    public static RelationshipSettingsVModel getRelationshipSettingsVModel() {
        try {
            return RelationshipSettingsController.locateRelationshipSettingsVMapper().getRelationshipSettingsVModel();
        } catch (Exception e) {
            throw new AuraHandledException(e.getMessage());
        }
    }

    /************************************************************************************
     * @description Retrieve an RelationshipLookupsVModel represeting the current values
     * specified for Reciprocal Relationship mappings.
     * @return An RelationshipLookupsVModel
     ************************************************************************************/
    @AuraEnabled(cacheable=true)
    public static RelationshipLookupsVModel getRelationshipLookupsVModel() {
        try {
            return RelationshipSettingsController.locateRelationshipLookupsVMapper().getRelationshipLookupsVModel();
        } catch (Exception e) {
            throw new AuraHandledException(e.getMessage());
        }
    }

    /**
     * @description gets all active Relationship Type picklist values for FemaleValue, MaleValue and NeutralValue
     * @param  relationshipLookupName Specifies and existing relationship lookup value. Should be an empty string for a new record
     * @return                        A ComboBoxVModel
     */
    @AuraEnabled(cacheable=true)
    public static ComboBoxVModel getRelationshipLookupComboboxVModel(String relationshipLookupName) {
        try {
            return RelationshipSettingsController.locateRelationshipLookupsVMapper()
                .getRelationshipLookupComboboxVModel(relationshipLookupName);
        } catch (Exception e) {
            throw new AuraHandledException(e.getMessage());
        }
    }

    /**
     * @description Gets picklist values for a relationship name lookup.
     * For a new record returns all active unmapped Relationship Type picklist values
     * For an existing record returns all active Relationship Type picklist values plus the existing one if it is not active
     * @param  relationshipLookupName Specifies and existing relationship lookup name. Should be an empty string for a new record
     * @return                        A ComboBoxVModel
     */
    @AuraEnabled
    public static ComboBoxVModel getRelationshipLookupNameComboboxVModel(String relationshipLookupName) {
        try {
            return RelationshipSettingsController.locateRelationshipLookupsVMapper()
                .getRelationshipLookupNameComboboxVModel(relationshipLookupName);
        } catch (Exception e) {
            throw new AuraHandledException(e.getMessage());
        }
    }

    /**
     * @description inserts a relationship lookup
     * @param  relationshipLookupName relationship lookup name
     * @param  femaleValue            female relationship type value
     * @param  maleValue              male relationship type value
     * @param  neutralValue           neutral relationship type value
     * @param  isActive               specifies if the lookup is active
     * @return                        inserted relationship lookup name
     */
    @AuraEnabled
    public static String createRelationshipLookup(
        String relationshipLookupName,
        String femaleValue,
        String maleValue,
        String neutralValue,
        Boolean isActive
    ) {
        try {
            return RelationshipSettingsController.locateRelationshipLookupSettingsService()
                .insertRelationshipLookup(relationshipLookupName, femaleValue, maleValue, neutralValue, isActive)
                .name;
        } catch (Exception e) {
            throw new AuraHandledException(e.getMessage());
        }
    }

    /**
     * @description updates a relationship lookup
     * @param  oldRelationshipLookupName old relationship lookup name
     * @param  newRelationshipLookupName new relationship lookup name
     * @param  femaleValue               female relationship type value
     * @param  maleValue                 male relationship type value
     * @param  neutralValue              neutral relationship type value
     * @param  isActive                  specifies if the lookup is active
     * @return                           updated relationship lookup name
     */
    @AuraEnabled
    public static String updateRelationshipLookup(
        String oldRelationshipLookupName,
        String newRelationshipLookupName,
        String femaleValue,
        String maleValue,
        String neutralValue,
        Boolean isActive
    ) {
        try {
            return RelationshipSettingsController.locateRelationshipLookupSettingsService()
                .updateRelationshipLookup(
                    oldRelationshipLookupName,
                    newRelationshipLookupName,
                    femaleValue,
                    maleValue,
                    neutralValue,
                    isActive
                )
                .name;
        } catch (Exception e) {
            throw new AuraHandledException(e.getMessage());
        }
    }

    /**
     * @description deletes a relationship lookup
     * @param  relationshipLookupName relationship lookup name to delete
     * @return                        deleted relationship lookup name or null if the record was not found
     */
    @AuraEnabled
    public static String deleteRelationshipLookup(String relationshipLookupName) {
        try {
            RelationshipLookupModel deletedRelationshipLookupModel = RelationshipSettingsController.locateRelationshipLookupSettingsService()
                .deleteRelationshipLookup(relationshipLookupName);
            return deletedRelationshipLookupModel == null ? null : deletedRelationshipLookupModel.name;
        } catch (Exception e) {
            throw new AuraHandledException(e.getMessage());
        }
    }

    /**********************************************************************************
     * @description Locates and returns an instance of RelationshipSettingsVMapper.
     **********************************************************************************/
    @TestVisible
    private static RelationshipSettingsVMapper locateRelationshipSettingsVMapper() {
        return RelationshipSettingsVMapper.getInstance();
    }

    /**********************************************************************************
     * @description Locates and returns an instance of RelationshipLookupsVMapper.
     * @return An instance of RelationshipLookupsVMapper
     **********************************************************************************/
    @TestVisible
    private static RelationshipLookupsVMapper locateRelationshipLookupsVMapper() {
        return RelationshipLookupsVMapper.getInstance();
    }

    /*****************************************************************************
     * @description Retrieve an instance of the RelationshipLookupSettingsService class.
     * @return An instance of RelationshipLookupSettingsService.
     *****************************************************************************/
    @TestVisible
    private static RelationshipLookupSettingsService locateRelationshipLookupSettingsService() {
        return RelationshipLookupSettingsService.getInstance();
    }
}
@isTest
private with sharing class RelationshipSettingsController_TEST {
    /**************************************************************************************************************************************************
     * @description Test method to verify that the locateRelationshipSettingsVMapper method returns instance of locateRelationshipSettingsVMapper.
     *************************************************************************************************************************************************/
    @isTest
    private static void locateRelationshipSettingsVMapper() {
        Test.startTest();
        RelationshipSettingsVMapper relationshipSettingsVMapperInstance = RelationshipSettingsController.locateRelationshipSettingsVMapper();
        Test.stopTest();

        System.assertEquals(
            RelationshipSettingsVMapper.getInstance(),
            RelationshipSettingsVMapperInstance,
            'Should return the instance of locateRelationshipSettingsVMapper.'
        );
    }

    /****************************************************************************************************************************
     * @description Test method to verify that the getRelationshipSettingsVModel method returns a RelationshipSettingsVModel
     * representing Relationship Settings in Hierarchy Settings.
     ****************************************************************************************************************************/
    @isTest
    private static void getRelationshipSettingsVModelValid() {
        RelationshipSettingsVMapper.instance = new STUB_RelationshipSettingsVMapper();

        Test.startTest();
        RelationshipSettingsVModel relationshipSettingsVModel = RelationshipSettingsController.getRelationshipSettingsVModel();
        Test.stopTest();

        System.assertEquals(
            'List Setting',
            relationshipSettingsVModel.reciprocalMethodComboboxVModel.value,
            'Selected value should be retrieved'
        );

        System.assertEquals(
            Label.stgReciprocalMethodListSetting,
            relationshipSettingsVModel.reciprocalMethodComboboxVModel.options[0].label,
            'Selected value should be retrieved'
        );

        System.assertEquals(
            'List Setting',
            relationshipSettingsVModel.reciprocalMethodComboboxVModel.options[0].value,
            'Selected value should be retrieved'
        );

        System.assertEquals(
            Label.stgReciprocalMethodValueInversion,
            relationshipSettingsVModel.reciprocalMethodComboboxVModel.options[1].label,
            'Selected value should be retrieved'
        );

        System.assertEquals(
            'Value Inversion',
            relationshipSettingsVModel.reciprocalMethodComboboxVModel.options[1].value,
            'Selected value should be retrieved'
        );

        System.assertEquals(
            true,
            relationshipSettingsVModel.preventAutoCreatedDuplicates,
            'Selected value should be retrieved for allow auto created duplicates'
        );
    }

    /****************************************************************************************************************************
     * @description Test method to verify that the getRelationshipSettingsVModel method fails gracefully when an exception is
     * encountered.
     ****************************************************************************************************************************/
    @isTest
    private static void getRelationshipSettingsVModelException() {
        RelationshipSettingsVMapper.instance = new STUB_ExceptionRelationshipSettingsVMapper();

        try {
            Test.startTest();
            RelationshipSettingsVModel relationshipSettingsVModel = RelationshipSettingsController.getRelationshipSettingsVModel();
            Test.stopTest();
        } catch (AuraHandledException e) {
            System.assertEquals('Script-thrown exception', e.getMessage(), 'Should throw exception.');
        }
    }

    /****************************************************************************************************************************
     * @description Test method to verify that the getRelationshipLookupsVModel method returns a RelationshipLookupsVModel
     * representing Relationship Lookups.
     ****************************************************************************************************************************/
    @isTest
    private static void getRelationshipLookupsVModelValid() {
        RelationshipLookupsVMapper.instance = new STUB_RelationshipLookupsVMapper();

        Test.startTest();
        RelationshipLookupsVModel relLookupsVModel = RelationshipSettingsController.getRelationshipLookupsVModel();
        Test.stopTest();
        System.assertEquals(2, relLookupsVModel.relationshipLookups.size(), 'Should return 2 items');
        System.assertEquals(
            'RelationshipLookupName1',
            relLookupsVModel.relationshipLookups[0].name,
            'Relationship lookup name should be \'RelationshipLookupName1\''
        );
        System.assertEquals(
            'FemaleValue1',
            relLookupsVModel.relationshipLookups[0].femaleValue,
            'femaleValue should be \'FemaleValue1\''
        );
        System.assertEquals(
            'MaleValue1',
            relLookupsVModel.relationshipLookups[0].maleValue,
            'maleValue should be \'MaleValue1\''
        );
        System.assertEquals(
            'NeutralValue1',
            relLookupsVModel.relationshipLookups[0].neutralValue,
            'neutralValue should be \'NeutralValue1\''
        );
    }

    /****************************************************************************************************************************
     * @description Test method to verify that the getRelationshipLookupComboboxVModel method returns a ComboBoxVModel
     * representing active relationship types.
     ****************************************************************************************************************************/
    @isTest
    private static void getRelationshipLookupComboboxVModelValid() {
        RelationshipLookupsVMapper.instance = new STUB_RelationshipLookupsVMapper();

        Test.startTest();
        ComboBoxVModel activeRelTypesComboboxVModel = RelationshipSettingsController.getRelationshipLookupComboboxVModel(
            ''
        );
        Test.stopTest();
        System.assertEquals(2, activeRelTypesComboboxVModel.options.size(), 'Should return 2 items');
        System.assertEquals(
            'ActiveRelationshipName1',
            activeRelTypesComboboxVModel.options[0].value,
            'Active item value should be \'ActiveRelationshipName1\''
        );
        System.assertEquals(
            'ActiveRelationshipLabel1',
            activeRelTypesComboboxVModel.options[0].label,
            'Active item label should be \'ActiveRelationshipLabel1\''
        );
    }

    /****************************************************************************************************************************
     * @description Test method to verify that the getRelationshipLookupNameComboboxVModel method returns a ComboBoxVModel
     * representing unmapped relationship types.
     ****************************************************************************************************************************/
    @isTest
    private static void getRelationshipLookupNameComboboxVModelValid() {
        RelationshipLookupsVMapper.instance = new STUB_RelationshipLookupsVMapper();

        Test.startTest();
        ComboBoxVModel activeUnmappedRelTypesComboboxVModel = RelationshipSettingsController.getRelationshipLookupNameComboboxVModel(
            ''
        );
        Test.stopTest();
        System.assertEquals(2, activeUnmappedRelTypesComboboxVModel.options.size(), 'Should return 2 items');
        System.assertEquals(
            'UnmappedRelationshipName1',
            activeUnmappedRelTypesComboboxVModel.options[0].value,
            'Unmapped item value should be \'UnmappedRelationshipName1\''
        );
        System.assertEquals(
            'UnmappedRelationshipLabel1',
            activeUnmappedRelTypesComboboxVModel.options[0].label,
            'Unmapped item label should be \'UnmappedRelationshipLabel1\''
        );
    }

    /****************************************************************************************************************************
     * @description Test method to verify that the getRelationshipLookupsVModel method fails gracefully when an exception is
     * encountered.
     ****************************************************************************************************************************/
    @isTest
    private static void getRelationshipLookupsVModelException() {
        RelationshipLookupsVMapper.instance = new STUB_ExceptionRelationshipLookupsVMapper();

        try {
            Test.startTest();
            RelationshipLookupsVModel relLookupsVModel = RelationshipSettingsController.getRelationshipLookupsVModel();
            Test.stopTest();
            System.assert(false, 'should always throw an exception');
        } catch (AuraHandledException e) {
            System.assertEquals('Script-thrown exception', e.getMessage(), 'Should throw exception.');
        }
    }

    /****************************************************************************************************************************
     * @description Test method to verify that the getRelationshipLookupComboboxVModel method fails gracefully when an exception is
     * encountered.
     ****************************************************************************************************************************/
    @isTest
    private static void getRelationshipLookupComboboxVModelException() {
        RelationshipLookupsVMapper.instance = new STUB_ExceptionRelationshipLookupsVMapper();

        try {
            Test.startTest();
            ComboBoxVModel activeRelTypesComboboxVModel = RelationshipSettingsController.getRelationshipLookupComboboxVModel(
                ''
            );
            Test.stopTest();
            System.assert(false, 'should always throw an exception');
        } catch (AuraHandledException e) {
            System.assertEquals('Script-thrown exception', e.getMessage(), 'Should throw exception.');
        }
    }

    /****************************************************************************************************************************
     * @description Test method to verify that the getRelationshipLookupNameComboboxVModel method fails gracefully when an exception is
     * encountered.
     ****************************************************************************************************************************/
    @isTest
    private static void getRelationshipLookupNameComboboxVModelException() {
        RelationshipLookupsVMapper.instance = new STUB_ExceptionRelationshipLookupsVMapper();

        try {
            Test.startTest();
            ComboBoxVModel activeUnmappedRelTypesComboboxVModel = RelationshipSettingsController.getRelationshipLookupNameComboboxVModel(
                ''
            );
            Test.stopTest();
            System.assert(false, 'should always throw an exception');
        } catch (AuraHandledException e) {
            System.assertEquals('Script-thrown exception', e.getMessage(), 'Should throw exception.');
        }

        RelationshipLookupsVMapper.instance = new STUB_RelationshipLookupsVMapper();
    }

    /****************************************************************************************************************************
     * @description Test method to verify that the createRelationshipLookup method returns a valid relationship lookup name
     ****************************************************************************************************************************/
    @isTest
    private static void createRelationshipLookupSuccess() {
        RelationshipLookupSettingsService.instance = new STUB_RelationshipLookupSettingsService();
        String relationshipLookupName = 'TestInsertedLookupName';

        Test.startTest();
        String insertedRelationshipLookupName = RelationshipSettingsController.createRelationshipLookup(
            relationshipLookupName,
            'TestFemaleValue',
            'TestMaleValue',
            'TestNeutralValue',
            true
        );
        Test.stopTest();
        System.assertEquals(
            relationshipLookupName,
            insertedRelationshipLookupName,
            'Relationship lookup name should be ' + relationshipLookupName
        );
    }

    /****************************************************************************************************************************
     * @description Test method to verify that the updateRelationshipLookup method returns a valid relationship lookup name
     ****************************************************************************************************************************/
    @isTest
    private static void updateRelationshipLookupSuccess() {
        RelationshipLookupSettingsService.instance = new STUB_RelationshipLookupSettingsService();

        String relationshipLookupName = 'TestUpdatedLookupName';
        String oldRelationshipLookupName = 'TestOldLookupName';

        Test.startTest();
        String updatedRelationshipLookupName = RelationshipSettingsController.updateRelationshipLookup(
            oldRelationshipLookupName,
            relationshipLookupName,
            'TestFemaleValue',
            'TestMaleValue',
            'TestNeutralValue',
            true
        );
        Test.stopTest();
        System.assertEquals(
            relationshipLookupName,
            updatedRelationshipLookupName,
            'Relationship lookup name should be ' + relationshipLookupName
        );
    }

    /****************************************************************************************************************************
     * @description Test method to verify that the deleteRelationshipLookup method returns a valid relationship lookup name
     ****************************************************************************************************************************/
    @isTest
    private static void deleteRelationshipLookupSuccess() {
        RelationshipLookupSettingsService.instance = new STUB_RelationshipLookupSettingsService();

        String relationshipLookupName = 'TestDeletedLookupName';

        Test.startTest();
        String deletedRelationshipLookupName = RelationshipSettingsController.deleteRelationshipLookup(
            relationshipLookupName
        );
        Test.stopTest();
        System.assertEquals(
            relationshipLookupName,
            deletedRelationshipLookupName,
            'Relationship lookup name should be ' + relationshipLookupName
        );
    }

    /****************************************************************************************************************************
     * @description Test method to verify that the createRelationshipLookup method fails gracefully when an exception is
     * encountered.
     ****************************************************************************************************************************/
    @isTest
    private static void createRelationshipLookupException() {
        RelationshipLookupSettingsService.instance = new STUB_ExceptionRelationshipLookupSettingsService();

        try {
            Test.startTest();
            String insertedRelLookupName = RelationshipSettingsController.createRelationshipLookup(
                'TestRelationshipLookupName',
                'femaleValue',
                'maleValue',
                'neutralValue',
                false
            );
            Test.stopTest();
            System.assert(false, 'should always throw an exception');
        } catch (AuraHandledException e) {
            System.assertEquals('Script-thrown exception', e.getMessage(), 'Should throw exception.');
        }
    }

    /****************************************************************************************************************************
     * @description Test method to verify that the updateRelationshipLookup method fails gracefully when an exception is
     * encountered.
     ****************************************************************************************************************************/
    @isTest
    private static void updateRelationshipLookupException() {
        RelationshipLookupSettingsService.instance = new STUB_ExceptionRelationshipLookupSettingsService();

        try {
            Test.startTest();
            String updatedRelLookupName = RelationshipSettingsController.updateRelationshipLookup(
                'TestOldRelationshipLookupName',
                'TestRelationshipLookupName',
                'femaleValue',
                'maleValue',
                'neutralValue',
                false
            );
            Test.stopTest();
            System.assert(false, 'should always throw an exception');
        } catch (AuraHandledException e) {
            System.assertEquals('Script-thrown exception', e.getMessage(), 'Should throw exception.');
        }
    }

    /****************************************************************************************************************************
     * @description Test method to verify that the deleteRelationshipLookup method fails gracefully when an exception is
     * encountered.
     ****************************************************************************************************************************/
    @isTest
    private static void deleteRelationshipLookupException() {
        RelationshipLookupSettingsService.instance = new STUB_ExceptionRelationshipLookupSettingsService();

        try {
            Test.startTest();
            String deletedRelLookupName = RelationshipSettingsController.deleteRelationshipLookup(
                'TestRelationshipLookupName'
            );
            Test.stopTest();
            System.assert(false, 'should always throw an exception');
        } catch (AuraHandledException e) {
            System.assertEquals('Script-thrown exception', e.getMessage(), 'Should throw exception.');
        }
    }

    /**************************************************************************************************************************
     ****************************************************** STUBS **************************************************************
     **************************************************************************************************************************/

    /**************************************************************************************************************************************
     * @description Stub class to simulate the response from RelationshipSettingsVMapper to return a valid RelationshipSettingsVModel
     **************************************************************************************************************************************/
    private class STUB_RelationshipSettingsVMapper extends RelationshipSettingsVMapper {
        public override RelationshipSettingsVModel getRelationshipSettingsVModel() {
            ComboboxValueVModel listSettingComboboxValueVModel = new ComboboxValueVModel(
                Label.stgReciprocalMethodListSetting,
                'List Setting'
            );
            ComboboxValueVModel valueInversionComboboxValueVModel = new ComboboxValueVModel(
                Label.stgReciprocalMethodValueInversion,
                'Value Inversion'
            );
            List<ComboboxValueVModel> relationshipTypeComboboxValueVModelsList = new List<ComboboxValueVModel>();

            relationshipTypeComboboxValueVModelsList.add(listSettingComboboxValueVModel);
            relationshipTypeComboboxValueVModelsList.add(valueInversionComboboxValueVModel);

            return new RelationshipSettingsVModel(
                new comboboxvmodel('List Setting', relationshipTypeComboboxValueVModelsList),
                true
            );
        }
    }

    /**************************************************************************************************************************************
     * @description Stub class to simulate the response from RelationshipSettingsVMapper to throw an exception
     **************************************************************************************************************************************/
    private class STUB_ExceptionRelationshipSettingsVMapper extends RelationshipSettingsVMapper {
        public override RelationshipSettingsVModel getRelationshipSettingsVModel() {
            throw new TestException('Exception encountered!');
        }
    }

    /**************************************************************************************************************************************
     * @description Stub class to simulate the response from RelationshipLookupsVMapper to return a valid RelationshipSettingsVModel
     **************************************************************************************************************************************/
    private class STUB_RelationshipLookupsVMapper extends RelationshipLookupsVMapper {
        public override RelationshipLookupsVModel getRelationshipLookupsVModel() {
            List<RelationshipLookupVModel> relationshipLookupVModelList = new List<RelationshipLookupVModel>();
            relationshipLookupVModelList.add(
                new RelationshipLookupVModel(
                    'RelationshipLookupName1',
                    'FemaleValue1',
                    'MaleValue1',
                    'NeutralValue1',
                    true
                )
            );
            relationshipLookupVModelList.add(
                new RelationshipLookupVModel(
                    'RelationshipLookupName2',
                    'FemaleValue2',
                    'MaleValue2',
                    'NeutralValue2',
                    true
                )
            );
            return new RelationshipLookupsVModel(relationshipLookupVModelList);
        }

        public override ComboBoxVModel getRelationshipLookupComboboxVModel(String relationshipLookupName) {
            List<ComboboxValueVModel> relationshipLookupComboboxValueVModelsList = new List<ComboboxValueVModel>();
            relationshipLookupComboboxValueVModelsList.add(
                new ComboboxValueVModel('ActiveRelationshipLabel1', 'ActiveRelationshipName1')
            );
            relationshipLookupComboboxValueVModelsList.add(
                new ComboboxValueVModel('ActiveRelationshipLabel2', 'ActiveRelationshipName2')
            );

            return new ComboboxVModel('ActiveRelationshipName1', relationshipLookupComboboxValueVModelsList);
        }

        public override ComboBoxVModel getRelationshipLookupNameComboboxVModel(String relationshipLookupName) {
            List<ComboboxValueVModel> relationshipLookupComboboxValueVModelsList = new List<ComboboxValueVModel>();
            relationshipLookupComboboxValueVModelsList.add(
                new ComboboxValueVModel('UnmappedRelationshipLabel1', 'UnmappedRelationshipName1')
            );
            relationshipLookupComboboxValueVModelsList.add(
                new ComboboxValueVModel('UnmappedRelationshipLabel2', 'UnmappedRelationshipName2')
            );

            return new ComboboxVModel('UnmappedRelationshipName1', relationshipLookupComboboxValueVModelsList);
        }
    }

    /**************************************************************************************************************************************
     * @description Stub class to simulate the response from RelationshipSettingsVMapper to throw an exception
     **************************************************************************************************************************************/
    private class STUB_ExceptionRelationshipLookupsVMapper extends RelationshipLookupsVMapper {
        public override RelationshipLookupsVModel getRelationshipLookupsVModel() {
            throw new TestException('Exception encountered!');
        }

        public override ComboBoxVModel getRelationshipLookupComboboxVModel(String relationshipLookupName) {
            throw new TestException('Exception encountered!');
        }

        public override ComboBoxVModel getRelationshipLookupNameComboboxVModel(String relationshipLookupName) {
            throw new TestException('Exception encountered!');
        }
    }

    /**************************************************************************************************************************************
     * @description Stub class to simulate the response from RelationshipLookupSettingsService to return a valid RelationshipLookupSettingsService
     **************************************************************************************************************************************/
    private class STUB_RelationshipLookupSettingsService extends RelationshipLookupSettingsService {
        public override RelationshipLookupModel insertRelationshipLookup(
            String relationshipLookupName,
            String femaleValue,
            String maleValue,
            String neutralValue,
            Boolean isActive
        ) {
            return new RelationshipLookupModel(relationshipLookupName, isActive, femaleValue, maleValue, neutralValue);
        }

        public override RelationshipLookupModel updateRelationshipLookup(
            String oldRelationshipLookupName,
            String newRelationshipLookupName,
            String femaleValue,
            String maleValue,
            String neutralValue,
            Boolean isActive
        ) {
            return new RelationshipLookupModel(
                newRelationshipLookupName,
                isActive,
                femaleValue,
                maleValue,
                neutralValue
            );
        }

        public override RelationshipLookupModel deleteRelationshipLookup(String relationshipLookupName) {
            return new RelationshipLookupModel(
                relationshipLookupName,
                true,
                'TestDeletedFemaleValue',
                'TestDeletedMaleValue',
                'TestDeletedNeutralValue'
            );
        }
    }

    /**************************************************************************************************************************************
     * @description Stub class to simulate the response from RelationshipLookupSettingsService to throw an exception
     **************************************************************************************************************************************/
    private class STUB_ExceptionRelationshipLookupSettingsService extends RelationshipLookupSettingsService {
        public override RelationshipLookupModel insertRelationshipLookup(
            String relationshipLookupName,
            String femaleValue,
            String maleValue,
            String neutralValue,
            Boolean isActive
        ) {
            throw new TestException('Exception encountered!');
        }

        public override RelationshipLookupModel updateRelationshipLookup(
            String oldRelationshipLookupName,
            String newRelationshipLookupName,
            String femaleValue,
            String maleValue,
            String neutralValue,
            Boolean isActive
        ) {
            throw new TestException('Exception encountered!');
        }

        public override RelationshipLookupModel deleteRelationshipLookup(String relationshipLookupName) {
            throw new TestException('Exception encountered!');
        }
    }

    private class TestException extends Exception {
    }
}
@isTest
private class RenameLeadConvertedAccounts_TEST {
    private static Integer leadCount = 5; // used to determine number of test contact records to create
    /*********************************************************************************************************
     * @description Insert and convert a new Lead with no Lead Conversion record types selected
     * Make sure the Account's name is the Lead Company Name
     */
    @isTest
    private static void convertLeadNoRecordTypes() {
        Lead testLead = new Lead(FirstName = 'First', LastName = 'Last', company = 'Company');
        insert testLead;

        Test.startTest();
        Database.LeadConvert lc = new database.LeadConvert();
        lc.setLeadId(testLead.Id);
        LeadStatus convertStatus = [SELECT Id, MasterLabel FROM LeadStatus WHERE IsConverted = TRUE LIMIT 1];
        lc.setConvertedStatus(convertStatus.MasterLabel);
        Database.LeadConvertResult lcr = Database.convertLead(lc);

        Test.stopTest();

        System.assert(lcr.isSuccess());

        Account assertAccount = [SELECT Id, RecordType.Name, Name FROM Account LIMIT 1];

        System.assertEquals('Company', assertAccount.Name);
    }

    /*********************************************************************************************************
     * @description Insert and convert a new lead with the Administrative Record Type selected
     * Make sure the Account's name is set based on account administrative naming setting.
     */
    @isTest
    private static void convertLeadAdminRecordType() {
        UTIL_CustomSettingsFacade.getSettingsForTests(
            new Hierarchy_Settings__c(
                Account_Processor__c = UTIL_Describe_API.getAdminAccRecTypeID(),
                Automatic_Household_Naming__c = true,
                Lead_Converted_Account_RTypes__c = UTIL_Describe_API.getAdminAccRecTypeID()
            )
        );

        Lead testLead = new Lead(FirstName = 'First', LastName = 'Last', company = 'Company');
        insert testLead;

        Test.startTest();
        Database.LeadConvert lc = new database.LeadConvert();
        lc.setLeadId(testLead.Id);
        LeadStatus convertStatus = [SELECT Id, MasterLabel FROM LeadStatus WHERE IsConverted = TRUE LIMIT 1];
        lc.setConvertedStatus(convertStatus.MasterLabel);
        Database.LeadConvertResult lcr = Database.convertLead(lc);

        Test.stopTest();

        System.assert(lcr.isSuccess());

        Account assertAccount = [SELECT Id, RecordType.Name, Name FROM Account LIMIT 1];

        System.assertEquals(testLead.LastName + ' Administrative Account', assertAccount.Name);
    }

    /*********************************************************************************************************
     * @description Insert and convert a new lead with the Administrative Record Type selected
     * convert this lead to an existing Account
     * Make sure the Account's name is set based on account administrative naming setting.
     */
    @isTest
    private static void convertLeadAdminRecordTypeExistingAccount() {
        UTIL_CustomSettingsFacade.getSettingsForTests(
            new Hierarchy_Settings__c(
                Account_Processor__c = UTIL_Describe_API.getAdminAccRecTypeID(),
                Automatic_Household_Naming__c = true,
                Lead_Converted_Account_RTypes__c = UTIL_Describe_API.getAdminAccRecTypeID()
            )
        );

        Lead testLead = new Lead(FirstName = 'First', LastName = 'Last', company = 'Company');
        insert testLead;

        Account anAccount = new Account(Name = 'Demo Admin', RecordTypeId = UTIL_Describe_API.getAdminAccRecTypeID());
        insert anAccount;

        Test.setCreatedDate(anAccount.Id, DateTime.newInstance(2012, 12, 12));

        Test.startTest();
        Database.LeadConvert lc = new database.LeadConvert();
        lc.setLeadId(testLead.Id);
        LeadStatus convertStatus = [SELECT Id, MasterLabel FROM LeadStatus WHERE IsConverted = TRUE LIMIT 1];
        lc.setConvertedStatus(convertStatus.MasterLabel);

        Account theaccount = [SELECT CreatedDate FROM Account WHERE Id = :anAccount.Id];
        lc.setAccountId(anAccount.Id);
        Database.LeadConvertResult lcr = Database.convertLead(lc);

        Test.stopTest();

        System.assert(lcr.isSuccess());

        Account assertAccount = [SELECT Id, RecordType.Name, Name FROM Account LIMIT 1];

        System.assertEquals('Demo Admin', assertAccount.Name);
    }

    /*********************************************************************************************************
     * @description Insert and convert a new lead with the Household Record Type selected
     * Make sure the Account's name is set based on account default naming setting.
     */
    @isTest
    private static void convertLeadHHRecordType() {
        UTIL_CustomSettingsFacade.getSettingsForTests(
            new Hierarchy_Settings__c(
                Account_Processor__c = UTIL_Describe_API.getAdminAccRecTypeID(),
                Household_Account_Naming_Format__c = '{!LastName} Household Account',
                Automatic_Household_Naming__c = true,
                Lead_Converted_Account_RTypes__c = UTIL_Describe_API.getHhAccRecTypeID()
            )
        );

        Lead testLead = new Lead(FirstName = 'First', LastName = 'Last', company = 'Company');
        insert testLead;

        Account testAccount = new Account(
            Name = 'Test Account Name',
            RecordTypeId = UTIL_Describe_API.getHhAccRecTypeID()
        );
        insert testAccount;

        Test.startTest();
        Database.LeadConvert lc = new database.LeadConvert();
        lc.setLeadId(testLead.Id);
        lc.setAccountId(testAccount.Id);
        LeadStatus convertStatus = [SELECT Id, MasterLabel FROM LeadStatus WHERE IsConverted = TRUE LIMIT 1];
        lc.setConvertedStatus(convertStatus.MasterLabel);
        Database.LeadConvertResult lcr = Database.convertLead(lc);

        Test.stopTest();

        System.assert(lcr.isSuccess());

        Account assertAccount = [SELECT Id, RecordType.Name, Name FROM Account LIMIT 1];

        System.assertEquals(testLead.LastName + ' Household Account', assertAccount.Name);
    }

    /*********************************************************************************************************
     * @description Insert and convert a new lead with the Household Record Type selected
     * with an Existing Account
     * Make sure the Account's name includes the new Contact lastName
     */
    @isTest
    private static void convertLeadHHRecordTypeExistingAccount() {
        UTIL_CustomSettingsFacade.getSettingsForTests(
            new Hierarchy_Settings__c(
                Account_Processor__c = UTIL_Describe_API.getAdminAccRecTypeID(),
                Household_Account_Naming_Format__c = '{!LastName} Household Account',
                Automatic_Household_Naming__c = true,
                Lead_Converted_Account_RTypes__c = UTIL_Describe_API.getHhAccRecTypeID()
            )
        );

        Lead testLead = new Lead(FirstName = 'Mickey', LastName = 'Mouse', company = 'Company');
        insert testLead;

        Account anAccount = new Account(Name = 'Demo Admin', RecordTypeId = UTIL_Describe_API.getHhAccRecTypeID());
        insert anAccount;

        Contact firstContact = new Contact(LastName = 'Duck', FirstName = 'Daffy', AccountId = anAccount.Id);
        insert firstContact;

        Test.setCreatedDate(anAccount.Id, DateTime.newInstance(2012, 12, 12));

        Test.startTest();
        Database.LeadConvert lc = new database.LeadConvert();
        lc.setLeadId(testLead.Id);
        lc.setAccountId(anAccount.Id);
        LeadStatus convertStatus = [SELECT Id, MasterLabel FROM LeadStatus WHERE IsConverted = TRUE LIMIT 1];
        lc.setConvertedStatus(convertStatus.MasterLabel);

        Account theaccount = [SELECT CreatedDate FROM Account WHERE Id = :anAccount.Id];
        lc.setAccountId(anAccount.Id);
        Database.LeadConvertResult lcr = Database.convertLead(lc);

        Test.stopTest();

        System.assert(lcr.isSuccess());

        Account assertAccount = [SELECT Id, RecordType.Name, Name FROM Account LIMIT 1];

        System.assertEquals('Duck and Mouse Household Account', assertAccount.Name);
    }

    @isTest
    private static void convertLeadDefaultRecordType() {
        UTIL_CustomSettingsFacade.getSettingsForTests(
            new Hierarchy_Settings__c(
                Account_Processor__c = UTIL_Describe_API.getAdminAccRecTypeID(),
                Household_Account_Naming_Format__c = '{!LastName} Household Account',
                Automatic_Household_Naming__c = true,
                Lead_Converted_Account_RTypes__c = UTIL_Describe_API.getAcademicAccRecTypeID()
            )
        );

        Lead testLead = new Lead(FirstName = 'First', LastName = 'Last', company = 'Company');
        insert testLead;

        Account testAccount = new Account(
            Name = 'Test Account Name',
            RecordTypeId = UTIL_Describe_API.getAcademicAccRecTypeID()
        );
        insert testAccount;

        Test.startTest();
        Database.LeadConvert lc = new database.LeadConvert();
        lc.setLeadId(testLead.Id);
        lc.setAccountId(testAccount.Id);
        LeadStatus convertStatus = [SELECT Id, MasterLabel FROM LeadStatus WHERE IsConverted = TRUE LIMIT 1];
        lc.setConvertedStatus(convertStatus.MasterLabel);
        Database.LeadConvertResult lcr = Database.convertLead(lc);

        Test.stopTest();

        System.assert(lcr.isSuccess());

        Account assertAccount = [SELECT Id, RecordType.Name, Name FROM Account LIMIT 1];

        System.assertEquals(testLead.LastName + ' Account', assertAccount.Name);
    }

    /*********************************************************************************************************
     * @description Insert and convert a specified number of leads to test for bulk, the number
     * to insert can be overriden for unpackaged
     */
    @isTest
    private static void bulkConvertLeadAdminRecordType() {
        UTIL_CustomSettingsFacade.getSettingsForTests(
            new Hierarchy_Settings__c(
                Account_Processor__c = UTIL_Describe_API.getAdminAccRecTypeID(),
                Automatic_Household_Naming__c = true,
                Lead_Converted_Account_RTypes__c = UTIL_Describe_API.getAdminAccRecTypeID()
            )
        );

        List<Lead> leadsToInsert = new List<Lead>();
        for (integer i = 0; i < leadCount; i++) {
            leadsToInsert.add(new Lead(Company = 'Company' + i, lastname = 'Last' + i));
        }

        insert leadsToInsert;

        Test.startTest();
        LeadStatus convertStatus = [SELECT Id, MasterLabel FROM LeadStatus WHERE IsConverted = TRUE LIMIT 1];
        list<Database.LeadConvert> leadConverts = new List<Database.LeadConvert>();
        for (Lead theLead : leadsToInsert) {
            Database.LeadConvert lc = new database.LeadConvert();
            lc.setLeadId(theLead.Id);
            lc.convertedStatus = convertStatus.MasterLabel;
            leadConverts.add(lc);
        }

        Database.LeadConvertResult[] leadConvertResults = Database.convertLead(leadConverts);

        for (Database.LeadConvertResult lcr : leadConvertResults) {
            System.assert(lcr.isSuccess());
        }

        Test.stopTest();
    }
}
@isTest
private class SRVC_Account_PreventDeletion_TEST {
    /**************************************************************************************************************************
     * @description Helper method to create Account with child records
     */
    private static Account createAccountWithChildRecordsHelper() {
        UTIL_CustomSettingsFacade.getSettingsForTests(
            new Hierarchy_Settings__c(
                Account_Processor__c = UTIL_Describe_API.getBizAccRecTypeID(),
                Prevent_Account_Deletion__c = true
            )
        );

        return UTIL_UnitTestData_TEST.createTestAccountWithMultipleRelations();
    }

    /**************************************************************************************************************************
     * @description Tests getInstance() and constructor of SRVC_Account_PreventDeletion
     */
    @isTest
    static void testGetInstance() {
        UTIL_CustomSettingsFacade.getSettingsForTests(
            new Hierarchy_Settings__c(
                Account_Processor__c = UTIL_Describe_API.getBizAccRecTypeID(),
                Prevent_Account_Deletion__c = true
            )
        );

        SRVC_Account_PreventDeletion srvcAccountPreventDeleteInstance = SRVC_Account_PreventDeletion.getInstance();
        System.assertEquals(SRVC_Account_PreventDeletion.instance, srvcAccountPreventDeleteInstance);
        System.assertNotEquals(null, srvcAccountPreventDeleteInstance);

        srvcAccountPreventDeleteInstance = SRVC_Account_PreventDeletion.getInstance();
        System.assertEquals(SRVC_Account_PreventDeletion.instance, srvcAccountPreventDeleteInstance);
        System.assertEquals(true, srvcAccountPreventDeleteInstance.enabledPreventAccountDeletion);
    }

    /**************************************************************************************************************************
     * @description Tests that isAccountDeletionPreventionEnabled is returning true when prevent deletion is enabled
     */
    @isTest
    static void shouldDetectEnabledPreventDeletionSetting() {
        UTIL_CustomSettingsFacade.getSettingsForTests(
            new Hierarchy_Settings__c(
                Account_Processor__c = UTIL_Describe_API.getBizAccRecTypeID(),
                Prevent_Account_Deletion__c = true
            )
        );

        SRVC_Account_PreventDeletion srvcAccountPreventDeleteInstance = SRVC_Account_PreventDeletion.getInstance();
        System.assertEquals(true, srvcAccountPreventDeleteInstance.isAccountDeletionPreventionEnabled());
    }

    /**************************************************************************************************************************
     * @description Tests that isAccountDeletionPreventionEnabled is returning false when prevent deletion is disabled
     */
    @isTest
    static void shouldDetectDisabledPreventDeletionSetting() {
        UTIL_CustomSettingsFacade.getSettingsForTests(
            new Hierarchy_Settings__c(
                Account_Processor__c = UTIL_Describe_API.getBizAccRecTypeID(),
                Prevent_Account_Deletion__c = false
            )
        );

        SRVC_Account_PreventDeletion srvcAccountPreventDeleteInstance = SRVC_Account_PreventDeletion.getInstance();
        System.assertEquals(false, srvcAccountPreventDeleteInstance.isAccountDeletionPreventionEnabled());
    }

    /**************************************************************************************************************************
     * @description Tests Prevent Deletion for Accounts with STUB_AccountsWithChildRelationships
     */
    @isTest
    static void shouldPreventDeletionForAccountsWithChildrenUsingSTUB() {
        SRVC_Account_PreventDeletion.instance = new STUB_AccountsWithChildRelationships();

        List<Account> accounts = UTIL_UnitTestData_TEST.getMultipleTestAccounts(
            1,
            UTIL_Describe_API.getBizAccRecTypeID()
        );
        accounts[0].Id = UTIL_UnitTestData_TEST.getFakeId(Account.sObjectType);

        Map<Id, Account> accountsById = new Map<Id, Account>((List<Account>) accounts);

        Test.startTest();
        List<Account> accountsWithRelations = SRVC_Account_PreventDeletion.getInstance()
            .getAccountsAndChildRelationships(accountsById.keySet());
        List<Account> accountsWithErrorsList = SRVC_Account_PreventDeletion.getInstance()
            .preventDeletionForAccounts(accountsById, accountsWithRelations);
        Test.stopTest();

        System.assertEquals(accountsById.values().size(), accountsWithErrorsList.size());

        for (Account accountToCheck : accountsWithErrorsList) {
            System.assert(accountsById.get(accountToCheck.Id) != null);
        }
    }

    /**************************************************************************************************************************
     * @description Tests Prevent Deletion for Accounts with STUB_AccountsWithNoChildRelationships
     */
    @isTest
    static void shouldPreventDeletionForAccountsWithNoChildrenUsingSTUB() {
        SRVC_Account_PreventDeletion.instance = new STUB_AccountsWithNoChildRelationships();

        List<Account> accounts = UTIL_UnitTestData_TEST.getMultipleTestAccounts(
            1,
            UTIL_Describe_API.getBizAccRecTypeID()
        );
        accounts[0].Id = UTIL_UnitTestData_TEST.getFakeId(Account.sObjectType);

        Map<Id, Account> accountById = new Map<Id, Account>((List<Account>) accounts);

        Test.startTest();
        List<Account> accountsWithRelations = SRVC_Account_PreventDeletion.getInstance()
            .getAccountsAndChildRelationships(accountById.keySet());
        List<Account> accountsWithErrorsList = SRVC_Account_PreventDeletion.getInstance()
            .preventDeletionForAccounts(accountById, accountsWithRelations);
        Test.stopTest();

        // Ensure accountsWithErrorsList is empty
        System.assertEquals(0, accountsWithErrorsList.size());
    }

    /**************************************************************************************************************************
     * @description Positive tests for preventDeletionForAccounts method using Account with Child records
     */
    @isTest
    static void shouldPreventDeletionForAccountsWithRelations() {
        Account accountWithChildRecords = SRVC_Account_PreventDeletion_TEST.createAccountWithChildRecordsHelper();
        Map<Id, Account> accountById = new Map<Id, Account>();
        accountById.put(accountWithChildRecords.Id, accountWithChildRecords);

        Test.startTest();
        List<Account> accountsWithRelations = SRVC_Account_PreventDeletion.getInstance()
            .getAccountsAndChildRelationships(accountById.keySet());
        List<account> accountErroredList = SRVC_Account_PreventDeletion.getInstance()
            .preventDeletionForAccounts(accountById, accountsWithRelations);
        Test.stopTest();

        // Ensure accountsWithErrorsList is not empty
        System.assertEquals(1, accountErroredList.size());
    }

    /**************************************************************************************************************************
     * @description Negative tests for preventDeletionForAccounts method with No Child records
     */
    @isTest
    static void shouldNotPreventDeletionForAccountsWithNoRelations() {
        List<Account> accountWithNoChildRecord = UTIL_UnitTestData_TEST.getMultipleTestAccounts(
            1,
            UTIL_Describe_API.getBizAccRecTypeID()
        );
        accountWithNoChildRecord[0].Id = UTIL_UnitTestData_TEST.getFakeId(Account.sObjectType);

        Map<Id, Account> accountById = new Map<Id, Account>(accountWithNoChildRecord);

        Test.startTest();
        List<Account> accountsWithRelations = SRVC_Account_PreventDeletion.getInstance()
            .getAccountsAndChildRelationships(accountById.keySet());
        List<account> accountErroredList = SRVC_Account_PreventDeletion.getInstance()
            .preventDeletionForAccounts(accountById, accountsWithRelations);
        Test.stopTest();

        // Ensure accountsWithErrorsList is empty
        System.assertEquals(0, accountErroredList.size());
    }

    /**************************************************************************************************************************
     * @description Positive tests for AccountsAndChildRelationships method
     */
    @isTest
    static void shouldGetAccountsAndChildRelationships() {
        Account accountWithChildRecords = SRVC_Account_PreventDeletion_TEST.createAccountWithChildRecordsHelper();

        Set<Id> accountIdSet = new Set<Id>();
        accountIdSet.add(accountWithChildRecords.Id);

        Test.startTest();
        List<Account> accountsWithChildRecords = SRVC_Account_PreventDeletion.getInstance()
            .getAccountsAndChildRelationships(accountIdSet);
        Test.stopTest();

        // Ensure child records are retrieved
        System.assertEquals(1, accountsWithChildRecords[0].Addresses__r.size());
        System.assertEquals(1, accountsWithChildRecords[0].Affl_Contacts__r.size());
        System.assertEquals(1, accountsWithChildRecords[0].Attributes__r.size());
        System.assertEquals(1, accountsWithChildRecords[0].Courses__r.size());
        System.assertEquals(1, accountsWithChildRecords[0].Education_History__r.size());
        System.assertEquals(1, accountsWithChildRecords[0].Facilities__r.size());
        System.assertEquals(1, accountsWithChildRecords[0].Household_Members__r.size());
        System.assertEquals(1, accountsWithChildRecords[0].Organization_Members__r.size());
        System.assertEquals(1, accountsWithChildRecords[0].Program_Enrollments__r.size());
        System.assertEquals(1, accountsWithChildRecords[0].Program_Plans__r.size());
        System.assertEquals(1, accountsWithChildRecords[0].Terms__r.size());
        System.assertEquals(1, accountsWithChildRecords[0].Time_Blocks__r.size());
    }

    /**************************************************************************************************************************
     * @description Negative tests for AccountsAndChildRelationships method
     */
    @isTest
    static void shouldNotGetChildRelationshipsForEmptyAccounts() {
        List<Account> accounts = UTIL_UnitTestData_TEST.getMultipleTestAccounts(
            1,
            UTIL_Describe_API.getBizAccRecTypeID()
        );
        insert accounts;

        Map<Id, Account> accountById = new Map<Id, Account>(accounts);
        Set<Id> accountIdSet = accountById.keySet();

        Test.startTest();
        List<account> accountsWithChildRecords = SRVC_Account_PreventDeletion.getInstance()
            .getAccountsAndChildRelationships(accountIdSet);
        Test.stopTest();

        System.assertEquals(0, accountsWithChildRecords[0].Addresses__r.size());
        System.assertEquals(0, accountsWithChildRecords[0].Affl_Contacts__r.size());
        System.assertEquals(0, accountsWithChildRecords[0].Attributes__r.size());
        System.assertEquals(0, accountsWithChildRecords[0].Courses__r.size());
        System.assertEquals(0, accountsWithChildRecords[0].Course_Enrollments__r.size());
        System.assertEquals(0, accountsWithChildRecords[0].Education_History__r.size());
        System.assertEquals(0, accountsWithChildRecords[0].Facilities__r.size());
        System.assertEquals(0, accountsWithChildRecords[0].Household_Members__r.size());
        System.assertEquals(0, accountsWithChildRecords[0].Organization_Members__r.size());
        System.assertEquals(0, accountsWithChildRecords[0].Program_Enrollments__r.size());
        System.assertEquals(0, accountsWithChildRecords[0].Program_Plans__r.size());
        System.assertEquals(0, accountsWithChildRecords[0].Terms__r.size());
        System.assertEquals(0, accountsWithChildRecords[0].Time_Blocks__r.size());
    }

    /**************************************************************************************************************************
     * @description positive test for AccountHasChildRecords method
     */
    @isTest
    static void shouldHaveChildRecordsForAccountWithChildRelations() {
        Account accountWithChildRecords = SRVC_Account_PreventDeletion_TEST.createAccountWithChildRecordsHelper();

        Account acc = [
            SELECT
                ID,
                (SELECT ID FROM Account.Addresses__r LIMIT 1),
                (SELECT ID FROM Account.Affl_Contacts__r LIMIT 1),
                (SELECT ID FROM Account.Attributes__r LIMIT 1),
                (SELECT ID FROM Account.Courses__r LIMIT 1),
                (SELECT ID FROM Account.Course_Enrollments__r LIMIT 1),
                (SELECT ID FROM Account.Education_History__r LIMIT 1),
                (SELECT ID FROM Account.Facilities__r LIMIT 1),
                (SELECT ID FROM Account.Household_Members__r LIMIT 1),
                (SELECT ID FROM Account.Organization_Members__r LIMIT 1),
                (SELECT ID FROM Account.Program_Enrollments__r LIMIT 1),
                (SELECT ID FROM Account.Program_Plans__r LIMIT 1),
                (SELECT ID FROM Account.Terms__r LIMIT 1),
                (SELECT ID FROM Account.Time_Blocks__r LIMIT 1)
            FROM Account
            WHERE ID = :accountWithChildRecords.Id
        ];

        Test.startTest();
        Boolean accountHasChildren = SRVC_Account_PreventDeletion.getInstance().hasChildRecords(acc);
        Test.stopTest();

        // Ensure accountHasChildren is true
        System.assertEquals(true, accountHasChildren);
    }

    /**************************************************************************************************************************
     * @description Negative test for AccountHasChildRecords method
     */
    @isTest
    static void shouldNotHaveChildRecordsForEmptyAccounts() {
        List<Account> accounts = UTIL_UnitTestData_TEST.getMultipleTestAccounts(
            1,
            UTIL_Describe_API.getBizAccRecTypeID()
        );

        Test.startTest();
        Boolean accountHasChildren = SRVC_Account_PreventDeletion.getInstance().hasChildRecords(accounts[0]);
        Test.stopTest();

        // Ensure accountHasChildren is false
        System.assertEquals(false, accountHasChildren);
    }

    /**************************************************************************************************************************
     * @description Positive tests for accountWasMerged method using Account with MasterRecordId
     */
    @isTest
    static void shouldReturnTrueWhenAccountWasMerged() {
        Account accountWithChildRecords = SRVC_Account_PreventDeletion_TEST.createAccountWithChildRecordsHelper();
        List<Account> accounts = UTIL_UnitTestData_TEST.getMultipleTestAccounts(
            2,
            UTIL_Describe_API.getBizAccRecTypeID()
        );
        insert accounts[1]; //Use the second account as master to avoid duplicate error
        merge accounts[1] accountWithChildRecords;
        Account mergeLoserAccount = [
            SELECT Id, MasterRecordId
            FROM Account
            WHERE Id = :accountWithChildRecords.Id
            ALL ROWS
        ];

        Test.startTest();
        Boolean accountWasMerged = SRVC_Account_PreventDeletion.getInstance().wasMerged(mergeLoserAccount);
        Test.stopTest();

        // Ensure accountWasMerged is true
        System.assertEquals(true, accountWasMerged);
    }

    /**************************************************************************************************************************
     * @description Negative tests for accountWasMerged method using Account without MasterRecordId
     */
    @isTest
    static void shouldReturnFalseWhenAccountNotMerged() {
        List<Account> accounts = UTIL_UnitTestData_TEST.getMultipleTestAccounts(
            2,
            UTIL_Describe_API.getBizAccRecTypeID()
        );

        Test.startTest();
        Boolean accountWasMerged = SRVC_Account_PreventDeletion.getInstance().wasMerged(accounts[0]);
        Test.stopTest();

        // Ensure accountWasMerged is false
        System.assertEquals(false, accountWasMerged);
    }

    /**************************************************************************************************************************
     * @description Tests Prevent Deletion for merged accounts with STUB_MergedAccounts
     */
    @isTest
    static void shouldNotPreventDeletionForMergedAccountsUsingSTUB() {
        SRVC_Account_PreventDeletion.instance = new STUB_MergedAccounts();

        List<Account> accounts = UTIL_UnitTestData_TEST.getMultipleTestAccounts(
            1,
            UTIL_Describe_API.getBizAccRecTypeID()
        );
        accounts[0].Id = UTIL_UnitTestData_TEST.getFakeId(Account.sObjectType);

        Map<Id, Account> accountById = new Map<Id, Account>((List<Account>) accounts);

        Test.startTest();
        List<Account> accountsWithRelations = SRVC_Account_PreventDeletion.getInstance()
            .getAccountsAndChildRelationships(accountById.keySet());
        List<Account> accountsWithErrorsList = SRVC_Account_PreventDeletion.getInstance()
            .PreventDeletionForAccounts(accountById, accountsWithRelations);
        Test.stopTest();

        //Ensure prevent deletion did not mark any account
        System.assertEquals(0, accountsWithErrorsList.size());
    }

    /**************************************************************************************************************************************
     * STUB class which extends SRVC_Account_PreventDeletion, overrides getAccountsAndChildRelationships and hasChildRecords method
     */
    private virtual class STUB_AccountsWithChildRelationships extends SRVC_Account_PreventDeletion {
        @TestVisible
        public override List<Account> getAccountsAndChildRelationships(Set<Id> accountIdSet) {
            List<Account> accountsList = new List<Account>();
            for (Id eachAccountId : accountIdSet) {
                Account acc = new Account(Id = eachAccountId, Name = eachAccountId);
                accountsList.add(acc);
            }
            return accountsList;
        }

        @TestVisible
        public override Boolean hasChildRecords(Account acc) {
            return true;
        }
    }

    /***************************************************************************************************************************************
     * STUB class which extends SRVC_Account_PreventDeletion, overrides getAccountsAndChildRelationships and hasChildRecords method
     */
    private virtual class STUB_AccountsWithNoChildRelationships extends SRVC_Account_PreventDeletion {
        @TestVisible
        public override List<Account> getAccountsAndChildRelationships(Set<Id> accountIdSet) {
            List<Account> accountsList = new List<Account>();
            for (Id eachAccountId : accountIdSet) {
                Account acc = new Account(Id = eachAccountId, Name = eachAccountId);
                accountsList.add(acc);
            }
            return accountsList;
        }

        @TestVisible
        public override Boolean hasChildRecords(Account acc) {
            return false;
        }
    }

    /**************************************************************************************************************************************
     * STUB class which extends STUB_AccountsWithChildRelationships, overrides wasMerged method to simulate merging
     */
    private virtual class STUB_MergedAccounts extends STUB_AccountsWithChildRelationships {
        @TestVisible
        protected override Boolean wasMerged(Account acc) {
            return true;
        }
    }
}
@isTest
private with sharing class AutoEnrollmentMappingsVMapper_TEST {
    /**************************************************************************************************
     * @description Test method to verify that the getInstance method returns a new instance of the
     * AutoEnrollmentMappingsVMapper class when one does not already exist.
     **************************************************************************************************/
    @isTest
    private static void getInstanceNew() {
        Test.startTest();
        AutoEnrollmentMappingsVMapper autoEnrollmentMappingsVMapperInstance = AutoEnrollmentMappingsVMapper.getInstance();
        Test.stopTest();

        System.assertEquals(
            AutoEnrollmentMappingsVMapper.instance,
            autoEnrollmentMappingsVMapperInstance,
            'Instance of mapper class returned should match static instance variable.'
        );
        System.assertEquals(
            true,
            autoEnrollmentMappingsVMapperInstance != null,
            'Instance of mapper class should not be null.'
        );
    }

    /**************************************************************************************************
     * @description Test method to verify that the getInstance method returns the existing instance of the
     * AutoEnrollmentMappingsVMapper class when one already exists.
     **************************************************************************************************/
    @isTest
    private static void getInstanceExisting() {
        Test.startTest();
        AutoEnrollmentMappingsVMapper autoEnrollmentMappingsVMapperInstance1 = AutoEnrollmentMappingsVMapper.getInstance();
        AutoEnrollmentMappingsVMapper autoEnrollmentMappingsVMapperInstance2 = AutoEnrollmentMappingsVMapper.getInstance();
        Test.stopTest();

        System.assertEquals(
            AutoEnrollmentMappingsVMapper.instance,
            autoEnrollmentMappingsVMapperInstance1,
            'Instance of mapper class returned should match static instance variable.'
        );
        System.assertEquals(
            autoEnrollmentMappingsVMapperInstance1,
            autoEnrollmentMappingsVMapperInstance2,
            'Subsequent retrievals of mapper class instance should return existing instance.'
        );
        System.assertEquals(
            true,
            autoEnrollmentMappingsVMapperInstance1 != null,
            'Instance of mapper class should not be null.'
        );
    }

    /****************************************************************************************
     * @description Test method to verify locateRecordTypeService() returns an instance of
     * the RecordTypeService class.
     ****************************************************************************************/
    @isTest
    private static void locateRecordTypeServiceValid() {
        AutoEnrollmentMappingsVMapper autoEnrollmentMappingsVMapperInstance = AutoEnrollmentMappingsVMapper.getInstance();

        Test.startTest();
        RecordTypeService recordTypeServiceInstance = autoEnrollmentMappingsVMapperInstance.locateRecordTypeService();
        Test.stopTest();

        System.assertEquals(
            RecordTypeService.getInstance(),
            recordTypeServiceInstance,
            'Should return instance of RecordTypeService class.'
        );
    }

    /****************************************************************************************
     * @description Test method to verify locateAffiliationMappingsService() returns an instance of
     * the AffiliationMappingsService class.
     ****************************************************************************************/
    @isTest
    private static void locateAffiliationMappingsServiceValid() {
        AutoEnrollmentMappingsVMapper autoEnrollmentMappingsVMapperInstance = AutoEnrollmentMappingsVMapper.getInstance();

        Test.startTest();
        AffiliationMappingsService affiliationMappingsServiceInstance = autoEnrollmentMappingsVMapperInstance.locateAffiliationMappingsService();
        Test.stopTest();

        System.assertEquals(
            AffiliationMappingsService.getInstance(),
            affiliationMappingsServiceInstance,
            'Should return instance of AffiliationMappingsService class.'
        );
    }

    /****************************************************************************************
     * @description Test method to verify locatePicklistEntryService() returns an instance of
     * the PicklistEntryService class.
     ****************************************************************************************/
    @isTest
    private static void locatePicklistEntryServiceValid() {
        AutoEnrollmentMappingsVMapper autoEnrollmentMappingsVMapperInstance = AutoEnrollmentMappingsVMapper.getInstance();

        Test.startTest();
        PicklistEntryService picklistEntryServiceInstance = autoEnrollmentMappingsVMapperInstance.locatePicklistEntryService();
        Test.stopTest();

        System.assertEquals(
            PicklistEntryService.getInstance(),
            picklistEntryServiceInstance,
            'Should return instance of PicklistEntryService class.'
        );
    }

    /****************************************************************************************
     * @description Test method to verify getAutoEnrollmentMappingVModel()
     * returns an instance of AutoEnrollmentMappingVModel with account record type
     * corresponding to the matching model properties when matching models exists.
     ****************************************************************************************/
    @isTest
    private static void getAutoEnrollmentMappingVModelValid() {
        RecordTypeService.instance = new STUB_RecordTypeServiceValid();

        AffiliationMappingsModel affiliationMappingsModel = new AffiliationMappingsModel(
            'Affliation Name',
            'Account Record Type',
            'Primary Affiliation Field',
            true,
            'autoProgramEnrollmentStatus',
            'autoProgramEnrollmentRole'
        );
        Map<String, RecordTypeModel> accountRecordTypeModelsByName = new Map<String, RecordTypeModel>{
            'Account_Record_Type' => new RecordTypeModel(
                '000000000000000009',
                'Account Record Type',
                'Account_Record_Type',
                true
            )
        };

        Map<String, RecordTypeModel> accountRecordTypeModelsByLabel = new Map<String, RecordTypeModel>{
            'Account Record Type' => new RecordTypeModel(
                '000000000000000009',
                'Account Record Type',
                'Account_Record_Type',
                true
            )
        };

        AutoEnrollmentMappingsVMapper autoEnrollmentMappingsVMapperInstance = AutoEnrollmentMappingsVMapper.getInstance();

        Test.startTest();
        AutoEnrollmentMappingVModel autoEnrollmentMappingVModel = autoEnrollmentMappingsVMapperInstance.getAutoEnrollmentMappingVModel(
            affiliationMappingsModel,
            accountRecordTypeModelsByName,
            accountRecordTypeModelsByLabel
        );
        Test.stopTest();

        System.assertEquals(
            'Affliation Name',
            autoEnrollmentMappingVModel.mappingName,
            'Mapping name should be Affliation Name.'
        );

        System.assertEquals(
            'Account_Record_Type',
            autoEnrollmentMappingVModel.accountRecordTypeName,
            'Account Record Type name should match developer name of Record Type model corresponding to record type specified for the affiliation mapping.'
        );

        System.assertEquals(
            'Account Record Type',
            autoEnrollmentMappingVModel.accountRecordTypeLabel,
            'Account Record Type label should match label of Record Type model corresponding to record type specified for the affiliation mapping.'
        );

        System.assertEquals(
            'autoProgramEnrollmentStatus',
            autoEnrollmentMappingVModel.autoProgramEnrollmentStatus,
            'Auto enrollment status should match the auto enrollment status of the affiliation mapping.'
        );

        System.assertEquals(
            'autoProgramEnrollmentRole',
            autoEnrollmentMappingVModel.autoProgramEnrollmentRole,
            'Auto enrollment role should match the auto enrollment role of the affiliation mapping.'
        );
    }

    /****************************************************************************************
     * @description Test method to verify getAutoEnrollmentMappingVModel()
     * returns an instance of AutoEnrollmentMappingVModel with valid values
     * when auto enrollment status and role are empty
     ****************************************************************************************/
    @isTest
    private static void getAutoEnrollmentMappingVModelEmpty() {
        RecordTypeService.instance = new STUB_RecordTypeServiceValid();

        AffiliationMappingsModel affiliationMappingsModel = new AffiliationMappingsModel(
            'Affliation Name',
            'Account Record Type',
            'Primary Affiliation Field',
            true,
            '',
            ''
        );
        Map<String, RecordTypeModel> accountRecordTypeModelsByName = new Map<String, RecordTypeModel>{
            'Account_Record_Type' => new RecordTypeModel(
                '000000000000000009',
                'Account Record Type',
                'Account_Record_Type',
                true
            )
        };

        Map<String, RecordTypeModel> accountRecordTypeModelsByLabel = new Map<String, RecordTypeModel>{
            'Account Record Type' => new RecordTypeModel(
                '000000000000000009',
                'Account Record Type',
                'Account_Record_Type',
                true
            )
        };

        AutoEnrollmentMappingsVMapper autoEnrollmentMappingsVMapperInstance = AutoEnrollmentMappingsVMapper.getInstance();

        Test.startTest();
        AutoEnrollmentMappingVModel autoEnrollmentMappingVModel = autoEnrollmentMappingsVMapperInstance.getAutoEnrollmentMappingVModel(
            affiliationMappingsModel,
            accountRecordTypeModelsByName,
            accountRecordTypeModelsByLabel
        );
        Test.stopTest();

        System.assertEquals(
            'Affliation Name',
            autoEnrollmentMappingVModel.mappingName,
            'Mapping name should be Affliation Name.'
        );

        System.assertEquals(
            'Account_Record_Type',
            autoEnrollmentMappingVModel.accountRecordTypeName,
            'Account Record Type name should match developer name of Record Type model corresponding to record type specified for the affiliation mapping.'
        );

        System.assertEquals(
            'Account Record Type',
            autoEnrollmentMappingVModel.accountRecordTypeLabel,
            'Account Record Type label should match label of Record Type model corresponding to record type specified for the affiliation mapping.'
        );

        System.assertEquals(
            '',
            autoEnrollmentMappingVModel.autoProgramEnrollmentStatus,
            'Auto enrollment status should be empty.'
        );

        System.assertEquals(
            '',
            autoEnrollmentMappingVModel.autoProgramEnrollmentRole,
            'Auto enrollment role should be empty.'
        );
    }

    /****************************************************************************************
     * @description Test method to verify getAutoEnrollmentMappingVModel()
     * returns a AutoEnrollmentMappingVModel with account record type and lookup field names
     * and labels corresponding to the properties specified for the affiliation mapping
     * when matching models do not exist.
     ****************************************************************************************/
    @isTest
    private static void getAutoEnrollmentMappingVModelInValidRecordType() {
        RecordTypeService.instance = new STUB_RecordTypeServiceInvalid();

        AffiliationMappingsModel affiliationMappingsModel = new AffiliationMappingsModel(
            'Affliation Name',
            'Invalid Account Record Type',
            'Invalid Primary Affiliation Field',
            false,
            'autoProgramEnrollmentStatus',
            'autoProgramEnrollmentRole'
        );

        Map<String, RecordTypeModel> accountRecordTypeModelsByName = new Map<String, RecordTypeModel>{
            'Account_Record_Type' => new RecordTypeModel(
                '000000000000000009',
                'Account Record Type',
                'Account_Record_Type',
                true
            )
        };

        Map<String, RecordTypeModel> accountRecordTypeModelsByLabel = new Map<String, RecordTypeModel>{
            'Account Record Type' => new RecordTypeModel(
                '000000000000000009',
                'Account Record Type',
                'Account_Record_Type',
                true
            )
        };

        AutoEnrollmentMappingsVMapper autoEnrollmentMappingsVMapperInstance = AutoEnrollmentMappingsVMapper.getInstance();

        Test.startTest();
        AutoEnrollmentMappingVModel autoEnrollmentMappingVModel = autoEnrollmentMappingsVMapperInstance.getAutoEnrollmentMappingVModel(
            affiliationMappingsModel,
            accountRecordTypeModelsByName,
            accountRecordTypeModelsByLabel
        );
        Test.stopTest();

        System.assertEquals(
            'Affliation Name',
            autoEnrollmentMappingVModel.mappingName,
            'Mapping name should be Affliation Name.'
        );

        System.assertEquals(
            'Invalid Account Record Type',
            autoEnrollmentMappingVModel.accountRecordTypeName,
            'Account Record Type name should match value specified for the affiliation mapping.'
        );

        System.assertEquals(
            'Invalid Account Record Type',
            autoEnrollmentMappingVModel.accountRecordTypeLabel,
            'Account Record Type label should match value specified for the affiliation mapping.'
        );

        System.assertEquals(
            'autoProgramEnrollmentStatus',
            autoEnrollmentMappingVModel.autoProgramEnrollmentStatus,
            'Auto enrollment status should match the auto enrollment status of the affiliation mapping.'
        );

        System.assertEquals(
            'autoProgramEnrollmentRole',
            autoEnrollmentMappingVModel.autoProgramEnrollmentRole,
            'Auto enrollment role should match the auto enrollment role of the affiliation mapping.'
        );
    }

    /****************************************************************************************
     * @description Test method to verify getAutoEnrollmentMappingsVModel()
     * returns a AutoEnrollmentMappingsVModel with proper values
     * when active auto enrollment exists.
     ****************************************************************************************/
    @isTest
    private static void getAutoEnrollmentMappingsVModelActiveAutoEnrollmentExists() {
        AffiliationMappingsService.instance = new STUB_AffiliationMappingsService();
        RecordTypeService.instance = new STUB_RecordTypeService();

        AutoEnrollmentMappingsVMapper autoEnrollmentMappingsVMapperInstance = AutoEnrollmentMappingsVMapper.getInstance();

        Test.startTest();
        AutoEnrollmentMappingsVModel autoEnrollmentMappingsVModel = autoEnrollmentMappingsVMapperInstance.getAutoEnrollmentMappingsVModel();
        Test.stopTest();

        System.assertEquals(
            2,
            autoEnrollmentMappingsVModel.autoEnrollmentMappingVModels.size(),
            'Should return 2 autoEnrollmentMappingVModels.'
        );

        for (Integer i = 0; i < autoEnrollmentMappingsVModel.autoEnrollmentMappingVModels.size(); i++) {
            System.assertEquals(
                'Record_Type_' + (i + 1),
                autoEnrollmentMappingsVModel.autoEnrollmentMappingVModels[i].accountRecordTypeName,
                'Account record type name should match developer name of corresponding record type model.'
            );

            System.assertEquals(
                'Record Type ' + (i + 1),
                autoEnrollmentMappingsVModel.autoEnrollmentMappingVModels[i].accountRecordTypeLabel,
                'Account record type label should match label of corresponding record type model.'
            );

            System.assertEquals(
                'autoProgramEnrollmentStatus' + (i + 1),
                autoEnrollmentMappingsVModel.autoEnrollmentMappingVModels[i].autoProgramEnrollmentStatus,
                'Auto-Enrollment status should match.'
            );

            System.assertEquals(
                'autoProgramEnrollmentRole' + (i + 1),
                autoEnrollmentMappingsVModel.autoEnrollmentMappingVModels[i].autoProgramEnrollmentRole,
                'Auto-Enrollment role should match.'
            );
        }
    }

    /****************************************************************************************
     * @description Test method to verify getAutoEnrollmentMappingsVModel()
     * returns a AutoEnrollmentMappingsVModel with proper values
     * when active auto enrollment exists but empty.
     ****************************************************************************************/
    @isTest
    private static void getAutoEnrollmentMappingsVModelActiveAutoEnrollmentEmpty() {
        AffiliationMappingsService.instance = new STUB_AffiliationMappingsServiceEmptyAutoEnrollment();
        RecordTypeService.instance = new STUB_RecordTypeService();

        AutoEnrollmentMappingsVMapper autoEnrollmentMappingsVMapperInstance = AutoEnrollmentMappingsVMapper.getInstance();

        Test.startTest();
        AutoEnrollmentMappingsVModel autoEnrollmentMappingsVModel = autoEnrollmentMappingsVMapperInstance.getAutoEnrollmentMappingsVModel();
        Test.stopTest();

        System.assertEquals(
            2,
            autoEnrollmentMappingsVModel.autoEnrollmentMappingVModels.size(),
            'Should return 2 autoEnrollmentMappingVModels.'
        );

        for (Integer i = 0; i < autoEnrollmentMappingsVModel.autoEnrollmentMappingVModels.size(); i++) {
            System.assertEquals(
                'Record_Type_' + (i + 1),
                autoEnrollmentMappingsVModel.autoEnrollmentMappingVModels[i].accountRecordTypeName,
                'Account record type name should match developer name of corresponding record type model.'
            );

            System.assertEquals(
                'Record Type ' + (i + 1),
                autoEnrollmentMappingsVModel.autoEnrollmentMappingVModels[i].accountRecordTypeLabel,
                'Account record type label should match label of corresponding record type model.'
            );

            System.assertEquals(
                '',
                autoEnrollmentMappingsVModel.autoEnrollmentMappingVModels[i].autoProgramEnrollmentStatus,
                'Auto-Enrollment status should be empty.'
            );

            System.assertEquals(
                '',
                autoEnrollmentMappingsVModel.autoEnrollmentMappingVModels[i].autoProgramEnrollmentRole,
                'Auto-Enrollment role should be empty.'
            );
        }
    }

    /****************************************************************************************
     * @description Test method to verify getAutoEnrollmentMappingsVModel()
     * returns a AutoEnrollmentMappingsVModel with proper values
     * when no active auto enrollment exists.
     ****************************************************************************************/
    @isTest
    private static void getAutoEnrollmentMappingsVModelActiveAutoEnrollmentNotExists() {
        AffiliationMappingsService.instance = new STUB_AffiliationMappingsServiceInactiveAutoEnrollment();
        RecordTypeService.instance = new STUB_RecordTypeService();

        AutoEnrollmentMappingsVMapper autoEnrollmentMappingsVMapperInstance = AutoEnrollmentMappingsVMapper.getInstance();

        Test.startTest();
        AutoEnrollmentMappingsVModel autoEnrollmentMappingsVModel = autoEnrollmentMappingsVMapperInstance.getAutoEnrollmentMappingsVModel();
        Test.stopTest();

        System.assertEquals(
            0,
            autoEnrollmentMappingsVModel.autoEnrollmentMappingVModels.size(),
            'Should return 0 autoEnrollmentMappingVModels.'
        );
    }

    /****************************************************************************************
     * @description Test method to verify getAutoEnrollmentMappingsVModel()
     * returns a AutoEnrollmentMappingsVModel with proper values when active auto enrollment exists.
     ****************************************************************************************/
    @isTest
    private static void unmappedRecordTypesExist() {
        AffiliationMappingsService.instance = new STUB_AffiliationMappingsServiceInactiveAutoEnrollment();
        RecordTypeService.instance = new STUB_RecordTypeService();

        AutoEnrollmentMappingsVMapper autoEnrollmentMappingsVMapperInstance = AutoEnrollmentMappingsVMapper.getInstance();

        Test.startTest();
        Boolean unmappedRecordTypesExistValue = autoEnrollmentMappingsVMapperInstance.unmappedRecordTypesExist();
        Test.stopTest();

        System.assertEquals(true, unmappedRecordTypesExistValue, 'Unmapped record types should exist');
    }

    /****************************************************************************************
     * @description Test method to verify getAutoEnrollmentMappingsVModel()
     * returns a AutoEnrollmentMappingsVModel with proper values when no active auto enrollment exists.
     ****************************************************************************************/
    @isTest
    private static void unmappedRecordTypesExistFalse() {
        AffiliationMappingsService.instance = new STUB_AffiliationMappingsService();
        RecordTypeService.instance = new STUB_RecordTypeService();

        AutoEnrollmentMappingsVMapper autoEnrollmentMappingsVMapperInstance = AutoEnrollmentMappingsVMapper.getInstance();

        Test.startTest();
        Boolean unmappedRecordTypesExistValue = autoEnrollmentMappingsVMapperInstance.unmappedRecordTypesExist();
        Test.stopTest();

        System.assertEquals(false, unmappedRecordTypesExistValue, 'No unmapped record types should exist');
    }

    /****************************************************************************************
     * @description Test method to verify getAccountRecordTypeComboboxVModel()
     * returns a ComboBoxVModel with proper values
     * when no record type except the current one is mapped to active auto enrollment.
     ****************************************************************************************/
    @isTest
    private static void getAccountRecordTypeComboboxVModelUnmapped() {
        AffiliationMappingsService.instance = new STUB_AffiliationMappingsServiceMixAutoEnrollment();
        RecordTypeService.instance = new STUB_RecordTypeServiceAccountRecordTypeCombobox(false);

        AutoEnrollmentMappingsVMapper autoEnrollmentMappingsVMapperInstance = AutoEnrollmentMappingsVMapper.getInstance();

        Test.startTest();
        ComboBoxVModel accountRecordTypeComboboxVModel = autoEnrollmentMappingsVMapperInstance.getAccountRecordTypeComboboxVModel(
            'Record_Type_1'
        );
        Test.stopTest();

        System.assertEquals(
            'Record_Type_1',
            accountRecordTypeComboboxVModel.value,
            'The size of comboboxVModelOptionsForActiveAccountRecordTypes should be 2'
        );
        System.assertEquals(
            2,
            accountRecordTypeComboboxVModel.options.size(),
            'The size of accountRecordTypeComboboxVModel.options should be 2'
        );
        System.assertEquals(
            'Record Type 1',
            accountRecordTypeComboboxVModel.options[0].label,
            'The label of accountRecordTypeComboboxVModel.options[0] should be Record Type 1'
        );
        System.assertEquals(
            'Record_Type_1',
            accountRecordTypeComboboxVModel.options[0].value,
            'The value of accountRecordTypeComboboxVModel.options[0] should be Record_Type_1'
        );
        System.assertEquals(
            'Record Type 2',
            accountRecordTypeComboboxVModel.options[1].label,
            'The label of accountRecordTypeComboboxVModel.options[1] should be Record Type 2'
        );
        System.assertEquals(
            'Record_Type_2',
            accountRecordTypeComboboxVModel.options[1].value,
            'The value of accountRecordTypeComboboxVModel.options[1] should be Record_Type_2'
        );
    }

    /****************************************************************************************
     * @description Test method to verify getAccountRecordTypeComboboxVModel()
     * returns a ComboBoxVModel with proper values when the account record type is empty
     ****************************************************************************************/
    @isTest
    private static void getAccountRecordTypeComboboxVModelEmpty() {
        AffiliationMappingsService.instance = new STUB_AffiliationMappingsServiceMixAutoEnrollment();
        RecordTypeService.instance = new STUB_RecordTypeServiceAccountRecordTypeCombobox(false);

        AutoEnrollmentMappingsVMapper autoEnrollmentMappingsVMapperInstance = AutoEnrollmentMappingsVMapper.getInstance();

        Test.startTest();
        ComboBoxVModel accountRecordTypeComboboxVModel = autoEnrollmentMappingsVMapperInstance.getAccountRecordTypeComboboxVModel(
            null
        );
        Test.stopTest();

        System.assertEquals(null, accountRecordTypeComboboxVModel.value, 'The account record type should be null');
        System.assertEquals(
            1,
            accountRecordTypeComboboxVModel.options.size(),
            'The size of accountRecordTypeComboboxVModel.options should be 1'
        );
        System.assertEquals(
            'Record Type 2',
            accountRecordTypeComboboxVModel.options[0].label,
            'The label of accountRecordTypeComboboxVModel.options[0] should be Record Type 2'
        );
        System.assertEquals(
            'Record_Type_2',
            accountRecordTypeComboboxVModel.options[0].value,
            'The value of accountRecordTypeComboboxVModel.options[0] should be Record_Type_2'
        );
    }

    /****************************************************************************************
     * @description Test method to verify getAccountRecordTypeComboboxVModel()
     * returns a ComboBoxVModel with proper values
     * when all record types are mapped to active auto enrollment.
     ****************************************************************************************/
    @isTest
    private static void getAccountRecordTypeComboboxVModelMapped() {
        AffiliationMappingsService.instance = new STUB_AffiliationMappingsService();
        RecordTypeService.instance = new STUB_RecordTypeServiceAccountRecordTypeCombobox(false);

        AutoEnrollmentMappingsVMapper autoEnrollmentMappingsVMapperInstance = AutoEnrollmentMappingsVMapper.getInstance();

        Test.startTest();
        ComboBoxVModel accountRecordTypeComboboxVModel = autoEnrollmentMappingsVMapperInstance.getAccountRecordTypeComboboxVModel(
            'Record_Type_1'
        );
        Test.stopTest();

        System.assertEquals(
            'Record_Type_1',
            accountRecordTypeComboboxVModel.value,
            'The value of comboboxVModelOptionsForActiveAccountRecordTypes should be Record_Type_1'
        );
        System.assertEquals(
            1,
            accountRecordTypeComboboxVModel.options.size(),
            'The size of accountRecordTypeComboboxVModel.options should be 1'
        );
        System.assertEquals(
            'Record Type 1',
            accountRecordTypeComboboxVModel.options[0].label,
            'The label of accountRecordTypeComboboxVModel.options[0] should be Record Type 1'
        );
        System.assertEquals(
            'Record_Type_1',
            accountRecordTypeComboboxVModel.options[0].value,
            'The value of accountRecordTypeComboboxVModel.options[0] should be Record_Type_1'
        );
    }

    /****************************************************************************************
     * @description Test method to verify getAccountRecordTypeComboboxVModel() returns a
     * ComboBoxVModel with proper values when the record type does not exist
     ****************************************************************************************/
    @isTest
    private static void getAccountRecordTypeComboboxVModelMappedNull() {
        AffiliationMappingsService.instance = new STUB_AffiliationMappingsService();
        RecordTypeService.instance = new STUB_RecordTypeServiceAccountRecordTypeCombobox(true);

        AutoEnrollmentMappingsVMapper autoEnrollmentMappingsVMapperInstance = AutoEnrollmentMappingsVMapper.getInstance();

        Test.startTest();
        ComboBoxVModel accountRecordTypeComboboxVModel = autoEnrollmentMappingsVMapperInstance.getAccountRecordTypeComboboxVModel(
            'Invalid'
        );
        Test.stopTest();

        System.assertEquals(
            'Invalid',
            accountRecordTypeComboboxVModel.value,
            'The value of comboboxVModelOptionsForActiveAccountRecordTypes should be Invalid'
        );
        System.assertEquals(
            1,
            accountRecordTypeComboboxVModel.options.size(),
            'The size of accountRecordTypeComboboxVModel.options should be 1'
        );
        System.assertEquals(
            'Invalid',
            accountRecordTypeComboboxVModel.options[0].label,
            'The label of accountRecordTypeComboboxVModel.options[0] should be Invalid'
        );
        System.assertEquals(
            'Invalid',
            accountRecordTypeComboboxVModel.options[0].value,
            'The value of accountRecordTypeComboboxVModel.options[0] should be Invalid'
        );
    }

    /****************************************************************************************
     * @description Test method to verify getComboboxVModelOptionsForActiveAccountRecordTypes()
     * returns a list of ComboboxValueVModel with proper values
     * when no record type is mapped to active auto enrollment.
     ****************************************************************************************/
    @isTest
    private static void getComboboxVModelOptionsForActiveAccountRecordTypesAllUnmapped() {
        AffiliationMappingsService.instance = new STUB_AffiliationMappingsServiceInactiveAutoEnrollment();
        List<RecordTypeModel> activeAccountRecordTypeModelsList = new List<RecordTypeModel>{
            new RecordTypeModel('000000000000000001', 'Record Type 1', 'Record_Type_1', true),
            new RecordTypeModel('000000000000000002', 'Record Type 2', 'Record_Type_2', true)
        };

        AutoEnrollmentMappingsVMapper autoEnrollmentMappingsVMapperInstance = AutoEnrollmentMappingsVMapper.getInstance();

        Test.startTest();
        List<ComboboxValueVModel> comboboxVModelOptionsForActiveAccountRecordTypes = autoEnrollmentMappingsVMapperInstance.getComboboxVModelOptionsForActiveAccountRecordTypes(
            activeAccountRecordTypeModelsList,
            'Record_Type_1'
        );
        Test.stopTest();

        System.assertEquals(
            2,
            comboboxVModelOptionsForActiveAccountRecordTypes.size(),
            'The size of comboboxVModelOptionsForActiveAccountRecordTypes should be 2'
        );
        System.assertEquals(
            'Record Type 1',
            comboboxVModelOptionsForActiveAccountRecordTypes[0].label,
            'The label of comboboxVModelOptionsForActiveAccountRecordTypes[0] should be Record Type 1'
        );
        System.assertEquals(
            'Record_Type_1',
            comboboxVModelOptionsForActiveAccountRecordTypes[0].value,
            'The value of comboboxVModelOptionsForActiveAccountRecordTypes[0] should be Record_Type_1'
        );
        System.assertEquals(
            'Record Type 2',
            comboboxVModelOptionsForActiveAccountRecordTypes[1].label,
            'The label of comboboxVModelOptionsForActiveAccountRecordTypes[1] should be Record Type 2'
        );
        System.assertEquals(
            'Record_Type_2',
            comboboxVModelOptionsForActiveAccountRecordTypes[1].value,
            'The value of comboboxVModelOptionsForActiveAccountRecordTypes[1] should be Record_Type_2'
        );
    }

    /****************************************************************************************
     * @description Test method to verify getComboboxVModelOptionsForActiveAccountRecordTypes()
     * returns a empty list of ComboboxValueVModel with proper values
     * when all record types are mapped to active auto enrollment.
     ****************************************************************************************/
    @isTest
    private static void getComboboxVModelOptionsForActiveAccountRecordTypesAllMapped() {
        AffiliationMappingsService.instance = new STUB_AffiliationMappingsService();
        List<RecordTypeModel> activeAccountRecordTypeModelsList = new List<RecordTypeModel>{
            new RecordTypeModel('000000000000000001', 'Record Type 1', 'Record_Type_1', true),
            new RecordTypeModel('000000000000000002', 'Record Type 2', 'Record_Type_2', true)
        };

        AutoEnrollmentMappingsVMapper autoEnrollmentMappingsVMapperInstance = AutoEnrollmentMappingsVMapper.getInstance();

        Test.startTest();
        List<ComboboxValueVModel> comboboxVModelOptionsForActiveAccountRecordTypes = autoEnrollmentMappingsVMapperInstance.getComboboxVModelOptionsForActiveAccountRecordTypes(
            activeAccountRecordTypeModelsList,
            'Record_Type_1'
        );
        Test.stopTest();

        System.assertEquals(
            1,
            comboboxVModelOptionsForActiveAccountRecordTypes.size(),
            'The size of comboboxVModelOptionsForActiveAccountRecordTypes should be 0'
        );
        System.assertEquals(
            'Record Type 1',
            comboboxVModelOptionsForActiveAccountRecordTypes[0].label,
            'The label of comboboxVModelOptionsForActiveAccountRecordTypes[0] should be Record Type 1'
        );
        System.assertEquals(
            'Record_Type_1',
            comboboxVModelOptionsForActiveAccountRecordTypes[0].value,
            'The value of comboboxVModelOptionsForActiveAccountRecordTypes[0] should be Record_Type_1'
        );
    }

    /****************************************************************************************
     * @description Test method to verify getAutoEnrollmentMappingStatusComboboxVModel()
     * returns a ComboBoxVModel with proper values of picklist entries.
     ****************************************************************************************/
    @isTest
    private static void getAutoEnrollmentMappingStatusComboboxVModelValid() {
        PicklistEntryService.instance = new STUB_StatusPicklistEntryServiceValid();

        AutoEnrollmentMappingsVMapper autoEnrollmentMappingsVMapperInstance = AutoEnrollmentMappingsVMapper.getInstance();

        Test.startTest();
        ComboBoxVModel autoEnrollmentMappingStatusCombobox = autoEnrollmentMappingsVMapperInstance.getAutoEnrollmentMappingStatusComboboxVModel(
            'Status'
        );
        Test.stopTest();

        System.assertEquals(
            'Status',
            autoEnrollmentMappingStatusCombobox.value,
            'The value of autoEnrollmentMappingStatusCombobox should be Status'
        );
        System.assertEquals(
            'Test Status',
            autoEnrollmentMappingStatusCombobox.options[0].label,
            'The label of autoEnrollmentMappingStatusCombobox.options[0] should be Test Status'
        );
        System.assertEquals(
            'Test_Status',
            autoEnrollmentMappingStatusCombobox.options[0].value,
            'The value of autoEnrollmentMappingStatusCombobox.options[0] should be Test_Status'
        );
    }

    /****************************************************************************************
     * @description Test method to verify getAutoEnrollmentMappingStatusComboboxVModel()
     * returns a ComboBoxVModel with no options when no valid picklist value entry is found.
     ****************************************************************************************/
    @isTest
    private static void getAutoEnrollmentMappingStatusComboboxVModelInvalid() {
        PicklistEntryService.instance = new STUB_StatusPicklistEntryServiceInvalid();

        AutoEnrollmentMappingsVMapper autoEnrollmentMappingsVMapperInstance = AutoEnrollmentMappingsVMapper.getInstance();

        Test.startTest();
        ComboBoxVModel autoEnrollmentMappingStatusCombobox = autoEnrollmentMappingsVMapperInstance.getAutoEnrollmentMappingStatusComboboxVModel(
            'Status'
        );
        Test.stopTest();

        System.assertEquals(
            'Status',
            autoEnrollmentMappingStatusCombobox.value,
            'The value of autoEnrollmentMappingStatusCombobox should be Status'
        );
        System.assertEquals(
            0,
            autoEnrollmentMappingStatusCombobox.options.size(),
            'The size of autoEnrollmentMappingStatusCombobox.options should be 0'
        );
    }

    /****************************************************************************************
     * @description Test method to verify getAutoEnrollmentMappingRoleComboboxVModel()
     * returns a ComboBoxVModel with proper values of picklist entries.
     ****************************************************************************************/
    @isTest
    private static void getAutoEnrollmentMappingRoleComboboxVModelValid() {
        PicklistEntryService.instance = new STUB_RolePicklistEntryServiceValid();

        AutoEnrollmentMappingsVMapper autoEnrollmentMappingsVMapperInstance = AutoEnrollmentMappingsVMapper.getInstance();

        Test.startTest();
        ComboBoxVModel autoEnrollmentMappingRoleCombobox = autoEnrollmentMappingsVMapperInstance.getAutoEnrollmentMappingRoleComboboxVModel(
            'Role'
        );
        Test.stopTest();

        System.assertEquals(
            'Role',
            autoEnrollmentMappingRoleCombobox.value,
            'The value of autoEnrollmentMappingRoleCombobox should be Role'
        );
        System.assertEquals(
            'Test Role',
            autoEnrollmentMappingRoleCombobox.options[0].label,
            'The label of autoEnrollmentMappingRoleCombobox.options[0] should be Test Role'
        );
        System.assertEquals(
            'Test_Role',
            autoEnrollmentMappingRoleCombobox.options[0].value,
            'The value of autoEnrollmentMappingRoleCombobox.options[0] should be Test_Role'
        );
    }

    /****************************************************************************************
     * @description Test method to verify getAutoEnrollmentMappingRoleComboboxVModel()
     * returns a ComboBoxVModel with no options when no valid picklist value entry is found.
     ****************************************************************************************/
    @isTest
    private static void getAutoEnrollmentMappingRoleComboboxVModelInvalid() {
        PicklistEntryService.instance = new STUB_RolePicklistEntryServiceInvalid();

        AutoEnrollmentMappingsVMapper autoEnrollmentMappingsVMapperInstance = AutoEnrollmentMappingsVMapper.getInstance();

        Test.startTest();
        ComboBoxVModel autoEnrollmentMappingRoleCombobox = autoEnrollmentMappingsVMapperInstance.getAutoEnrollmentMappingRoleComboboxVModel(
            'Role'
        );
        Test.stopTest();

        System.assertEquals(
            'Role',
            autoEnrollmentMappingRoleCombobox.value,
            'The value of autoEnrollmentMappingRoleCombobox should be Role'
        );
        System.assertEquals(
            0,
            autoEnrollmentMappingRoleCombobox.options.size(),
            'The size of autoEnrollmentMappingRoleCombobox.options should be 0'
        );
    }

    /***********************************************************************************************************************************
     ****************************************************** STUBS ***********************************************************************
     ***********************************************************************************************************************************/

    /**************************************************************************************************************************************
     * @description Stub class to simulate valid responses from AffiliationMappingsService
     **************************************************************************************************************************************/
    private class STUB_AffiliationMappingsService extends AffiliationMappingsService {
        public override List<AffiliationMappingsModel> getAffiliationMappingsModels() {
            return new List<AffiliationMappingsModel>{
                new AffiliationMappingsModel(
                    'Affiliation Name 1',
                    'Record_Type_1',
                    'Contact_Account_Lookup_1',
                    true,
                    'autoProgramEnrollmentStatus1',
                    'autoProgramEnrollmentRole1'
                ),
                new AffiliationMappingsModel(
                    'Affiliation Name 2',
                    'Record_Type_2',
                    'Contact_Account_Lookup_2',
                    true,
                    'autoProgramEnrollmentStatus2',
                    'autoProgramEnrollmentRole2'
                )
            };
        }
    }

    /**************************************************************************************************************************************
     * @description Stub class to simulate valid responses from AffiliationMappingsService with inactive auto enrollment
     **************************************************************************************************************************************/
    private class STUB_AffiliationMappingsServiceInactiveAutoEnrollment extends AffiliationMappingsService {
        public override List<AffiliationMappingsModel> getAffiliationMappingsModels() {
            return new List<AffiliationMappingsModel>{
                new AffiliationMappingsModel(
                    'Affiliation Name 1',
                    'Record_Type_1',
                    'Contact_Account_Lookup_1',
                    false,
                    'autoProgramEnrollmentStatus1',
                    'autoProgramEnrollmentRole1'
                ),
                new AffiliationMappingsModel(
                    'Affiliation Name 2',
                    'Record_Type_2',
                    'Contact_Account_Lookup_2',
                    false,
                    'autoProgramEnrollmentStatus2',
                    'autoProgramEnrollmentRole2'
                )
            };
        }
    }

    /**************************************************************************************************************************************
     * @description Stub class to simulate valid responses from AffiliationMappingsService with inactive auto enrollment
     **************************************************************************************************************************************/
    private class STUB_AffiliationMappingsServiceMixAutoEnrollment extends AffiliationMappingsService {
        public override List<AffiliationMappingsModel> getAffiliationMappingsModels() {
            return new List<AffiliationMappingsModel>{
                new AffiliationMappingsModel(
                    'Affiliation Name 1',
                    'Record_Type_1',
                    'Contact_Account_Lookup_1',
                    true,
                    'autoProgramEnrollmentStatus1',
                    'autoProgramEnrollmentRole1'
                ),
                new AffiliationMappingsModel(
                    'Affiliation Name 2',
                    'Record_Type_2',
                    'Contact_Account_Lookup_2',
                    false,
                    'autoProgramEnrollmentStatus2',
                    'autoProgramEnrollmentRole2'
                )
            };
        }
    }

    /**************************************************************************************************************************************
     * @description Stub class to simulate valid responses from AffiliationMappingsService with empty auto enrollment
     **************************************************************************************************************************************/
    private class STUB_AffiliationMappingsServiceEmptyAutoEnrollment extends AffiliationMappingsService {
        public override List<AffiliationMappingsModel> getAffiliationMappingsModels() {
            return new List<AffiliationMappingsModel>{
                new AffiliationMappingsModel(
                    'Affiliation Name 1',
                    'Record_Type_1',
                    'Contact Account Lookup Label 1',
                    true,
                    '',
                    ''
                ),
                new AffiliationMappingsModel(
                    'Affiliation Name 2',
                    'Record_Type_2',
                    'Contact Account Lookup Label 2',
                    true,
                    '',
                    ''
                )
            };
        }
    }

    /**************************************************************************************************************************************
     * @description Stub class to simulate valid responses from RecordTypeService
     **************************************************************************************************************************************/
    private class STUB_RecordTypeService extends RecordTypeService {
        public override Map<Id, RecordTypeModel> getModelByIdMapForSObjectType(Schema.SObjectType sObjectType) {
            return new Map<Id, RecordTypeModel>{
                '000000000000000001' => new RecordTypeModel(
                    '000000000000000001',
                    'Record Type 1',
                    'Record_Type_1',
                    true
                ),
                '000000000000000002' => new RecordTypeModel(
                    '000000000000000002',
                    'Record Type 2',
                    'Record_Type_2',
                    true
                ),
                '000000000000000003' => new RecordTypeModel(
                    '000000000000000003',
                    'Record Type 3',
                    'Record_Type_3',
                    false
                )
            };
        }
    }

    /**************************************************************************************************************************************
     * @description Stub class to simulate valid responses from RecordTypeService
     **************************************************************************************************************************************/
    private class STUB_RecordTypeServiceValid extends RecordTypeService {
        public override RecordTypeModel getRecordTypeModelFromNameAndLabelMaps(
            String recordTypeNameOrLabel,
            Map<String, RecordTypeModel> recordTypeModelByName,
            Map<String, RecordTypeModel> recordTypeModelByLabel
        ) {
            return new RecordTypeModel('000000000000000009', 'Account Record Type', 'Account_Record_Type', true);
        }
    }

    /**************************************************************************************************************************************
     * @description Stub class to simulate invalid responses from RecordTypeService
     **************************************************************************************************************************************/
    private class STUB_RecordTypeServiceInvalid extends RecordTypeService {
        public override RecordTypeModel getRecordTypeModelFromNameAndLabelMaps(
            String recordTypeNameOrLabel,
            Map<String, RecordTypeModel> recordTypeModelByName,
            Map<String, RecordTypeModel> recordTypeModelByLabel
        ) {
            return null;
        }
    }

    /**************************************************************************************************************************************
     * @description Stub class to simulate valid responses for account record type combobox
     **************************************************************************************************************************************/
    private class STUB_RecordTypeServiceAccountRecordTypeCombobox extends RecordTypeService {
        private Boolean neverFindRecordType = false;

        public STUB_RecordTypeServiceAccountRecordTypeCombobox(Boolean neverFindRecordType) {
            this.neverFindRecordType = neverFindRecordType;
        }

        public override Map<Id, RecordTypeModel> getModelByIdMapForSObjectType(Schema.SObjectType sObjectType) {
            return new Map<Id, RecordTypeModel>{
                '000000000000000001' => new RecordTypeModel(
                    '000000000000000001',
                    'Record Type 1',
                    'Record_Type_1',
                    true
                ),
                '000000000000000002' => new RecordTypeModel(
                    '000000000000000002',
                    'Record Type 2',
                    'Record_Type_2',
                    true
                )
            };
        }

        public override RecordTypeModel getRecordTypeModelFromNameAndLabelMaps(
            String recordTypeNameOrLabel,
            Map<String, RecordTypeModel> recordTypeModelByName,
            Map<String, RecordTypeModel> recordTypeModelByLabel
        ) {
            if (this.neverFindRecordType) {
                return null;
            }

            return new RecordTypeModel('000000000000000001', 'Record Type 1', 'Record_Type_1', true);
        }
    }

    /**************************************************************************************************************************************
     * @description Stub class to simulate valid responses from PicklistEntryService
     **************************************************************************************************************************************/
    private class STUB_StatusPicklistEntryServiceValid extends PicklistEntryService {
        public override Map<String, PicklistEntryModel> getModelsByNameForSObjectField(
            SObjectType sObjectTypeName,
            SObjectField SObjectFieldName
        ) {
            return new Map<String, PicklistEntryModel>{
                'Status' => new PicklistEntryModel('Test_Status', 'Test Status', true)
            };
        }
    }

    /**************************************************************************************************************************************
     * @description Stub class to simulate invalid responses from PicklistEntryService
     **************************************************************************************************************************************/
    private class STUB_StatusPicklistEntryServiceInvalid extends PicklistEntryService {
        public override Map<String, PicklistEntryModel> getModelsByNameForSObjectField(
            SObjectType sObjectTypeName,
            SObjectField SObjectFieldName
        ) {
            return new Map<String, PicklistEntryModel>{
                'Status' => new PicklistEntryModel('Test_Status', 'Test Status', false)
            };
        }
    }

    /**************************************************************************************************************************************
     * @description Stub class to simulate valid responses from PicklistEntryService
     **************************************************************************************************************************************/
    private class STUB_RolePicklistEntryServiceValid extends PicklistEntryService {
        public override Map<String, PicklistEntryModel> getModelsByNameForSObjectField(
            SObjectType sObjectTypeName,
            SObjectField SObjectFieldName
        ) {
            return new Map<String, PicklistEntryModel>{
                'Role' => new PicklistEntryModel('Test_Role', 'Test Role', true)
            };
        }
    }

    /**************************************************************************************************************************************
     * @description Stub class to simulate invalid responses from PicklistEntryService
     **************************************************************************************************************************************/
    private class STUB_RolePicklistEntryServiceInvalid extends PicklistEntryService {
        public override Map<String, PicklistEntryModel> getModelsByNameForSObjectField(
            SObjectType sObjectTypeName,
            SObjectField SObjectFieldName
        ) {
            return new Map<String, PicklistEntryModel>{
                'Role' => new PicklistEntryModel('Test_Role', 'Test Role', false)
            };
        }
    }
}
/*
    Copyright (c) 2014, Salesforce.org
    All rights reserved.

    Redistribution and use in source and binary forms, with or without
    modification, are permitted provided that the following conditions are met:

    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
    * Neither the name of Salesforce.org nor the names of
      its contributors may be used to endorse or promote products derived
      from this software without specific prior written permission.

    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
    "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
    LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
    FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
    COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
    INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
    BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
    LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
    CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
    LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
    ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
    POSSIBILITY OF SUCH DAMAGE.
*/
/**
 * @author Salesforce.org
 * @date 2015
 * @group Course Offering
 * @group-content ../../ApexDocContent/CourseOfferings.htm
 * @description Keeps Course Offering and Affiliation records for a Contact in sync.
 */
public class COFF_Affiliation_TDTM extends TDTM_Runnable {
    /*******************************************************************************************************
    * @description Handles Affiliation management for Course Offering.
                   Populates Start and End Date from Term, if fields are empty.
    * @param listNew the list of Course Offerings from trigger new.
    * @param listOld the list of Course Offerings from trigger old.
    * @param triggerAction which trigger event (BeforeInsert, AfterInsert, etc.).
    * @param objResult the describe for Course Offering.
    * @return dmlWrapper.
    ********************************************************************************************************/
    public override DmlWrapper run(
        List<SObject> newlist,
        List<SObject> oldlist,
        TDTM_Runnable.Action triggerAction,
        Schema.DescribeSObjectResult objResult
    ) {
        DmlWrapper dmlWrapper = new DmlWrapper();
        // prevent recursion
        if (!TDTM_ProcessControl.getRecursionFlag(TDTM_ProcessControl.registeredTrigger.COFF_Affiliation_TDTM)) {
            List<Course_Offering__c> offsWithNewFaculty = new List<Course_Offering__c>();
            Set<Id> offsWithChangedFaculty = new Set<Id>();
            Set<Id> offsWithRemovedFaculty = new Set<Id>();
            Set<Id> oldCourseOfferingFacultyIDs = new Set<Id>();
            Set<Id> newCourseOfferingFacultyIDs = new Set<Id>();

            List<ID> newFacultyIDs = new List<ID>();
            List<ID> updatedFacultyIDs = new List<ID>();
            List<ID> outdatedFacultyIDs = new List<ID>();
            List<ID> removedFacultyIDs = new List<ID>();
            List<ID> facultyCleanupIDs = new List<ID>();

            List<SObject> objectsToInsert = new List<SObject>();
            List<SObject> objectsToUpdate = new List<SObject>();
            List<SObject> objectsToDelete = new List<SObject>();

            List<Course_Enrollment__c> courseEnrllsToInsert = new List<Course_Enrollment__c>();

            Map<Id, Course_Offering__c> mapNewFacultyIdToNewCourseOffering = new Map<Id, Course_Offering__c>();

            if (newlist != null) {
                if (
                    triggerAction == TDTM_Runnable.Action.AfterInsert ||
                    triggerAction == TDTM_Runnable.Action.AfterUpdate
                ) {
                    //Query fields not available in the trigger
                    newList = [
                        SELECT
                            Course__c,
                            Faculty__c,
                            Start_Date__c,
                            End_Date__c,
                            Course__r.Account__c,
                            Term__r.Start_Date__c,
                            Term__r.End_Date__c
                        FROM Course_Offering__c
                        WHERE ID IN :newlist
                    ];
                }

                for (Integer i = 0; i < newlist.size(); i++) {
                    Course_Offering__c newOff = (Course_Offering__c) newlist[i];

                    if (triggerAction == TDTM_Runnable.Action.AfterInsert) {
                        //Course Offering with Faculty has been created
                        //   --> create Affl if no other Affl to Dpt exists
                        //   --> create Course Enrollment
                        if (newOff.Faculty__c != null) {
                            UTIL_Debug.debug('****Course Offering with Faculty has been created');
                            newFacultyIDs.add(newOff.Faculty__c);
                            offsWithNewFaculty.add(newOff);
                            Course_Enrollment__c newEnroll = new Course_Enrollment__c(
                                Contact__c = newOff.Faculty__c,
                                Account__c = newOff.Course__r.Account__c,
                                Course_Offering__c = newOff.Id
                            );
                            if (UTIL_CustomSettingsFacade.courseConnectionsEnabled()) {
                                // Course Connections is enabled, set RecordType and Primary__c
                                newEnroll.put('RecordTypeId', UTIL_Describe.getFacultyConnectionRecType());
                                newEnroll.Primary__c = true;
                            }
                            courseEnrllsToInsert.add(newEnroll);
                        }

                        Boolean dateCopied = false;
                        //Copy Start Date from parent Term, if no value entered
                        if (
                            String.isBlank(String.valueOf(newOff.Start_Date__c)) &&
                            !String.isBlank(String.valueOf(newOff.Term__r.Start_Date__c))
                        ) {
                            UTIL_Debug.debug(
                                '****Copying term start date to course offering: ' + newOff.Term__r.Start_Date__c
                            );
                            newOff.Start_Date__c = newOff.Term__r.Start_Date__c;
                            dateCopied = true;
                        }
                        //Copy End Date from parent Term, if no value entered
                        if (
                            String.isBlank(String.valueOf(newOff.End_Date__c)) &&
                            !String.isBlank(String.valueOf(newOff.Term__r.End_Date__c))
                        ) {
                            UTIL_Debug.debug(
                                '****Copying term start date to course offering: ' + newOff.Term__r.Start_Date__c
                            );
                            newOff.End_Date__c = newOff.Term__r.End_Date__c;
                            dateCopied = true;
                        }

                        //Nowhere else in this class are Course Offerings added to dmlWrapper.objectsToUpdate. If they were, we
                        //should put all those changes together to avoid adding those records to dmlWrapper.objectsToUpdate more
                        //than once.
                        if (dateCopied) {
                            dmlWrapper.objectsToUpdate.add(newOff);
                        }
                    } else if (triggerAction == TDTM_Runnable.Action.AfterUpdate) {
                        Course_Offering__c oldOff = (Course_Offering__c) oldlist[i];

                        //Faculty member has been added to existing Course Offering
                        //   --> create Affl if no other Affl to Dpt exists
                        //   --> create Course Enrollment
                        //     --> Create without recordtype if course connections disabled
                        //     --> Create with recordtype and as primary if course connections enabled
                        if (oldOff.Faculty__c == null && newOff.Faculty__c != null) {
                            UTIL_Debug.debug('****Faculty member has been added to existing Course Offering');
                            newFacultyIDs.add(newOff.Faculty__c);
                            offsWithNewFaculty.add(newOff);
                            // Do not perform adding new Course Enrollments if Course Connections is enabled.
                            // Logic for if Course Connections is enabled is handled below.
                            if (!UTIL_CustomSettingsFacade.courseConnectionsEnabled()) {
                                Course_Enrollment__c enroll = new Course_Enrollment__c(
                                    Contact__c = newOff.Faculty__c,
                                    Account__c = newOff.Course__r.Account__c,
                                    Course_Offering__c = newOff.Id
                                );
                                courseEnrllsToInsert.add(enroll);
                            }

                            //Faculty member has been changed
                            //   --> update Affiliation to Dpt to point it to the new Faculty
                        } else if (
                            oldOff.Faculty__c != null &&
                            newOff.Faculty__c != null &&
                            oldOff.Faculty__c != newOff.Faculty__c
                        ) {
                            UTIL_Debug.debug('****Faculty member has been changed');
                            offsWithChangedFaculty.add(newOff.Id);
                            outdatedFacultyIDs.add(oldOff.Faculty__c);
                            updatedFacultyIDs.add(newOff.Faculty__c);
                            mapNewFacultyIdToNewCourseOffering.put(newOff.Faculty__c, newOff);
                            oldCourseOfferingFacultyIDs.add(oldOff.Faculty__c);
                            newCourseOfferingFacultyIDs.add(newOff.Faculty__c);
                            //Faculty member has been removed from existing Course Offering
                            //   --> delete related Affiliation
                            //   --> delete Course Enrollment
                        } else if (oldOff.Faculty__c != null && newOff.Faculty__c == null) {
                            UTIL_Debug.debug('****Faculty member has been removed from existing Course Offering');
                            removedFacultyIDs.add(oldOff.Faculty__c);
                            offsWithRemovedFaculty.add(newOff.Id);
                        }
                    }
                }
            }

            if (oldlist != null) {
                for (Integer i = 0; i < oldlist.size(); i++) {
                    Course_Offering__c oldOff = (Course_Offering__c) oldlist[i];

                    if (triggerAction == TDTM_Runnable.Action.BeforeDelete) {
                        //Course Offering has been deleted
                        //     --> delete related Affiliation, if the faculty field had a value
                        //     --> delete the Course Enrollment, if the faculty field had a value
                        if (oldOff.Faculty__c != null) {
                            UTIL_Debug.debug('****Course Offering with faculty has been deleted');
                            facultyCleanupIDs.add(oldOff.Faculty__c);
                            offsWithRemovedFaculty.add(oldOff.Id);
                        }
                    }
                }
            }
            // If new faculty added to existing Course Offering
            if (offsWithNewFaculty.size() > 0) {
                if (UTIL_CustomSettingsFacade.courseConnectionsEnabled()) {
                    updateConnectionsOnFacultyAdd(offsWithNewFaculty, objectsToInsert, objectsToUpdate);
                } else {
                    createOrLinkAffls(offsWithNewFaculty, newFacultyIDs, courseEnrllsToInsert);
                }
                dmlWrapper.objectsToInsert.addAll((List<SObject>) courseEnrllsToInsert);
            }

            if (updatedFacultyIDs.size() > 0) {
                if (UTIL_CustomSettingsFacade.courseConnectionsEnabled()) {
                    // Course connections is enabled. Handle updating of objects
                    updateConnectionsOnFacultyChange(
                        offsWithChangedFaculty,
                        oldCourseOfferingFacultyIDs,
                        newCourseOfferingFacultyIDs,
                        objectsToInsert,
                        objectsToUpdate
                    );
                } else {
                    List<Affiliation__c> newAffls = getAfflsToUpdate(
                        outdatedFacultyIDs,
                        updatedFacultyIDs,
                        mapNewFacultyIdToNewCourseOffering
                    );
                    for (Affiliation__c newAffl : newAffls) {
                        if (newAffl.Id != null) {
                            dmlWrapper.objectsToUpdate.add(newAffl);
                        } else {
                            dmlWrapper.objectsToInsert.add(newAffl);
                        }
                    }
                    // Course connections is not enabled. Handle deletion and creation of course enrollments
                    updateEnrollments(outdatedFacultyIDs, updatedFacultyIDs, offsWithChangedFaculty, dmlWrapper); //Passing dmlWrapper because there's more than one DML to perform
                }
            }

            if (removedFacultyIDs.size() > 0) {
                if (UTIL_CustomSettingsFacade.courseConnectionsEnabled()) {
                    updateConnectionsOnFacultyRemove(removedFacultyIDs, offsWithRemovedFaculty, objectsToUpdate);
                } else {
                    deleteAfflsEnrolls(removedFacultyIDs, offsWithRemovedFaculty, dmlWrapper); //Passing dmlWrapper because there's more than one DML to perform
                }
            }

            if (facultyCleanupIDs.size() > 0) {
                deleteAfflsEnrolls(facultyCleanupIDs, offsWithRemovedFaculty, dmlWrapper); //Passing dmlWrapper because there's more than one DML to perform
            }

            TDTM_ProcessControl.setRecursionFlag(TDTM_ProcessControl.registeredTrigger.COFF_Affiliation_TDTM, true);

            dmlWrapper.objectsToUpdate.addAll(objectsToUpdate);
            dmlWrapper.objectsToInsert.addAll(objectsToInsert);
            dmlWrapper.objectsToDelete.addAll(objectsToDelete);
        }

        TDTM_TriggerHandler.processDML(dmlWrapper, true);
        dmlWrapper = null;
        TDTM_ProcessControl.setRecursionFlag(TDTM_ProcessControl.registeredTrigger.COFF_Affiliation_TDTM, false);
        return dmlWrapper;
    }

    /*******************************************************************************************************
     * @description Creates Affiliation records for Faculty members assigned to Course Offerings, if no Affiliation
     * existed for the department the Course Offering belongs to. Also, it links the automatically created Course
     * Enrollments to the automatically created Affiliations.
     ********************************************************************************************************/
    private void createOrLinkAffls(
        List<Course_Offering__c> offsWithNewFaculty,
        List<Id> newFacultyIDs,
        List<Course_Enrollment__c> courseEnrllsToInsert
    ) {
        //Find all Affls for all Faculty members in the trigger.
        Map<Id, List<Affiliation__c>> facultyIDtoAffls = getAfflsForContact(newFacultyIDs);
        //Automatically create an Affiliation record if a Course Offering record with a value in the Faculty field has been created,
        //and no Affl to the parent Department exists.
        Map<String, Affiliation__c> affiliationsToInsertByContactAccountString = new Map<String, Affiliation__c>();
        List<Affiliation__c> afflsTemp = new List<Affiliation__c>();
        for (Integer i = 0; i < offsWithNewFaculty.size(); i++) {
            Course_Offering__c offering = offsWithNewFaculty[i];
            Affiliation__c afflToDpt = affiliationToAccount(offering, facultyIDtoAffls);

            if (afflToDpt == null) {
                UTIL_Debug.debug('****Affl to Dpt does not exist');
                Affiliation__c afflToInsert;

                String contactAccountKey = offering.Faculty__c + '' + offering.Course__r.Account__c;
                // Is the Affiliation already being inserted? If so, do not insert a duplicate.
                if (affiliationsToInsertByContactAccountString.containsKey(contactAccountKey)) {
                    afflToInsert = affiliationsToInsertByContactAccountString.get(contactAccountKey);
                } else {
                    afflToInsert = createAffiliationFromCourseOffering(offering);
                    affiliationsToInsertByContactAccountString.put(contactAccountKey, afflToInsert);
                }
                afflsTemp.add(afflToInsert);
            } else {
                UTIL_Debug.debug('****Affl to Dpt exists: ' + afflToDpt.Id);
                afflsTemp.add(afflToDpt); // Add existing affl to link to Course Enrollment
            }
        }
        insert affiliationsToInsertByContactAccountString.values();

        //Link Course Enrollments to Affiliations
        for (Integer i = 0; i < afflsTemp.size(); i++) {
            if (afflsTemp[i] != null) {
                courseEnrllsToInsert[i].Affiliation__c = afflsTemp[i].Id;
            }
        }
    }

    /*******************************************************************************************************
     * @description Sets each Affiliation pointing to the new Faculty member that is teaching the Course Offering.
     ********************************************************************************************************/
    private List<SObject> getAfflsToUpdate(
        List<ID> outdatedFacultyIDs,
        List<ID> updatedFacultyIDs,
        Map<Id, Course_Offering__c> mapNewFacultyIdToNewCourseOffering
    ) {
        List<Affiliation__c> afflsWithContact = [
            SELECT Contact__c
            FROM Affiliation__c
            WHERE Contact__c IN :outdatedFacultyIDs AND Role__c = 'Faculty'
        ];
        Map<String, Affiliation__c> affiliationsToInsertByContactAccountString = new Map<String, Affiliation__c>();

        Map<ID, Affiliation__c> oldFacultyToAfflMap = new Map<ID, Affiliation__c>();
        for (Affiliation__c affl : afflsWithContact) {
            oldFacultyToAfflMap.put(affl.Contact__c, affl);
        }

        //We have to make sure we are updating the correct Affiliations.
        for (Integer i = 0; i < outdatedFacultyIDs.size(); i++) {
            Id outdatedFacultyID = outdatedFacultyIDs[i];
            Id updatedFacultyID = updatedFacultyIDs[i];
            if (oldFacultyToAfflMap.keySet().contains(outdatedFacultyID)) {
                Affiliation__c oldAffl = oldFacultyToAfflMap.get(outdatedFacultyID);
                oldAffl.Contact__c = updatedFacultyID;
            } else {
                if (
                    mapNewFacultyIdToNewCourseOffering.keySet().contains(updatedFacultyID) &&
                    mapNewFacultyIdToNewCourseOffering.get(updatedFacultyID) != null
                ) {
                    Course_Offering__c offering = mapNewFacultyIdToNewCourseOffering.get(updatedFacultyID);
                    String contactAccountKey = offering.Faculty__c + '' + offering.Course__r.Account__c;
                    // Is the Affiliation already being inserted? If so, do not insert a duplicate.
                    if (affiliationsToInsertByContactAccountString.containsKey(contactAccountKey)) {
                        continue;
                    }

                    Affiliation__c newAffl = createAffiliationFromCourseOffering(offering);
                    affiliationsToInsertByContactAccountString.put(contactAccountKey, newAffl);
                }
            }
        }

        afflsWithContact.addAll(affiliationsToInsertByContactAccountString.values());
        return afflsWithContact;
    }

    /*******************************************************************************************************
     * @description Creates and returns a new Faculty Affiliation record from the given Course Offering.
     * @return Affiliation__c The new Faculty Affiliation record.
     ********************************************************************************************************/
    private Affiliation__c createAffiliationFromCourseOffering(Course_Offering__c offering) {
        return new Affiliation__c(
            Contact__c = offering.Faculty__c,
            Account__c = offering.Course__r.Account__c,
            Role__c = 'Faculty',
            StartDate__c = offering.Term__r.Start_Date__c,
            EndDate__c = offering.Term__r.End_Date__c
        );
    }

    /*******************************************************************************************************
     * @description Updates each Course Enrollment from the old Faculty member to the new Faculty member. A Faculty
     * member should not be at the same time teaching and attending a course if the course connection is disabled.
     * However, it still allows users to replace the course enrollment with the new faculty member.
     ********************************************************************************************************/
    private void updateEnrollments(
        List<ID> outdatedFacultyIDs,
        List<ID> updatedFacultyIDs,
        Set<Id> offsWithChangedFaculty,
        DmlWrapper dmlWrapper
    ) {
        List<Course_Enrollment__c> newEnrolls = new List<Course_Enrollment__c>();
        List<Course_Enrollment__c> oldEnrolls = [
            SELECT Affiliation__c, Account__c, Course_Offering__c, Course_Offering__r.Faculty__c
            FROM Course_Enrollment__c
            WHERE Contact__c IN :outdatedFacultyIDs AND Course_Offering__c IN :offsWithChangedFaculty
        ];
        for (Course_Enrollment__c enroll : oldEnrolls) {
            newEnrolls.add(
                new Course_Enrollment__c(
                    Contact__c = enroll.Course_Offering__r.Faculty__c,
                    Account__c = enroll.Account__c,
                    Course_Offering__c = enroll.Course_Offering__c,
                    Affiliation__c = enroll.Affiliation__c
                )
            );
        }

        dmlWrapper.objectsToDelete.addAll((List<SObject>) oldEnrolls);
        dmlWrapper.objectsToInsert.addAll((List<SObject>) newEnrolls);
    }

    /*******************************************************************************************************
     * @description Updates each Course Connection to mark old as not Primary and new as Primary. A Faculty
     * member may already have a Course Connection that may need to be marked primary or may need to be created
     * if a connection for the Faculty member does not exist.
     ********************************************************************************************************/
    @testVisible
    private void updateConnectionsOnFacultyChange(
        Set<Id> offsWithChangedFaculty,
        Set<Id> outdatedFacultyIDs,
        Set<Id> updatedFacultyIDs,
        List<SObject> objectsToInsert,
        List<SObject> objectsToUpdate
    ) {
        Id facultyRecordTypeId = UTIL_Describe.getFacultyConnectionRecType();
        Map<Id, Course_Enrollment__c> updatedCouserEnrollmentBycourseOfferingId = new Map<Id, Course_Enrollment__c>();
        String subQueryString = ', (SELECT Id, Contact__c, Affiliation__c, Account__c, Course_Offering__c, Primary__c';
        subQueryString += ' FROM Course_Enrollment__r';
        subQueryString += ' WHERE (Contact__c IN :outdatedFacultyIDs OR Contact__c IN :updatedFacultyIDs)';
        subQueryString += ' AND Course_Offering__c IN :offsWithChangedFaculty';

        //Record type of course enrollment not in the package
        if (
            UTIL_Describe.isValidField(UTIL_Namespace.StrTokenNSPrefix('Course_Enrollment__c'), 'RecordTypeId') &&
            facultyRecordTypeId != null
        ) {
            subQueryString += ' AND RecordTypeId = :facultyRecordTypeId';
        }
        subQueryString += ')';
        String queryString = 'SELECT Id, Faculty__c';
        queryString += subQueryString;
        queryString += ' FROM Course_Offering__c WHERE Id IN :offsWithChangedFaculty';

        List<Course_Offering__c> updatedCourseOfferings = Database.query(queryString);

        for (Course_Offering__c updatedCourseOffering : updatedCourseOfferings) {
            Boolean hasExistingCourseConnection = false;

            if (updatedCourseOffering.Faculty__c == null) {
                continue;
            }

            if (updatedCourseOffering.Course_Enrollment__r.size() == 0) {
                continue;
            }

            for (Course_Enrollment__c childCourseConnection : updatedCourseOffering.Course_Enrollment__r) {
                if (updatedCourseOffering.Faculty__c == childCourseConnection.Contact__c) {
                    if (childCourseConnection.Primary__c == false) {
                        childCourseConnection.Primary__c = true;
                        objectsToUpdate.add(childCourseConnection);
                    }
                    hasExistingCourseConnection = true;
                    continue;
                }

                if (childCourseConnection.Primary__c == false) {
                    continue;
                }

                childCourseConnection.Primary__c = false;
                objectsToUpdate.add(childCourseConnection);

                if (updatedCouserEnrollmentBycourseOfferingId.keySet().contains(updatedCourseOffering.Id) == false) {
                    updatedCouserEnrollmentBycourseOfferingId.put(updatedCourseOffering.Id, childCourseConnection);
                }
            }

            if (hasExistingCourseConnection == true) {
                continue;
            }

            Course_Enrollment__c newCourseConnection = new Course_Enrollment__c(
                Contact__c = updatedCourseOffering.Faculty__c,
                Primary__c = true
            );

            if (
                updatedCouserEnrollmentBycourseOfferingId.keySet().contains(updatedCourseOffering.Id) &&
                updatedCouserEnrollmentBycourseOfferingId.get(updatedCourseOffering.Id) != null
            ) {
                newCourseConnection.Account__c = updatedCouserEnrollmentBycourseOfferingId.get(updatedCourseOffering.Id)
                    .Account__c;
                newCourseConnection.Course_Offering__c = updatedCouserEnrollmentBycourseOfferingId.get(
                        updatedCourseOffering.Id
                    )
                    .Course_Offering__c;
                newCourseConnection.Affiliation__c = updatedCouserEnrollmentBycourseOfferingId.get(
                        updatedCourseOffering.Id
                    )
                    .Affiliation__c;
                if (
                    UTIL_Describe.isValidField(UTIL_Namespace.StrTokenNSPrefix('Course_Enrollment__c'), 'RecordTypeId')
                ) {
                    newCourseConnection.put('RecordTypeId', facultyRecordTypeId);
                }
            }
            objectsToInsert.add(newCourseConnection);
        }
    }

    /*******************************************************************************************************
     * @description Updates or adds a Course Connection for each added to a Course Offering. A Faculty
     * member may already have a Course Connection that may need to be marked primary or may need to be created
     * if a Course Connection for the Faculty member does not exist.
     ********************************************************************************************************/
    @testVisible
    private void updateConnectionsOnFacultyAdd(
        List<Course_Offering__c> courseOfferings,
        List<SObject> objectsToInsert,
        List<SObject> objectsToUpdate
    ) {
        Id facultyRecordTypeId = UTIL_Describe.getFacultyConnectionRecType();

        Set<Id> offIds = (new Map<Id, Course_Offering__c>(courseOfferings)).keySet();

        Map<Id, Map<Id, Course_Enrollment__c>> offeringFacultyConnIds = getOfferingIdFacultyIdConnection(
            offIds,
            facultyRecordTypeId
        );

        for (Course_Offering__c offering : courseOfferings) {
            if (
                offeringFacultyConnIds.containsKey(offering.Id) &&
                offeringFacultyConnIds.get(offering.Id).containsKey(offering.Faculty__c)
            ) {
                Course_Enrollment__c existingConn = offeringFacultyConnIds.get(offering.Id).get(offering.Faculty__c);
                if (!existingConn.Primary__c) {
                    // Current Course Connection exists on Course Offering with Contact, mark as Primary
                    objectsToUpdate.add(new Course_Enrollment__c(Id = existingConn.Id, Primary__c = true));
                }
            } else {
                // No current Course Connection exists on Course Offering with Contact, create a new one
                Course_Enrollment__c conn = new Course_Enrollment__c(
                    Contact__c = offering.Faculty__c,
                    Account__c = offering.Course__r.Account__c,
                    Course_Offering__c = offering.Id,
                    Primary__c = true
                );
                if (
                    UTIL_Describe.isValidField(UTIL_Namespace.StrTokenNSPrefix('Course_Enrollment__c'), 'RecordTypeId')
                ) {
                    conn.put('RecordTypeId', facultyRecordTypeId);
                }
                objectsToInsert.add(conn);
            }
        }
    }

    /*******************************************************************************************************
     * @description Updates each Course Connection as not Primary for all Course Connections tied to Faculty
     * that are no longer the Primary Faculty for the given Course Offerings.
     ********************************************************************************************************/
    @testVisible
    private void updateConnectionsOnFacultyRemove(
        List<ID> removedFacultyIDs,
        Set<Id> offsWithRemovedFaculty,
        List<SObject> objectsToUpdate
    ) {
        List<Course_Enrollment__c> oldConns = [
            SELECT Id, Course_Offering__c, Primary__c
            FROM Course_Enrollment__c
            WHERE Contact__c IN :removedFacultyIDs AND Course_Offering__c IN :offsWithRemovedFaculty
        ];

        for (Course_Enrollment__c conn : oldConns) {
            if (conn.Primary__c && offsWithRemovedFaculty.contains(conn.Course_Offering__c)) {
                conn.Primary__c = false;
                objectsToUpdate.add(conn);
            }
        }
    }

    /*******************************************************************************************************
     * @description Deletes the Affiliations that had been automatically created from the Course Enrollments with
     * assigned Faculty members but only if those Affiliations would no longer have any Course Enrollments
     * linked to them. Also deletes the Course Enrollments themselves.
     ********************************************************************************************************/
    private void deleteAfflsEnrolls(List<ID> removedFacultyIds, Set<Id> offsWithRemovedFaculty, DmlWrapper dmlWrapper) {
        Set<Id> afflIds = new Set<Id>();
        Set<Id> afflsToDeleteIds = new Set<Id>();

        List<Course_Enrollment__c> oldEnrolls = [
            SELECT Id, Affiliation__c
            FROM Course_Enrollment__c
            WHERE Contact__c IN :removedFacultyIds AND Course_Offering__c IN :offsWithRemovedFaculty
        ];

        for (Course_Enrollment__c enroll : oldEnrolls) {
            afflIds.add(enroll.Affiliation__c);
        }

        Map<Id, Affiliation__c> affls = new Map<Id, Affiliation__c>(
            [
                SELECT Id, (SELECT Id FROM Course_Enrollment__r WHERE Course_Offering__c NOT IN :offsWithRemovedFaculty)
                FROM Affiliation__c
                WHERE Id IN :afflIds
            ]
        );

        for (Course_Enrollment__c enroll : oldEnrolls) {
            if (affls.get(enroll.Affiliation__c) != null) {
                if (affls.get(enroll.Affiliation__c).Course_Enrollment__r.size() == 0) {
                    afflsToDeleteIds.add(enroll.Affiliation__c);
                }
            }
        }

        if (afflsToDeleteIds.size() > 0) {
            dmlWrapper.objectsToDelete.addAll(
                (List<SObject>) [SELECT Id FROM Affiliation__c WHERE Id IN :afflsToDeleteIds]
            );
        }
        dmlWrapper.objectsToDelete.addAll((List<SObject>) oldEnrolls);
    }

    /*******************************************************************************************************
     * @description Returns a map with the Contact ID of each faculty member as the key, and all its Affiliations
     * as the values.
     ********************************************************************************************************/
    @testVisible
    private Map<ID, List<Affiliation__c>> getAfflsForContact(List<ID> newFacultyIDs) {
        UTIL_Debug.debug('****Number of newly assigned faculty: ' + newFacultyIDs.size());
        //Find all Affls for all Faculty members in the trigger.
        Map<ID, List<Affiliation__c>> facultyIDtoAffls = new Map<ID, List<Affiliation__c>>();
        List<Affiliation__c> affls = [
            SELECT Id, Account__c, Contact__c
            FROM Affiliation__c
            WHERE Contact__c IN :newFacultyIDs
            ORDER BY Contact__c
        ];
        UTIL_Debug.debug('****Number of affls for existing faculty: ' + affls.size());

        if (affls.size() > 0) {
            //Set initial values, to compare against
            Affiliation__c affl = affls[0];
            ID contactID = affls[0].Contact__c;
            List<Affiliation__c> facultyAffls = new List<Affiliation__c>{ affl };
            facultyIDtoAffls.put(contactID, facultyAffls);

            //Iterate through the rest of the affiliations
            for (Integer i = 1; i < affls.size(); i++) {
                if (affls[i].Contact__c == contactID) {
                    facultyAffls.add(affls[i]);
                } else {
                    contactID = affls[i].Contact__c;
                    facultyAffls = new List<Affiliation__c>();
                    facultyAffls.add(affls[i]);
                    facultyIDtoAffls.put(contactID, facultyAffls);
                }
            }
        }
        return facultyIDtoAffls;
    }

    /*******************************************************************************************************
     * @description Returns a map with Course Offering Id as key and a value as a Map of Contact Id as
     * key with the corresponding Course Connection as value.
     ********************************************************************************************************/
    private Map<Id, Map<Id, Course_Enrollment__c>> getOfferingIdFacultyIdConnection(
        Set<Id> offeringIds,
        Id facultyRecordTypeId
    ) {
        // Map with Course Offering Id as key and a value as a Map of Contact Id as key with the corresponding Course Connection as value
        Map<Id, Map<Id, Course_Enrollment__c>> connToOfferingIdMap = new Map<Id, Map<Id, Course_Enrollment__c>>();
        String queryString = 'SELECT Id, Course_Offering__c, Contact__c, Primary__c FROM Course_Enrollment__c WHERE Course_Offering__c IN :offeringIds';
        if (
            UTIL_Describe.isValidField(UTIL_Namespace.StrTokenNSPrefix('Course_Enrollment__c'), 'RecordTypeId') &&
            facultyRecordTypeId != null
        ) {
            queryString += ' AND RecordTypeId = :facultyRecordTypeId';
        }
        List<Course_Enrollment__c> conns = Database.query(queryString);
        UTIL_Debug.debug('****Number of Faculty Course Connections for Course Offerings: ' + conns.size());

        for (Course_Enrollment__c conn : conns) {
            if (!connToOfferingIdMap.containsKey(conn.Course_Offering__c)) {
                connToOfferingIdMap.put(conn.Course_Offering__c, new Map<Id, Course_Enrollment__c>());
            }
            connToOfferingIdMap.get(conn.Course_Offering__c).put(conn.Contact__c, conn);
        }

        return connToOfferingIdMap;
    }

    /*******************************************************************************************************
     * @description Determines whether an Affiliation to the Account the Course Offering belongs to already
     * exists for each faculty member. Will return null if no Affiliation exists.
     * @return Affiliation__c Affiliation to the Account or null
     ********************************************************************************************************/
    @testVisible
    private Affiliation__c affiliationToAccount(
        Course_Offering__c offering,
        Map<ID, List<Affiliation__c>> facultyIDtoAffls
    ) {
        List<Affiliation__c> facultyMemberAffls = facultyIDtoAffls.get(offering.Faculty__c);
        if (facultyMemberAffls != null && facultyMemberAffls.size() > 0) {
            for (Affiliation__c affl : facultyMemberAffls) {
                if (affl.Account__c == offering.Course__r.Account__c) {
                    return affl;
                }
            }
        }

        return null;
    }
}

/*
    Copyright (c) 2015, Salesforce.org
    All rights reserved.

    Redistribution and use in source and binary forms, with or without
    modification, are permitted provided that the following conditions are met:

    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
    * Neither the name of Salesforce.org nor the names of
      its contributors may be used to endorse or promote products derived
      from this software without specific prior written permission.

    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
    "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
    LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
    FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
    COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
    INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
    BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
    LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
    CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
    LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
    ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
    POSSIBILITY OF SUCH DAMAGE.
*/
/**
 * @author Salesforce.org
 * @date 2015
 * @group Course Offering
 * @group-content ../../ApexDocContent/CourseOfferings.htm
 * @description Tests specific to Course Offering.
 */
@isTest
public with sharing class COFF_Affiliation_TEST {
    private static Account university;
    private static Account dpt;
    private static Course__c course;
    private static Term__c term;
    private static Contact faculty;

    private static void setup() {
        STG_InstallScript.insertMappings();
        // Create university
        university = new Account(Name = 'Advanced University', RecordTypeId = UTIL_Describe.getAcademicAccRecTypeID());
        insert university;

        // Create department
        dpt = new Account(
            Name = 'Biology Department',
            Parent = university,
            RecordTypeId = UTIL_Describe.getDepAccRecTypeID()
        );
        insert dpt;

        //Create Course
        course = new Course__c(
            Course_ID__c = 'Biology 101',
            Account__c = dpt.Id,
            Credit_Hours__c = 40,
            Description__c = 'Intro to Biology'
        );
        insert course;

        //Create Term
        term = new Term__c(
            Account__c = university.Id,
            Start_Date__c = System.today() + 5,
            End_Date__c = System.today() + 90
        );
        insert term;

        //Create faculty member
        faculty = new Contact(FirstName = 'Test', LastName = 'Testerson');
        insert faculty;
    }

    private static void enableCourseConnections() {
        UTIL_CustomSettingsFacade.getSettingsForTests(
            new Hierarchy_Settings__c(
                Enable_Course_Connections__c = true,
                Faculty_RecType__c = UTIL_Describe_API.getFacultyConnectionRecType()
            )
        );
    }

    private static Boolean recordTypesExist() {
        return (UTIL_Describe_API.isValidField(
            UTIL_Namespace.StrTokenNSPrefix('Course_Enrollment__c'),
            'RecordTypeId'
        ) && UTIL_Describe_API.getFacultyConnectionRecType() != null);
    }

    /*********************************************************************************************************
     * @description Verifies that an Affiliation to the Department is automatically created when a Course Offering
     * with a value in the Faculty field is created and that Contact did not already have an Affiliation to that
     * Department.
     */
    @isTest
    public static void newCourseOffering() {
        setup();

        //Create Course Offering with Faculty member
        Course_Offering__c offering = new Course_Offering__c(
            Section_ID__c = 'BIO-101 Spring 16',
            Course__c = course.ID,
            Faculty__c = faculty.Id,
            Term__c = term.Id,
            Capacity__c = 200
        );
        Test.startTest();
        insert offering;
        Test.stopTest();

        //Since no previous Affl to the Dpt existed, an Affl should have been automatically created for the faculty member
        List<Affiliation__c> affls = [
            SELECT Contact__c, Account__c, Role__c, StartDate__c, EndDate__c
            FROM Affiliation__c
            WHERE Contact__r.Id = :faculty.Id AND Role__c = 'Faculty'
        ];
        System.assertEquals(1, affls.size());
        System.assertEquals('Faculty', affls[0].Role__c);
        System.assertEquals(term.Start_Date__c, affls[0].StartDate__c);
        System.assertEquals(term.End_Date__c, affls[0].EndDate__c);

        //A Course Enrollment should have been automatically created
        List<Course_Enrollment__c> enrolls = [
            SELECT Contact__c, Course_Offering__c, Affiliation__c
            FROM Course_Enrollment__c
            WHERE Contact__r.Id = :faculty.Id
        ];
        System.assertEquals(1, enrolls.size());
        //The Course Enrollment should have been linked to the Affiliation that was automatically created
        System.assertEquals(affls[0].ID, enrolls[0].Affiliation__c);

        //If a new Course Offering is created under the same Department and is taught by the same Faculty member, no additional
        //Affiliation should be created.
        Course_Offering__c offering2 = new Course_Offering__c(
            Section_ID__c = 'BIO-101 Summer 16',
            Course__c = course.ID,
            Faculty__c = faculty.Id,
            Term__c = term.Id,
            Capacity__c = 200
        );
        insert offering2;
        affls = [
            SELECT Contact__c, Account__c, Role__c, StartDate__c, EndDate__c
            FROM Affiliation__c
            WHERE Contact__r.Id = :faculty.Id AND Role__c = 'Faculty'
        ];
        System.assertEquals(1, affls.size());
    }

    /*********************************************************************************************************
     * @description Verifies that a single Affiliation to the Department is automatically created when multiple
     * Course Offerings with a value in the Faculty field are created and that Contact did not already have an
     * Affiliation to that Department.
     */
    @isTest
    public static void multipleNewCourseOfferingsWithSameDepartmentAndFaculty() {
        setup();

        //Create Course Offerings with Faculty member
        Course_Offering__c offering = new Course_Offering__c(
            Section_ID__c = 'BIO-101 Spring 16',
            Course__c = course.ID,
            Faculty__c = faculty.Id,
            Term__c = term.Id,
            Capacity__c = 200
        );
        Course_Offering__c offering2 = new Course_Offering__c(
            Section_ID__c = 'BIO-102 Summer 16',
            Course__c = course.ID,
            Faculty__c = faculty.Id,
            Term__c = term.Id,
            Capacity__c = 200
        );

        Test.startTest();
        insert new List<Course_Offering__c>{ offering, offering2 };
        Test.stopTest();

        //Since no previous Affl to the Dpt existed, an Affl should have been automatically created for the faculty member
        List<Affiliation__c> affls = [
            SELECT Contact__c, Account__c, Role__c, StartDate__c, EndDate__c
            FROM Affiliation__c
            WHERE Contact__c = :faculty.Id AND Role__c = 'Faculty'
        ];
        System.assertEquals(1, affls.size());
        System.assertEquals('Faculty', affls[0].Role__c);
        System.assertEquals(term.Start_Date__c, affls[0].StartDate__c);
        System.assertEquals(term.End_Date__c, affls[0].EndDate__c);

        //A Course Enrollment should have been automatically created for each Course Offering
        List<Course_Enrollment__c> enrolls = [
            SELECT Contact__c, Course_Offering__c, Affiliation__c
            FROM Course_Enrollment__c
            WHERE Contact__c = :faculty.Id
        ];
        System.assertEquals(2, enrolls.size());
        //The Course Enrollments should have been linked to the Affiliation that was automatically created
        System.assertEquals(affls[0].ID, enrolls[0].Affiliation__c);
        System.assertEquals(affls[0].ID, enrolls[1].Affiliation__c);
    }

    /*********************************************************************************************************
     * @description Verifies that a single Affiliation to the Department is automatically created when multiple
     * Course Offerings with a value in the Faculty field are updated and that Contact did not already have an
     * Affiliation to that Department.
     */
    @isTest
    public static void addFacultyToMultipleCourseOfferingsNoPrevAffl() {
        setup();

        //Create Course Offerings without Faculty member
        Course_Offering__c offering = new Course_Offering__c(
            Section_ID__c = 'BIO-101 Spring 16',
            Course__c = course.ID,
            Term__c = term.Id,
            Capacity__c = 200
        );
        Course_Offering__c offering2 = new Course_Offering__c(
            Section_ID__c = 'BIO-102 Spring 16',
            Course__c = course.ID,
            Term__c = term.Id,
            Capacity__c = 200
        );
        insert new List<Course_Offering__c>{ offering, offering2 };

        //No affiliation should have been created
        List<Affiliation__c> affls = [SELECT ID FROM Affiliation__c];
        System.assertEquals(0, affls.size());

        //Add faculty to offerings
        offering.Faculty__c = faculty.Id;
        offering2.Faculty__c = faculty.Id;
        Test.startTest();
        TDTM_ProcessControl.setRecursionFlag(TDTM_ProcessControl.registeredTrigger.COFF_Affiliation_TDTM, false);
        update new List<Course_Offering__c>{ offering, offering2 };
        Test.stopTest();

        //An Affiliation should have been automatically created for the faculty member, if no Affiliation to that Department
        //already existed.
        affls = [
            SELECT Contact__c, Account__c, Role__c, StartDate__c, EndDate__c
            FROM Affiliation__c
            WHERE Contact__c = :faculty.Id AND Role__c = 'Faculty'
        ];
        System.assertEquals(1, affls.size());
        System.assertEquals('Faculty', affls[0].Role__c);
        System.assertEquals(term.Start_Date__c, affls[0].StartDate__c);
        System.assertEquals(term.End_Date__c, affls[0].EndDate__c);

        //A Course Enrollment should have been automatically created for each Course Offering
        List<Course_Enrollment__c> enrolls = [
            SELECT Contact__c, Course_Offering__c, Affiliation__c
            FROM Course_Enrollment__c
            WHERE Contact__c = :faculty.Id
        ];
        System.assertEquals(2, enrolls.size());
        //The Course Enrollments should have been linked to the Affiliation that was automatically created
        System.assertEquals(affls[0].ID, enrolls[0].Affiliation__c);
        System.assertEquals(affls[0].ID, enrolls[1].Affiliation__c);
    }

    @isTest
    public static void addFacultyToOfferingPrevAffl() {
        setup();

        //Create affiliation from faculty member to dpt
        Affiliation__c affl = new Affiliation__c(Account__c = dpt.ID, Contact__c = faculty.ID);
        insert affl;

        List<Affiliation__c> affls = [SELECT Id FROM Affiliation__c];
        Integer afflsSize1 = affls.size();

        //Create Course Offering without Faculty member
        Course_Offering__c offering = new Course_Offering__c(
            Section_ID__c = 'BIO-101 Spring 16',
            Course__c = course.ID,
            Term__c = term.Id,
            Capacity__c = 200
        );
        insert offering;

        //No new affiliations should have been created
        affls = [SELECT Id FROM Affiliation__c];
        System.assertEquals(afflsSize1, affls.size());

        //Add faculty to offering
        offering.Faculty__c = faculty.Id;
        Test.startTest();
        TDTM_ProcessControl.setRecursionFlag(TDTM_ProcessControl.registeredTrigger.COFF_Affiliation_TDTM, false);
        update offering;
        Test.stopTest();

        //Still no new affiliations should have been created
        affls = [SELECT Id FROM Affiliation__c];
        System.assertEquals(afflsSize1, affls.size());

        //A Course Enrollment should have been automatically created
        List<Course_Enrollment__c> enrolls = [
            SELECT Contact__c, Course_Offering__c, Affiliation__c
            FROM Course_Enrollment__c
            WHERE Contact__r.Id = :faculty.Id
        ];
        System.assertEquals(1, enrolls.size());
        //The Course Enrollment should be linked to the existing Affiliation that already existed (and wasn't automatically created)
        System.assertEquals(affls[0].Id, enrolls[0].Affiliation__c);
    }

    /*********************************************************************************************************
     * @description Verifies that changing the Faculty on multiple Course Offerings for the same Departmenet does
     * not create duplicate Affiliation records and the existing Affiliation record is updated.
     */
    @isTest
    public static void changeFacultyWithMultipleCourseOfferings() {
        setup();

        //Create Course Offering with Faculty member
        Course_Offering__c offering = new Course_Offering__c(
            Section_ID__c = 'BIO-101 Spring 16',
            Course__c = course.ID,
            Faculty__c = faculty.Id,
            Term__c = term.Id,
            Capacity__c = 200
        );
        Course_Offering__c offering2 = new Course_Offering__c(
            Section_ID__c = 'BIO-102 Spring 16',
            Course__c = course.ID,
            Faculty__c = faculty.Id,
            Term__c = term.Id,
            Capacity__c = 200
        );
        insert new List<Course_Offering__c>{ offering, offering2 };

        //Since no previous Affl to the Dpt existed, an Affl should have been automatically created for the faculty member
        List<Affiliation__c> affls = [
            SELECT Contact__c, Account__c, Role__c, StartDate__c, EndDate__c
            FROM Affiliation__c
            WHERE Contact__c = :faculty.Id AND Role__c = 'Faculty'
        ];
        System.assertEquals(1, affls.size());

        //A Course Enrollment should have been automatically created for each Course Offering
        List<Course_Enrollment__c> enrolls = [
            SELECT Contact__c, Course_Offering__c, Affiliation__c
            FROM Course_Enrollment__c
            WHERE Contact__c = :faculty.Id
        ];
        System.assertEquals(2, enrolls.size());

        //Create second faculty member
        Contact faculty2 = new Contact(FirstName = 'Test', LastName = 'Testerson');
        insert faculty2;

        //Update Offerings & create new course offerings
        offering.Faculty__c = faculty2.Id;
        offering2.Faculty__c = faculty2.Id;
        Test.startTest();
        TDTM_ProcessControl.setRecursionFlag(TDTM_ProcessControl.registeredTrigger.COFF_Affiliation_TDTM, false);
        update new List<Course_Offering__c>{ offering, offering2 };
        Test.stopTest();

        //The affiliation should have been updated to point to the second faculty member
        affls = [
            SELECT Contact__c, Account__c, Role__c, StartDate__c, EndDate__c
            FROM Affiliation__c
            WHERE Contact__c = :faculty2.Id AND Role__c = 'Faculty' AND ID = :affls[0].ID
        ];
        System.assertEquals(1, affls.size());
        System.assertEquals('Faculty', affls[0].Role__c);
        System.assertEquals(term.Start_Date__c, affls[0].StartDate__c);
        System.assertEquals(term.End_Date__c, affls[0].EndDate__c);

        //The Course Enrollments of the old Faculty member should have been deleted
        enrolls = [SELECT ID FROM Course_Enrollment__c WHERE Contact__c = :faculty.Id];
        System.assertEquals(0, enrolls.size());

        //A Course Enrollment should have been automatically created for the new Faculty for each Course Offering
        List<Course_Enrollment__c> newEnrolls = [
            SELECT Contact__c, Course_Offering__c, Affiliation__c
            FROM Course_Enrollment__c
            WHERE Contact__c = :faculty2.Id
        ];
        System.assertEquals(2, newEnrolls.size());
        //The Course Enrollment should have been linked to the Affiliation that was updated
        System.assertEquals(affls[0].ID, newEnrolls[0].Affiliation__c);
        System.assertEquals(affls[0].ID, newEnrolls[1].Affiliation__c);
    }

    @isTest
    public static void changeFacultyWithCourseConnEnabled() {
        if (recordTypesExist()) {
            enableCourseConnections();
            setup();

            //Create Course Offering with Faculty member
            Course_Offering__c offering = new Course_Offering__c(
                Section_ID__c = 'BIO-101 Spring 16',
                Course__c = course.ID,
                Faculty__c = faculty.Id,
                Term__c = term.Id,
                Capacity__c = 200
            );
            insert offering;

            //A Course Enrollment should have been automatically created
            List<Course_Enrollment__c> enrolls = [
                SELECT Contact__c, Course_Offering__c, Affiliation__c
                FROM Course_Enrollment__c
                WHERE Contact__r.Id = :faculty.Id
            ];
            System.assertEquals(1, enrolls.size());

            //Since no previous Affl to the Dpt existed, an Affl should have been automatically created for the faculty member
            List<Affiliation__c> affls = [
                SELECT Contact__c, Account__c, Role__c
                FROM Affiliation__c
                WHERE Contact__c = :faculty.Id AND Role__c = 'Faculty'
            ];
            System.assertEquals(1, affls.size());

            //Create second faculty member
            Contact faculty2 = new Contact(FirstName = 'Test', LastName = 'Testerson');
            insert faculty2;

            //Update Offering
            offering.Faculty__c = faculty2.Id;
            Test.startTest();
            TDTM_ProcessControl.setRecursionFlag(TDTM_ProcessControl.registeredTrigger.COFF_Affiliation_TDTM, false);
            update offering;
            Test.stopTest();

            //A new affiliation should have been created for the new Faculty
            affls = [
                SELECT Contact__c, Account__c, Role__c, (SELECT Id FROM Course_Enrollment__r)
                FROM Affiliation__c
                WHERE Contact__c = :faculty2.Id AND Role__c = 'Faculty'
            ];
            System.assertEquals(1, affls.size());
            System.assertEquals('Faculty', affls[0].Role__c);
            System.assertEquals(1, affls[0].Course_Enrollment__r.size());

            //The Course Enrollment of the old Faculty member should not have been deleted and should not be primary
            enrolls = [SELECT Id, Primary__c FROM Course_Enrollment__c WHERE Contact__r.Id = :faculty.Id];
            System.assertEquals(1, enrolls.size());
            System.assertEquals(false, enrolls[0].Primary__c);

            //A Course Enrollment should have been automatically created for the new Faculty
            List<Course_Enrollment__c> newEnrolls = [
                SELECT Contact__c, Course_Offering__c, Affiliation__c, Primary__c
                FROM Course_Enrollment__c
                WHERE Contact__r.Id = :faculty2.Id
            ];
            System.assertEquals(1, newEnrolls.size());
            System.assertEquals(true, newEnrolls[0].Primary__c);
            //The Course Enrollment should have been linked to the new Affiliation that was automatically created
            System.assertEquals(affls[0].Id, newEnrolls[0].Affiliation__c);
        }
    }

    @isTest
    public static void setFacultyToExistingConnWithCourseConnEnabled() {
        if (recordTypesExist()) {
            enableCourseConnections();
            setup();

            //Create Course Offering with Faculty member
            Course_Offering__c offering = new Course_Offering__c(
                Section_ID__c = 'BIO-101 Spring 16',
                Course__c = course.ID,
                Term__c = term.Id,
                Capacity__c = 200
            );
            insert offering;

            Course_Enrollment__c enroll = new Course_Enrollment__c(
                Contact__c = faculty.Id,
                Account__c = dpt.Id,
                Course_Offering__c = offering.Id,
                Primary__c = false
            );
            enroll.put('RecordTypeId', UTIL_Describe_API.getFacultyConnectionRecType());
            insert enroll;

            //Update Offering
            offering.Faculty__c = faculty.Id;
            Test.startTest();
            TDTM_ProcessControl.setRecursionFlag(TDTM_ProcessControl.registeredTrigger.COFF_Affiliation_TDTM, false);
            update offering;
            Test.stopTest();

            //The Course Enrollment of the Faculty member should not have been created but marked primary
            List<Course_Enrollment__c> enrolls = [
                SELECT Id, Primary__c
                FROM Course_Enrollment__c
                WHERE Contact__r.Id = :faculty.Id
            ];
            System.assertEquals(1, enrolls.size());
            System.assertEquals(true, enrolls[0].Primary__c);
        }
    }

    @isTest
    public static void changeFacultyToExistingConnWithCourseConnEnabled() {
        if (recordTypesExist()) {
            enableCourseConnections();
            setup();

            //Create Course Offering with Faculty member
            Course_Offering__c offering = new Course_Offering__c(
                Section_ID__c = 'BIO-101 Spring 16',
                Course__c = course.ID,
                Faculty__c = faculty.Id,
                Term__c = term.Id,
                Capacity__c = 200
            );
            insert offering;

            //Create second faculty member
            Contact faculty2 = new Contact(FirstName = 'Test', LastName = 'Testerson');
            insert faculty2;

            //Create second Course Enrollment
            Course_Enrollment__c enroll = new Course_Enrollment__c(
                Contact__c = faculty2.Id,
                Account__c = dpt.Id,
                Course_Offering__c = offering.Id,
                Primary__c = false
            );
            enroll.put('RecordTypeId', UTIL_Describe_API.getFacultyConnectionRecType());
            insert enroll;

            //Update Offering
            offering.Faculty__c = faculty2.Id;
            Test.startTest();
            TDTM_ProcessControl.setRecursionFlag(TDTM_ProcessControl.registeredTrigger.COFF_Affiliation_TDTM, false);
            update offering;
            Test.stopTest();

            //The Course Enrollment of the Faculty member should not have been created but marked primary
            List<Course_Enrollment__c> enrolls = [
                SELECT Id, Primary__c
                FROM Course_Enrollment__c
                WHERE Contact__r.Id = :faculty2.Id
            ];
            System.assertEquals(1, enrolls.size());
            System.assertEquals(true, enrolls[0].Primary__c);
        }
    }

    @isTest
    public static void facultyMadeNull() {
        setup();

        //Create Course Offering with Faculty member
        Course_Offering__c offering = new Course_Offering__c(
            Section_ID__c = 'BIO-101 Spring 16',
            Course__c = course.ID,
            Faculty__c = faculty.Id,
            Term__c = term.Id,
            Capacity__c = 200
        );
        insert offering;

        //An Affiliation should have been automatically created for the faculty member
        List<Affiliation__c> affls = [
            SELECT Contact__c, Account__c, Role__c, StartDate__c, EndDate__c
            FROM Affiliation__c
            WHERE Contact__r.Id = :faculty.Id AND Role__c = 'Faculty'
        ];
        System.assertEquals(1, affls.size());

        //A Course Enrollment should have been automatically created
        List<Course_Enrollment__c> enrolls = [
            SELECT Contact__c, Course_Offering__c, Affiliation__c
            FROM Course_Enrollment__c
            WHERE Contact__r.Id = :faculty.Id
        ];
        System.assertEquals(1, enrolls.size());
        //The Course Enrollment should have been linked to the Affiliation that was automatically created
        System.assertEquals(affls[0].ID, enrolls[0].Affiliation__c);

        //Update Offering
        offering.Faculty__c = null;
        Test.startTest();
        TDTM_ProcessControl.setRecursionFlag(TDTM_ProcessControl.registeredTrigger.COFF_Affiliation_TDTM, false);
        update offering;
        Test.stopTest();

        //The affiliation should have been deleted
        affls = [
            SELECT Contact__c, Account__c, Role__c, StartDate__c, EndDate__c
            FROM Affiliation__c
            WHERE ID = :affls[0].ID
        ];
        System.assertEquals(0, affls.size());

        //The Course Enrollment should have been deleted
        enrolls = [SELECT ID FROM Course_Enrollment__c WHERE Contact__r.Id = :faculty.Id];
        System.assertEquals(0, enrolls.size());
    }

    @isTest
    public static void facultyMadeNullWhenOtherEnrollmentsExist() {
        setup();

        // Create first Course Offering with Faculty member
        Course_Offering__c firstOffering = new Course_Offering__c(
            Section_Id__c = 'BIO-101 Spring 16 - 1',
            Course__c = course.Id,
            Faculty__c = faculty.Id,
            Term__c = term.Id,
            Capacity__c = 200
        );
        insert firstOffering;

        TDTM_ProcessControl.setRecursionFlag(TDTM_ProcessControl.registeredTrigger.COFF_Affiliation_TDTM, false);
        //Create second Course Offering with Faculty member
        Course_Offering__c secondOffering = new Course_Offering__c(
            Section_Id__c = 'BIO-101 Spring 16 - 2',
            Course__c = course.Id,
            Faculty__c = faculty.Id,
            Term__c = term.Id,
            Capacity__c = 200
        );
        insert secondOffering;

        //An Affiliation should have been automatically created for the faculty member
        List<Affiliation__c> affls = [
            SELECT Id, (SELECT Id FROM Course_Enrollment__r)
            FROM Affiliation__c
            WHERE Contact__r.Id = :faculty.Id AND Role__c = 'Faculty'
        ];
        System.assertEquals(1, affls.size());

        // The affiliation should have two Course Enrollments
        System.assertEquals(2, affls[0].Course_Enrollment__r.size());

        // Two Course Enrollments should have been automatically created
        List<Course_Enrollment__c> enrolls = [
            SELECT Contact__c, Course_Offering__c, Affiliation__c
            FROM Course_Enrollment__c
            WHERE Contact__r.Id = :faculty.Id
        ];
        System.assertEquals(2, enrolls.size());
        //The Course Enrollments should have been linked to the Affiliation that was automatically created
        System.assertEquals(affls[0].Id, enrolls[0].Affiliation__c);
        System.assertEquals(affls[0].Id, enrolls[1].Affiliation__c);

        // Update first Offering
        firstOffering.Faculty__c = null;
        Test.startTest();
        TDTM_ProcessControl.setRecursionFlag(TDTM_ProcessControl.registeredTrigger.COFF_Affiliation_TDTM, false);
        update firstOffering;
        Test.stopTest();

        // The affiliation should not have been deleted
        affls = [SELECT Id, (SELECT Id FROM Course_Enrollment__r) FROM Affiliation__c WHERE Id = :affls[0].Id];
        System.assertEquals(1, affls.size());

        // The affiliation should have one Course Enrollment
        System.assertEquals(1, affls[0].Course_Enrollment__r.size());

        // One Course Enrollment should have been deleted
        enrolls = [SELECT Id FROM Course_Enrollment__c WHERE Contact__r.Id = :faculty.Id];
        System.assertEquals(1, enrolls.size());
    }

    @isTest
    public static void deleteMultipleCourseOfferingsWithFaculty() {
        setup();

        // Create first Course Offering with Faculty member
        Course_Offering__c firstOffering = new Course_Offering__c(
            Section_Id__c = 'BIO-101 Spring 16 - 1',
            Course__c = course.Id,
            Faculty__c = faculty.Id,
            Term__c = term.Id,
            Capacity__c = 200
        );
        insert firstOffering;

        //Create second Course Offering with Faculty member
        TDTM_ProcessControl.setRecursionFlag(TDTM_ProcessControl.registeredTrigger.COFF_Affiliation_TDTM, false);
        Course_Offering__c secondOffering = new Course_Offering__c(
            Section_Id__c = 'BIO-101 Spring 16 - 2',
            Course__c = course.Id,
            Faculty__c = faculty.Id,
            Term__c = term.Id,
            Capacity__c = 200
        );
        insert secondOffering;

        //An Affiliation should have been automatically created for the faculty member
        List<Affiliation__c> affls = [
            SELECT Id, (SELECT Id FROM Course_Enrollment__r)
            FROM Affiliation__c
            WHERE Contact__r.Id = :faculty.Id AND Role__c = 'Faculty'
        ];
        System.assertEquals(1, affls.size());

        // The affiliation should have two Course Enrollments
        System.assertEquals(2, affls[0].Course_Enrollment__r.size());

        // Two Course Enrollments should have been automatically created
        List<Course_Enrollment__c> enrolls = [
            SELECT Contact__c, Course_Offering__c, Affiliation__c
            FROM Course_Enrollment__c
            WHERE Contact__r.Id = :faculty.Id
        ];
        System.assertEquals(2, enrolls.size());
        //The Course Enrollments should have been linked to the Affiliation that was automatically created
        System.assertEquals(affls[0].Id, enrolls[0].Affiliation__c);
        System.assertEquals(affls[0].Id, enrolls[1].Affiliation__c);

        Test.startTest();
        TDTM_ProcessControl.setRecursionFlag(TDTM_ProcessControl.registeredTrigger.COFF_Affiliation_TDTM, false);
        delete new List<Course_Offering__c>{ firstOffering, secondOffering };
        Test.stopTest();

        // The two Course Enrollments should have been deleted
        enrolls = [
            SELECT Contact__c, Course_Offering__c, Affiliation__c
            FROM Course_Enrollment__c
            WHERE Contact__r.Id = :faculty.Id
        ];
        System.assertEquals(0, enrolls.size());

        // The affiliation should have been deleted
        affls = [SELECT Id, (SELECT Id FROM Course_Enrollment__r) FROM Affiliation__c WHERE Id = :affls[0].Id];
        System.assertEquals(0, affls.size());
    }

    @isTest
    public static void facultyMadeNullWithCourseConnEnabled() {
        if (recordTypesExist()) {
            enableCourseConnections();
            setup();

            //Create Course Offering with Faculty member
            Course_Offering__c offering = new Course_Offering__c(
                Section_ID__c = 'BIO-101 Spring 16',
                Course__c = course.Id,
                Faculty__c = faculty.Id,
                Term__c = term.Id,
                Capacity__c = 200
            );
            insert offering;

            //A Course Enrollment should have been automatically created
            List<Course_Enrollment__c> enrolls = [
                SELECT Contact__c, Course_Offering__c, Primary__c, Affiliation__c
                FROM Course_Enrollment__c
                WHERE Contact__r.Id = :faculty.Id
            ];
            System.assertEquals(1, enrolls.size());
            System.assertEquals(true, enrolls[0].Primary__c);
            //The Course Enrollment should have been linked to the Affiliation that was automatically created

            //An Affiliation should have been automatically created for the faculty member
            List<Affiliation__c> affls = [
                SELECT Contact__c, Account__c, Role__c
                FROM Affiliation__c
                WHERE Contact__c = :faculty.Id AND Role__c = 'Faculty'
            ];
            System.assertEquals(1, affls.size());

            System.assertEquals(affls[0].ID, enrolls[0].Affiliation__c);

            //Update Offering
            offering.Faculty__c = null;
            Test.startTest();
            TDTM_ProcessControl.setRecursionFlag(TDTM_ProcessControl.registeredTrigger.COFF_Affiliation_TDTM, false);
            update offering;
            Test.stopTest();

            //The affiliation should still exist
            affls = [
                SELECT Contact__c, Account__c, Role__c, StartDate__c, EndDate__c
                FROM Affiliation__c
                WHERE Id = :affls[0].Id
            ];
            System.assertEquals(1, affls.size());

            //The Course Enrollment should have been marked as not Primary
            enrolls = [SELECT Id, Primary__c FROM Course_Enrollment__c WHERE Id = :enrolls[0].Id];
            System.assertEquals(false, enrolls[0].Primary__c);
        }
    }

    @isTest
    public static void deleteCourseOffering() {
        setup();

        //Create Course Offering with Faculty member
        Course_Offering__c offering = new Course_Offering__c(
            Section_ID__c = 'BIO-101 Spring 16',
            Course__c = course.Id,
            Faculty__c = faculty.Id,
            Term__c = term.Id,
            Capacity__c = 200
        );
        insert offering;

        //An Affiliation should have been automatically created for the faculty member
        List<Affiliation__c> affls = [
            SELECT Contact__c, Account__c, Role__c, StartDate__c, EndDate__c
            FROM Affiliation__c
            WHERE Contact__r.Id = :faculty.Id AND Role__c = 'Faculty'
        ];
        System.assertEquals(1, affls.size());

        //A Course Enrollment should have been automatically created
        List<Course_Enrollment__c> enrolls = [
            SELECT Contact__c, Course_Offering__c, Affiliation__c
            FROM Course_Enrollment__c
            WHERE Contact__r.Id = :faculty.Id
        ];
        System.assertEquals(1, enrolls.size());
        //The Course Enrollment should have been linked to the Affiliation that was automatically created
        System.assertEquals(affls[0].Id, enrolls[0].Affiliation__c);

        Test.startTest();
        TDTM_ProcessControl.setRecursionFlag(TDTM_ProcessControl.registeredTrigger.COFF_Affiliation_TDTM, false);
        delete offering;
        Test.stopTest();

        //The affiliation should have been deleted
        affls = [
            SELECT Contact__c, Account__c, Role__c, StartDate__c, EndDate__c
            FROM Affiliation__c
            WHERE Id = :affls[0].Id
        ];
        System.assertEquals(0, affls.size());

        //The Course Enrollment should have been deleted
        enrolls = [SELECT Id FROM Course_Enrollment__c WHERE Contact__r.Id = :faculty.Id];
        System.assertEquals(0, enrolls.size());
    }

    @isTest
    public static void testGetAfflsForContact() {
        setup();

        Contact faculty1 = new Contact(FirstName = 'Test', LastName = 'Testerson1');
        Contact faculty2 = new Contact(FirstName = 'Test', LastName = 'Testerson2');
        Contact faculty3 = new Contact(FirstName = 'Test', LastName = 'Testerson3');
        Contact faculty4 = new Contact(FirstName = 'Test', LastName = 'Testerson4');
        insert new List<Contact>{ faculty1, faculty2, faculty3, faculty4 };

        Account dpt1 = new Account(
            Name = 'English Department',
            Parent = university,
            RecordTypeId = UTIL_Describe.getDepAccRecTypeID()
        );
        Account dpt2 = new Account(
            Name = 'CS Department',
            Parent = university,
            RecordTypeId = UTIL_Describe.getDepAccRecTypeID()
        );
        Account dpt3 = new Account(
            Name = 'Math Department',
            Parent = university,
            RecordTypeId = UTIL_Describe.getDepAccRecTypeID()
        );
        Account dpt4 = new Account(
            Name = 'Law Department',
            Parent = university,
            RecordTypeId = UTIL_Describe.getDepAccRecTypeID()
        );
        insert new List<Account>{ dpt1, dpt2, dpt3, dpt4 };

        Affiliation__c aff1 = new Affiliation__c(Contact__c = faculty1.ID, Account__c = dpt1.ID);
        Affiliation__c aff2 = new Affiliation__c(Contact__c = faculty4.ID, Account__c = dpt1.ID);
        Affiliation__c aff3 = new Affiliation__c(Contact__c = faculty2.ID, Account__c = dpt2.ID);
        Affiliation__c aff4 = new Affiliation__c(Contact__c = faculty4.ID, Account__c = dpt3.ID);
        Affiliation__c aff5 = new Affiliation__c(Contact__c = faculty1.ID, Account__c = dpt2.ID);
        Affiliation__c aff6 = new Affiliation__c(Contact__c = faculty3.ID, Account__c = dpt1.ID);
        Affiliation__c aff7 = new Affiliation__c(Contact__c = faculty1.ID, Account__c = dpt4.ID);
        Affiliation__c aff8 = new Affiliation__c(Contact__c = faculty2.ID, Account__c = dpt3.ID);
        insert new List<Affiliation__c>{ aff1, aff2, aff3, aff4, aff5, aff6, aff7, aff8 };

        COFF_Affiliation_TDTM tdtm = new COFF_Affiliation_TDTM();
        Map<ID, List<Affiliation__c>> facultyIDtoAffls = tdtm.getAfflsForContact(
            new List<ID>{ faculty1.ID, faculty2.ID, faculty3.ID, faculty4.ID }
        );

        Set<Affiliation__c> faculty1Affls = new Set<Affiliation__c>(facultyIDtoAffls.get(faculty1.ID));
        Set<Affiliation__c> faculty2Affls = new Set<Affiliation__c>(facultyIDtoAffls.get(faculty2.ID));
        Set<Affiliation__c> faculty3Affls = new Set<Affiliation__c>(facultyIDtoAffls.get(faculty3.ID));
        Set<Affiliation__c> faculty4Affls = new Set<Affiliation__c>(facultyIDtoAffls.get(faculty4.ID));
        System.assertEquals(true, faculty1Affls.contains(aff1));
        System.assertEquals(true, faculty1Affls.contains(aff5));
        System.assertEquals(true, faculty1Affls.contains(aff7));
        System.assertEquals(true, faculty2Affls.contains(aff3));
        System.assertEquals(true, faculty2Affls.contains(aff8));
        System.assertEquals(true, faculty3Affls.contains(aff6));
        System.assertEquals(true, faculty4Affls.contains(aff2));
        System.assertEquals(true, faculty4Affls.contains(aff4));
    }

    @isTest
    public static void testAfflToDptExists() {
        setup();

        //dpt is the parent Account of course
        insert new Affiliation__c(Contact__c = faculty.ID, Account__c = dpt.ID);

        //Create Course Offering with Faculty member
        Course_Offering__c offering = new Course_Offering__c(
            Section_ID__c = 'BIO-101 Spring 16',
            Course__c = course.ID,
            Faculty__c = faculty.Id,
            Term__c = term.Id,
            Capacity__c = 200
        );
        insert offering;

        //An Affiliation from the faculty member to the Department should already exist
        offering = [SELECT Faculty__c, Course__r.Account__c FROM Course_Offering__c WHERE ID = :offering.ID];
        COFF_Affiliation_TDTM tdtm = new COFF_Affiliation_TDTM();
        Map<ID, List<Affiliation__c>> facultyIDtoAffls = tdtm.getAfflsForContact(new List<ID>{ faculty.ID });
        Affiliation__c afflToDpt = tdtm.affiliationToAccount(offering, facultyIDtoAffls);
        System.assertNotEquals(null, afflToDpt.Id);
    }

    @isTest
    public static void newCourseOfferingNoDates() {
        setup();

        //Create Course Offering
        Course_Offering__c offering = new Course_Offering__c(
            Section_ID__c = 'BIO-101 Spring 16',
            Course__c = course.ID,
            Faculty__c = faculty.Id,
            Term__c = term.Id,
            Capacity__c = 200
        );
        Test.startTest();
        insert offering;
        Test.stopTest();

        //Since no dates were entered for the Course Offering, the dates from the parent term should have been copied
        offering = [SELECT Start_Date__c, End_Date__c FROM Course_Offering__c WHERE ID = :offering.ID];
        System.assertEquals(System.today() + 5, offering.Start_Date__c);
        System.assertEquals(System.today() + 90, offering.End_Date__c);
    }

    @isTest
    public static void newCourseOfferingWithDates() {
        setup();

        //Create Course Offering
        Course_Offering__c offering = new Course_Offering__c(
            Section_ID__c = 'BIO-101 Spring 16',
            Course__c = course.ID,
            Faculty__c = faculty.Id,
            Term__c = term.Id,
            Capacity__c = 200,
            Start_Date__c = System.today() + 10,
            End_Date__c = System.today() + 100
        );
        Test.startTest();
        insert offering;
        Test.stopTest();

        //The dates entered when creating the Course Offering should not have been overridden
        offering = [SELECT Start_Date__c, End_Date__c FROM Course_Offering__c WHERE ID = :offering.ID];
        System.assertEquals(System.today() + 10, offering.Start_Date__c);
        System.assertEquals(System.today() + 100, offering.End_Date__c);
    }

    @isTest
    public static void testUpdateConnectionsOnFacultyChangeUpdateExisting() {
        setup();
        enableCourseConnections();

        Boolean courseConnectionsHasRecordTypeIdField = UTIL_Describe_API.isValidField(
            UTIL_Namespace.StrTokenNSPrefix('Course_Enrollment__c'),
            'RecordTypeId'
        );

        TDTM_ProcessControl.setRecursionFlag(TDTM_ProcessControl.registeredTrigger.COFF_Affiliation_TDTM, true);

        //Create Course Offering with Faculty member
        Course_Offering__c offering = new Course_Offering__c(
            Section_ID__c = 'BIO-101 Spring 16',
            Course__c = course.ID,
            Faculty__c = faculty.Id,
            Term__c = term.Id,
            Capacity__c = 200
        );
        insert offering;

        //Create Primary Course Connection for the Faculty member
        Course_Enrollment__c conn = new Course_Enrollment__c(
            Contact__c = faculty.Id,
            Course_Offering__c = offering.Id,
            Primary__c = true
        );
        if (UTIL_Describe_API.isValidField(UTIL_Namespace.StrTokenNSPrefix('Course_Enrollment__c'), 'RecordTypeId')) {
            conn.put('RecordTypeId', UTIL_Describe_API.getFacultyConnectionRecType());
        }
        insert conn;

        Contact faculty2 = new Contact(FirstName = 'Test', LastName = 'Testerson2');
        insert faculty2;

        //Create Non-Primary Course Connection for the Faculty member
        Course_Enrollment__c conn2 = new Course_Enrollment__c(
            Contact__c = faculty2.Id,
            Course_Offering__c = offering.Id
        );
        if (UTIL_Describe_API.isValidField(UTIL_Namespace.StrTokenNSPrefix('Course_Enrollment__c'), 'RecordTypeId')) {
            conn2.put('RecordTypeId', UTIL_Describe_API.getFacultyConnectionRecType());
        }
        insert conn2;

        Test.startTest();
        offering.Faculty__c = faculty2.Id;
        update offering;
        Test.stopTest();

        List<Course_Enrollment__c> courseConnections = [SELECT Id, Primary__c, Contact__c FROM Course_Enrollment__c];

        System.assertEquals(2, courseConnections.size());

        for (Course_Enrollment__c courseConnection : courseConnections) {
            if (!courseConnectionsHasRecordTypeIdField) {
                System.assertEquals(false, courseConnection.Primary__c);
            } else if (courseConnection.Contact__c == faculty.Id) {
                System.assertEquals(false, courseConnection.Primary__c);
            } else {
                System.assertEquals(true, courseConnection.Primary__c);
            }
        }
    }

    @isTest
    public static void testUpdateConnectionsOnFacultyChangeInsertNew() {
        setup();
        enableCourseConnections();

        Boolean courseConnectionsHasRecordTypeIdField = UTIL_Describe_API.isValidField(
            UTIL_Namespace.StrTokenNSPrefix('Course_Enrollment__c'),
            'RecordTypeId'
        );

        TDTM_ProcessControl.setRecursionFlag(TDTM_ProcessControl.registeredTrigger.COFF_Affiliation_TDTM, true);

        //Create Course Offering with Faculty member
        Course_Offering__c offering = new Course_Offering__c(
            Section_ID__c = 'BIO-101 Spring 16',
            Course__c = course.ID,
            Faculty__c = faculty.Id,
            Term__c = term.Id,
            Capacity__c = 200
        );
        insert offering;

        //Create Primary Course Connection for the Faculty member
        Course_Enrollment__c conn = new Course_Enrollment__c(
            Contact__c = faculty.Id,
            Course_Offering__c = offering.Id,
            Primary__c = true
        );

        if (courseConnectionsHasRecordTypeIdField) {
            conn.put('RecordTypeId', UTIL_Describe_API.getFacultyConnectionRecType());
        }
        insert conn;

        Contact faculty2 = new Contact(FirstName = 'Test', LastName = 'Testerson2');
        insert faculty2;

        Test.startTest();
        offering.Faculty__c = faculty2.Id;
        update offering;
        Test.stopTest();

        List<Course_Enrollment__c> courseConnections = [SELECT Id, Primary__c, Contact__c FROM Course_Enrollment__c];

        //This is necessary to account for record type existence as the test changes behavior based on the existence of a record type id field
        if (courseConnectionsHasRecordTypeIdField) {
            System.assertEquals(2, courseConnections.size());
        } else {
            System.assertEquals(1, courseConnections.size());
        }

        for (Course_Enrollment__c courseConnection : courseConnections) {
            if (!courseConnectionsHasRecordTypeIdField) {
                System.assertEquals(false, courseConnection.Primary__c);
            } else if (courseConnection.Contact__c == faculty.Id) {
                System.assertEquals(false, courseConnection.Primary__c);
            } else {
                System.assertEquals(true, courseConnection.Primary__c);
            }
        }
    }

    @isTest
    public static void testUpdateConnectionsOnFacultyRemove() {
        setup();

        TDTM_ProcessControl.setRecursionFlag(TDTM_ProcessControl.registeredTrigger.COFF_Affiliation_TDTM, true);

        //Create Course Offering with Faculty member
        Course_Offering__c offering = new Course_Offering__c(
            Section_ID__c = 'BIO-101 Spring 16',
            Course__c = course.ID,
            Faculty__c = faculty.Id,
            Term__c = term.Id,
            Capacity__c = 200
        );
        insert offering;

        //Create Primary Course Connection for the Faculty member
        Course_Enrollment__c conn = new Course_Enrollment__c(
            Contact__c = faculty.Id,
            Course_Offering__c = offering.Id,
            Primary__c = true
        );
        if (UTIL_Describe_API.isValidField(UTIL_Namespace.StrTokenNSPrefix('Course_Enrollment__c'), 'RecordTypeId')) {
            conn.put('RecordTypeId', UTIL_Describe_API.getFacultyConnectionRecType());
        }
        insert conn;

        List<Id> removedFacultyIds = new List<Id>{ faculty.Id };
        Set<Id> offsWithRemovedFaculty = new Set<Id>{ offering.Id };

        List<SObject> objectsToUpdate = new List<SObject>();

        COFF_Affiliation_TDTM cls = new COFF_Affiliation_TDTM();

        Test.startTest();
        cls.updateConnectionsOnFacultyRemove(removedFacultyIds, offsWithRemovedFaculty, objectsToUpdate);
        Test.stopTest();

        System.assertEquals(1, objectsToUpdate.size());
        System.assertEquals(objectsToUpdate[0].get('Primary__c'), false);
    }

    @isTest
    public static void testUpdateConnectionsOnFacultyAddInsertNew() {
        setup();

        TDTM_ProcessControl.setRecursionFlag(TDTM_ProcessControl.registeredTrigger.COFF_Affiliation_TDTM, true);

        //Create Course Offering with Faculty member
        Course_Offering__c offering = new Course_Offering__c(
            Section_ID__c = 'BIO-101 Spring 16',
            Course__c = course.ID,
            Faculty__c = faculty.Id,
            Term__c = term.Id,
            Capacity__c = 200
        );
        insert offering;

        List<Course_Offering__c> offerings = new List<Course_Offering__c>{ offering };

        List<SObject> objectsToInsert = new List<SObject>();
        List<SObject> objectsToUpdate = new List<SObject>();

        COFF_Affiliation_TDTM cls = new COFF_Affiliation_TDTM();

        Test.startTest();
        TDTM_ProcessControl.setRecursionFlag(TDTM_ProcessControl.registeredTrigger.COFF_Affiliation_TDTM, false);
        cls.updateConnectionsOnFacultyAdd(offerings, objectsToInsert, objectsToUpdate);
        Test.stopTest();

        System.assertEquals(0, objectsToUpdate.size());
        System.assertEquals(1, objectsToInsert.size());
        System.assertEquals(objectsToInsert[0].get('Primary__c'), true);
    }

    @isTest
    public static void testUpdateConnectionsOnFacultyAddUpdateExisting() {
        setup();

        TDTM_ProcessControl.setRecursionFlag(TDTM_ProcessControl.registeredTrigger.COFF_Affiliation_TDTM, true);

        //Create Course Offering with Faculty member
        Course_Offering__c offering = new Course_Offering__c(
            Section_ID__c = 'BIO-101 Spring 16',
            Course__c = course.ID,
            Faculty__c = faculty.Id,
            Term__c = term.Id,
            Capacity__c = 200
        );
        insert offering;

        Course_Enrollment__c conn = new Course_Enrollment__c(Contact__c = faculty.Id, Course_Offering__c = offering.Id);
        if (UTIL_Describe_API.isValidField(UTIL_Namespace.StrTokenNSPrefix('Course_Enrollment__c'), 'RecordTypeId')) {
            conn.put('RecordTypeId', UTIL_Describe_API.getFacultyConnectionRecType());
        }
        insert conn;

        List<Course_Offering__c> offerings = new List<Course_Offering__c>{ offering };

        List<SObject> objectsToInsert = new List<SObject>();
        List<SObject> objectsToUpdate = new List<SObject>();

        COFF_Affiliation_TDTM cls = new COFF_Affiliation_TDTM();

        Test.startTest();
        cls.updateConnectionsOnFacultyAdd(offerings, objectsToInsert, objectsToUpdate);
        Test.stopTest();

        System.assertEquals(1, objectsToUpdate.size());
        System.assertEquals(0, objectsToInsert.size());
        System.assertEquals(objectsToUpdate[0].get('Primary__c'), true);
    }

    @isTest
    public static void testUpdateMultipleConnectionsOnFacultyAddUpdateExisting() {
        setup();

        //Create Course Offerings with same Faculty member
        List<Course_Offering__c> offerings = new List<Course_Offering__c>();
        Course_Offering__c offering = new Course_Offering__c(
            Section_ID__c = 'BIO-101 Spring 16',
            Course__c = course.ID,
            Faculty__c = faculty.Id,
            Term__c = term.Id,
            Capacity__c = 200
        );
        Course_Offering__c offering2 = new Course_Offering__c(
            Section_ID__c = 'BIO-101 Spring 16',
            Course__c = course.ID,
            Faculty__c = faculty.Id,
            Term__c = term.Id,
            Capacity__c = 200
        );
        offerings.add(offering);
        offerings.add(offering2);
        insert offerings;

        Contact newFaculty = new Contact(FirstName = 'Test2', LastName = 'Test2');
        insert newFaculty;

        Course_Enrollment__c conn = [
            SELECT Id, Contact__c
            FROM Course_Enrollment__c
            WHERE Course_Offering__c = :offering2.Id
            LIMIT 1
        ];

        Test.startTest();
        offering2.Faculty__c = newFaculty.Id;
        TDTM_ProcessControl.setRecursionFlag(TDTM_ProcessControl.registeredTrigger.COFF_Affiliation_TDTM, false);
        update offering2;
        Test.stopTest();

        //assert
        List<Course_Enrollment__c> resultConns = [
            SELECT Id, Contact__c
            FROM Course_Enrollment__c
            WHERE Course_Offering__c = :offering2.Id
        ];
        //course offering still has only one course connection
        system.assertEquals(1, resultConns.size());
        //the faculty of course offering is changed to new faculty
        system.assertEquals(newFaculty.Id, resultConns[0].Contact__c);
        //course offering has a different course connection
        system.assertNotEquals(conn.Id, resultConns[0].Id);
    }

    @isTest
    public static void testUpdateCourseOfferingWithPrimaryFacultyIfAfflMissing() {
        setup();

        //Create Course Offerings with same Faculty member
        List<Course_Offering__c> offerings = new List<Course_Offering__c>();
        Course_Offering__c offering = new Course_Offering__c(
            Section_ID__c = 'BIO-101 Spring 16',
            Course__c = course.ID,
            Faculty__c = faculty.Id,
            Term__c = term.Id,
            Capacity__c = 200
        );
        offerings.add(offering);
        insert offerings;

        Contact newFaculty = UTIL_UnitTestData_TEST.getContact();
        insert newFaculty;

        Affiliation__c oldAffl = [SELECT Id FROM Affiliation__c WHERE Contact__c = :faculty.Id];
        delete oldAffl;

        Test.startTest();
        offering.Faculty__c = newFaculty.Id;
        TDTM_ProcessControl.setRecursionFlag(TDTM_ProcessControl.registeredTrigger.COFF_Affiliation_TDTM, false);
        update offering;
        Test.stopTest();

        //assert
        List<Affiliation__c> affls = [SELECT Contact__c FROM Affiliation__c];
        //There should be only one affliation
        system.assertEquals(1, affls.size());
        //The contact of affiliation should be new faculty
        system.assertEquals(newFaculty.Id, affls[0].Contact__c);
    }
}
/*
    Copyright (c) 2020, Salesforce.org
    All rights reserved.

    Redistribution and use in source and binary forms, with or without
    modification, are permitted provided that the following conditions are met:

    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
    * Neither the name of Salesforce.org nor the names of
      its contributors may be used to endorse or promote products derived
      from this software without specific prior written permission.

    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
    "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
    LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
    FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
    COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
    INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
    BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
    LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
    CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
    LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
    ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
    POSSIBILITY OF SUCH DAMAGE.
*/
/**
 * @author Salesforce.org
 * @date 2020
 * @group Course Offering
 * @group-content ../../ApexDocContent/CourseOfferings.htm
 * @description Tests for COFF_CannotDelete_TDTM.
 */
@isTest
private with sharing class COFF_CannotDelete_TEST {
    /*********************************************************************************************************
     * @description Test method to test the following:
     * (1) If Prevent_Course_Offering_Deletion__c is enabled in Hierarchy Settings, and a Course Offering
     * has child records, it cannot be deleted.
     * (2) If Prevent_Course_Offering_Deletion__c is enabled in Hierarchy Settings, and a Course Offering
     * does not have any child records, it can be deleted.
     */
    @isTest
    private static void testPreventCourseOfferingDeletion() {
        UTIL_CustomSettingsFacade.getSettingsForTests(
            new Hierarchy_Settings__c(
                Account_Processor__c = UTIL_Describe.getHhAccRecTypeID(),
                Prevent_Course_Offering_Deletion__c = true
            )
        );

        Contact[] contacts = UTIL_UnitTestData_TEST.getMultipleTestContacts(6);
        insert contacts;

        List<Course_Offering__c> courseOfferings = new List<Course_Offering__c>();
        Course_Offering__c courseOffering1 = UTIL_UnitTestData_TEST.createCourseOffering(null, null);
        Course_Offering__c courseOffering2 = UTIL_UnitTestdata_TEST.createCourseOffering(null, null);
        Course_Offering__c courseOffering3 = UTIL_UnitTestdata_TEST.createCourseOffering(null, null);
        Course_Offering__c courseOffering4 = UTIL_UnitTestdata_TEST.createCourseOffering(null, null);
        Course_Offering__c courseOffering5 = UTIL_UnitTestdata_TEST.createCourseOffering(null, null);
        Course_Offering__c courseOffering6 = UTIL_UnitTestdata_TEST.createCourseOffering(null, null);
        Course_Offering__c courseOffering7 = UTIL_UnitTestdata_TEST.createCourseOffering(null, null);
        courseOfferings.add(courseOffering1);
        courseOfferings.add(courseOffering2);
        courseOfferings.add(courseOffering3);
        courseOfferings.add(courseOffering4);
        courseOfferings.add(courseOffering5);
        courseOfferings.add(courseOffering6);
        courseOfferings.add(courseOffering7);

        List<Course_Enrollment__c> courseConnections = new List<Course_Enrollment__c>();
        Course_Enrollment__c courseConnection1 = UTIL_UnitTestdata_TEST.getCourseConnection(
            contacts[0].Id,
            courseOfferings[0].Id
        );
        Course_Enrollment__c courseConnection2 = UTIL_UnitTestdata_TEST.getCourseConnection(
            contacts[1].Id,
            courseOfferings[1].Id
        );
        Course_Enrollment__c courseConnection3 = UTIL_UnitTestdata_TEST.getCourseConnection(
            contacts[3].Id,
            courseOfferings[3].Id
        );
        courseConnections.add(courseConnection1);
        courseConnections.add(courseConnection2);
        courseConnections.add(courseConnection3);
        insert courseConnections;

        List<Course_Offering_Schedule__c> courseOfferingSchedules = new List<Course_Offering_Schedule__c>();
        Course_Offering_Schedule__c courseOfferingSchedule1 = UTIL_UnitTestdata_TEST.createCourseOfferingSchedule(
            courseOfferings[0].Id
        );
        Course_Offering_Schedule__c courseOfferingSchedule2 = UTIL_UnitTestdata_TEST.createCourseOfferingSchedule(
            courseOfferings[1].Id
        );
        Course_Offering_Schedule__c courseOfferingSchedule3 = UTIL_UnitTestdata_TEST.createCourseOfferingSchedule(
            courseOfferings[2].Id
        );
        Course_Offering_Schedule__c courseOfferingSchedule4 = UTIL_UnitTestdata_TEST.createCourseOfferingSchedule(
            courseOfferings[5].Id
        );
        courseOfferingSchedules.add(courseOfferingSchedule1);
        courseOfferingSchedules.add(courseOfferingSchedule2);
        courseOfferingSchedules.add(courseOfferingSchedule3);
        courseOfferingSchedules.add(courseOfferingSchedule4);
        insert courseOfferingSchedules;

        List<Term_Grade__c> termGrades = new List<Term_Grade__c>();
        Term_Grade__c termGrade1 = UTIL_UnitTestData_TEST.getTermGrade(null, null, courseConnections[0].Id);
        Term_Grade__c termGrade2 = UTIL_UnitTestData_TEST.getTermGrade(null, null, courseConnections[1].Id);
        Term_Grade__c termGrade3 = UTIL_UnitTestData_TEST.getTermGrade(null, null, courseConnections[2].Id);
        termGrades.add(termGrade1);
        termGrades.add(termGrade2);
        termGrades.add(termGrade3);
        insert termGrades;

        Test.startTest();
        Database.DeleteResult[] results = Database.delete(courseOfferings, false);
        Test.stopTest();

        //Verifies only 1 Course Offering was deleted
        List<Course_Offering__c> returnCourseOfferings = [
            SELECT Id
            FROM Course_Offering__c
            WHERE Id IN :courseOfferings
        ];
        System.assertEquals(5, returnCourseOfferings.size());

        //Verifies Course Offering with Course Connection was not deleted
        System.assertEquals(false, results[3].success);
        System.assertEquals(Label.CannotDelete, results[3].errors[0].message);

        //Verifies Course Offering with Course Offering Schedule was not deleted
        System.assertEquals(false, results[5].success);
        System.assertEquals(Label.CannotDelete, results[5].errors[0].message);

        //Verifies Course Offering with Term Grade and Course Connection was not deleted
        System.assertEquals(false, results[0].success);
        System.assertEquals(Label.CannotDelete, results[0].errors[0].message);

        //Verifies Course Offering with Term Grade and Course Offering Schedule was not deleted
        System.assertEquals(false, results[2].success);
        System.assertEquals(Label.CannotDelete, results[2].errors[0].message);

        //Verifies Course Offering with Term Grade, Course Connection, and Course Offering Schedule was not deleted
        System.assertEquals(false, results[1].success);
        System.assertEquals(Label.CannotDelete, results[1].errors[0].message);
    }

    /*********************************************************************************************************
     * @description Test method to test the following:
     * (1) If Prevent_Course_Offering_Deletion__c is disabled in Hierarchy Settings, and a Course Offering
     * has child records, it can be deleted.
     * (2) If Prevent_Course_Offering_Deletion__c is disabled in Hierarchy Settings, and a Course Offering
     * does not have any child records, it can be deleted.
     */
    @isTest
    private static void testAllowCourseOfferingDeletion() {
        UTIL_CustomSettingsFacade.getSettingsForTests(
            new Hierarchy_Settings__c(
                Account_Processor__c = UTIL_Describe.getHhAccRecTypeID(),
                Prevent_Course_Offering_Deletion__c = false
            )
        );

        Contact[] contacts = UTIL_UnitTestData_TEST.getMultipleTestContacts(6);
        insert contacts;

        List<Course_Offering__c> courseOfferings = new List<Course_Offering__c>();
        Course_Offering__c courseOffering1 = UTIL_UnitTestData_TEST.createCourseOffering(null, null);
        Course_Offering__c courseOffering2 = UTIL_UnitTestdata_TEST.createCourseOffering(null, null);
        Course_Offering__c courseOffering3 = UTIL_UnitTestdata_TEST.createCourseOffering(null, null);
        Course_Offering__c courseOffering4 = UTIL_UnitTestdata_TEST.createCourseOffering(null, null);
        Course_Offering__c courseOffering5 = UTIL_UnitTestdata_TEST.createCourseOffering(null, null);
        Course_Offering__c courseOffering6 = UTIL_UnitTestdata_TEST.createCourseOffering(null, null);
        Course_Offering__c courseOffering7 = UTIL_UnitTestdata_TEST.createCourseOffering(null, null);
        courseOfferings.add(courseOffering1);
        courseOfferings.add(courseOffering2);
        courseOfferings.add(courseOffering3);
        courseOfferings.add(courseOffering4);
        courseOfferings.add(courseOffering5);
        courseOfferings.add(courseOffering6);
        courseOfferings.add(courseOffering7);

        List<Course_Enrollment__c> courseConnections = new List<Course_Enrollment__c>();
        Course_Enrollment__c courseConnection1 = UTIL_UnitTestdata_TEST.getCourseConnection(
            contacts[0].Id,
            courseOfferings[0].Id
        );
        Course_Enrollment__c courseConnection2 = UTIL_UnitTestdata_TEST.getCourseConnection(
            contacts[1].Id,
            courseOfferings[1].Id
        );
        Course_Enrollment__c courseConnection3 = UTIL_UnitTestdata_TEST.getCourseConnection(
            contacts[3].Id,
            courseOfferings[3].Id
        );
        courseConnections.add(courseConnection1);
        courseConnections.add(courseConnection2);
        courseConnections.add(courseConnection3);
        insert courseConnections;

        List<Course_Offering_Schedule__c> courseOfferingSchedules = new List<Course_Offering_Schedule__c>();
        Course_Offering_Schedule__c courseOfferingSchedule1 = UTIL_UnitTestdata_TEST.createCourseOfferingSchedule(
            courseOfferings[0].Id
        );
        Course_Offering_Schedule__c courseOfferingSchedule2 = UTIL_UnitTestdata_TEST.createCourseOfferingSchedule(
            courseOfferings[1].Id
        );
        Course_Offering_Schedule__c courseOfferingSchedule3 = UTIL_UnitTestdata_TEST.createCourseOfferingSchedule(
            courseOfferings[2].Id
        );
        Course_Offering_Schedule__c courseOfferingSchedule4 = UTIL_UnitTestdata_TEST.createCourseOfferingSchedule(
            courseOfferings[5].Id
        );
        courseOfferingSchedules.add(courseOfferingSchedule1);
        courseOfferingSchedules.add(courseOfferingSchedule2);
        courseOfferingSchedules.add(courseOfferingSchedule3);
        courseOfferingSchedules.add(courseOfferingSchedule4);
        insert courseOfferingSchedules;

        List<Term_Grade__c> termGrades = new List<Term_Grade__c>();
        Term_Grade__c termGrade1 = UTIL_UnitTestData_TEST.getTermGrade(null, null, courseConnections[0].Id);
        Term_Grade__c termGrade2 = UTIL_UnitTestData_TEST.getTermGrade(null, null, courseConnections[1].Id);
        Term_Grade__c termGrade3 = UTIL_UnitTestData_TEST.getTermGrade(null, null, courseConnections[2].Id);
        termGrades.add(termGrade1);
        termGrades.add(termGrade2);
        termGrades.add(termGrade3);
        insert termGrades;

        Test.startTest();
        Database.DeleteResult[] results = Database.delete(courseOfferings, false);
        Test.stopTest();

        //Verifies all Course Offerings were deleted
        List<Course_Offering__c> returnCourseOfferings = [
            SELECT Id
            FROM Course_Offering__c
            WHERE Id IN :courseOfferings
        ];
        System.assertEquals(0, returnCourseOfferings.size());
    }
}

/*
    Copyright (c) 2016, Salesforce.org
    All rights reserved.

    Redistribution and use in source and binary forms, with or without
    modification, are permitted provided that the following conditions are met:

    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
    * Neither the name of Salesforce.org nor the names of
      its contributors may be used to endorse or promote products derived
      from this software without specific prior written permission.

    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
    "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
    LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
    FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
    COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
    INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
    BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
    LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
    CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
    LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
    ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
    POSSIBILITY OF SUCH DAMAGE.
*/
/**
 * @author Salesforce.org
 * @date 2016
 * @group Contacts
 * @group-content ../../ApexDocContent/Contacts.htm
 * @description Tests for CON_CannotDelete_TDTM.
 */
@isTest
private with sharing class CON_CannotDelete_TEST {
    /**************************************************************************************************************************
     ****************************************************** FUNCTIONAL TESTS ***************************************************
     **************************************************************************************************************************/

    /*********************************************************************************************************
     * @description Test method to test if Prevent_Contact_Deletion__c is enabled in Hierarchy Settings, and
     * Contact has an Address record associated to it, that it cannot be deleted.
     */
    @isTest
    private static void conCannotDeleteWithAddress() {
        UTIL_CustomSettingsFacade.getSettingsForTests(
            new Hierarchy_Settings__c(
                Account_Processor__c = UTIL_Describe.getHhAccRecTypeID(),
                Prevent_Contact_Deletion__c = true
            )
        );

        UTIL_UnitTestData_TEST.ContactsWithAddrs consAccsAddrs = UTIL_UnitTestData_TEST.createTestContactsAddrs(2);

        List<Contact> returnNewContacts = consAccsAddrs.contacts;

        List<Contact> queryContacts = [SELECT Id FROM Contact WHERE Id IN :returnNewContacts];

        Test.startTest();
        List<Database.DeleteResult> results = Database.delete(queryContacts, false);
        Test.stopTest();

        List<Contact> returnContacts = [SELECT Id FROM Contact WHERE Id IN :queryContacts];

        //Verify that none of the Contact records were deleted
        System.assertEquals(2, returnContacts.size());
        System.assertEquals(Label.CannotDelete, results[0].errors[0].message);
    }

    /*********************************************************************************************************
     * @description Test method to test if Prevent_Contact_Deletion__c is enabled in Hierarchy Settings, and
     * Contact has an Affiliation record associated to it, that it cannot be deleted.
     */
    @isTest
    private static void conCannotDeleteWithAffiliation() {
        UTIL_CustomSettingsFacade.getSettingsForTests(
            new Hierarchy_Settings__c(
                Account_Processor__c = UTIL_Describe.getHhAccRecTypeID(),
                Prevent_Contact_Deletion__c = true
            )
        );

        Account acc = UTIL_UnitTestData_TEST.getMultipleTestAccounts(1, UTIL_Describe_API.getBizAccRecTypeID())[0];
        insert acc;

        List<Contact> contacts = UTIL_UnitTestData_TEST.getMultipleTestContacts(2);
        insert contacts;

        Affiliation__c affiliation1 = UTIL_UnitTestData_TEST.getAffiliation(contacts[0].Id, acc.Id, false);
        Affiliation__c affiliation2 = UTIL_UnitTestData_TEST.getAffiliation(contacts[1].Id, acc.Id, false);

        insert new List<Affiliation__c>{ affiliation1, affiliation2 };

        Test.startTest();
        List<Database.DeleteResult> results = Database.delete(contacts, false);
        Test.stopTest();

        List<Contact> returnedContactsList = [SELECT Id FROM Contact WHERE Id IN :contacts];

        //Verify that none of the Contact records were deleted
        System.assertEquals(2, returnedContactsList.size());
        System.assertEquals(Label.CannotDelete, results[0].errors[0].message);
    }

    /*********************************************************************************************************
     * @description Test method to test if Prevent_Contact_Deletion__c is enabled in Hierarchy Settings, and
     * Contact has an Applicant Application record associated to it, that it cannot be deleted.
     */
    @isTest
    private static void conCannotDeleteWithApplicant() {
        UTIL_CustomSettingsFacade.getSettingsForTests(
            new Hierarchy_Settings__c(
                Account_Processor__c = UTIL_Describe.getHhAccRecTypeID(),
                Prevent_Contact_Deletion__c = true
            )
        );

        Account acc = UTIL_UnitTestData_TEST.getMultipleTestAccounts(1, UTIL_Describe_API.getBizAccRecTypeID())[0];
        insert acc;

        List<Contact> contacts = UTIL_UnitTestData_TEST.getMultipleTestContacts(2);
        insert contacts;

        Term__c term = UTIL_UnitTestData_TEST.getTerm(acc.Id, 'Spring 2020');

        Application__c application1 = UTIL_UnitTestData_TEST.getApplication(acc.Id, contacts[0].Id, term.Id);
        Application__c application2 = UTIL_UnitTestData_TEST.getApplication(acc.Id, contacts[1].Id, term.Id);

        insert new List<Application__c>{ application1, application2 };

        Test.startTest();
        List<Database.DeleteResult> results = Database.delete(contacts, false);
        Test.stopTest();

        List<Contact> returnContacts = [SELECT Id FROM Contact WHERE Id IN :contacts];

        //Verify that none of the Contact records were deleted
        System.assertEquals(2, returnContacts.size());
        System.assertEquals(Label.CannotDelete, results[0].errors[0].message);
    }

    /*********************************************************************************************************
     * @description Test method to test if Prevent_Contact_Deletion__c is enabled in Hierarchy Settings, and
     * Contact has an Preparer Application record associated to it, that it cannot be deleted.
     */
    @isTest
    private static void conCannotDeleteWithAppPreparer() {
        UTIL_CustomSettingsFacade.getSettingsForTests(
            new Hierarchy_Settings__c(
                Account_Processor__c = UTIL_Describe.getHhAccRecTypeID(),
                Prevent_Contact_Deletion__c = true
            )
        );

        Account acc = UTIL_UnitTestData_TEST.getMultipleTestAccounts(1, UTIL_Describe_API.getBizAccRecTypeID())[0];
        insert acc;

        List<Contact> contacts = UTIL_UnitTestData_TEST.getMultipleTestContacts(2);
        insert contacts;

        Term__c term = UTIL_UnitTestData_TEST.getTerm(acc.Id, 'Spring 2020');

        Application__c application1 = UTIL_UnitTestData_TEST.getApplication(acc.Id, contacts[0].Id, term.Id);
        application1.Preparer__c = contacts[1].Id;
        Application__c application2 = UTIL_UnitTestData_TEST.getApplication(acc.Id, contacts[1].Id, term.Id);
        application2.Preparer__c = contacts[0].Id;

        insert new List<Application__c>{ application1, application2 };

        Test.startTest();
        List<Database.DeleteResult> results = Database.delete(contacts, false);
        Test.stopTest();

        List<Contact> returnContacts = [SELECT Id FROM Contact WHERE Id IN :contacts];

        //Verify that none of the Contact records were deleted
        System.assertEquals(2, returnContacts.size());
        System.assertEquals(Label.CannotDelete, results[0].errors[0].message);
    }

    /*********************************************************************************************************
     * @description Test method to test if Prevent_Contact_Deletion__c is enabled in Hierarchy Settings, and
     * Contact has an Attendance record associated to it, that it cannot be deleted.
     */
    @isTest
    private static void conCannotDeleteWithAttendance() {
        UTIL_CustomSettingsFacade.getSettingsForTests(
            new Hierarchy_Settings__c(
                Account_Processor__c = UTIL_Describe.getHhAccRecTypeID(),
                Prevent_Contact_Deletion__c = true
            )
        );

        Account acc = UTIL_UnitTestData_TEST.getMultipleTestAccounts(1, UTIL_Describe_API.getBizAccRecTypeID())[0];
        insert acc;

        List<Contact> contacts = UTIL_UnitTestData_TEST.getMultipleTestContacts(2);
        insert contacts;

        Attendance_Event__c attendanceEvent1 = UTIL_UnitTestData_TEST.getAttendanceEvent();
        attendanceEvent1.Date__c = System.today();
        attendanceEvent1.Contact__c = contacts[0].Id;

        Attendance_Event__c attendanceEvent2 = UTIL_UnitTestData_TEST.getAttendanceEvent();
        attendanceEvent2.Date__c = System.today();
        attendanceEvent2.Contact__c = contacts[1].Id;

        insert new List<Attendance_Event__c>{ attendanceEvent1, attendanceEvent2 };

        Test.startTest();
        List<Database.DeleteResult> results = Database.delete(contacts, false);
        Test.stopTest();

        List<Contact> returnContacts = [SELECT Id FROM Contact WHERE Id IN :contacts];

        //Verify that none of the Contact records were deleted
        System.assertEquals(2, returnContacts.size());
        System.assertEquals(Label.CannotDelete, results[0].errors[0].message);
    }

    /*********************************************************************************************************
     * @description Test method to test if Prevent_Contact_Deletion__c is enabled in Hierarchy Settings, and
     * Contact has a Credential Attribute record associated to it, that it cannot be deleted.
     */
    @isTest
    private static void conCannotDeleteWithAttributeCredentials() {
        UTIL_CustomSettingsFacade.getSettingsForTests(
            new Hierarchy_Settings__c(
                Account_Processor__c = UTIL_Describe.getHhAccRecTypeID(),
                Prevent_Contact_Deletion__c = true
            )
        );

        Account acc = UTIL_UnitTestData_TEST.getMultipleTestAccounts(1, UTIL_Describe_API.getBizAccRecTypeID())[0];
        insert acc;

        List<Contact> contacts = UTIL_UnitTestData_TEST.getMultipleTestContacts(2);
        insert contacts;

        Id credentialRecTypeId = UTIL_Describe_API.getCredentialAttributeRecType();

        Attribute__c attribute1 = UTIL_UnitTestData_TEST.getAttribute('TestCred1', contacts[0].Id, credentialRecTypeId);
        Attribute__c attribute2 = UTIL_UnitTestData_TEST.getAttribute('TestCred2', contacts[1].Id, credentialRecTypeId);

        insert new List<Attribute__c>{ attribute1, attribute2 };

        Test.startTest();
        List<Database.DeleteResult> results = Database.delete(contacts, false);
        Test.stopTest();

        List<Contact> returnContacts = [SELECT Id FROM Contact WHERE Id IN :contacts];

        //Verify that none of the Contact records were deleted
        System.assertEquals(2, returnContacts.size());
        System.assertEquals(Label.CannotDelete, results[0].errors[0].message);
    }

    /*********************************************************************************************************
     * @description Test method to test if Prevent_Contact_Deletion__c is enabled in Hierarchy Settings, and
     * Contact has a Student Attribute record associated to it, that it cannot be deleted.
     */
    @isTest
    private static void conCannotDeleteWithAttributeStudent() {
        UTIL_CustomSettingsFacade.getSettingsForTests(
            new Hierarchy_Settings__c(
                Account_Processor__c = UTIL_Describe.getHhAccRecTypeID(),
                Prevent_Contact_Deletion__c = true
            )
        );

        Account acc = UTIL_UnitTestData_TEST.getMultipleTestAccounts(1, UTIL_Describe_API.getBizAccRecTypeID())[0];
        insert acc;

        List<Contact> contacts = UTIL_UnitTestData_TEST.getMultipleTestContacts(2);
        insert contacts;

        Id studentCharRecTypeId = UTIL_Describe_API.getStudentCharacteristicAttributeRecType();

        Attribute__c attribute1 = UTIL_UnitTestData_TEST.getAttribute(
            'TestCred1',
            contacts[0].Id,
            studentCharRecTypeId
        );
        Attribute__c attribute2 = UTIL_UnitTestData_TEST.getAttribute(
            'TestCred2',
            contacts[1].Id,
            studentCharRecTypeId
        );

        insert new List<Attribute__c>{ attribute1, attribute2 };

        Test.startTest();
        List<Database.DeleteResult> results = Database.delete(contacts, false);
        Test.stopTest();

        List<Contact> returnContacts = [SELECT Id FROM Contact WHERE Id IN :contacts];

        //Verify that none of the Contact records were deleted
        System.assertEquals(2, returnContacts.size());
        System.assertEquals(Label.CannotDelete, results[0].errors[0].message);
    }

    /*********************************************************************************************************
     * @description Test method to test if Prevent_Contact_Deletion__c is enabled in Hierarchy Settings, and
     * Contact has a Behavior Involvement record associated to it, that it cannot be deleted.
     */
    @isTest
    private static void conCannotDeleteWithBehaviorInvolvement() {
        UTIL_CustomSettingsFacade.getSettingsForTests(
            new Hierarchy_Settings__c(
                Account_Processor__c = UTIL_Describe.getHhAccRecTypeID(),
                Prevent_Contact_Deletion__c = true
            )
        );

        Account acc = UTIL_UnitTestData_TEST.getMultipleTestAccounts(1, UTIL_Describe_API.getBizAccRecTypeID())[0];
        insert acc;

        List<Contact> contacts = UTIL_UnitTestData_TEST.getMultipleTestContacts(2);
        insert contacts;

        Case case1 = UTIL_UnitTestData_TEST.getCase(null, 'School Code of Conduct', 'Current');
        case1.AccountId = acc.Id;
        Case case2 = UTIL_UnitTestData_TEST.getCase(null, 'School Code of Conduct', 'Current');
        case2.AccountId = acc.Id;

        insert new List<case>{ case1, case2 };

        Behavior_Involvement__c behaviorInvolvement1 = UTIL_UnitTestData_TEST.getBehaviorInvolvementRecord(
            contacts[0].Id,
            case1.Id,
            'Reporter'
        );
        Behavior_Involvement__c behaviorInvolvement2 = UTIL_UnitTestData_TEST.getBehaviorInvolvementRecord(
            contacts[1].Id,
            case2.Id,
            'Reporter'
        );

        insert new List<Behavior_Involvement__c>{ behaviorInvolvement1, behaviorInvolvement2 };

        Test.startTest();
        List<Database.DeleteResult> results = Database.delete(contacts, false);
        Test.stopTest();

        List<Contact> returnContacts = [SELECT Id FROM Contact WHERE Id IN :contacts];

        //Verify that none of the Contact records were deleted
        System.assertEquals(2, returnContacts.size());
        System.assertEquals(Label.CannotDelete, results[0].errors[0].message);
    }

    /*********************************************************************************************************
     * @description Test method to test if Prevent_Contact_Deletion__c is enabled in Hierarchy Settings, and
     * Contact has a Contact Language record associated to it, that it cannot be deleted.
     */
    @isTest
    private static void conCannotDeleteWithConLanguage() {
        UTIL_CustomSettingsFacade.getSettingsForTests(
            new Hierarchy_Settings__c(
                Account_Processor__c = UTIL_Describe.getHhAccRecTypeID(),
                Prevent_Contact_Deletion__c = true
            )
        );

        Account acc = UTIL_UnitTestData_TEST.getMultipleTestAccounts(1, UTIL_Describe_API.getBizAccRecTypeID())[0];
        insert acc;

        List<Contact> contacts = UTIL_UnitTestData_TEST.getMultipleTestContacts(2);
        insert contacts;

        Language__c language = UTIL_UnitTestData_TEST.createLanguage('Italian');

        Contact_Language__c contactLanguage1 = UTIL_UnitTestData_TEST.createContactLanguage(
            language.Id,
            contacts[0].Id,
            false
        );
        Contact_Language__c contactLanguage2 = UTIL_UnitTestData_TEST.createContactLanguage(
            language.Id,
            contacts[1].Id,
            false
        );

        Test.startTest();
        List<Database.DeleteResult> results = Database.delete(contacts, false);
        Test.stopTest();

        List<Contact> returnContacts = [SELECT Id FROM Contact WHERE Id IN :contacts];

        //Verify that none of the Contact records were deleted
        System.assertEquals(2, returnContacts.size());
        System.assertEquals(Label.CannotDelete, results[0].errors[0].message);
    }

    /*********************************************************************************************************
     * @description Test method to test if Prevent_Contact_Deletion__c is enabled in Hierarchy Settings, and
     * Contact has a Course Offering record associated to it, that it cannot be deleted.
     */
    @isTest
    private static void conCannotDeleteWithCourseOffering() {
        UTIL_CustomSettingsFacade.getSettingsForTests(
            new Hierarchy_Settings__c(
                Account_Processor__c = UTIL_Describe.getHhAccRecTypeID(),
                Prevent_Contact_Deletion__c = true
            )
        );

        Account acc = UTIL_UnitTestData_TEST.getMultipleTestAccounts(1, UTIL_Describe_API.getBizAccRecTypeID())[0];
        insert acc;

        List<Contact> contacts = UTIL_UnitTestData_TEST.getMultipleTestContacts(2);
        insert contacts;

        Term__c term = UTIL_UnitTestData_TEST.getTerm(acc.Id, 'Fall');
        insert term;

        Course__c course = UTIL_UnitTestData_TEST.getCourse('Biology', acc.Id);
        insert course;

        Course_Offering__c courseOfferings1 = UTIL_UnitTestData_TEST.createCourseOffering(course.Id, term.Id);
        courseOfferings1.Faculty__c = contacts[0].Id;

        Course_Offering__c courseOfferings2 = UTIL_UnitTestData_TEST.createCourseOffering(course.Id, term.Id);
        courseOfferings2.Faculty__c = contacts[1].Id;

        update new List<Course_Offering__c>{ courseOfferings1, courseOfferings2 };

        Test.startTest();
        List<Database.DeleteResult> results = Database.delete(contacts, false);
        Test.stopTest();

        List<Contact> returnContacts = [SELECT Id FROM Contact WHERE Id IN :contacts];

        //Verify that none of the Contact records were deleted
        System.assertEquals(2, returnContacts.size());
        System.assertEquals(Label.CannotDelete, results[0].errors[0].message);
    }

    /*********************************************************************************************************
     * @description Test method to test if Prevent_Contact_Deletion__c is enabled in Hierarchy Settings, and
     * Contact has a Student Course Connection record associated to it, that it cannot be deleted.
     */
    @isTest
    private static void conCannotDeleteWithStudentCourseCxn() {
        UTIL_CustomSettingsFacade.getSettingsForTests(
            new Hierarchy_Settings__c(
                Account_Processor__c = UTIL_Describe.getHhAccRecTypeID(),
                Prevent_Contact_Deletion__c = true
            )
        );

        Account acc = UTIL_UnitTestData_TEST.getMultipleTestAccounts(1, UTIL_Describe_API.getBizAccRecTypeID())[0];
        insert acc;

        List<Contact> contacts = UTIL_UnitTestData_TEST.getMultipleTestContacts(2);
        insert contacts;

        Term__c term = UTIL_UnitTestData_TEST.getTerm(acc.Id, 'Fall');
        insert term;

        Course__c course = UTIL_UnitTestData_TEST.getCourse('Biology', acc.Id);
        insert course;

        Course_Offering__c courseOffering = UTIL_UnitTestData_TEST.createCourseOffering(course.Id, term.Id);

        Id studentCourseCxnRecTypeId = UTIL_Describe_API.getStudentConnectionRecType();

        Course_Enrollment__c studentCourseCxn1 = UTIL_UnitTestData_TEST.getCourseConnection(
            contacts[0].Id,
            courseOffering.Id
        );
        studentCourseCxn1.Status__c = 'Current';

        Course_Enrollment__c studentCourseCxn2 = UTIL_UnitTestData_TEST.getCourseConnection(
            contacts[1].Id,
            courseOffering.Id
        );
        studentCourseCxn2.Status__c = 'Current';

        insert new List<Course_Enrollment__c>{ studentCourseCxn1, studentCourseCxn2 };

        Test.startTest();
        List<Database.DeleteResult> results = Database.delete(contacts, false);
        Test.stopTest();

        List<Contact> returnContacts = [SELECT Id FROM Contact WHERE Id IN :contacts];

        //Verify that none of the Contact records were deleted
        System.assertEquals(2, returnContacts.size());
        System.assertEquals(Label.CannotDelete, results[0].errors[0].message);
    }

    /*********************************************************************************************************
     * @description Test method to test if Prevent_Contact_Deletion__c is enabled in Hierarchy Settings, and
     * Contact has an Education History record associated to it, that it cannot be deleted.
     */
    @isTest
    private static void conCannotDeleteWithEduHistory() {
        UTIL_CustomSettingsFacade.getSettingsForTests(new Hierarchy_Settings__c(Prevent_Contact_Deletion__c = true));

        List<Contact> contacts = UTIL_UnitTestData_TEST.getMultipleTestContacts(2);
        insert contacts;

        Education_History__c eduHis = UTIL_UnitTestData_Test.getEduHistory(null, contacts[0].Id);
        insert eduHis;

        Test.startTest();
        List<Database.DeleteResult> results = Database.delete(contacts, false);
        Test.stopTest();

        List<Contact> returnContacts = [SELECT Id FROM Contact WHERE Id IN :contacts];

        //Verify that only one of the Contact records was deleted
        System.assertEquals(1, returnContacts.size());
        System.assertEquals(Label.CannotDelete, results[0].errors[0].message);
    }

    /*********************************************************************************************************
     * @description Test method to test if Prevent_Contact_Deletion__c is enabled in Hierarchy Settings, and
     * Contact has a Faculty Course Connection record associated to it, that it cannot be deleted.
     */
    @isTest
    private static void conCannotDeleteWithFacultyCourseCxn() {
        UTIL_CustomSettingsFacade.getSettingsForTests(
            new Hierarchy_Settings__c(
                Account_Processor__c = UTIL_Describe.getHhAccRecTypeID(),
                Prevent_Contact_Deletion__c = true
            )
        );

        Account acc = UTIL_UnitTestData_TEST.getMultipleTestAccounts(1, UTIL_Describe_API.getBizAccRecTypeID())[0];
        insert acc;

        List<Contact> contacts = UTIL_UnitTestData_TEST.getMultipleTestContacts(2);
        insert contacts;

        Term__c term = UTIL_UnitTestData_TEST.getTerm(acc.Id, 'Fall');
        insert term;

        Course__c course = UTIL_UnitTestData_TEST.getCourse('Biology', acc.Id);
        insert course;

        Course_Offering__c courseOffering = UTIL_UnitTestData_TEST.createCourseOffering(course.Id, term.Id);

        Id studentCourseCxnRecTypeId = UTIL_Describe_API.getFacultyConnectionRecType();

        Course_Enrollment__c studentCourseCxn1 = UTIL_UnitTestData_TEST.getCourseConnection(
            contacts[0].Id,
            courseOffering.Id
        );
        studentCourseCxn1.Status__c = 'Current';

        Course_Enrollment__c studentCourseCxn2 = UTIL_UnitTestData_TEST.getCourseConnection(
            contacts[1].Id,
            courseOffering.Id
        );
        studentCourseCxn2.Status__c = 'Current';

        insert new List<Course_Enrollment__c>{ studentCourseCxn1, studentCourseCxn2 };

        Test.startTest();
        List<Database.DeleteResult> results = Database.delete(contacts, false);
        Test.stopTest();

        List<Contact> returnContacts = [SELECT Id FROM Contact WHERE Id IN :contacts];

        //Verify that none of the Contact records were deleted
        System.assertEquals(2, returnContacts.size());
        System.assertEquals(Label.CannotDelete, results[0].errors[0].message);
    }

    /*********************************************************************************************************
     * @description Test method to test if Prevent_Contact_Deletion__c is enabled in Hierarchy Settings, and
     * Contact has a Program Enrollment record associated to it, that it cannot be deleted.
     */
    @isTest
    private static void conCannotDeleteWithProgramEnrollment() {
        UTIL_CustomSettingsFacade.getSettingsForTests(
            new Hierarchy_Settings__c(
                Account_Processor__c = UTIL_Describe.getHhAccRecTypeID(),
                Prevent_Contact_Deletion__c = true
            )
        );

        Account acc = UTIL_UnitTestData_TEST.getMultipleTestAccounts(1, UTIL_Describe_API.getBizAccRecTypeID())[0];
        insert acc;

        List<Contact> contacts = UTIL_UnitTestData_TEST.getMultipleTestContacts(2);
        insert contacts;

        Program_Enrollment__c programEnrollment1 = UTIL_UnitTestData_TEST.getProgramEnrollment(acc.Id);
        programEnrollment1.Contact__c = contacts[0].Id;

        Program_Enrollment__c programEnrollment2 = UTIL_UnitTestData_TEST.getProgramEnrollment(acc.Id);
        programEnrollment2.Contact__c = contacts[1].Id;

        insert new List<Program_Enrollment__c>{ programEnrollment1, programEnrollment2 };

        Test.startTest();
        List<Database.DeleteResult> results = Database.delete(contacts, false);
        Test.stopTest();

        List<Contact> returnContacts = [SELECT Id FROM Contact WHERE Id IN :contacts];

        //Verify that none of the Contact records were deleted
        System.assertEquals(2, returnContacts.size());
        System.assertEquals(Label.CannotDelete, results[0].errors[0].message);
    }

    /*********************************************************************************************************
     * @description Test method to test if Prevent_Contact_Deletion__c is enabled in Hierarchy Settings, and
     * Contact has a Term Grade record associated to it, that it cannot be deleted.
     */
    @isTest
    private static void conCannotDeleteWithTermGrade() {
        UTIL_CustomSettingsFacade.getSettingsForTests(
            new Hierarchy_Settings__c(
                Account_Processor__c = UTIL_Describe.getHhAccRecTypeID(),
                Prevent_Contact_Deletion__c = true
            )
        );

        Account acc = UTIL_UnitTestData_TEST.getMultipleTestAccounts(1, UTIL_Describe_API.getBizAccRecTypeID())[0];
        insert acc;

        List<Contact> contacts = UTIL_UnitTestData_TEST.getMultipleTestContacts(2);
        insert contacts;

        Term__c term = UTIL_UnitTestData_TEST.getTerm(acc.Id, 'Fall');
        insert term;

        Course__c course = UTIL_UnitTestData_TEST.getCourse('Biology', acc.Id);
        insert course;

        Course_Offering__c courseOffering1 = UTIL_UnitTestData_TEST.createCourseOffering(course.Id, term.Id);
        Course_Offering__c courseOffering2 = UTIL_UnitTestData_TEST.createCourseOffering(course.Id, term.Id);

        courseOffering1.Faculty__c = contacts[0].Id;
        courseOffering2.Faculty__c = contacts[1].Id;

        List<Course_Offering__c> courseOfferings = new List<Course_Offering__c>();
        courseOfferings.add(courseOffering1);
        courseOfferings.add(courseOffering2);
        update courseOfferings;

        Term_Grade__c termGrade1 = UTIL_UnitTestData_TEST.getTermGrade(contacts[0].Id, courseOfferings[0].Id, null);
        Term_Grade__c termGrade2 = UTIL_UnitTestData_TEST.getTermGrade(contacts[1].Id, courseOfferings[1].Id, null);

        insert new List<Term_Grade__c>{ termGrade1, termGrade2 };

        Test.startTest();
        List<Database.DeleteResult> results = Database.delete(contacts, false);
        Test.stopTest();

        List<Contact> returnContacts = [SELECT Id FROM Contact WHERE Id IN :contacts];

        //Verify that none of the Contact records were deleted
        System.assertEquals(2, returnContacts.size());
        System.assertEquals(Label.CannotDelete, results[0].errors[0].message);
    }

    /*********************************************************************************************************
     * @description Test method to test if Prevent_Contact_Deletion__c is enabled in Hierarchy Settings, and
     * Contact has a Test record associated to it, that it cannot be deleted.
     */
    @isTest
    private static void conCannotDeleteWithTest() {
        UTIL_CustomSettingsFacade.getSettingsForTests(
            new Hierarchy_Settings__c(
                Account_Processor__c = UTIL_Describe.getHhAccRecTypeID(),
                Prevent_Contact_Deletion__c = true
            )
        );

        Account acc = UTIL_UnitTestData_TEST.getMultipleTestAccounts(1, UTIL_Describe_API.getBizAccRecTypeID())[0];
        insert acc;

        List<Contact> contacts = UTIL_UnitTestData_TEST.getMultipleTestContacts(2);
        insert contacts;

        Test__c testRecord1 = UTIL_UnitTestData_TEST.getTest('SAT', System.today(), contacts[0].Id);
        Test__c testRecord2 = UTIL_UnitTestData_TEST.getTest('SAT', System.today(), contacts[1].Id);

        insert new List<Test__c>{ testRecord1, testRecord2 };

        Test.startTest();
        List<Database.DeleteResult> results = Database.delete(contacts, false);
        Test.stopTest();

        List<Contact> returnContacts = [SELECT Id FROM Contact WHERE Id IN :contacts];

        //Verify that none of the Contact records were deleted
        System.assertEquals(2, returnContacts.size());
        System.assertEquals(Label.CannotDelete, results[0].errors[0].message);
    }

    /*********************************************************************************************************
     * @description Test method to test if Prevent_Contact_Deletion__c is disabled in Hierarchy Settings, and
     * Contact has an Address record associated to it, that it can be deleted.
     */
    @isTest
    private static void conCanDeleteWithAddress() {
        UTIL_CustomSettingsFacade.getSettingsForTests(
            new Hierarchy_Settings__c(
                Account_Processor__c = UTIL_Describe.getHhAccRecTypeID(),
                Prevent_Contact_Deletion__c = false
            )
        );

        UTIL_UnitTestData_TEST.ContactsWithAddrs consAccsAddrs = UTIL_UnitTestData_TEST.createTestContactsAddrs(2);

        List<Contact> returnNewContacts = consAccsAddrs.contacts;

        List<Contact> queryContacts = [SELECT Id FROM Contact WHERE Id IN :returnNewContacts];

        Test.startTest();
        List<Database.DeleteResult> results = Database.delete(queryContacts, false);
        Test.stopTest();

        List<Contact> returnContacts = [SELECT Id FROM Contact WHERE Id IN :queryContacts];

        //Verify that all of Contact records were deleted
        System.assertEquals(0, returnContacts.size());
    }

    /*********************************************************************************************************
     * @description Test method to test if Prevent_Contact_Deletion__c is disabled in Hierarchy Settings, and
     * Contact has an Affiliation record associated to it, that it can be deleted.
     */
    @isTest
    private static void conCanDeleteWithAffiliation() {
        UTIL_CustomSettingsFacade.getSettingsForTests(
            new Hierarchy_Settings__c(
                Account_Processor__c = UTIL_Describe.getHhAccRecTypeID(),
                Prevent_Contact_Deletion__c = false
            )
        );

        Account acc = UTIL_UnitTestData_TEST.getMultipleTestAccounts(1, UTIL_Describe_API.getBizAccRecTypeID())[0];
        insert acc;

        List<Contact> contacts = UTIL_UnitTestData_TEST.getMultipleTestContacts(2);
        insert contacts;

        Affiliation__c affiliation1 = UTIL_UnitTestData_TEST.getAffiliation(contacts[0].Id, acc.Id, false);
        Affiliation__c affiliation2 = UTIL_UnitTestData_TEST.getAffiliation(contacts[1].Id, acc.Id, false);

        insert new List<Affiliation__c>{ affiliation1, affiliation2 };

        Test.startTest();
        List<Database.DeleteResult> results = Database.delete(contacts, false);
        Test.stopTest();

        List<Contact> returnContacts = [SELECT Id FROM Contact WHERE Id IN :contacts];

        //Verify that all of Contact the records were deleted
        System.assertEquals(0, returnContacts.size());
    }

    /*********************************************************************************************************
     * @description Test method to test if Prevent_Contact_Deletion__c is disabled in Hierarchy Settings, and
     * Contact has an Applicant Application record associated to it, that it can be deleted.
     */
    @isTest
    private static void conCanDeleteWithApplicant() {
        UTIL_CustomSettingsFacade.getSettingsForTests(
            new Hierarchy_Settings__c(
                Account_Processor__c = UTIL_Describe.getHhAccRecTypeID(),
                Prevent_Contact_Deletion__c = false
            )
        );

        Account acc = UTIL_UnitTestData_TEST.getMultipleTestAccounts(1, UTIL_Describe_API.getBizAccRecTypeID())[0];
        insert acc;

        List<Contact> contacts = UTIL_UnitTestData_TEST.getMultipleTestContacts(2);
        insert contacts;

        Term__c term = UTIL_UnitTestData_TEST.getTerm(acc.Id, 'Fall');
        insert term;

        Application__c applicant1 = UTIL_UnitTestData_TEST.getApplication(acc.Id, contacts[0].Id, term.Id);
        Application__c applicant2 = UTIL_UnitTestData_TEST.getApplication(acc.Id, contacts[1].Id, term.Id);

        insert new List<Application__c>{ applicant1, applicant2 };

        Test.startTest();
        List<Database.DeleteResult> results = Database.delete(contacts, false);
        Test.stopTest();

        List<Contact> returnContacts = [SELECT Id FROM Contact WHERE Id IN :contacts];

        //Verify that all of Contact records were deleted
        System.assertEquals(0, returnContacts.size());
    }

    /*********************************************************************************************************
     * @description Test method to test if Prevent_Contact_Deletion__c is disabled in Hierarchy Settings, and
     * Contact has an Preparer Application record associated to it, that it can be deleted.
     */
    @isTest
    private static void conCanDeleteWithAppPreparer() {
        UTIL_CustomSettingsFacade.getSettingsForTests(
            new Hierarchy_Settings__c(
                Account_Processor__c = UTIL_Describe.getHhAccRecTypeID(),
                Prevent_Contact_Deletion__c = false
            )
        );

        Account acc = UTIL_UnitTestData_TEST.getMultipleTestAccounts(1, UTIL_Describe_API.getBizAccRecTypeID())[0];
        insert acc;

        List<Contact> contacts = UTIL_UnitTestData_TEST.getMultipleTestContacts(2);
        insert contacts;

        Term__c term = UTIL_UnitTestData_TEST.getTerm(acc.Id, 'Fall');
        insert term;

        Application__c applicant1 = UTIL_UnitTestData_TEST.getApplication(acc.Id, contacts[0].Id, term.Id);
        applicant1.Preparer__c = contacts[1].Id;
        Application__c applicant2 = UTIL_UnitTestData_TEST.getApplication(acc.Id, contacts[1].Id, term.Id);
        applicant2.Preparer__c = contacts[0].Id;

        insert new List<Application__c>{ applicant1, applicant2 };

        Test.startTest();
        List<Database.DeleteResult> results = Database.delete(contacts, false);
        Test.stopTest();

        List<Contact> returnContacts = [SELECT Id FROM Contact WHERE Id IN :contacts];

        //Verify that all of Contact records were deleted
        System.assertEquals(0, returnContacts.size());
    }

    /*********************************************************************************************************
     * @description Test method to test if Prevent_Contact_Deletion__c is enabled in Hierarchy Settings, and
     * Contact has an Attendance record associated to it, that it cannot be deleted.
     */
    @isTest
    private static void conCanDeleteWithAttendance() {
        UTIL_CustomSettingsFacade.getSettingsForTests(
            new Hierarchy_Settings__c(
                Account_Processor__c = UTIL_Describe.getHhAccRecTypeID(),
                Prevent_Contact_Deletion__c = false
            )
        );

        Account acc = UTIL_UnitTestData_TEST.getMultipleTestAccounts(1, UTIL_Describe_API.getBizAccRecTypeID())[0];
        insert acc;

        List<Contact> contacts = UTIL_UnitTestData_TEST.getMultipleTestContacts(2);
        insert contacts;

        Attendance_Event__c attendanceEvent1 = UTIL_UnitTestData_TEST.getAttendanceEvent();
        attendanceEvent1.Date__c = System.today();
        attendanceEvent1.Contact__c = contacts[0].Id;

        Attendance_Event__c attendanceEvent2 = UTIL_UnitTestData_TEST.getAttendanceEvent();
        attendanceEvent2.Date__c = System.today();
        attendanceEvent2.Contact__c = contacts[1].Id;

        insert new List<Attendance_Event__c>{ attendanceEvent1, attendanceEvent2 };

        Test.startTest();
        List<Database.DeleteResult> results = Database.delete(contacts, false);
        Test.stopTest();

        List<Contact> returnContacts = [SELECT Id FROM Contact WHERE Id IN :contacts];

        //Verify that all of Contact records were deleted
        System.assertEquals(0, returnContacts.size());
    }

    /*********************************************************************************************************
     * @description Test method to test if Prevent_Contact_Deletion__c is disabled in Hierarchy Settings, and
     * Contact has a Credential Attribute record associated to it, that it can be deleted.
     */
    @isTest
    private static void conCanDeleteWithAttributeCredentials() {
        UTIL_CustomSettingsFacade.getSettingsForTests(
            new Hierarchy_Settings__c(
                Account_Processor__c = UTIL_Describe.getHhAccRecTypeID(),
                Prevent_Contact_Deletion__c = false
            )
        );

        Account acc = UTIL_UnitTestData_TEST.getMultipleTestAccounts(1, UTIL_Describe_API.getBizAccRecTypeID())[0];
        insert acc;

        List<Contact> contacts = UTIL_UnitTestData_TEST.getMultipleTestContacts(2);
        insert contacts;

        Id credentialRecTypeId = UTIL_Describe_API.getCredentialAttributeRecType();
        Attribute__c credentialAttribute1 = UTIL_UnitTestData_TEST.getAttribute(
            'TestCred1',
            contacts[0].Id,
            credentialRecTypeId
        );
        Attribute__c credentialAttribute2 = UTIL_UnitTestData_TEST.getAttribute(
            'TestCred2',
            contacts[1].Id,
            credentialRecTypeId
        );

        insert new List<Attribute__c>{ credentialAttribute1, credentialAttribute2 };

        Test.startTest();
        List<Database.DeleteResult> results = Database.delete(contacts, false);
        Test.stopTest();

        List<Contact> returnContacts = [SELECT Id FROM Contact WHERE Id IN :contacts];

        //Verify that all of Contact records were deleted
        System.assertEquals(0, returnContacts.size());
    }

    /*********************************************************************************************************
     * @description Test method to test if Prevent_Contact_Deletion__c is disabled in Hierarchy Settings, and
     * Contact has a Behavior Involvement record associated to it, that it cannot be deleted.
     */
    @isTest
    private static void conCanDeleteWithBehaviorInvolvement() {
        UTIL_CustomSettingsFacade.getSettingsForTests(
            new Hierarchy_Settings__c(
                Account_Processor__c = UTIL_Describe.getHhAccRecTypeID(),
                Prevent_Contact_Deletion__c = false
            )
        );

        Account acc = UTIL_UnitTestData_TEST.getMultipleTestAccounts(1, UTIL_Describe_API.getBizAccRecTypeID())[0];
        insert acc;

        List<Contact> contacts = UTIL_UnitTestData_TEST.getMultipleTestContacts(2);
        insert contacts;

        Case case1 = UTIL_UnitTestData_TEST.getCase(null, 'School Code of Conduct', 'Current');
        case1.AccountId = acc.Id;
        Case case2 = UTIL_UnitTestData_TEST.getCase(null, 'School Code of Conduct', 'Current');
        case2.AccountId = acc.Id;

        insert new List<case>{ case1, case2 };

        Behavior_Involvement__c behaviorInvolvement1 = UTIL_UnitTestData_TEST.getBehaviorInvolvementRecord(
            contacts[0].Id,
            case1.Id,
            'Reporter'
        );
        Behavior_Involvement__c behaviorInvolvement2 = UTIL_UnitTestData_TEST.getBehaviorInvolvementRecord(
            contacts[1].Id,
            case2.Id,
            'Reporter'
        );

        insert new List<Behavior_Involvement__c>{ behaviorInvolvement1, behaviorInvolvement2 };

        Test.startTest();
        List<Database.DeleteResult> results = Database.delete(contacts, false);
        Test.stopTest();

        List<Contact> returnContacts = [SELECT Id FROM Contact WHERE Id IN :contacts];

        //Verify that all of Contact records were deleted
        System.assertEquals(0, returnContacts.size());
    }

    /*********************************************************************************************************
     * @description Test method to test if Prevent_Contact_Deletion__c is disabled in Hierarchy Settings, and
     * Contact has a Contact Language record associated to it, that it can be deleted.
     */
    @isTest
    private static void conCanDeleteWithConLanguage() {
        UTIL_CustomSettingsFacade.getSettingsForTests(
            new Hierarchy_Settings__c(
                Account_Processor__c = UTIL_Describe.getHhAccRecTypeID(),
                Prevent_Contact_Deletion__c = false
            )
        );

        Account acc = UTIL_UnitTestData_TEST.getMultipleTestAccounts(1, UTIL_Describe_API.getBizAccRecTypeID())[0];
        insert acc;

        List<Contact> contacts = UTIL_UnitTestData_TEST.getMultipleTestContacts(2);
        insert contacts;

        Language__c language = UTIL_UnitTestData_TEST.createLanguage('Spanish');
        Contact_Language__c contactLanguage1 = UTIL_UnitTestData_TEST.createContactLanguage(
            language.Id,
            contacts[0].Id,
            false
        );
        Contact_Language__c contactLanguage2 = UTIL_UnitTestData_TEST.createContactLanguage(
            language.Id,
            contacts[1].Id,
            false
        );

        update new List<Contact_Language__c>{ contactLanguage1, contactLanguage2 };

        Test.startTest();
        List<Database.DeleteResult> results = Database.delete(contacts, false);
        Test.stopTest();

        List<Contact> returnContacts = [SELECT Id FROM Contact WHERE Id IN :contacts];

        //Verify that all of Contact records were deleted
        System.assertEquals(0, returnContacts.size());
    }

    /*********************************************************************************************************
     * @description Test method to test if Prevent_Contact_Deletion__c is disabled in Hierarchy Settings, and
     * Contact has a Course Offering record associated to it, that it can be deleted.
     */
    @isTest
    private static void conCanDeleteWithCourseOffering() {
        UTIL_CustomSettingsFacade.getSettingsForTests(
            new Hierarchy_Settings__c(
                Account_Processor__c = UTIL_Describe.getHhAccRecTypeID(),
                Prevent_Contact_Deletion__c = false
            )
        );

        Account acc = UTIL_UnitTestData_TEST.getMultipleTestAccounts(1, UTIL_Describe_API.getBizAccRecTypeID())[0];
        insert acc;

        List<Contact> contacts = UTIL_UnitTestData_TEST.getMultipleTestContacts(2);
        insert contacts;

        Term__c term = UTIL_UnitTestData_TEST.getTerm(acc.Id, 'Fall');
        insert term;

        Course__c course = UTIL_UnitTestData_TEST.getCourse('Biology', acc.Id);
        insert course;

        Course_Offering__c courseOffering1 = UTIL_UnitTestData_TEST.createCourseOffering(course.Id, term.Id);
        courseOffering1.Faculty__c = contacts[0].Id;
        update courseOffering1;

        Course_Offering__c courseOffering2 = UTIL_UnitTestData_TEST.createCourseOffering(course.Id, term.Id);
        courseOffering2.Faculty__c = contacts[1].Id;
        update courseOffering2;

        Test.startTest();
        List<Database.DeleteResult> results = Database.delete(contacts, false);
        Test.stopTest();

        List<Contact> returnContacts = [SELECT Id FROM Contact WHERE Id IN :contacts];

        //Verify that all of Contact records were deleted
        System.assertEquals(0, returnContacts.size());
    }

    /*********************************************************************************************************
     * @description Test method to test if Prevent_Contact_Deletion__c is disabled in Hierarchy Settings, and
     * Contact has a Student Course Connection record associated to it, that it can be deleted.
     */
    @isTest
    private static void conCanDeleteWithStudentCourseCxn() {
        UTIL_CustomSettingsFacade.getSettingsForTests(
            new Hierarchy_Settings__c(
                Account_Processor__c = UTIL_Describe.getHhAccRecTypeID(),
                Prevent_Contact_Deletion__c = false
            )
        );

        Account acc = UTIL_UnitTestData_TEST.getMultipleTestAccounts(1, UTIL_Describe_API.getBizAccRecTypeID())[0];
        insert acc;

        List<Contact> contacts = UTIL_UnitTestData_TEST.getMultipleTestContacts(2);
        insert contacts;

        Term__c term = UTIL_UnitTestData_TEST.getTerm(acc.Id, 'Fall');
        insert term;

        Course__c course = UTIL_UnitTestData_TEST.getCourse('Biology', acc.Id);
        insert course;

        Course_Offering__c courseOffering = UTIL_UnitTestData_TEST.createCourseOffering(course.Id, term.Id);

        Id studentCourseCxnRecTypeId = UTIL_Describe_API.getStudentConnectionRecType();

        Course_Enrollment__c studentCourseCxn1 = UTIL_UnitTestData_TEST.getCourseConnection(
            contacts[0].Id,
            courseOffering.Id
        );
        studentCourseCxn1.Status__c = 'Current';

        Course_Enrollment__c studentCourseCxn2 = UTIL_UnitTestData_TEST.getCourseConnection(
            contacts[1].Id,
            courseOffering.Id
        );
        studentCourseCxn2.Status__c = 'Current';

        insert new List<Course_Enrollment__c>{ studentCourseCxn1, studentCourseCxn2 };

        Test.startTest();
        List<Database.DeleteResult> results = Database.delete(contacts, false);
        Test.stopTest();

        List<Contact> returnContacts = [SELECT Id FROM Contact WHERE Id IN :contacts];

        //Verify that all of Contact records were deleted
        System.assertEquals(0, returnContacts.size());
    }

    /*********************************************************************************************************
     * @description Test method to test if Prevent_Contact_Deletion__c is disabled in Hierarchy Settings, and
     * Contact has a Faculty Course Connection record associated to it, that it can be deleted.
     */
    @isTest
    private static void conCanDeleteWithFacultyCourseCxn() {
        UTIL_CustomSettingsFacade.getSettingsForTests(
            new Hierarchy_Settings__c(
                Account_Processor__c = UTIL_Describe.getHhAccRecTypeID(),
                Prevent_Contact_Deletion__c = false
            )
        );

        Account acc = UTIL_UnitTestData_TEST.getMultipleTestAccounts(1, UTIL_Describe_API.getBizAccRecTypeID())[0];
        insert acc;

        List<Contact> contacts = UTIL_UnitTestData_TEST.getMultipleTestContacts(2);
        insert contacts;

        Term__c term = UTIL_UnitTestData_TEST.getTerm(acc.Id, 'Fall');
        insert term;

        Course__c course = UTIL_UnitTestData_TEST.getCourse('Biology', acc.Id);
        insert course;

        Course_Offering__c courseOffering = UTIL_UnitTestData_TEST.createCourseOffering(course.Id, term.Id);

        Id studentCourseCxnRecTypeId = UTIL_Describe_API.getFacultyConnectionRecType();
        Course_Enrollment__c studentCourseCxn1 = UTIL_UnitTestData_TEST.getCourseConnection(
            contacts[0].Id,
            courseOffering.Id
        );
        studentCourseCxn1.Status__c = 'Current';

        Course_Enrollment__c studentCourseCxn2 = UTIL_UnitTestData_TEST.getCourseConnection(
            contacts[1].Id,
            courseOffering.Id
        );
        studentCourseCxn2.Status__c = 'Current';

        insert new List<Course_Enrollment__c>{ studentCourseCxn1, studentCourseCxn2 };

        Test.startTest();
        List<Database.DeleteResult> results = Database.delete(contacts, false);
        Test.stopTest();

        List<Contact> returnContacts = [SELECT Id FROM Contact WHERE Id IN :contacts];

        //Verify that all of Contact records were deleted
        System.assertEquals(0, returnContacts.size());
    }

    /*********************************************************************************************************
     * @description Test method to test if Prevent_Contact_Deletion__c is disabled in Hierarchy Settings, and
     * Contact has a Program Enrollment record associated to it, that it can be deleted.
     */
    @isTest
    private static void conCanDeleteWithProgramEnrollment() {
        UTIL_CustomSettingsFacade.getSettingsForTests(
            new Hierarchy_Settings__c(
                Account_Processor__c = UTIL_Describe.getHhAccRecTypeID(),
                Prevent_Contact_Deletion__c = false
            )
        );

        Account acc = UTIL_UnitTestData_TEST.getMultipleTestAccounts(1, UTIL_Describe_API.getBizAccRecTypeID())[0];
        insert acc;

        List<Contact> contacts = UTIL_UnitTestData_TEST.getMultipleTestContacts(2);
        insert contacts;

        Program_Enrollment__c programEnrollment1 = UTIL_UnitTestData_TEST.getProgramEnrollment(acc.Id);
        programEnrollment1.Contact__c = contacts[0].Id;

        Program_Enrollment__c programEnrollment2 = UTIL_UnitTestData_TEST.getProgramEnrollment(acc.Id);
        programEnrollment2.Contact__c = contacts[1].Id;

        insert new List<Program_Enrollment__c>{ programEnrollment1, programEnrollment2 };

        Test.startTest();
        List<Database.DeleteResult> results = Database.delete(contacts, false);
        Test.stopTest();

        List<Contact> returnContacts = [SELECT Id FROM Contact WHERE Id IN :contacts];

        //Verify that all of Contact records were deleted
        System.assertEquals(0, returnContacts.size());
    }

    /*********************************************************************************************************
     * @description Test method to test if Prevent_Contact_Deletion__c is disabled in Hierarchy Settings, and
     * Contact has a Term Grade record associated to it, that it can be deleted.
     */
    @isTest
    private static void conCanDeleteWithTermGrade() {
        UTIL_CustomSettingsFacade.getSettingsForTests(
            new Hierarchy_Settings__c(
                Account_Processor__c = UTIL_Describe.getHhAccRecTypeID(),
                Prevent_Contact_Deletion__c = false
            )
        );

        Account acc = UTIL_UnitTestData_TEST.getMultipleTestAccounts(1, UTIL_Describe_API.getBizAccRecTypeID())[0];
        insert acc;

        List<Contact> contacts = UTIL_UnitTestData_TEST.getMultipleTestContacts(2);
        insert contacts;

        Term__c term = UTIL_UnitTestData_TEST.getTerm(acc.Id, 'Fall');
        insert term;

        Course__c course = UTIL_UnitTestData_TEST.getCourse('Biology', acc.Id);
        insert course;

        Course_Offering__c courseOffering1 = UTIL_UnitTestData_TEST.createCourseOffering(course.Id, term.Id);
        courseOffering1.Faculty__c = contacts[0].Id;

        Course_Offering__c courseOffering2 = UTIL_UnitTestData_TEST.createCourseOffering(course.Id, term.Id);
        courseOffering2.Faculty__c = contacts[1].Id;

        List<Course_Offering__c> courseOfferings = new List<Course_Offering__c>();
        courseOfferings.add(courseOffering1);
        courseOfferings.add(courseOffering2);

        update courseOfferings;

        Term_Grade__c termGrade1 = UTIL_UnitTestData_TEST.getTermGrade(contacts[0].Id, courseOfferings[0].Id, null);
        Term_Grade__c termGrade2 = UTIL_UnitTestData_TEST.getTermGrade(contacts[1].Id, courseOfferings[1].Id, null);

        insert new List<Term_Grade__c>{ termGrade1, termGrade2 };

        Test.startTest();
        List<Database.DeleteResult> results = Database.delete(contacts, false);
        Test.stopTest();

        List<Contact> returnContacts = [SELECT Id FROM Contact WHERE Id IN :contacts];

        //Verify that all of Contact records were deleted
        System.assertEquals(0, returnContacts.size());
    }

    /*********************************************************************************************************
     * @description Test method to test if Prevent_Contact_Deletion__c is disabled in Hierarchy Settings, and
     * Contact has a Test record associated to it, that it can be deleted.
     */
    @isTest
    private static void conCanDeleteWithTest() {
        UTIL_CustomSettingsFacade.getSettingsForTests(
            new Hierarchy_Settings__c(
                Account_Processor__c = UTIL_Describe.getHhAccRecTypeID(),
                Prevent_Contact_Deletion__c = false
            )
        );

        Account acc = UTIL_UnitTestData_TEST.getMultipleTestAccounts(1, UTIL_Describe_API.getBizAccRecTypeID())[0];
        insert acc;

        List<Contact> contacts = UTIL_UnitTestData_TEST.getMultipleTestContacts(2);
        insert contacts;

        Test__c testRecord1 = UTIL_UnitTestData_TEST.getTest('SAT', System.today(), contacts[0].Id);
        Test__c testRecord2 = UTIL_UnitTestData_TEST.getTest('SAT', System.today(), contacts[1].Id);

        insert new List<Test__c>{ testRecord1, testRecord2 };

        Test.startTest();
        List<Database.DeleteResult> results = Database.delete(contacts, false);
        Test.stopTest();

        List<Contact> returnContacts = [SELECT Id FROM Contact WHERE Id IN :contacts];

        //Verify that all of Contact records were deleted
        System.assertEquals(0, returnContacts.size());
    }

    /**************************************************************************************************************************
     * @description Test if contacts can be merged when prevent deletion is enabled
     */
    @isTest
    static void conCanMerge() {
        UTIL_CustomSettingsFacade.getSettingsForTests(new Hierarchy_Settings__c(Prevent_Contact_Deletion__c = true));

        Contact contactWithChildRecords = UTIL_UnitTestData_TEST.createTestContactWithMultipleRelations();
        List<Contact> contacts = UTIL_UnitTestData_TEST.getMultipleTestContacts(2);
        insert contacts[1]; //Use the second contact as master to avoid duplicate error

        Test.startTest();
        merge contacts[1] contactWithChildRecords;
        Test.stopTest();

        // Ensure loser contact is deleted
        List<Contact> mergeLoserContacts = [
            SELECT Id, MasterRecordId, IsDeleted
            FROM Contact
            WHERE Id = :contactWithChildRecords.Id
            ALL ROWS
        ];
        System.assertEquals(1, mergeLoserContacts.size(), 'There should be 1 merge loser contact');
        System.assertEquals(true, mergeLoserContacts[0].IsDeleted, 'The merge loser contact should be deleted');
        System.assertEquals(
            contacts[1].Id,
            mergeLoserContacts[0].MasterRecordId,
            'MasterRecordId should contain winner contact id'
        );

        Contact mergeWinnerContact = [
            SELECT
                ID,
                (SELECT ID FROM Addresses__r LIMIT 1),
                (SELECT ID FROM Applications_Applicant__r LIMIT 1),
                (SELECT ID FROM Applications_Preparer__r LIMIT 1),
                (SELECT ID FROM Attendance_Events__r LIMIT 1),
                (SELECT ID FROM Attributes__r LIMIT 1),
                (SELECT ID FROM Contact_Languages__r LIMIT 1),
                (SELECT ID FROM Education_History__r LIMIT 1),
                (SELECT ID FROM Program_Enrollments__r LIMIT 1),
                (SELECT ID FROM Term_Grades__r LIMIT 1),
                (SELECT ID FROM Tests__r LIMIT 1)
            FROM Contact
            WHERE ID = :contacts[1].Id
        ];
        System.assertEquals(1, mergeWinnerContact.Addresses__r.size(), 'There should be 1 merged address');
        System.assertEquals(
            1,
            mergeWinnerContact.Applications_Applicant__r.size(),
            'There should be 1 merged applicant'
        );
        System.assertEquals(1, mergeWinnerContact.Applications_Preparer__r.size(), 'There should be 1 merged preparer');
        System.assertEquals(1, mergeWinnerContact.Attendance_Events__r.size(), 'There should be 1 merged attendance');
        System.assertEquals(1, mergeWinnerContact.Attributes__r.size(), 'There should be 1 merged attribute');
        System.assertEquals(1, mergeWinnerContact.Contact_Languages__r.size(), 'There should be 1 merged language');
        System.assertEquals(
            1,
            mergeWinnerContact.Education_History__r.size(),
            'There should be 1 merged education history'
        );
        System.assertEquals(1, mergeWinnerContact.Program_Enrollments__r.size(), 'There should be 1 merged enrollment');
        System.assertEquals(1, mergeWinnerContact.Term_Grades__r.size(), 'There should be 1 merged term grades');
        System.assertEquals(1, mergeWinnerContact.Tests__r.size(), 'There should be 1 merged test');
    }

    /*********************************************************************************************************
     * @description Test method to test if Prevent_Contact_Deletion__c is enabled in Hierarchy Settings,and the
     * Contact record has different child records associated to it,then it cannot be deleted.
     */
    @isTest
    private static void cannotDelete() {
        UTIL_CustomSettingsFacade.getSettingsForTests(
            new Hierarchy_Settings__c(
                Account_Processor__c = UTIL_Describe.getHhAccRecTypeID(),
                Prevent_Contact_Deletion__c = true
            )
        );

        Account acc = UTIL_UnitTestData_TEST.getMultipleTestAccounts(1, UTIL_Describe_API.getBizAccRecTypeID())[0];
        insert acc;

        List<Contact> contacts = UTIL_UnitTestData_TEST.getMultipleTestContacts(2);
        insert contacts;

        Term__c term = UTIL_UnitTestData_TEST.getTerm(acc.Id, 'Fall');
        insert term;

        Course__c course = UTIL_UnitTestData_TEST.getCourse('Biology', acc.Id);
        insert course;

        Affiliation__c affiliation1 = UTIL_UnitTestData_TEST.getAffiliation(contacts[0].Id, acc.Id, false);
        Affiliation__c affiliation2 = UTIL_UnitTestData_TEST.getAffiliation(contacts[1].Id, acc.Id, false);

        insert new List<Affiliation__c>{ affiliation1, affiliation2 };

        Application__c application1 = UTIL_UnitTestData_TEST.getApplication(acc.Id, contacts[0].Id, term.Id);
        Application__c application2 = UTIL_UnitTestData_TEST.getApplication(acc.Id, contacts[1].Id, term.Id);

        insert new List<Application__c>{ application1, application2 };

        Attendance_Event__c attendanceEvent1 = UTIL_UnitTestData_TEST.getAttendanceEvent();
        attendanceEvent1.Date__c = System.today();
        attendanceEvent1.Contact__c = contacts[0].Id;

        Attendance_Event__c attendanceEvent2 = UTIL_UnitTestData_TEST.getAttendanceEvent();
        attendanceEvent2.Date__c = System.today();
        attendanceEvent2.Contact__c = contacts[1].Id;

        insert new List<Attendance_Event__c>{ attendanceEvent1, attendanceEvent2 };

        Id credentialRecTypeId = UTIL_Describe_API.getCredentialAttributeRecType();

        Attribute__c attribute1 = UTIL_UnitTestData_TEST.getAttribute('TestCred1', contacts[0].Id, credentialRecTypeId);
        Attribute__c attribute2 = UTIL_UnitTestData_TEST.getAttribute('TestCred2', contacts[1].Id, credentialRecTypeId);

        insert new List<Attribute__c>{ attribute1, attribute2 };

        Language__c language = UTIL_UnitTestData_TEST.createLanguage('Spanish');

        Contact_Language__c contactLanguage1 = UTIL_UnitTestData_TEST.createContactLanguage(
            language.Id,
            contacts[0].Id,
            false
        );
        Contact_Language__c contactLanguage2 = UTIL_UnitTestData_TEST.createContactLanguage(
            language.Id,
            contacts[1].Id,
            false
        );

        Course_Offering__c courseOfferings1 = UTIL_UnitTestData_TEST.createCourseOffering(course.Id, term.Id);
        courseOfferings1.Faculty__c = contacts[0].Id;

        Course_Offering__c courseOfferings2 = UTIL_UnitTestData_TEST.createCourseOffering(course.Id, term.Id);
        courseOfferings2.Faculty__c = contacts[1].Id;

        update new List<Course_Offering__c>{ courseOfferings1, courseOfferings2 };

        Education_History__c eduHis1 = UTIL_UnitTestData_Test.getEduHistory(acc.Id, contacts[0].Id);
        Education_History__c eduHis2 = UTIL_UnitTestData_Test.getEduHistory(acc.Id, contacts[1].Id);
        insert new List<Education_History__c>{ eduHis1, eduHis2 };

        Term_Grade__c termGrade1 = UTIL_UnitTestData_TEST.getTermGrade(contacts[0].Id, courseOfferings1.Id, null);
        Term_Grade__c termGrade2 = UTIL_UnitTestData_TEST.getTermGrade(contacts[1].Id, courseOfferings2.Id, null);

        insert new List<Term_Grade__c>{ termGrade1, termGrade2 };

        Course_Enrollment__c studentCourseCxn1 = UTIL_UnitTestData_TEST.getCourseConnection(
            contacts[0].Id,
            courseOfferings1.Id
        );
        studentCourseCxn1.Status__c = 'Current';

        Course_Enrollment__c studentCourseCxn2 = UTIL_UnitTestData_TEST.getCourseConnection(
            contacts[1].Id,
            courseOfferings2.Id
        );
        studentCourseCxn2.Status__c = 'Current';

        insert new List<Course_Enrollment__c>{ studentCourseCxn1, studentCourseCxn2 };

        Program_Enrollment__c programEnrollment1 = UTIL_UnitTestData_TEST.getProgramEnrollment(acc.Id);
        programEnrollment1.Contact__c = contacts[0].Id;

        Program_Enrollment__c programEnrollment2 = UTIL_UnitTestData_TEST.getProgramEnrollment(acc.Id);
        programEnrollment2.Contact__c = contacts[1].Id;

        insert new List<Program_Enrollment__c>{ programEnrollment1, programEnrollment2 };

        Test__c testRecord1 = UTIL_UnitTestData_TEST.getTest('SAT', System.today(), contacts[0].Id);
        Test__c testRecord2 = UTIL_UnitTestData_TEST.getTest('SAT', System.today(), contacts[1].Id);

        insert new List<Test__c>{ testRecord1, testRecord2 };

        Test.startTest();
        List<Database.DeleteResult> results = Database.delete(contacts, false);
        Test.stopTest();

        //Verify that none of the Contact records were deleted
        List<Contact> returnContacts = [SELECT Id FROM Contact WHERE Id IN :contacts];
        System.assertEquals(2, contacts.size());
        System.assertEquals(false, results[0].success);
        System.assertEquals(Label.CannotDelete, results[0].errors[0].message);
        System.assertEquals(false, results[1].success);
        System.assertEquals(Label.CannotDelete, results[1].errors[0].message);
    }

    /******************************************************************************************************************
     * @description Test method to test when Prevent_Contact_Deletion__c is enabled in Hierarchy Settings, and if
     * one of the Contact records has child records associated to it, then it should not be deleted. The Contact records
     * that do not have any child related records should be deleted.
     */
    @isTest
    private static void cannotDeleteSomeContacts() {
        UTIL_CustomSettingsFacade.getSettingsForTests(
            new Hierarchy_Settings__c(
                Account_Processor__c = UTIL_Describe.getHhAccRecTypeID(),
                Prevent_Contact_Deletion__c = true
            )
        );

        Account acc = UTIL_UnitTestData_TEST.getMultipleTestAccounts(1, UTIL_Describe_API.getBizAccRecTypeID())[0];
        insert acc;

        List<Contact> contacts = UTIL_UnitTestData_TEST.getMultipleTestContacts(2);
        insert contacts;

        Term__c term = UTIL_UnitTestData_TEST.getTerm(acc.Id, 'Fall');
        insert term;

        Course__c course = UTIL_UnitTestData_TEST.getCourse('Biology', acc.Id);
        insert course;

        Affiliation__c affiliation = UTIL_UnitTestData_TEST.getAffiliation(contacts[1].Id, acc.Id, false);
        insert affiliation;

        Application__c applicant = UTIL_UnitTestData_TEST.getApplication(acc.Id, contacts[1].Id, term.Id);
        insert applicant;

        Attendance_Event__c attendance = UTIL_UnitTestData_TEST.getAttendanceEvent();
        attendance.Date__c = System.today();
        insert attendance;

        Id credentialRecTypeId = UTIL_Describe_API.getCredentialAttributeRecType();

        Attribute__c attribute1 = UTIL_UnitTestData_TEST.getAttribute('TestCred2', contacts[1].Id, credentialRecTypeId);

        Language__c language = UTIL_UnitTestData_TEST.createLanguage('Spanish');

        Contact_Language__c contactLanguage = UTIL_UnitTestData_TEST.createContactLanguage(
            language.Id,
            contacts[1].Id,
            false
        );

        Course_Offering__c courseOffering = UTIL_UnitTestData_TEST.createCourseOffering(course.Id, term.Id);
        courseOffering.Faculty__c = contacts[1].Id;
        update courseOffering;

        Education_History__c eduHis = UTIL_UnitTestData_Test.getEduHistory(acc.Id, contacts[1].Id);
        insert eduHis;

        Term_Grade__c termGrade = UTIL_UnitTestData_TEST.getTermGrade(contacts[1].Id, courseOffering.Id, null);
        insert termGrade;

        Course_Enrollment__c courseCxn = UTIL_UnitTestData_TEST.getCourseConnection(contacts[1].Id, courseOffering.Id);
        courseCxn.Status__c = 'Current';
        insert courseCxn;

        Program_Enrollment__c programEnrollment = UTIL_UnitTestData_TEST.getProgramEnrollment(acc.Id);
        programEnrollment.Contact__c = contacts[1].Id;

        Test__c testRecord = UTIL_UnitTestData_TEST.getTest('SAT', System.today(), contacts[1].Id);
        insert testRecord;

        Test.startTest();
        List<Database.DeleteResult> results = Database.delete(contacts, false);
        Test.stopTest();

        //Verify that 1 of the Contact records was deleted
        List<Contact> returnContacts = [SELECT Id FROM Contact WHERE Id IN :contacts];
        System.assertEquals(true, results[0].success);
        System.assertEquals(false, results[1].success);
        System.assertEquals(Label.CannotDelete, results[1].errors[0].message);
    }

    /**********************************************************************************************************
     * @description Test method to test if Prevent_Contact_Deletion__c is disabled in Hierarchy Settings,and the
     * Contact record has different child records associated to it, then it can be deleted.
     */
    @isTest
    private static void canDelete() {
        UTIL_CustomSettingsFacade.getSettingsForTests(
            new Hierarchy_Settings__c(
                Account_Processor__c = UTIL_Describe.getHhAccRecTypeID(),
                Prevent_Contact_Deletion__c = false
            )
        );

        Account acc = UTIL_UnitTestData_TEST.getMultipleTestAccounts(1, UTIL_Describe_API.getBizAccRecTypeID())[0];
        insert acc;

        List<Contact> contacts = UTIL_UnitTestData_TEST.getMultipleTestContacts(2);
        insert contacts;

        Term__c term = UTIL_UnitTestData_TEST.getTerm(acc.Id, 'Fall');
        insert term;

        Course__c course = UTIL_UnitTestData_TEST.getCourse('Biology', acc.Id);
        insert course;

        Affiliation__c affiliation1 = UTIL_UnitTestData_TEST.getAffiliation(contacts[0].Id, acc.Id, false);
        Affiliation__c affiliation2 = UTIL_UnitTestData_TEST.getAffiliation(contacts[1].Id, acc.Id, false);

        insert new List<Affiliation__c>{ affiliation1, affiliation2 };

        Application__c application1 = UTIL_UnitTestData_TEST.getApplication(acc.Id, contacts[0].Id, term.Id);
        Application__c application2 = UTIL_UnitTestData_TEST.getApplication(acc.Id, contacts[1].Id, term.Id);

        insert new List<Application__c>{ application1, application2 };

        Attendance_Event__c attendanceEvent1 = UTIL_UnitTestData_TEST.getAttendanceEvent();
        attendanceEvent1.Date__c = System.today();
        attendanceEvent1.Contact__c = contacts[0].Id;

        Attendance_Event__c attendanceEvent2 = UTIL_UnitTestData_TEST.getAttendanceEvent();
        attendanceEvent2.Date__c = System.today();
        attendanceEvent2.Contact__c = contacts[1].Id;

        insert new List<Attendance_Event__c>{ attendanceEvent1, attendanceEvent2 };

        Id credentialRecTypeId = UTIL_Describe_API.getCredentialAttributeRecType();

        Attribute__c attribute1 = UTIL_UnitTestData_TEST.getAttribute('TestCred1', contacts[0].Id, credentialRecTypeId);
        Attribute__c attribute2 = UTIL_UnitTestData_TEST.getAttribute('TestCred2', contacts[1].Id, credentialRecTypeId);

        insert new List<Attribute__c>{ attribute1, attribute2 };

        Case case1 = UTIL_UnitTestData_TEST.getCase(null, 'School Code of Conduct', 'Current');
        case1.AccountId = acc.Id;
        Case case2 = UTIL_UnitTestData_TEST.getCase(null, 'School Code of Conduct', 'Current');
        case2.AccountId = acc.Id;

        insert new List<case>{ case1, case2 };
        Behavior_Involvement__c beh1 = UTIL_UnitTestData_TEST.getBehaviorInvolvementRecord(
            contacts[0].Id,
            case1.Id,
            'Reporter'
        );
        Behavior_Involvement__c beh2 = UTIL_UnitTestData_TEST.getBehaviorInvolvementRecord(
            contacts[1].Id,
            case2.Id,
            'Reporter'
        );

        insert new List<Behavior_Involvement__c>{ beh1, beh2 };

        Language__c language = UTIL_UnitTestData_TEST.createLanguage('Spanish');

        Contact_Language__c contactLanguage1 = UTIL_UnitTestData_TEST.createContactLanguage(
            language.Id,
            contacts[0].Id,
            false
        );
        Contact_Language__c contactLanguage2 = UTIL_UnitTestData_TEST.createContactLanguage(
            language.Id,
            contacts[1].Id,
            false
        );
        Course_Offering__c courseOfferings1 = UTIL_UnitTestData_TEST.createCourseOffering(course.Id, term.Id);
        courseOfferings1.Faculty__c = contacts[0].Id;

        Course_Offering__c courseOfferings2 = UTIL_UnitTestData_TEST.createCourseOffering(course.Id, term.Id);
        courseOfferings2.Faculty__c = contacts[1].Id;

        update new List<Course_Offering__c>{ courseOfferings1, courseOfferings2 };

        Education_History__c eduHis1 = UTIL_UnitTestData_Test.getEduHistory(acc.Id, contacts[0].Id);
        Education_History__c eduHis2 = UTIL_UnitTestData_Test.getEduHistory(acc.Id, contacts[1].Id);
        insert new List<Education_History__c>{ eduHis1, eduHis2 };

        Term_Grade__c termGrade1 = UTIL_UnitTestData_TEST.getTermGrade(contacts[0].Id, courseOfferings1.Id, null);
        Term_Grade__c termGrade2 = UTIL_UnitTestData_TEST.getTermGrade(contacts[1].Id, courseOfferings2.Id, null);

        insert new List<Term_Grade__c>{ termGrade1, termGrade2 };

        Id studentCourseCxnRecTypeId = UTIL_Describe_API.getStudentConnectionRecType();

        Course_Enrollment__c studentCourseCxn1 = UTIL_UnitTestData_TEST.getCourseConnection(
            contacts[0].Id,
            courseOfferings1.Id
        );
        studentCourseCxn1.Status__c = 'Current';

        Course_Enrollment__c studentCourseCxn2 = UTIL_UnitTestData_TEST.getCourseConnection(
            contacts[1].Id,
            courseOfferings2.Id
        );
        studentCourseCxn2.Status__c = 'Current';

        insert new List<Course_Enrollment__c>{ studentCourseCxn1, studentCourseCxn2 };

        Program_Enrollment__c programEnrollment1 = UTIL_UnitTestData_TEST.getProgramEnrollment(acc.Id);
        programEnrollment1.Contact__c = contacts[0].Id;

        Program_Enrollment__c programEnrollment2 = UTIL_UnitTestData_TEST.getProgramEnrollment(acc.Id);
        programEnrollment2.Contact__c = contacts[1].Id;

        insert new List<Program_Enrollment__c>{ programEnrollment1, programEnrollment2 };

        Test__c testRecord1 = UTIL_UnitTestData_TEST.getTest('SAT', System.today(), contacts[0].Id);
        Test__c testRecord2 = UTIL_UnitTestData_TEST.getTest('SAT', System.today(), contacts[1].Id);

        insert new List<Test__c>{ testRecord1, testRecord2 };
        Test.startTest();
        List<Database.DeleteResult> results = Database.delete(contacts, false);
        Test.stopTest();

        //Verify that all Contact records were deleted
        List<Contact> returnContacts = [SELECT Id FROM Contact WHERE Id IN :contacts];

        System.assertEquals(0, returnContacts.size());
    }

    /*********************************************************************************************************
     * @description Test method to test if Prevent_Contact_Deletion__c is disabled in Hierarchy Settings, and if
     * one of the Contact record has child records associated to it, then it should be deleted. The Contact record
     * that do not have any child related records should be deleted.
     */
    @isTest
    private static void canDeleteAllContacts() {
        UTIL_CustomSettingsFacade.getSettingsForTests(
            new Hierarchy_Settings__c(
                Account_Processor__c = UTIL_Describe.getHhAccRecTypeID(),
                Prevent_Contact_Deletion__c = false
            )
        );

        Account acc = UTIL_UnitTestData_TEST.getMultipleTestAccounts(1, UTIL_Describe_API.getBizAccRecTypeID())[0];
        insert acc;

        List<Contact> contacts = UTIL_UnitTestData_TEST.getMultipleTestContacts(2);
        insert contacts;

        Term__c term = UTIL_UnitTestData_TEST.getTerm(acc.Id, 'Fall');
        insert term;

        Course__c course = UTIL_UnitTestData_TEST.getCourse('Biology', acc.Id);
        insert course;

        Affiliation__c affiliation = UTIL_UnitTestData_TEST.getAffiliation(contacts[1].Id, acc.Id, false);
        insert affiliation;

        Application__c applicant = UTIL_UnitTestData_TEST.getApplication(acc.Id, contacts[1].Id, term.Id);
        insert applicant;

        Attendance_Event__c attendance = UTIL_UnitTestData_TEST.getAttendanceEvent();
        attendance.Date__c = System.today();
        attendance.Contact__c = contacts[0].Id;
        insert attendance;

        Id credentialRecTypeId = UTIL_Describe_API.getCredentialAttributeRecType();
        Attribute__c credentialAttribute = UTIL_UnitTestData_TEST.getAttribute(
            'TestCred2',
            contacts[1].Id,
            credentialRecTypeId
        );
        insert credentialAttribute;

        Language__c language = UTIL_UnitTestData_TEST.createLanguage('Spanish');

        Contact_Language__c contactLanguage = UTIL_UnitTestData_TEST.createContactLanguage(
            language.Id,
            contacts[1].Id,
            false
        );

        Course_Offering__c courseOffering = UTIL_UnitTestData_TEST.createCourseOffering(course.Id, term.Id);
        courseOffering.Faculty__c = contacts[1].Id;
        update courseOffering;

        Education_History__c eduHis = UTIL_UnitTestData_Test.getEduHistory(acc.Id, contacts[1].Id);
        insert eduHis;

        Term_Grade__c termGrade = UTIL_UnitTestData_TEST.getTermGrade(contacts[1].Id, courseOffering.Id, null);
        insert termGrade;

        Course_Enrollment__c courseCxn = UTIL_UnitTestData_TEST.getCourseConnection(contacts[1].Id, courseOffering.Id);
        courseCxn.Status__c = 'Current';
        insert courseCxn;

        Program_Enrollment__c programEnrollment = UTIL_UnitTestData_TEST.getProgramEnrollment(acc.Id);
        programEnrollment.Contact__c = contacts[1].Id;
        insert programEnrollment;

        Test__c testRecord = UTIL_UnitTestData_TEST.getTest('SAT', System.today(), contacts[1].Id);
        insert testRecord;

        Test.startTest();
        List<Database.DeleteResult> results = Database.delete(contacts, false);
        Test.stopTest();

        //Verify that all of the Contact records was deleted
        List<Contact> returnContacts = [SELECT Id FROM Contact WHERE Id IN :contacts];
        System.assertEquals(0, returnContacts.size());
        System.assertEquals(true, results[0].success);
        System.assertEquals(true, results[1].success);
    }

    /**************************************************************************************************************************
     ****************************************************** UNIT TESTS *********************************************************
     **************************************************************************************************************************/

    /*************************************************************************************************************
     * @description NULL test for run method to verify new DmlWrapper(); is returned when oldList is null
     */
    @isTest
    private static void runMethodNULLTest() {
        TDTM_Runnable.Action testAction = TDTM_Runnable.Action.BeforeDelete;
        Schema.DescribeSObjectResult objResult = Schema.SObjectType.Contact;

        CON_CannotDelete_TDTM ConCannotDeleteTDTM = new CON_CannotDelete_TDTM();
        TDTM_Runnable.DmlWrapper dmlWrapperReturned = ConCannotDeleteTDTM.run(null, null, testAction, objResult);

        System.assertEquals(0, dmlWrapperReturned.objectsToDelete.size());
    }

    /****************************************************************************************************************
     * @description Positive test for run method to verify contactPreventedFromDeletionList has the records prevented
     * from Deletion when Prevent Contact Deletion Custom Settings is enabled
     */
    @isTest
    private static void runMethodPositiveTest() {
        SRVC_Contact_PreventDeletion.instance = new STUB_deletionPreventionContactList();

        UTIL_CustomSettingsFacade.getSettingsForTests(new Hierarchy_Settings__c(Prevent_Contact_Deletion__c = true));

        TDTM_Runnable.Action testBeforeAction = TDTM_Runnable.Action.BeforeDelete;
        TDTM_Runnable.Action testAfterAction = TDTM_Runnable.Action.AfterDelete;
        Schema.DescribeSObjectResult objResult = Schema.SObjectType.Contact;

        Account acc = UTIL_UnitTestData_TEST.getMultipleTestAccounts(1, UTIL_Describe_API.getBizAccRecTypeID())[0];
        insert acc;

        List<Contact> contacts = UTIL_UnitTestData_TEST.getMultipleTestContacts(1);
        insert contacts;

        Term__c term = new Term__c(Name = 'Fall', Account__c = acc.Id);
        insert term;

        Course__c course = new Course__c(Name = 'Biology', Account__c = acc.Id);
        insert course;

        Affiliation__c affiliation = new Affiliation__c(Account__c = acc.Id, Contact__c = contacts[0].Id);
        insert affiliation;

        Education_History__c eduHis = UTIL_UnitTestData_Test.getEduHistory(acc.Id, contacts[0].Id);
        insert eduHis;

        List<SObject> oldList = new List<SObject>((List<SObject>) contacts);

        Map<Id, Contact> contactById = new Map<Id, Contact>(contacts);

        CON_CannotDelete_TDTM ConCannotDeleteTDTM = new CON_CannotDelete_TDTM();

        Test.startTest();
        ConCannotDeleteTDTM.run(null, oldList, testBeforeAction, objResult);
        List<Contact> contactsWithChildRelations = CON_CannotDelete_TDTM.contactsWithChildRelations;
        ConCannotDeleteTDTM.run(null, oldList, testAfterAction, objResult);
        Test.stopTest();

        // verify before handler retrieved contact with relations
        System.assertEquals(oldList.size(), contactsWithChildRelations.size());
        List<Contact> deletionPreventedContactList = SRVC_Contact_PreventDeletion.getInstance()
            .preventDeletionForContacts(contactById, contactsWithChildRelations);

        // verify deletionPreventedContactList is not empty
        System.assertEquals(1, deletionPreventedContactList.size());
        // verify after handler cleared contactsWithChildRelations static var
        System.assertEquals(null, CON_CannotDelete_TDTM.contactsWithChildRelations);
    }

    /************************************************************************************************************************
     * @description Negative test for run method to verify contactPreventedFromDeletionList has no records that are prevented
     * from Deletion when Prevent Contact Deletion Custom Settings is disabled
     */
    @isTest
    private static void runMethodNegativeTestWithCustomSettingsDisabled() {
        SRVC_Contact_PreventDeletion.instance = new STUB_DeletionPreventionContactList();

        UTIL_CustomSettingsFacade.getSettingsForTests(new Hierarchy_Settings__c(Prevent_Contact_Deletion__c = false));

        TDTM_Runnable.Action testBeforeAction = TDTM_Runnable.Action.BeforeDelete;
        TDTM_Runnable.Action testAfterAction = TDTM_Runnable.Action.AfterDelete;
        Schema.DescribeSObjectResult objResult = Schema.SObjectType.Contact;

        Account acc = UTIL_UnitTestData_TEST.getMultipleTestAccounts(1, UTIL_Describe_API.getBizAccRecTypeID())[0];
        insert acc;

        List<Contact> contacts = UTIL_UnitTestData_TEST.getMultipleTestContacts(1);
        insert contacts;

        Term__c term = new Term__c(Name = 'Fall', Account__c = acc.Id);
        insert term;

        Course__c course = new Course__c(Name = 'Biology', Account__c = acc.Id);
        insert course;

        Affiliation__c affiliation = new Affiliation__c(Account__c = acc.Id, Contact__c = contacts[0].Id);
        insert affiliation;

        Education_History__c eduHis = UTIL_UnitTestData_Test.getEduHistory(acc.Id, contacts[0].Id);
        insert eduHis;

        List<SObject> oldList = new List<SObject>((List<SObject>) contacts);

        Map<Id, Contact> contactById = new Map<Id, Contact>();

        CON_CannotDelete_TDTM ConCannotDeleteTDTM = new CON_CannotDelete_TDTM();

        Test.startTest();
        ConCannotDeleteTDTM.run(null, oldList, testBeforeAction, objResult);
        List<Contact> contactsWithChildRelations = CON_CannotDelete_TDTM.contactsWithChildRelations;
        ConCannotDeleteTDTM.run(null, oldList, testAfterAction, objResult);
        Test.stopTest();

        // verify before handler didn't retrieve any contacts with relations
        System.assertEquals(null, contactsWithChildRelations);

        List<Contact> deletionPreventedContactList = SRVC_Contact_PreventDeletion.getInstance()
            .preventDeletionForContacts(contactById, new List<Contact>());

        // Verify deletionPreventedContactList is empty
        System.assertEquals(0, deletionPreventedContactList.size());
        // verify after handler cleared contactsWithChildRelations static var
        System.assertEquals(null, CON_CannotDelete_TDTM.contactsWithChildRelations);
    }

    /*************************************************************************************************************************
     * @description Negative test for run method to verify contactPreventedFromDeletionList has no records that are prevented
     * from Deletion when Prevent Contact Deletion Custom Settings is enabled.
     */
    @isTest
    static void runMethodNegativeTestWithNoChildren() {
        SRVC_Contact_PreventDeletion.instance = new STUB_deletionPreventionContactList();

        UTIL_CustomSettingsFacade.getSettingsForTests(new Hierarchy_Settings__c(Prevent_Contact_Deletion__c = true));

        TDTM_Runnable.Action testBeforeAction = TDTM_Runnable.Action.BeforeDelete;
        TDTM_Runnable.Action testAfterAction = TDTM_Runnable.Action.AfterDelete;
        Schema.DescribeSObjectResult objResult = Schema.SObjectType.Contact;

        List<Contact> contacts = UTIL_UnitTestData_TEST.getMultipleTestContacts(1);
        insert contacts;

        List<SObject> oldList = new List<SObject>((List<SObject>) contacts);

        Map<Id, Contact> contactById = new Map<Id, Contact>((List<Contact>) oldList);

        CON_CannotDelete_TDTM ConCannotDeleteTDTM = new CON_CannotDelete_TDTM();

        Test.startTest();
        ConCannotDeleteTDTM.run(null, oldList, testBeforeAction, objResult);
        List<Contact> contactsWithChildRelations = CON_CannotDelete_TDTM.contactsWithChildRelations;
        ConCannotDeleteTDTM.run(null, oldList, testAfterAction, objResult);
        Test.stopTest();

        List<Contact> deletionPreventedContactList = SRVC_Contact_PreventDeletion.getInstance()
            .preventDeletionForContacts(contactById, contactsWithChildRelations);

        // Verify deletionPreventedContactList is empty
        System.assertEquals(0, deletionPreventedContactList.size());
    }

    /********************************************************************************************************************************
     * @description Tests handleBeforeDelete method of CON_CannotDelete_TDTM when Prevent Contact Deletion Custom Settings is enabled
     * and Contact having child records
     */
    @isTest
    private static void handleBeforeDeleteMethodWithCustomSettingsEnabledPositiveTest() {
        UTIL_CustomSettingsFacade.getSettingsForTests(new Hierarchy_Settings__c(Prevent_Contact_Deletion__c = true));
        Account acc = UTIL_UnitTestData_TEST.getMultipleTestAccounts(1, UTIL_Describe_API.getBizAccRecTypeID())[0];
        insert acc;

        List<Contact> contacts = UTIL_UnitTestData_TEST.getMultipleTestContacts(1);
        insert contacts;

        Term__c term = new Term__c(Name = 'Fall', Account__c = acc.Id);
        insert term;

        Course__c course = new Course__c(Name = 'Biology', Account__c = acc.Id);
        insert course;

        Affiliation__c affiliation = new Affiliation__c(Account__c = acc.Id, Contact__c = contacts[0].Id);
        insert affiliation;

        Education_History__c eduHis = UTIL_UnitTestData_Test.getEduHistory(acc.Id, contacts[0].Id);
        insert eduHis;

        CON_CannotDelete_TDTM conCanNotDeleteTDTM = new CON_CannotDelete_TDTM();
        Test.startTest();
        List<Contact> contactsWithChildRelations = conCanNotDeleteTDTM.handleBeforeDelete(contacts);
        Test.stopTest();

        // Verify contactsWithChildRelations is not empty
        System.assertEquals(1, contactsWithChildRelations.size());
    }

    /*******************************************************************************************************************************************
     * @description positive test for handleBeforeDelete method of CON_CannotDelete_TDTM when Prevent Contact Deletion Custom Settings is enabled
     * with no CHild records for Contact
     */
    @isTest
    private static void handleBeforeDeleteMethodWithCustomSettingsEnabledNoRelationsPositiveTest() {
        UTIL_CustomSettingsFacade.getSettingsForTests(new Hierarchy_Settings__c(Prevent_Contact_Deletion__c = true));

        List<Contact> contacts = UTIL_UnitTestData_TEST.getMultipleTestContacts(1);
        insert contacts;

        CON_CannotDelete_TDTM conCanNotDeleteTDTM = new CON_CannotDelete_TDTM();
        Test.startTest();
        List<Contact> contactsWithChildRelations = conCanNotDeleteTDTM.handleBeforeDelete((List<SObject>) contacts);
        Test.stopTest();

        // Verify contactsWithChildRelations is empty
        System.assertEquals(1, contactsWithChildRelations.size());
    }

    /************************************************************************************************************************
     * @description Tests handleBeforeDelete method of CON_CannotDelete_TDTM with Prevent Deletion Custom Settings disabled
     */
    @isTest
    private static void handleBeforeDeleteMethodWIthCustomSettingsDisabledTest() {
        UTIL_CustomSettingsFacade.getSettingsForTests(new Hierarchy_Settings__c(Prevent_Contact_Deletion__c = false));

        List<SObject> testContactlist = UTIL_UnitTestData_TEST.getMultipleTestContacts(10);

        CON_CannotDelete_TDTM conCanNotDeleteTDTM = new CON_CannotDelete_TDTM();
        Test.startTest();
        List<Contact> contactsWithChildRelations = conCanNotDeleteTDTM.handleBeforeDelete(testContactlist);
        Test.stopTest();

        // Verify contactsWithChildRelations is null
        System.assertEquals(null, contactsWithChildRelations);
    }

    /*************************************************************************************************************
     * @description Tests locateContactPreventDeletionService method of CON_CannotDelete_TDTM
     */
    @isTest
    private static void locateContactPreventDeletionServiceTest() {
        CON_CannotDelete_TDTM conCanNotDeleteTDTM = new CON_CannotDelete_TDTM();
        Test.startTest();
        SRVC_Contact_PreventDeletion conPreventDeleteInstance = conCanNotDeleteTDTM.locateContactPreventDeletionService();
        Test.stopTest();

        SRVC_Contact_PreventDeletion srvcInstance = SRVC_Contact_PreventDeletion.getInstance();

        System.assertEquals(srvcInstance, conPreventDeleteInstance);
    }

    /*************************************************************************************************************
     * @description Positive tests for isContactDeletionPreventionEnabled method of CON_CannotDelete_TDTM
     */
    @isTest
    private static void isContactDeletionPreventionEnabledPositiveTest() {
        UTIL_CustomSettingsFacade.getSettingsForTests(new Hierarchy_Settings__c(Prevent_Contact_Deletion__c = true));
        Test.startTest();
        CON_CannotDelete_TDTM conPreventDeleteInstance = new CON_CannotDelete_TDTM();
        Test.stopTest();

        Boolean isContactDeletionPreventionEnabled = conPreventDeleteInstance.isContactDeletionPreventionEnabled();

        // Verify isContactDeletionPreventionEnabled is true
        System.assertEquals(true, isContactDeletionPreventionEnabled);
    }

    /*************************************************************************************************************
     * @description Negative tests for isContactDeletionPreventionEnabled method of CON_CannotDelete_TDTM
     */
    @isTest
    private static void isContactDeletionPreventionEnabledNegativeTest() {
        UTIL_CustomSettingsFacade.getSettingsForTests(new Hierarchy_Settings__c(Prevent_Contact_Deletion__c = false));
        Test.startTest();
        CON_CannotDelete_TDTM conPreventDeleteInstance = new CON_CannotDelete_TDTM();
        Test.stopTest();

        Boolean isContactDeletionPreventionEnabled = conPreventDeleteInstance.isContactDeletionPreventionEnabled();

        System.assertEquals(false, isContactDeletionPreventionEnabled);
    }

    /**************************************************************************************************************************
     ****************************************************** STUB CLASS *********************************************************
     **************************************************************************************************************************/

    /*************************************************************************************************************
     * STUB class which extends SRVC_Contact_PreventDeletion
     */
    private class STUB_DeletionPreventionContactList extends SRVC_Contact_PreventDeletion {
        @TestVisible
        List<Contact> deletionPreventedContactList = new List<Contact>();

        public override List<Contact> preventDeletionForContacts(
            Map<Id, Contact> contactById,
            List<Contact> contactWithChildRecordsList
        ) {
            deletionPreventedContactList = super.preventDeletionForContacts(contactById, contactWithChildRecordsList);
            return deletionPreventedContactList;
        }
    }
}
/*
    Copyright (c) 2014, Salesforce.org
    All rights reserved.

    Redistribution and use in source and binary forms, with or without
    modification, are permitted provided that the following conditions are met:

    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
    * Neither the name of Salesforce.org nor the names of
      its contributors may be used to endorse or promote products derived
      from this software without specific prior written permission.
 
    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
    "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
    LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
    FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
    COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
    INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
    BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
    LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
    CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
    LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
    ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
    POSSIBILITY OF SUCH DAMAGE.
*/

/**
* @author Salesforce.org
* @date 2015
* @group Contacts
* @group-content ../../ApexDocContent/Contacts.htm
* @description Tests to validate the functionality of the CON_DoNotContact_TDTM class to
* synchronize Household naming exclusions and communication preferences with changes to the Deceased
* and Do Not Contact fields for the Contact object.
*/
@isTest
private class CON_DoNotContact_TEST {
    /**************************************************************************************************************************
    ****************************************************** FUNCTIONAL TESTS ***************************************************
    **************************************************************************************************************************/

    /**************************************************************************************************************************
    * @description Test method to verify that contacts inserted with "Deceased" = true are excluded from 
    * from Household naming functionality and have the following fields automatically marked as true: 
    * Do Not Contact, Email Opt Out, Do Not Call, Do Not Fax
    */
    @isTest 
    private static void insertContactDeceasedIsTrue(){
        List<Contact> testContactsList = UTIL_UnitTestData_TEST.getMultipleTestContacts(5);
        
        for (Contact con : testContactsList){
            con.Deceased__c = true;
        }

        Test.startTest();
        insert testContactsList;
        Test.stopTest();

        List<Contact> contactsAfterInsertList = [SELECT Do_Not_Contact__c, 
                                                        Exclude_from_Household_Name__c, 
                                                        Exclude_from_Household_Formal_Greeting__c,
                                                        Exclude_from_Household_Informal_Greeting__c, 
                                                        HasOptedOutOfEmail, 
                                                        DoNotCall, 
                                                        HasOptedOutOfFax
                                                FROM CONTACT 
                                                WHERE Id IN :testContactsList];
        
        for (Contact con : contactsAfterInsertList){
            System.assertEquals(true, con.Exclude_from_Household_Name__c, 'Contact should be excluded from Household Naming.');
            System.assertEquals(true, con.Exclude_from_Household_Formal_Greeting__c, 'Contact should be excluded from Household Formal Greeting.');
            System.assertEquals(true, con.Exclude_from_Household_Informal_Greeting__c, 'Contact should be excluded from Household Informal Greeting.');
            System.assertEquals(true, con.Do_Not_Contact__c, 'Contact should be marked as Do Not Contact.');
            System.assertEquals(true, con.HasOptedOutOfEmail, 'Contact should be opted out of receiving emails.');
            System.assertEquals(true, con.HasOptedOutOfFax, 'Contact should be opted out of receiving faxes.');
            System.assertEquals(true, con.DoNotCall, 'Contact should be opted out of receiving phone calls.');
        }
    }

    /**************************************************************************************************************************
    * @description Test method to verify that contacts inserted with "Deceased" = false are not excluded from 
    * from Household naming functionality and have the following fields automatically marked as false: 
    * Do Not Contact, Email Opt Out, Do Not Call, Do Not Fax
    */
    @isTest 
    private static void insertContactDeceasedIsFalse(){
        List<Contact> testContactsList = UTIL_UnitTestData_TEST.getMultipleTestContacts(5);
        
        for (Contact con : testContactsList){
            con.Deceased__c = false;
        }

        Test.startTest();
        insert testContactsList;
        Test.stopTest();

        List<Contact> contactsAfterInsertList = [SELECT Do_Not_Contact__c, 
                                                    Exclude_from_Household_Name__c, 
                                                    Exclude_from_Household_Formal_Greeting__c,
                                                    Exclude_from_Household_Informal_Greeting__c, 
                                                    HasOptedOutOfEmail, 
                                                    DoNotCall, 
                                                    HasOptedOutOfFax
                                             FROM CONTACT 
                                             WHERE Id IN :testContactsList];

        for (Contact con : contactsAfterInsertList){
            System.assertEquals(false, con.Exclude_from_Household_Name__c, 'Contact should be excluded from Household Naming.');
            System.assertEquals(false, con.Exclude_from_Household_Formal_Greeting__c, 'Contact should be excluded from Household Formal Greeting.');
            System.assertEquals(false, con.Exclude_from_Household_Informal_Greeting__c, 'Contact should be excluded from Household Informal Greeting.');
            System.assertEquals(false, con.Do_Not_Contact__c, 'Contact should be marked as Do Not Contact.');
            System.assertEquals(false, con.HasOptedOutOfEmail, 'Contact should be opted out of receiving emails.');
            System.assertEquals(false, con.HasOptedOutOfFax, 'Contact should be opted out of receiving faxes.');
            System.assertEquals(false, con.DoNotCall, 'Contact should be opted out of receiving phone calls.');
        }
    }

    /**************************************************************************************************************************
    * @description Test method to verify that contacts updated from being deceased to not deceased are not excluded from 
    * from Household naming functionality and have the following fields automatically marked as false: 
    * Do Not Contact, Email Opt Out, Do Not Call, Do Not Fax
    */
    @isTest
    private static void updateContactDeceasedToFalse() {
        List<Contact> testContactsList = UTIL_UnitTestData_TEST.getMultipleTestContacts(5);
        
        for (Contact con : testContactsList){
            con.Deceased__c = true;
        }

        insert testContactsList;

        for (Contact con : testContactsList){
            con.Deceased__c = false; 
        }

        Test.startTest();
        update testContactsList;
        Test.stopTest();

        List<Contact> contactsAfterUpdateList = [SELECT Do_Not_Contact__c, 
                                                        Exclude_from_Household_Name__c, 
                                                        Exclude_from_Household_Formal_Greeting__c,
                                                        Exclude_from_Household_Informal_Greeting__c, 
                                                        HasOptedOutOfEmail, 
                                                        DoNotCall, 
                                                        HasOptedOutOfFax
                                                FROM CONTACT 
                                                WHERE Id IN :testContactsList];

        for (Contact con : contactsAfterUpdateList){
            System.assertEquals(false, con.Exclude_from_Household_Name__c, 'Contact should not be excluded from Household Naming.');
            System.assertEquals(false, con.Exclude_from_Household_Formal_Greeting__c, 'Contact should not be excluded from Household Formal Greeting.');
            System.assertEquals(false, con.Exclude_from_Household_Informal_Greeting__c, 'Contact should not be excluded from Household Informal Greeting.');
            System.assertEquals(false, con.Do_Not_Contact__c, 'Contact should not be marked as Do Not Contact.');
            System.assertEquals(false, con.HasOptedOutOfEmail, 'Contact should not be opted out of email.');
            System.assertEquals(false, con.DoNotCall, 'Contact should not be opted out of phone calls.');
            System.assertEquals(false, con.HasOptedOutOfFax, 'Contact should not be opted out of fax.');
        }
    }

    /**************************************************************************************************************************
    * @description Test method to verify that contacts updated as deceased are excluded from Household naming functionality
    * and have the following fields automatically marked as true: Do Not Contact, Email Opt Out, Do Not Call, Do Not Fax
    */
    @isTest
    private static void updateContactDeceasedToTrue() {
        List<Contact> testContactsList = UTIL_UnitTestData_TEST.getMultipleTestContacts(5);
        
        for (Contact con : testContactsList){
            con.Deceased__c = false;
        }

        insert testContactsList;

        for (Contact con : testContactsList){
            con.Deceased__c = true; 
        }

        Test.startTest();
        update testContactsList;
        Test.stopTest();

        List<Contact> contactsAfterUpdateList = [SELECT Do_Not_Contact__c, 
                                                        Exclude_from_Household_Name__c, 
                                                        Exclude_from_Household_Formal_Greeting__c,
                                                        Exclude_from_Household_Informal_Greeting__c, 
                                                        HasOptedOutOfEmail, 
                                                        DoNotCall, 
                                                        HasOptedOutOfFax
                                                FROM CONTACT 
                                                WHERE Id IN :testContactsList];

        for (Contact con : contactsAfterUpdateList){
            System.assertEquals(true, con.Exclude_from_Household_Name__c, 'Contact should be excluded from Household Naming.');
            System.assertEquals(true, con.Exclude_from_Household_Formal_Greeting__c, 'Contact should be excluded from Household Formal Greeting.');
            System.assertEquals(true, con.Exclude_from_Household_Informal_Greeting__c, 'Contact should be excluded from Household Informal Greeting.');
            System.assertEquals(true, con.Exclude_from_Household_Name__c, 'Contact should be excluded from Household Naming.');
            System.assertEquals(true, con.Exclude_from_Household_Formal_Greeting__c, 'Contact should be excluded from Household Formal Greeting.');
            System.assertEquals(true, con.Exclude_from_Household_Informal_Greeting__c, 'Contact should be excluded from Household Informal Greeting.');    
            System.assertEquals(true, con.Do_Not_Contact__c, 'Contact should be marked as Do Not Contact.');
            System.assertEquals(true, con.HasOptedOutOfEmail, 'Contact should be opted out of email.');
            System.assertEquals(true, con.DoNotCall, 'Contact should be opted out of phone calls.');
            System.assertEquals(true, con.HasOptedOutOfFax, 'Contact should be opted out of fax.');
        }
    }

    /**************************************************************************************************************************
    * @description Test method to verify that contacts inserted with "Do Not Contact" selected have the following communication
    * fields automatically updated to true: Email Opt Out, Do Not Call, Do Not Fax
    */
    @isTest
    private static void insertDoNotContactIsTrue() {
        List<Contact> testContactsList = UTIL_UnitTestData_TEST.getMultipleTestContacts(5);
        
        for (Contact con : testContactsList){
            con.Do_Not_Contact__c = true;
        }

        Test.startTest();
        insert testContactsList;
        Test.stopTest();

        List<Contact> contactsAfterInsertList = [SELECT DoNotCall, 
                                                        HasOptedOutOfEmail, 
                                                        HasOptedOutOfFax 
                                                FROM Contact 
                                                WHERE Id IN :testContactsList];

        for (Contact con : contactsAfterInsertList){
            System.assertEquals(true, con.DoNotCall, 'Contact should be opted out of phone calls.');
            System.assertEquals(true, con.HasOptedOutOfEmail, 'Contact should be opted out of email.');
            System.assertEquals(true, con.HasOptedOutOfFax, 'Contact should be opted out of fax.');    
        }
    }

    /**************************************************************************************************************************
    * @description Test method to verify that contacts inserted with "Do Not Contact" selected have the following communication
    * fields automatically updated to true: Email Opt Out, Do Not Call, Do Not Fax
    */
    @isTest
    private static void insertDoNotContactIsFalse() {
        List<Contact> testContactsList = UTIL_UnitTestData_TEST.getMultipleTestContacts(5);
        
        for (Contact con : testContactsList){
            con.Do_Not_Contact__c = false;
        }

        Test.startTest();
        insert testContactsList;
        Test.stopTest();

        List<Contact> contactsAfterInsertList = [SELECT DoNotCall, 
                                                        HasOptedOutOfEmail, 
                                                        HasOptedOutOfFax 
                                                FROM Contact 
                                                WHERE Id IN :testContactsList];

        for (Contact con : contactsAfterInsertList){
            System.assertEquals(false, con.DoNotCall, 'Contact should not be opted out of phone calls.');
            System.assertEquals(false, con.HasOptedOutOfEmail, 'Contact should not be opted out of email.');
            System.assertEquals(false, con.HasOptedOutOfFax, 'Contact should not be opted out of fax.');    
        }
    }

    /**************************************************************************************************************************
    * @description Test method to verify that contacts updated with "Do Not Contact" = true have the following fields 
    * automatically marked as true: Do Not Contact, Email Opt Out, Do Not Call, Do Not Fax
    */   
    @isTest
    private static void updateDoNotContactTotrue() {
        List<Contact> testContactsList = UTIL_UnitTestData_TEST.getMultipleTestContacts(5);
        
        for (Contact con : testContactsList){
            con.Do_Not_Contact__c = false;
        }

        insert testContactsList;

        for (Contact con : testContactsList){
            con.Do_Not_Contact__c = true;
        }

        Test.startTest();
        update testContactsList;
        Test.stopTest();

        List<Contact> contactsAfterUpdateList = [SELECT DoNotCall, 
                                                        HasOptedOutOfEmail, 
                                                        HasOptedOutOfFax 
                                                FROM Contact 
                                                WHERE Id IN :testContactsList];

        for (Contact con : contactsAfterUpdateList){
            System.assertEquals(true, con.DoNotCall, 'Contact should be opted out of phone calls.');
            System.assertEquals(true, con.HasOptedOutOfEmail, 'Contact should  be opted out of email.');
            System.assertEquals(true, con.HasOptedOutOfFax, 'Contact should be opted out of fax.');    
        }
    }

    /****************************************************************************************************************************
    * @description Test method to verify that contacts updated with "Do Not Contact" = False
    * have the following fields automatically marked as false: Do Not Contact, Email Opt Out, Do Not Call, Do Not Fax
    */  
    @isTest
    private static void updateDoNotContactToFalse() {
        List<Contact> testContactsList = UTIL_UnitTestData_TEST.getMultipleTestContacts(5);
        
        for (Contact con : testContactsList){
            con.Do_Not_Contact__c = true;
        }

        insert testContactsList;

        for (Contact con : testContactsList){
            con.Do_Not_Contact__c = false;
        }

        Test.startTest();
        update testContactsList;
        Test.stopTest();

        List<Contact> contactsAfterUpdateList = [SELECT DoNotCall, 
                                                        HasOptedOutOfEmail, 
                                                        HasOptedOutOfFax 
                                                FROM Contact 
                                                WHERE Id IN :testContactsList];

        for (Contact con : contactsAfterUpdateList){
            System.assertEquals(false, con.DoNotCall, 'Contact should not be opted out of phone calls.');
            System.assertEquals(false, con.HasOptedOutOfEmail, 'Contact should not  be opted out of email.');
            System.assertEquals(false, con.HasOptedOutOfFax, 'Contact should not be opted out of fax.');    
        }
    }

    /**************************************************************************************************************************************
    * @description Test method to verify that deceased contacts updated with "Do Not Contact" = false will remain excluded from household
    * naming functionality, but will have the following communication preferences automatically updated to false:
    * Email Opt Out, Do Not Call, Do Not Fax
    */  
    @isTest
    private static void updateDoNotContactToFalseOnADeceasedContact() {
        List<Contact> testContactsList = UTIL_UnitTestData_TEST.getMultipleTestContacts(5);
        
        for (Contact con : testContactsList){
            con.Deceased__c = true;
        }

        insert testContactsList;

        for (Contact con : testContactsList){
            con.Do_Not_Contact__c = false;
        }

        Test.startTest();
        update testContactsList;
        Test.stopTest();

        List<Contact> contactAfterUpdateList = [SELECT DoNotCall, 
                                                       HasOptedOutOfEmail, 
                                                       HasOptedOutOfFax,
                                                       Do_Not_Contact__c, 
                                                       Exclude_from_Household_Name__c,
                                                       Exclude_from_Household_Formal_Greeting__c, 
                                                       Exclude_from_Household_Informal_Greeting__c
                                               FROM Contact 
                                               WHERE Id IN :testContactsList];

        for (Contact con : contactAfterUpdateList){
            System.assertEquals(false, con.Do_Not_Contact__c, 'Contact should not be marked as Do Not Contact.');
            System.assertEquals(false, con.DoNotCall, 'Contact should not be opted out of phone calls.');
            System.assertEquals(false, con.HasOptedOutOfEmail, 'Contact should not be opted out of Email.');
            System.assertEquals(false, con.HasOptedOutOfFax, 'Contact should not be opted out of Fax.');
            System.assertEquals(true, con.Exclude_from_Household_Name__c, 'Contact should be excluded from Household Naming.');
            System.assertEquals(true, con.Exclude_from_Household_Formal_Greeting__c, 'Contact should be excluded from Household Formal Greeting.');
            System.assertEquals(true, con.Exclude_from_Household_Informal_Greeting__c, 'Contact should be excluded from Household Formal Greeting.');
        }
    }

    /**************************************************************************************************************************
    ****************************************************** UNIT TESTS *********************************************************
    **************************************************************************************************************************/

    /**************************************************************************************************************************
    * @description Test method to verify that syncDoNotContactFieldsOnContact synchronizes the following fields to true when 
    * "Do Not Contact" is selected: Email Opt Out, Do Not Call, Do Not Fax
    */
    @isTest
    private static void syncDoNotContactFieldsToPositive(){
        List<Contact> testContactList = UTIL_UnitTestData_TEST.getMultipleTestContacts(5);

        for (Contact con : testContactList){
            con.Do_Not_Contact__c = true;
        }

        Test.startTest();
        CON_DoNotContact_TDTM conDoNotContactTDTM = new CON_DoNotContact_TDTM();
        conDoNotContactTDTM.syncDoNotContactFieldsOnContacts(testContactList);
        Test.stopTest();

        for (Contact con : testContactList){
            System.assertEquals(true, con.HasOptedOutOfEmail, 'Contact should be opted out of emails.');
            System.assertEquals(true, con.DoNotCall, 'Contact should be opted out of phone calls.');
            System.assertEquals(true, con.HasOptedOutOfFax, 'Contact should be opted out of receiving faxes.');
        }
    }

    /**************************************************************************************************************************
    * @description Test method to verify that syncDoNotContactFieldsOnContact synchronizes the following fields to false when 
    * "Do Not Contact" is not selected: Email Opt Out, Do Not Call, Do Not Fax
    */
    @isTest
    private static void syncDoNotContactFieldsToNegative(){
        List<Contact> testContactList = UTIL_UnitTestData_TEST.getMultipleTestContacts(5);

        for (Contact con : testContactList){
            con.Do_Not_Contact__c = false;
        }

        Test.startTest();
        CON_DoNotContact_TDTM conDoNotContactTDTM = new CON_DoNotContact_TDTM();
        conDoNotContactTDTM.syncDoNotContactFieldsOnContacts(testContactList);
        Test.stopTest();

        for (Contact con : testContactList){
            System.assertEquals(false, con.HasOptedOutOfEmail, 'Contact should not be opted out of emails.');
            System.assertEquals(false, con.DoNotCall, 'Contact should not be opted out of phone calls.');
            System.assertEquals(false, con.HasOptedOutOfFax, 'Contact should not be opted out of receiving faxes.');
        }
    }

    /**************************************************************************************************************************
    * @description Test method to verify that syncDoNotContactFieldsOnContact synchronizes the following fields to false when 
    * a null value is set for "Do Not Contact": Email Opt Out, Do Not Call, Do Not Fax
    */
    @isTest
    private static void syncDoNotContactFieldsNull(){
        List<Contact> testContactList = UTIL_UnitTestData_TEST.getMultipleTestContacts(5);

        for (Contact con : testContactList){
            con.Do_Not_Contact__c = null;
        }

        Test.startTest();
        CON_DoNotContact_TDTM conDoNotContactTDTM = new CON_DoNotContact_TDTM();
        conDoNotContactTDTM.syncDoNotContactFieldsOnContacts(testContactList);
        Test.stopTest();

        for (Contact con : testContactList){
            System.assertEquals(false, con.HasOptedOutOfEmail, 'Contact should not be opted out of emails.');
            System.assertEquals(false, con.DoNotCall, 'Contact should not be opted out of phone calls.');
            System.assertEquals(false, con.HasOptedOutOfFax, 'Contact should not be opted out of receiving faxes.');
        }
    }

    /**************************************************************************************************************************
    * @description Test method to verify that syncNamingExclusionsOnContact excludes the following naming conventions  
    * when a contact has been marked as deceased: Household Name, Household Formal Greeting, Household Informal Greeting
    */
    @isTest 
    private static void syncNamingExclusionsPositive(){
        List<Contact> testContactList = UTIL_UnitTestData_TEST.getMultipleTestContacts(5);

        for (Contact con : testContactList){
            con.Deceased__c = true;
        }

        Test.startTest();
        CON_DoNotContact_TDTM conDoNotContactTDTM = new CON_DoNotContact_TDTM();
        conDoNotContactTDTM.syncNamingExclusionsOnContacts(testContactList);
        Test.stopTest();

        for (Contact con : testContactList){
            System.assertEquals(true, con.Exclude_from_Household_Name__c, 'Contact should be excluded from Household Naming.');
            System.assertEquals(true, con.Exclude_from_Household_Formal_Greeting__c, 'Contact should be excluded from Household Formal Greeting.');
            System.assertEquals(true, con.Exclude_from_Household_Informal_Greeting__c, 'Contact should be excluded from Household Informal Greeting.');
        }
    }

    /**************************************************************************************************************************
    * @description Test method to verify that syncNamingExclusionsOnContact removes all household naming exclusions   
    * when a contact is marked as being not deceased.
    */
    @isTest 
    private static void syncNamingExclusionsNegative(){
        List<Contact> testContactList = UTIL_UnitTestData_TEST.getMultipleTestContacts(5);

        for (Contact con : testContactList){
            con.Deceased__c = false;
        }

        Test.startTest();
        CON_DoNotContact_TDTM conDoNotContactTDTM = new CON_DoNotContact_TDTM();
        conDoNotContactTDTM.syncNamingExclusionsOnContacts(testContactList);
        Test.stopTest();

        for (Contact con : testContactList){
            System.assertEquals(false, con.Exclude_from_Household_Name__c, 'Contact should not be excluded from Household Naming.');
            System.assertEquals(false, con.Exclude_from_Household_Formal_Greeting__c, 'Contact should not be excluded from Household Formal Greeting.');
            System.assertEquals(false, con.Exclude_from_Household_Informal_Greeting__c, 'Contact should not be excluded from Household Informal Greeting.');
        }
    }

    /**************************************************************************************************************************
    * @description Test method to verify that syncNamingExclusionsOnContact removes all household naming exclusions   
    * when a null value is passed for Deceased.
    */
    @isTest 
    private static void syncNamingExclusionsNull(){
        List<Contact> testContactList = UTIL_UnitTestData_TEST.getMultipleTestContacts(5);

        for (Contact con : testContactList){
            con.Deceased__c = null;
        }

        Test.startTest();
        CON_DoNotContact_TDTM conDoNotContactTDTM = new CON_DoNotContact_TDTM();
        conDoNotContactTDTM.syncNamingExclusionsOnContacts(testContactList);
        Test.stopTest();

        for (Contact con : testContactList){
            System.assertEquals(false, con.Exclude_from_Household_Name__c, 'Contact should not be excluded from Household Naming.');
            System.assertEquals(false, con.Exclude_from_Household_Formal_Greeting__c, 'Contact should not be excluded from Household Formal Greeting.');
            System.assertEquals(false, con.Exclude_from_Household_Informal_Greeting__c, 'Contact should not be excluded from Household Informal Greeting.');
        }
    }

    /**************************************************************************************************************************
    * @description Test method to verify that processBeforeInsert excludes a deceased contact from all household naming
    * functionality and the following fields are set to true: Do Not Contact, Email Opt Out, Fax Opt Out, Do Not Call
    */
    @isTest 
    private static void processBeforeInsertDeceasedPositive(){
        List<Contact> testContactsList = UTIL_UnitTestData_TEST.getMultipleTestContacts(5);
        
        for (Contact con : testContactsList){
            con.Deceased__c = true;
        }

        Test.startTest();
        CON_DoNotContact_TDTM conDoNotContactTDTM = new CON_DoNotContact_TDTM();
        conDoNotContactTDTM.processBeforeInsert(testContactsList);
        Test.stopTest();

        List<Contact> contactsAfterInsertList = [SELECT Do_Not_Contact__c, 
                                                        Exclude_from_Household_Name__c, 
                                                        Exclude_from_Household_Formal_Greeting__c,
                                                        Exclude_from_Household_Informal_Greeting__c, 
                                                        HasOptedOutOfEmail, 
                                                        DoNotCall, 
                                                        HasOptedOutOfFax
                                                FROM CONTACT 
                                                WHERE Id IN :testContactsList];

        for (Contact con : contactsAfterInsertList){
            System.assertEquals(true, con.Exclude_from_Household_Name__c, 'Contact should be excluded from Household Naming.');
            System.assertEquals(true, con.Exclude_from_Household_Formal_Greeting__c, 'Contact should be excluded from Household Formal Greeting.');
            System.assertEquals(true, con.Exclude_from_Household_Informal_Greeting__c, 'Contact should be excluded from Household Informal Greeting.');
            System.assertEquals(true, con.Do_Not_Contact__c, 'Contact should be marked as Do Not Contact.');
            System.assertEquals(true, con.HasOptedOutOfEmail, 'Contact should be opted out of receiving emails.');
            System.assertEquals(true, con.HasOptedOutOfFax, 'Contact should be opted out of receiving faxes.');
            System.assertEquals(true, con.DoNotCall, 'Contact should be opted out of receiving phone calls.');
        }
    }

    /**************************************************************************************************************************
    * @description Test method to verify that processBeforeInsert does not exclude a living contact from any household naming
    * functionality and the following fields are set to false: Do Not Contact, Email Opt Out, Fax Opt Out, Do Not Call
    */
    @isTest 
    private static void processBeforeInsertDeceasedNegative(){
        List<Contact> testContactsList = UTIL_UnitTestData_TEST.getMultipleTestContacts(5);
        
        for (Contact con : testContactsList){
            con.Deceased__c = false;
        }

        Test.startTest();
        CON_DoNotContact_TDTM conDoNotContactTDTM = new CON_DoNotContact_TDTM();
        conDoNotContactTDTM.processBeforeInsert(testContactsList);
        Test.stopTest();

        List<Contact> contactsAfterInsertList = [SELECT Do_Not_Contact__c, 
                                                        Exclude_from_Household_Name__c, 
                                                        Exclude_from_Household_Formal_Greeting__c,
                                                        Exclude_from_Household_Informal_Greeting__c, 
                                                        HasOptedOutOfEmail, 
                                                        DoNotCall, 
                                                        HasOptedOutOfFax
                                                FROM CONTACT 
                                                WHERE Id IN :testContactsList];

        for (Contact con : contactsAfterInsertList){
            System.assertEquals(false, con.Exclude_from_Household_Name__c, 'Contact should not be excluded from Household Naming.');
            System.assertEquals(false, con.Exclude_from_Household_Formal_Greeting__c, 'Contact should not be excluded from Household Formal Greeting.');
            System.assertEquals(false, con.Exclude_from_Household_Informal_Greeting__c, 'Contact should note be excluded from Household Informal Greeting.');
            System.assertEquals(false, con.Do_Not_Contact__c, 'Contact should not be marked as Do Not Contact.');
            System.assertEquals(false, con.HasOptedOutOfEmail, 'Contact should not be opted out of receiving emails.');
            System.assertEquals(false, con.HasOptedOutOfFax, 'Contact should not be opted out of receiving faxes.');
            System.assertEquals(false, con.DoNotCall, 'Contact should note be opted out of receiving phone calls.');
        }
    }

    /**************************************************************************************************************************
    * @description Test method to verify that when Deceased is null, processBeforeInsert does not exclude a contact from any 
    * household naming functionality and the following fields are set to false: 
    * Do Not Contact, Email Opt Out, Fax Opt Out, Do Not Call
    */
    @isTest 
    private static void processBeforeInsertDeceasedNull(){
        List<Contact> testContactsList = UTIL_UnitTestData_TEST.getMultipleTestContacts(5);
        
        for (Contact con : testContactsList){
            con.Deceased__c = null;
        }

        Test.startTest();
        CON_DoNotContact_TDTM conDoNotContactTDTM = new CON_DoNotContact_TDTM();
        conDoNotContactTDTM.processBeforeInsert(testContactsList);
        Test.stopTest();

        List<Contact> contactsAfterInsertList = [SELECT Do_Not_Contact__c, 
                                                        Exclude_from_Household_Name__c, 
                                                        Exclude_from_Household_Formal_Greeting__c,
                                                        Exclude_from_Household_Informal_Greeting__c, 
                                                        HasOptedOutOfEmail, 
                                                        DoNotCall, 
                                                        HasOptedOutOfFax,
                                                        Account.Name 
                                                FROM CONTACT 
                                                WHERE Id IN :testContactsList];

        for (Contact con : contactsAfterInsertList){
            System.assertEquals(false, con.Exclude_from_Household_Name__c, 'Contact should not be excluded from Household Naming.');
            System.assertEquals(false, con.Exclude_from_Household_Formal_Greeting__c, 'Contact should not be excluded from Household Formal Greeting.');
            System.assertEquals(false, con.Exclude_from_Household_Informal_Greeting__c, 'Contact should note be excluded from Household Informal Greeting.');
            System.assertEquals(false, con.Do_Not_Contact__c, 'Contact should not be marked as Do Not Contact.');
            System.assertEquals(false, con.HasOptedOutOfEmail, 'Contact should not be opted out of receiving emails.');
            System.assertEquals(false, con.HasOptedOutOfFax, 'Contact should not be opted out of receiving faxes.');
            System.assertEquals(false, con.DoNotCall, 'Contact should not be opted out of receiving phone calls.');
        }
    }

    /**************************************************************************************************************************
    * @description Test method to verify that processBeforeInsert synchronizes the following fields to true when 
    * "Do Not Contact" is selected: Email Opt Out, Fax Opt Out, Do Not Call
    */
    @isTest 
    private static void processBeforeInsertDoNotContactPositive(){
        List<Contact> testContactsList = UTIL_UnitTestData_TEST.getMultipleTestContacts(5);
        
        for (Contact con : testContactsList){
            con.Do_Not_Contact__c = true;
        }

        Test.startTest();
        CON_DoNotContact_TDTM conDoNotContactTDTM = new CON_DoNotContact_TDTM();
        conDoNotContactTDTM.processBeforeInsert(testContactsList);
        Test.stopTest();

        List<Contact> contactsAfterInsertList = [SELECT Do_Not_Contact__c, 
                                                        HasOptedOutOfEmail, 
                                                        DoNotCall, 
                                                        HasOptedOutOfFax
                                                FROM CONTACT 
                                                WHERE Id IN :testContactsList];

        for (Contact con : contactsAfterInsertList){
            System.assertEquals(true, con.HasOptedOutOfEmail, 'Contact should be opted out of receiving emails.');
            System.assertEquals(true, con.HasOptedOutOfFax, 'Contact should be opted out of receiving faxes.');
            System.assertEquals(true, con.DoNotCall, 'Contact should be opted out of receiving phone calls.');
        }
    }

    /**************************************************************************************************************************
    * @description Test method to verify that processBeforeInsert synchronizes the following fields to false when 
    * "Do Not Contact" is not selected: Email Opt Out, Fax Opt Out, Do Not Call
    */
    @isTest 
    private static void processBeforeInsertDoNotContactNegative(){
        List<Contact> testContactsList = UTIL_UnitTestData_TEST.getMultipleTestContacts(5);
        
        for (Contact con : testContactsList){
            con.Do_Not_Contact__c = false;
        }

        Test.startTest();
        CON_DoNotContact_TDTM conDoNotContactTDTM = new CON_DoNotContact_TDTM();
        conDoNotContactTDTM.processBeforeInsert(testContactsList);
        Test.stopTest();

        List<Contact> contactsAfterInsertList = [SELECT Do_Not_Contact__c, 
                                                        HasOptedOutOfEmail, 
                                                        DoNotCall, 
                                                        HasOptedOutOfFax
                                                FROM CONTACT 
                                                WHERE Id IN :testContactsList];

        for (Contact con : contactsAfterInsertList){
            System.assertEquals(false, con.HasOptedOutOfEmail, 'Contact should not be opted out of receiving emails.');
            System.assertEquals(false, con.HasOptedOutOfFax, 'Contact should not be opted out of receiving faxes.');
            System.assertEquals(false, con.DoNotCall, 'Contact should not be opted out of receiving phone calls.');
        }
    }

    /**************************************************************************************************************************
    * @description Test method to verify that processBeforeInsert synchronizes the following fields to false when 
    * "Do Not Contact" is null: Email Opt Out, Fax Opt Out, Do Not Call
    */
    @isTest 
    private static void processBeforeInsertDoNotContactNull(){
        List<Contact> testContactsList = UTIL_UnitTestData_TEST.getMultipleTestContacts(5);
        
        for (Contact con : testContactsList){
            con.Do_Not_Contact__c = null;
        }

        Test.startTest();
        CON_DoNotContact_TDTM conDoNotContactTDTM = new CON_DoNotContact_TDTM();
        conDoNotContactTDTM.processBeforeInsert(testContactsList);
        Test.stopTest();

        List<Contact> contactsAfterInsertList = [SELECT Do_Not_Contact__c, 
                                                        HasOptedOutOfEmail, 
                                                        DoNotCall, 
                                                        HasOptedOutOfFax
                                                FROM CONTACT 
                                                WHERE Id IN :testContactsList];

        for (Contact con : contactsAfterInsertList){
            System.assertEquals(false, con.HasOptedOutOfEmail, 'Contact should not be opted out of receiving emails.');
            System.assertEquals(false, con.HasOptedOutOfFax, 'Contact should not be opted out of receiving faxes.');
            System.assertEquals(false, con.DoNotCall, 'Contact should not be opted out of receiving phone calls.');
        }
    }

    /**************************************************************************************************************************
    * @description Test method to verify that processBeforeUpdate excludes a deceased contact from household naming 
    * functionality and synchronizes the following fields to true: Email Opt Out, Fax Opt Out, Do Not Call
    */
    @isTest 
    private static void processBeforeUpdateDeceasedPositive(){
        List<Contact> testContactsList = UTIL_UnitTestData_TEST.getMultipleTestContacts(5);
        Map<Id, Contact> testContactsById = new Map<Id, Contact>();
        
        for (Contact con : testContactsList){
            String testId = UTIL_UnitTestData_TEST.getFakeId(Contact.sObjectType);

            Contact oldCon = con.clone(false);
            oldCon.Id = testId;
            oldCon.Deceased__c = false;
            testContactsById.put(testId, oldCon);

            con.Id = testId;
            con.Deceased__c = true;
        }

        Test.startTest();
        CON_DoNotContact_TDTM conDoNotContactTDTM = new CON_DoNotContact_TDTM();
        conDoNotContactTDTM.processBeforeUpdate(testContactsList, testContactsById);
        Test.stopTest();

        for (Contact con : testContactsList){
            System.assertEquals(true, con.Exclude_from_Household_Name__c, 'Contact should be excluded from Household Naming.');
            System.assertEquals(true, con.Exclude_from_Household_Formal_Greeting__c, 'Contact should be excluded from Household Formal Greeting.');
            System.assertEquals(true, con.Exclude_from_Household_Informal_Greeting__c, 'Contact should be excluded from Household Informal Greeting.');
            System.assertEquals(true, con.Do_Not_Contact__c, 'Contact should be marked as Do Not Contact.');
            System.assertEquals(true, con.HasOptedOutOfEmail, 'Contact should be opted out of receiving emails.');
            System.assertEquals(true, con.HasOptedOutOfFax, 'Contact should be opted out of receiving faxes.');
            System.assertEquals(true, con.DoNotCall, 'Contact should be opted out of receiving phone calls.');
        }
    }

    /**************************************************************************************************************************
    * @description Test method to verify that processBeforeUpdate does not exclude a living contact from household naming 
    * functionality and synchronizes the following fields to false: Email Opt Out, Fax Opt Out, Do Not Call
    */
    @isTest 
    private static void processBeforeInsertUpdateDeceasedNegative(){
        List<Contact> testContactsList = UTIL_UnitTestData_TEST.getMultipleTestContacts(5);
        Map<Id, Contact> testContactsById = new Map<Id, Contact>();
        
        for (Contact con : testContactsList){
            String testId = UTIL_UnitTestData_TEST.getFakeId(Contact.sObjectType);

            Contact oldCon = con.clone(false);
            oldCon.Id = testId;
            oldCon.Deceased__c = true;
            testContactsById.put(testId, oldCon);

            con.Id = testId;
            con.Deceased__c = false;
        }

        Test.startTest();
        CON_DoNotContact_TDTM conDoNotContactTDTM = new CON_DoNotContact_TDTM();
        conDoNotContactTDTM.processBeforeUpdate(testContactsList, testContactsById);
        Test.stopTest();

        for (Contact con : testContactsList){
            System.assertEquals(false, con.Exclude_from_Household_Name__c, 'Contact should not be excluded from Household Naming.');
            System.assertEquals(false, con.Exclude_from_Household_Formal_Greeting__c, 'Contact should not be excluded from Household Formal Greeting.');
            System.assertEquals(false, con.Exclude_from_Household_Informal_Greeting__c, 'Contact should not be excluded from Household Informal Greeting.');
            System.assertEquals(false, con.Do_Not_Contact__c, 'Contact should not be marked as Do Not Contact.');
            System.assertEquals(false, con.HasOptedOutOfEmail, 'Contact should not be opted out of receiving emails.');
            System.assertEquals(false, con.HasOptedOutOfFax, 'Contact should not be opted out of receiving faxes.');
            System.assertEquals(false, con.DoNotCall, 'Contact should not be opted out of receiving phone calls.');
        }
    }

    /**************************************************************************************************************************
    * @description Test method to verify that when Deceased is null, processBeforeUpdate does not exclude a contact from 
    * household naming functionality and synchronizes the following fields to false: Email Opt Out, Fax Opt Out, Do Not Call
    */
    @isTest 
    private static void processBeforeUpdateDeceasedNull(){
        List<Contact> testContactsList = UTIL_UnitTestData_TEST.getMultipleTestContacts(5);
        Map<Id, Contact> testContactsById = new Map<Id, Contact>();
        
        for (Contact con : testContactsList){
            String testId = UTIL_UnitTestData_TEST.getFakeId(Contact.sObjectType);

            Contact oldCon = con.clone(false);
            oldCon.Id = testId;
            oldCon.Deceased__c = true;
            testContactsById.put(testId, oldCon);

            con.Id = testId;
            con.Deceased__c = null;
        }

        Test.startTest();
        CON_DoNotContact_TDTM conDoNotContactTDTM = new CON_DoNotContact_TDTM();
        conDoNotContactTDTM.processBeforeUpdate(testContactsList, testContactsById);
        Test.stopTest();

        for (Contact con : testContactsList){
            System.assertEquals(false, con.Exclude_from_Household_Name__c, 'Contact should not be excluded from Household Naming.');
            System.assertEquals(false, con.Exclude_from_Household_Formal_Greeting__c, 'Contact should not be excluded from Household Formal Greeting.');
            System.assertEquals(false, con.Exclude_from_Household_Informal_Greeting__c, 'Contact should not be excluded from Household Informal Greeting.');
            System.assertEquals(false, con.Do_Not_Contact__c, 'Contact should not be marked as Do Not Contact.');
            System.assertEquals(false, con.HasOptedOutOfEmail, 'Contact should not be opted out of receiving emails.');
            System.assertEquals(false, con.HasOptedOutOfFax, 'Contact should not be opted out of receiving faxes.');
            System.assertEquals(false, con.DoNotCall, 'Contact should not be opted out of receiving phone calls.');
        }
    }

    /**************************************************************************************************************************
    * @description Test method to verify that when "Do Not Contact" is updated to checked, processBeforeUpdate synchronizes 
    * the following communication preference fields to true: Email Opt Out, Fax Opt Out, Do Not Call
    */
    @isTest 
    private static void processBeforeUpdateDoNotContactPositive(){
        List<Contact> testContactsList = UTIL_UnitTestData_TEST.getMultipleTestContacts(5);
        Map<Id, Contact> testContactsById = new Map<Id, Contact>();
        
        for (Contact con : testContactsList){
            String testId = UTIL_UnitTestData_TEST.getFakeId(Contact.sObjectType);

            Contact oldCon = con.clone(false);
            oldCon.Id = testId;
            oldCon.Do_Not_Contact__c = false;
            testContactsById.put(testId, oldCon);

            con.Id = testId;
            con.Do_Not_Contact__c = true;
        }

        Test.startTest();
        CON_DoNotContact_TDTM conDoNotContactTDTM = new CON_DoNotContact_TDTM();
        conDoNotContactTDTM.processBeforeUpdate(testContactsList, testContactsById);
        Test.stopTest();

        for (Contact con : testContactsList){
            System.assertEquals(true, con.HasOptedOutOfEmail, 'Contact should be opted out of receiving emails.');
            System.assertEquals(true, con.HasOptedOutOfFax, 'Contact should be opted out of receiving faxes.');
            System.assertEquals(true, con.DoNotCall, 'Contact should be opted out of receiving phone calls.');
        }
    }

    /**************************************************************************************************************************
    * @description Test method to verify that when "Do Not Contact" is updated to unchecked, processBeforeUpdate synchronizes 
    * the following communication preference fields to false: Email Opt Out, Fax Opt Out, Do Not Call
    */
    @isTest 
    private static void processBeforeUpdateDoNotContactNegative(){
        List<Contact> testContactsList = UTIL_UnitTestData_TEST.getMultipleTestContacts(5);
        Map<Id, Contact> testContactsById = new Map<Id, Contact>();
        
        for (Contact con : testContactsList){
            String testId = UTIL_UnitTestData_TEST.getFakeId(Contact.sObjectType);

            Contact oldCon = con.clone(false);
            oldCon.Id = testId;
            oldCon.Do_Not_Contact__c = true;
            testContactsById.put(testId, oldCon);

            con.Id = testId;
            con.Do_Not_Contact__c = false;
        }

        Test.startTest();
        CON_DoNotContact_TDTM conDoNotContactTDTM = new CON_DoNotContact_TDTM();
        conDoNotContactTDTM.processBeforeUpdate(testContactsList, testContactsById);
        Test.stopTest();

        for (Contact con : testContactsList){
            System.assertEquals(false, con.HasOptedOutOfEmail, 'Contact should not be opted out of receiving emails.');
            System.assertEquals(false, con.HasOptedOutOfFax, 'Contact should not be opted out of receiving faxes.');
            System.assertEquals(false, con.DoNotCall, 'Contact should not be opted out of receiving phone calls.');
        }
    }

    /**************************************************************************************************************************
    * @description Test method to verify that when "Do Not Contact" is updated to null, processBeforeUpdate synchronizes 
    * the following communication preference fields to false: Email Opt Out, Fax Opt Out, Do Not Call
    */
    @isTest 
    private static void processBeforeUpdateDoNotContactNull(){
        List<Contact> testContactsList = UTIL_UnitTestData_TEST.getMultipleTestContacts(5);
        Map<Id, Contact> testContactsById = new Map<Id, Contact>();
        
        for (Contact con : testContactsList){
            String testId = UTIL_UnitTestData_TEST.getFakeId(Contact.sObjectType);

            Contact oldCon = con.clone(false);
            oldCon.Id = testId;
            oldCon.Do_Not_Contact__c = true;
            testContactsById.put(testId, oldCon);

            con.Id = testId;
            con.Do_Not_Contact__c = null;
        }

        Test.startTest();
        CON_DoNotContact_TDTM conDoNotContactTDTM = new CON_DoNotContact_TDTM();
        conDoNotContactTDTM.processBeforeUpdate(testContactsList, testContactsById);
        Test.stopTest();

        for (Contact con : testContactsList){
            System.assertEquals(false, con.HasOptedOutOfEmail, 'Contact should not be opted out of receiving emails.');
            System.assertEquals(false, con.HasOptedOutOfFax, 'Contact should not be opted out of receiving faxes.');
            System.assertEquals(false, con.DoNotCall, 'Contact should not be opted out of receiving phone calls.');
        }
    }

    /**************************************************************************************************************************
    * @description Test method to verify that isBeforeInsert returns true for a BeforeInsert trigger action.
    */
    @isTest 
    private static void checkIsBeforeInsertPositive(){
        TDTM_Runnable.Action testAction = TDTM_Runnable.Action.BeforeInsert;

        CON_DoNotContact_TDTM conDoNotContactTDTM = new CON_DoNotContact_TDTM();
        System.assertEquals(true, conDoNotContactTDTM.isBeforeInsert(testAction), 'Trigger Action is BeforeInsert');
    }

    /**************************************************************************************************************************
    * @description Test method to verify that isBeforeInsert returns false when the trigger action is not BeforeInsert.
    */
    @isTest 
    private static void checkIsBeforeInsertNegative(){
        TDTM_Runnable.Action testAction = TDTM_Runnable.Action.AfterInsert;

        CON_DoNotContact_TDTM conDoNotContactTDTM = new CON_DoNotContact_TDTM();
        System.assertEquals(false, conDoNotContactTDTM.isBeforeInsert(testAction), 'Trigger Action is not BeforeInsert');
    }

    /**************************************************************************************************************************
    * @description Test method to verify that isBeforeUpdate returns true for a BeforeUpdate trigger action.
    */
    @isTest 
    private static void checkIsBeforeUpdatePositive(){
        TDTM_Runnable.Action testAction = TDTM_Runnable.Action.BeforeUpdate;

        CON_DoNotContact_TDTM conDoNotContactTDTM = new CON_DoNotContact_TDTM();
        System.assertEquals(true, conDoNotContactTDTM.isBeforeUpdate(testAction), 'Trigger Action is BeforeUpdate');
    }

    /**************************************************************************************************************************
    * @description Test method to verify that isBeforeUpdate returns false when the trigger action is not BeforeUpdate.
    */
    @isTest 
    private static void checkIsBeforeUpdateNegative(){
        TDTM_Runnable.Action testAction = TDTM_Runnable.Action.AfterUpdate;

        CON_DoNotContact_TDTM conDoNotContactTDTM = new CON_DoNotContact_TDTM();
        System.assertEquals(false, conDoNotContactTDTM.isBeforeUpdate(testAction), 'Trigger Action is not BeforeUpdate');
    }

    /**************************************************************************************************************************
    * @description Test method to verify that the run method excludes contact updated to deceased from household naming 
    * functionality and sets the following fields to true: Do Not Contact, Email Opt Out, Fax Opt Out, Do Not Call
    */
    @isTest 
    private static void fireBeforeUpdateDeceasedPositive(){
        List<SObject> newList = UTIL_UnitTestData_TEST.getMultipleTestContacts(5);
        List<SObject> oldList = new List<SObject>();

        TDTM_Runnable.Action triggerAction = TDTM_Runnable.Action.BeforeInsert;
        Schema.DescribeSObjectResult objResult = Schema.SObjectType.Contact;
        
        for (SObject so : newList){
            SObject oldObj = so.clone(false);
            oldObj.put('Deceased__c', false);
            oldList.add(oldObj);

            so.put('Deceased__c', true);
        }

        CON_DoNotContact_TDTM conDoNotContactTDTM = new CON_DoNotContact_TDTM();
        conDoNotContactTDTM.run(newList, oldList, triggerAction, objResult);

        for (Contact con : (List<Contact>)newList){
            System.assertEquals(true, con.Exclude_from_Household_Name__c, 'Contact should be excluded from Household Naming.');
            System.assertEquals(true, con.Exclude_from_Household_Formal_Greeting__c, 'Contact should be excluded from Household Formal Greeting.');
            System.assertEquals(true, con.Exclude_from_Household_Informal_Greeting__c, 'Contact should be excluded from Household Informal Greeting.');
            System.assertEquals(true, con.Do_Not_Contact__c, 'Contact should be marked as Do Not Contact.');
            System.assertEquals(true, con.HasOptedOutOfEmail, 'Contact should be opted out of receiving emails.');
            System.assertEquals(true, con.HasOptedOutOfFax, 'Contact should be opted out of receiving faxes.');
            System.assertEquals(true, con.DoNotCall, 'Contact should be opted out of receiving phone calls.');
        }
    }

    /**************************************************************************************************************************
    * @description Test method to verify that the run method clears household naming exclusions for contacts updated from 
    * being deceased and sets the following fields to false: Do Not Contact, Email Opt Out, Fax Opt Out, Do Not Call
    */
    @isTest 
    private static void fireBeforeUpdateDeceasedNegative(){
        List<SObject> newList = UTIL_UnitTestData_TEST.getMultipleTestContacts(5);
        List<SObject> oldList = new List<SObject>();

        TDTM_Runnable.Action triggerAction = TDTM_Runnable.Action.BeforeInsert;
        Schema.DescribeSObjectResult objResult = Schema.SObjectType.Contact;
        
        for (SObject so : newList){
            SObject oldObj = so.clone(false);
            oldObj.put('Deceased__c', true);
            oldList.add(oldObj);
            
            so.put('Deceased__c', false);
        }

        CON_DoNotContact_TDTM conDoNotContactTDTM = new CON_DoNotContact_TDTM();
        conDoNotContactTDTM.run(newList, oldList, triggerAction, objResult);

        for (Contact con : (List<Contact>)newList){
            System.assertEquals(false, con.Exclude_from_Household_Name__c, 'Contact should not be excluded from Household Naming.');
            System.assertEquals(false, con.Exclude_from_Household_Formal_Greeting__c, 'Contact should not be excluded from Household Formal Greeting.');
            System.assertEquals(false, con.Exclude_from_Household_Informal_Greeting__c, 'Contact should not be excluded from Household Informal Greeting.');
            System.assertEquals(false, con.Do_Not_Contact__c, 'Contact should not be marked as Do Not Contact.');
            System.assertEquals(false, con.HasOptedOutOfEmail, 'Contact should not be opted out of receiving emails.');
            System.assertEquals(false, con.HasOptedOutOfFax, 'Contact should not be opted out of receiving faxes.');
            System.assertEquals(false, con.DoNotCall, 'Contact should not be opted out of receiving phone calls.');
        }
    }

    /**************************************************************************************************************************
    * @description Test method to verify that the run method sets the following fields to true for contacts when the  
    * "Do Not Contact" field is updated to checked: Email Opt Out, Fax Opt Out, Do Not Call
    */
    @isTest 
    private static void fireBeforeUpdateDoNotContactPositive(){
        List<SObject> newList = UTIL_UnitTestData_TEST.getMultipleTestContacts(5);
        List<SObject> oldList = new List<SObject>();

        TDTM_Runnable.Action triggerAction = TDTM_Runnable.Action.BeforeInsert;
        Schema.DescribeSObjectResult objResult = Schema.SObjectType.Contact;
        
        for (SObject so : newList){
            SObject oldObj = so.clone(false);
            oldObj.put('Do_Not_Contact__c', false);
            oldList.add(oldObj);

            so.put('Do_Not_Contact__c', true);
        }

        CON_DoNotContact_TDTM conDoNotContactTDTM = new CON_DoNotContact_TDTM();
        conDoNotContactTDTM.run(newList, oldList, triggerAction, objResult);

        for (Contact con : (List<Contact>)newList){
            System.assertEquals(true, con.HasOptedOutOfEmail, 'Contact should be opted out of receiving emails.');
            System.assertEquals(true, con.HasOptedOutOfFax, 'Contact should be opted out of receiving faxes.');
            System.assertEquals(true, con.DoNotCall, 'Contact should be opted out of receiving phone calls.');
        }
    }

    /**************************************************************************************************************************
    * @description Test method to verify that the run method sets the following fields to false for contacts when the  
    * "Do Not Contact" field is updated to unchecked: Email Opt Out, Fax Opt Out, Do Not Call
    */
    @isTest 
    private static void fireBeforeUpdateDoNotContactNegative(){
        List<SObject> newList = UTIL_UnitTestData_TEST.getMultipleTestContacts(5);
        List<SObject> oldList = new List<SObject>();

        TDTM_Runnable.Action triggerAction = TDTM_Runnable.Action.BeforeInsert;
        Schema.DescribeSObjectResult objResult = Schema.SObjectType.Contact;
        
        for (SObject so : newList){
            SObject oldObj = so.clone(false);
            oldObj.put('Do_Not_Contact__c', true);
            oldList.add(oldObj);
            
            so.put('Do_Not_Contact__c', false);
        }

        CON_DoNotContact_TDTM conDoNotContactTDTM = new CON_DoNotContact_TDTM();
        conDoNotContactTDTM.run(newList, oldList, triggerAction, objResult);

        for (Contact con : (List<Contact>)newList){
            System.assertEquals(false, con.HasOptedOutOfEmail, 'Contact should not be opted out of receiving emails.');
            System.assertEquals(false, con.HasOptedOutOfFax, 'Contact should not be opted out of receiving faxes.');
            System.assertEquals(false, con.DoNotCall, 'Contact should not be opted out of receiving phone calls.');
        }
    }

    /**************************************************************************************************************************
    * @description Test method to verify that the run method excludes inserted deceased contacts from household naming 
    * functionality and sets the following fields to true: Do Not Contact, Email Opt Out, Fax Opt Out, Do Not Call
    */
    @isTest 
    private static void fireBeforeInsertDeceasedPositive(){
        List<SObject> newList = UTIL_UnitTestData_TEST.getMultipleTestContacts(5);
        List<SObject> oldList = null;

        TDTM_Runnable.Action triggerAction = TDTM_Runnable.Action.BeforeInsert;
        Schema.DescribeSObjectResult objResult = Schema.SObjectType.Contact;
        
        for (SObject so : newList){
            so.put('Deceased__c', true);
        }

        CON_DoNotContact_TDTM conDoNotContactTDTM = new CON_DoNotContact_TDTM();
        conDoNotContactTDTM.run(newList, oldList, triggerAction, objResult);

        for (Contact con : (List<Contact>)newList){
            System.assertEquals(true, con.Exclude_from_Household_Name__c, 'Contact should be excluded from Household Naming.');
            System.assertEquals(true, con.Exclude_from_Household_Formal_Greeting__c, 'Contact should be excluded from Household Formal Greeting.');
            System.assertEquals(true, con.Exclude_from_Household_Informal_Greeting__c, 'Contact should be excluded from Household Informal Greeting.');
            System.assertEquals(true, con.Do_Not_Contact__c, 'Contact should be marked as Do Not Contact.');
            System.assertEquals(true, con.HasOptedOutOfEmail, 'Contact should be opted out of receiving emails.');
            System.assertEquals(true, con.HasOptedOutOfFax, 'Contact should be opted out of receiving faxes.');
            System.assertEquals(true, con.DoNotCall, 'Contact should be opted out of receiving phone calls.');
        }
    }

    /**************************************************************************************************************************
    * @description Test method to verify that the run method does not exclude inserted living contacts from household naming 
    * functionality and sets the following fields to false: Do Not Contact, Email Opt Out, Fax Opt Out, Do Not Call
    */
    @isTest 
    private static void fireBeforeInsertDeceasedNegative(){
        List<SObject> newList = UTIL_UnitTestData_TEST.getMultipleTestContacts(5);
        List<SObject> oldList = null;

        TDTM_Runnable.Action triggerAction = TDTM_Runnable.Action.BeforeInsert;
        Schema.DescribeSObjectResult objResult = Schema.SObjectType.Contact;
        
        for (SObject so : newList){
            so.put('Deceased__c', false);
        }

        CON_DoNotContact_TDTM conDoNotContactTDTM = new CON_DoNotContact_TDTM();
        conDoNotContactTDTM.run(newList, oldList, triggerAction, objResult);

        for (Contact con : (List<Contact>)newList){
            System.assertEquals(false, con.Exclude_from_Household_Name__c, 'Contact should not be excluded from Household Naming.');
            System.assertEquals(false, con.Exclude_from_Household_Formal_Greeting__c, 'Contact should not be excluded from Household Formal Greeting.');
            System.assertEquals(false, con.Exclude_from_Household_Informal_Greeting__c, 'Contact should not be excluded from Household Informal Greeting.');
            System.assertEquals(false, con.Do_Not_Contact__c, 'Contact should not be marked as Do Not Contact.');
            System.assertEquals(false, con.HasOptedOutOfEmail, 'Contact should not be opted out of receiving emails.');
            System.assertEquals(false, con.HasOptedOutOfFax, 'Contact should not be opted out of receiving faxes.');
            System.assertEquals(false, con.DoNotCall, 'Contact should not be opted out of receiving phone calls.');
        }
    }

    /**************************************************************************************************************************
    * @description Test method to verify that the run method synchronizes the following to fields to true when contacts are
    * inserted with "Do Not Contact" selected: Email Opt Out, Fax Opt Out, Do Not Call
    */
    @isTest 
    private static void fireBeforeInsertDoNotContactPositive(){
        List<SObject> newList = UTIL_UnitTestData_TEST.getMultipleTestContacts(5);
        List<SObject> oldList = null;

        TDTM_Runnable.Action triggerAction = TDTM_Runnable.Action.BeforeInsert;
        Schema.DescribeSObjectResult objResult = Schema.SObjectType.Contact;
        
        for (SObject so : newList){
            so.put('Do_Not_Contact__c', true);
        }

        CON_DoNotContact_TDTM conDoNotContactTDTM = new CON_DoNotContact_TDTM();
        conDoNotContactTDTM.run(newList, oldList, triggerAction, objResult);

        for (Contact con : (List<Contact>)newList){
            System.assertEquals(true, con.HasOptedOutOfEmail, 'Contact should be opted out of receiving emails.');
            System.assertEquals(true, con.HasOptedOutOfFax, 'Contact should be opted out of receiving faxes.');
            System.assertEquals(true, con.DoNotCall, 'Contact should be opted out of receiving phone calls.');
        }
    }

    /**************************************************************************************************************************
    * @description Test method to verify that the run method synchronizes the following to fields to false when contacts are
    * inserted with "Do Not Contact" unchecked: Email Opt Out, Fax Opt Out, Do Not Call
    */
    @isTest 
    private static void fireBeforeInsertDoNotContactNegative(){
        List<SObject> newList = UTIL_UnitTestData_TEST.getMultipleTestContacts(5);
        List<SObject> oldList = null;

        TDTM_Runnable.Action triggerAction = TDTM_Runnable.Action.BeforeInsert;
        Schema.DescribeSObjectResult objResult = Schema.SObjectType.Contact;
        
        for (SObject so : newList){
            so.put('Do_Not_Contact__c', false);
        }

        CON_DoNotContact_TDTM conDoNotContactTDTM = new CON_DoNotContact_TDTM();
        conDoNotContactTDTM.run(newList, oldList, triggerAction, objResult);

        for (Contact con : (List<Contact>)newList){
            System.assertEquals(false, con.HasOptedOutOfEmail, 'Contact should not be opted out of receiving emails.');
            System.assertEquals(false, con.HasOptedOutOfFax, 'Contact should not be opted out of receiving faxes.');
            System.assertEquals(false, con.DoNotCall, 'Contact should not be opted out of receiving phone calls.');
        }
    }
}
/*
    Copyright (c) 2019 Salesforce.org
    All rights reserved.

    Redistribution and use in source and binary forms, with or without
    modification, are permitted provided that the following conditions are met:

    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
    * Neither the name of Salesforce.org nor the names of
      its contributors may be used to endorse or promote products derived
      from this software without specific prior written permission.

    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
    "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
    LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
    FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
    COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
    INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
    BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
    LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
    CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
    LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
    ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
    POSSIBILITY OF SUCH DAMAGE.
/**
* @author Salesforce.org
* @date 2019
* @group Contacts
* @group-content ../../ApexDocContent/Contacts.htm
* @description Handles processing of Contact Preferred Phone. Copies custom Phone fields to the standard field.
* Ensures a phone is selected when Preferred phone is set.
*/
public with sharing class CON_Phone {
    /*******************************************************************************************************
    * @description Sets the Phone field depending on the value of Preferred Phone
    * @param Contact the contact to update
    * @param oldlist list of old contacts from update or delete context of a trigger
    */
     
    public static void processPreferredPhone(Contact contact, Contact oldContact, Boolean validatePreferredPhone, String selectedPreferredPhone) {
        
        // No need to run if we are in a delete context
        if (contact == null) {
            return;
        }

         Boolean isUpdate = (oldContact != null) ? true : false;

        // Build the list of phone fields
        CON_PhoneFieldList phoneFields = new CON_PhoneFieldList(contact);

        if( phoneFields.valuedFields.size() > 0 ) {
            // Check the presence of a special cases when running a batch process.
            // This will prevent some validation errors below to allow batches to complete successfully.
            if( validatePreferredPhone && System.isBatch() ) {
                   
                // Catch a special case when there is a value in Phone that doesn't match the 
                // other fields and Preferred Phone is blank
                if(String.isNotBlank(contact.Phone) && phoneFields.valueExists(contact.Phone) == null && String.isBlank(contact.PreferredPhone__c)) {
                   
                    contact.PreferredPhone__c = Label.preferredBatchDefaultPhone;
                }

                // Process when Phone matches an existing value
                if(String.isNotBlank(contact.Phone) && phoneFields.valueExists(contact.Phone) != null && String.isBlank(contact.PreferredPhone__c)) {
                    contact.PreferredPhone__c = phoneFields.valueExists(contact.Phone).prefLabel;
                }

                // We are catching a special case here when there are multiple Phones but Phone is blank.
                // If there is only one custom Phone present, we will set it as preferred. When multiple
                // Phones are present the first in the list will be set to preferred if a selection
                // is not made in EDA settings.
                if(String.isBlank(contact.Phone) ) {
                    
                    if (phoneFields.valuedFields.size() > 1 && String.isNotEmpty(selectedPreferredPhone)) {
                    
                        for (CON_PhoneField eachField : phoneFields.valuedFields)  {
                                                     
                            if (eachField.apiName == selectedPreferredPhone) {
                                
                                setPhoneFields(contact, eachField.value, eachField.prefLabel);
                                break;
                            }    
                            
                        }

                        if (contact.Phone == NULL && Contact.PreferredPhone__c == NULL) {
                              setPhoneFields(contact, phoneFields.valuedFields[0].value, phoneFields.valuedFields[0].prefLabel);
                        }
                    }
                    
                     // Get the first item from the list either one or many
                     
                    else {
                        setPhoneFields(contact, phoneFields.valuedFields[0].value, phoneFields.valuedFields[0].prefLabel);
                    }
                }
            }

            // Only one phone field, so we can intelligently set Preferred Phone.
            if(validatePreferredPhone && phoneFields.valuedFields.size() == 1 && String.isBlank(contact.PreferredPhone__c)){
                setPhoneFields(contact, phoneFields.valuedFields[0].value, phoneFields.valuedFields[0].prefLabel);
                
            // Enforce Preferred Phone field unless validation is disabled
            } else if(validatePreferredPhone && String.isBlank(contact.PreferredPhone__c)){

                contact.addError( Label.PreferredPhoneRequiredError );

            // Check if the field selected for Preferred Phone matches the label
            // throw an error if it doesn't match or update according if there is a match
            } else if ( String.isNotBlank(contact.PreferredPhone__c) && contact.PreferredPhone__c != Label.preferredBatchDefaultPhone && contact.PreferredPhone__c != phoneFields.phoneLabel ) {

                CON_PhoneField field = phoneFields.getFieldByPrefLabel(contact.PreferredPhone__c);
                if( field != null) {
                    // Make sure we are not setting to a blank value
                    if(String.isNotBlank(field.value)) {
                        // Copy the value that matches preferred Phone to the standard Phone field
                        contact.Phone = field.value;
                    } else {
                        contact.addError(Label.PreferredPhoneMatchNotNull);
                    }

                // Make sure the value in Preferred Phone matches an actual field 
                } else {
                    contact.addError(Label.PreferredPhoneMatchMustExist);
                }
            }

        } else {
                   
            // Cannot have Preferred Phone set if there are no phones present
            if( String.isNotBlank(contact.PreferredPhone__c)) {
                contact.addError(Label.PreferredPhoneMatchNotNull);
            }

            // We are not going to format data for orgs that are not enforcing the Preferred Phone field
            if(validatePreferredPhone && String.isNotBlank(contact.Phone)) {

                // oldlist is NULL on insert so we check to make sure this logic only applies on updates.
                // We make sure this isn't a batch, because the batch relies on this trigger while
                // updating contacts
                if( isUpdate && !System.isBatch() ) {
                   // Map<ID, Contact> oldmap = new Map<ID, Contact>( (List<Contact>)oldlist);

                    // Get the old phone values - if any - to compare.
                    //CON_PhoneFieldList oldPhoneFields = new CON_PhoneFieldList( oldmap.get(contact.Id) );
                     CON_PhoneFieldList oldPhoneFields = new CON_PhoneFieldList(Oldcontact);
                    // If this is an update and the contact contained previous phones we want to clear the standard phone field
                    // we do this because when a user deletes all phone values in the EDA contact without clearing
                    // the value if phone, there would be an phone number that the user tried to delete.
                    if (oldPhoneFields.valuedFields.size() > 0) {
                        contact.Phone = null;
                    } else {

                        copyStdPhoneToOther(contact, phoneFields);
                    }
                } else {

                    copyStdPhoneToOther(contact, phoneFields);
                }
            }
        }


    } 

    /*******************************************************************************************************
    * @description Copies the value of the standard Phone field to the Other Phone field if Phone has a value and no other phones.
    * @param contact the contact to change
    * @param fieldList an instance of the CON_PhoneFieldList class
    */
    public static void copyStdPhoneToOther(Contact contact, CON_PhoneFieldList fieldList) {
        if(contact.Phone != null) {

            // Retrieve field from field list using the known API name.
            CON_PhoneField otherField = fieldList.getFieldByApiName('OtherPhone');

                contact.PreferredPhone__c = otherField.prefLabel;
                contact.OtherPhone = contact.Phone;          
        }
    }
    
    private static Map<String, String> preferredPhoneLabelToAPI;

    /*******************************************************************************************************
    * @description Returns a map with Preferred Phone picklist entry's label as key and API as value
    * @return  preferredPhoneLabelToAPI A Map<String, String> with key value pair of Preferred Phone picklist entrys's label and API respectively
    */
    private static Map<String, String> createPreferredLabelToAPIMap() {   
        if (preferredPhoneLabelToAPI == NULL) {          
            String namespace = UTIL_Namespace.getNamespace();
            String prefix = (String.isNotBlank(namespace)) ? namespace + '__' : '';
            preferredPhoneLabelToAPI =  UTIL_Describe.getpicklistEntriesLabelToAPIMap('Contact', prefix+'preferredPhone__c');
        }
        return preferredPhoneLabelToAPI;            
    }
    
    /*******************************************************************************************************
    * @description Copies the value of the standard Phone field to the Other Phone field if Phone has a value and no other phones.
    * @param contact the contact to change
    * @param phone the value that needs to be set for standard phone
    * @param preferredPhone the preferred phone label
    */

    private static void setPhoneFields(Contact contact, String phone, String preferredPhone) {
        contact.Phone = phone;
        contact.PreferredPhone__c = preferredPhone;
    }

    private static Map<String, Schema.DescribeFieldResult> contactPhoneFieldMap;

    /*******************************************************************************************************
    * @description An inner wrapper class to contain a list of phone fields and perform functions on them
    */

    private class CON_PhoneFieldList {

        private List<CON_PhoneField> allFields {get;set;}
        private List<CON_PhoneField> valuedFields {get;set;}
        public String phoneLabel {get;set;}
        
        /************************************************************
        *@description Constructor for the wrapper class
        *@param Contact in context
        */

        public CON_PhoneFieldList(Contact contact) {

            this.allFields = new List<CON_PhoneField>();
            this.valuedFields = new List<CON_PhoneField>();

            if (contactPhoneFieldMap == null) {
                contactPhoneFieldMap = UTIL_Describe.getFieldsOfType('Contact', 'Phone');
            }
            this.phoneLabel = contactPhoneFieldMap.get('Phone').getLabel();

            Map<String, String> edaPhoneField = new Map<String, String>();
            //build map for EDA phone field map (Label, API Name)
            for(String fieldName : contactPhoneFieldMap.keySet() ) {
                if(String.isNotBlank(UTIL_Namespace.getNamespace()) && fieldName.startsWithIgnoreCase(UTIL_Namespace.getNamespace())) {
                    edaPhoneField.put(contactPhoneFieldMap.get(fieldName).getLabel(), fieldName);
                }
            }

            for(String fieldName : contactPhoneFieldMap.keySet()) {
                String fieldLabel = contactPhoneFieldMap.get(fieldName).getLabel();
                
                // Add the phone field to valued fields if it is not a standard phone
                // If named field check if it is in edaPhoneField Map
                if (fieldName != 'Phone' && !(edaPhoneField.get(fieldLabel) != null && fieldName != edaPhoneField.get(fieldLabel))){
                    String phoneField = (String)contact.get(fieldName);

                    allFields.add(new CON_PhoneField(phoneField, fieldLabel, fieldName));
                    if(String.isNotBlank(phoneField)) {
                        valuedFields.add(new CON_PhoneField(phoneField, fieldLabel, fieldName));
                    }
                }
            }
        }

        public CON_PhoneField getFieldByPrefLabel(String labelSearch) {
            labelSearch = getCustomPicklistValue(labelSearch);
            for(CON_PhoneField field : this.allFields) {
                if (labelSearch == field.label || labelSearch == field.prefLabel) {
                    return field;
                }
            }
            return null;
        }

        public CON_PhoneField getFieldByApiName(String apiSearch) {
            for(CON_PhoneField field : this.allFields) {
                if (apiSearch == field.apiName ) {
                    return field;
                }
            }
            return null;
        }

        private CON_PhoneField valueExists(String search) {
            for(CON_PhoneField field : this.valuedFields ){
                if(String.isNotBlank(search) && field.value == search){
                    return field;
                }
            }
            return null;
        }

        //Check if transalted picklist value of preferred phone exist
        private String getCustomPicklistValue(String labelSearch) {       
            Map<String,String> apiLabelMappings = new Map<String,String>();       
            Schema.DescribeFieldResult fieldResult = Contact.PreferredPhone__c.getDescribe();
            List<Schema.PicklistEntry> picklistEntries = fieldResult.getPicklistValues();
            for( Schema.PicklistEntry entry : fieldResult.getPicklistValues()) {
                if (entry.getValue() == labelSearch) {
                    return entry.getLabel();
                }
            }
            return labelSearch;         
        }

    }

    /*******************************************************************************************************
    * @description An inner wrapper class to represent a phone field on a contact
    */
    private class CON_PhoneField {

        public String value {get;set;}
        public String label {get;set;}
        public String apiName {get;set;}
        public String prefLabel {get;set;}
        
        /*******************************************************************************************************
        Constructor for wrapper class
        * @param val The value of the phone field
        * @param lbl The label of the phone field
        * @param api The API name of the phone field
        */
        public CON_PhoneField(String val, String lbl, String api ) {
            // Store default phone field mappings to Preferred Phone picklist values prior to EDA 1.86.
            // The mapping is used when Preferred Phone picklist values do not match corresponding the field labels.
            Map<String,String> preferredPhoneMappings = new Map<String,String>{
                'Home Phone' => 'Home',
                'Work Phone' => 'Work',
                'Mobile Phone' => 'Mobile',
                'Other Phone' => 'Other'
            };
            
            this.value = val;
            this.label = lbl;
            this.apiName = api;
            
            Map<String, String> preferredLabelToApi = createPreferredLabelToAPIMap();
            
            /* If the field label is not in Preferrred Phone picklist API values then check if it is in PreferredPhoneMappings, if yes then take the value from mappings
             else keep the label as label. If the field label is in the Preferrred Phone picklist API values then assign the picklist API value that matches the field label
             such that Preferred Phone field will reflect the translated value when users use a language that is not English. */
            if (!PreferredLabelToApi.keySet().contains(lbl)) {
                this.prefLabel = (preferredPhoneMappings.containsKey(lbl)) ? preferredPhoneMappings.get(lbl) : lbl;
            } else {            
                 this.prefLabel = PreferredLabelToApi.get(lbl);
            }
            
        }
        
    }   
}
/*
    Copyright (c) 2019, Salesforce.org
    All rights reserved.

    Redistribution and use in source and binary forms, with or without
    modification, are permitted provided that the following conditions are met:

    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
    * Neither the name of Salesforce.org nor the names of
      its contributors may be used to endorse or promote products derived
      from this software without specific prior written permission.

    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
    "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
    LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
    FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
    COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
    INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
    BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
    LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
    CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
    LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
    ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
    POSSIBILITY OF SUCH DAMAGE.
*/
/**
 * @author Salesforce.org
 * @date 2019
 * @group Contacts
 * @group-content ../../ApexDocContent/Contacts.htm
 * @description Unit tests for Preferred Phone
 */
@isTest
private class CON_PreferredPhone_TEST {
    private static Hierarchy_Settings__c enablePreferredPhone() {
        return UTIL_CustomSettingsFacade.getSettingsForTests(
            new Hierarchy_Settings__c(
                Disable_Preferred_Phone_Enforcement__c = false,
                Enable_New_Preferred_Phone_Sync__c = true
            )
        );
    }

    private static Hierarchy_Settings__c disablePreferredPhone() {
        return UTIL_CustomSettingsFacade.getSettingsForTests(
            new Hierarchy_Settings__c(
                Disable_Preferred_Phone_Enforcement__c = true,
                Enable_New_Preferred_Phone_Sync__c = false
            )
        );
    }

    /* When Preferred Phone is blank and the count of valued phone fields is one
        update Preferred Phone to label of valued phone and copy the value to 
        standard Phone.
    */
    @isTest
    static void testSinglePhoneSmartSet() {
        enablePreferredPhone();

        Contact newCont = new Contact(FirstName = 'JohnnyTest1', LastName = 'JohnnyTest', WorkPhone__c = '1234567890');

        Test.startTest();
        insert newCont;
        Test.stopTest();

        Contact newContAfter = [
            SELECT Id, FirstName, LastName, Name, WorkPhone__c, Phone, PreferredPhone__c
            FROM Contact
        ];

        System.assertEquals(newContAfter.Phone, newContAfter.WorkPhone__c);
        System.assertEquals('Work Phone', newContAfter.PreferredPhone__c);
    }

    /* When Preferred Phone is defined and the count of valued phone fields is more
        then one, the Preferred Phone field will be used.
        Test Scenario: T-3903365
    */
    @isTest
    static void testMultiplePhoneSmartSetEnforced() {
        enablePreferredPhone();

        Test.startTest();
        insert new Contact(
            FirstName = 'JohnnyTest1',
            LastName = 'JohnnyTest',
            WorkPhone__c = '1234567890',
            HomePhone = '2345678901',
            OtherPhone = '3456789012',
            PreferredPhone__c = 'Work Phone'
        );
        Test.stopTest();

        Contact newContAfter = getCurrentContact();
        System.assertEquals(newContAfter.Phone, newContAfter.WorkPhone__c);
        System.assertEquals('Work Phone', newContAfter.PreferredPhone__c);
    }

    /*
     * When Preferred Phone is blank and the count of valued phone fields is one
     * update Preferred Phone to label of valued phone and copy the value to
     * standard Phone.
     * Test Scenario: T-3903367
     */
    @isTest
    static void testMultiplePhoneSmartSetUnenforced() {
        disablePreferredPhone();

        Test.startTest();
        insert new Contact(
            FirstName = 'JohnnyTest1',
            LastName = 'JohnnyTest',
            HomePhone = '2345678901',
            WorkPhone__c = '1234567890',
            OtherPhone = '3456789012',
            PreferredPhone__c = 'Other Phone'
        );
        Test.stopTest();

        Contact newContAfter = getCurrentContact();
        System.assertEquals(newContAfter.Phone, newContAfter.OtherPhone);

        newContAfter.PreferredPhone__c = 'Work Phone';
        update newContAfter;
        newContAfter = getCurrentContact();

        System.assertEquals(newContAfter.Phone, newContAfter.WorkPhone__c);
    }

    /* When Standard Phone is not null and Preferred Phone is enforced update Preferred Phone
       to Other and update Other Phone to the value of Standard Phone.
    */
    @isTest
    static void testUpdatePrefPhoneToOther() {
        enablePreferredPhone();

        Contact newCont = new Contact(FirstName = 'JohnnyTest1', LastName = 'JohnnyTest');
        insert newCont;

        Test.startTest();
        newCont.Phone = '0000000000';
        update newCont;
        Test.stopTest();

        Contact newContAfter = getCurrentContact();
        System.assertEquals('0000000000', newContAfter.OtherPhone);
        System.assertEquals('Other Phone', newContAfter.PreferredPhone__c);
    }

    /* Clear the value in Standard Phone when the other valued Phone is cleared
     *  Test Scenario: T-3903368
     */
    @isTest
    static void testClearPhoneValue() {
        enablePreferredPhone();

        insert new Contact(
            FirstName = 'JohnnyTest1',
            LastName = 'JohnnyTest',
            Phone = '111111111',
            HomePhone = '2345678901',
            WorkPhone__c = '1234567890',
            OtherPhone = '3456789012',
            PreferredPhone__c = 'Work Phone'
        );

        Contact newContAfter = getCurrentContact();
        Test.startTest();
        newContAfter.WorkPhone__c = 'JJJJJ';
        update newContAfter;
        Test.stopTest();

        newContAfter = getCurrentContact();
        System.assertEquals('JJJJJ', newContAfter.Phone);
    }

    /* Update standard Phone's value to another valued phone's and update Preferred Phone to
     the label of another Phone.  */
    @isTest
    static void testOnClearOther() {
        enablePreferredPhone();

        Contact newCont = new Contact(
            FirstName = 'JohnnyTest1',
            LastName = 'JohnnyTest',
            WorkPhone__c = '111111111',
            PreferredPhone__c = 'Work Phone',
            OtherPhone = '0000000000'
        );
        insert newCont;

        Contact newContAfter = getCurrentContact();
        Test.startTest();
        newContAfter.WorkPhone__c = '';
        newContAfter.PreferredPhone__c = '';
        update newContAfter;
        Test.stopTest();

        newContAfter = getCurrentContact();
        System.assertEquals('Other Phone', newContAfter.PreferredPhone__c);
        System.assertEquals('0000000000', newContAfter.Phone);
    }

    /*
     Update Preferred Phone to 'Phone (Standard)' when standard Phone's value is not same as 
     any other Phone values and when Preferred Phone is Blank and the Context is batch.
    */
    @isTest
    static void testBatchPhoneNull() {
        disablePreferredPhone();

        insert new Contact(
            FirstName = 'JohnnyTest1',
            LastName = 'JohnnyTest',
            Phone = '111111111',
            OtherPhone = '0000000000'
        );

        Test.startTest();
        enablePreferredPhone();
        CON_Email_BATCH batch = new CON_Email_BATCH(null);
        Database.executeBatch(batch);
        Test.stopTest();

        System.assertEquals('Phone (standard)', getCurrentContact().PreferredPhone__c);
    }

    /* 
     Updates Preferred Phone to the label of the Phone field that has a value which is not same as 
     standard phone
    */
    @isTest
    static void testBatchOther() {
        disablePreferredPhone();

        insert new Contact(
            FirstName = 'JohnnyTest1',
            LastName = 'JohnnyTest',
            Phone = '111111111',
            OtherPhone = '111111111'
        );

        Test.startTest();
        enablePreferredPhone();
        CON_Email_BATCH batch = new CON_Email_BATCH(null);
        Database.executeBatch(batch);
        Test.stopTest();

        System.assertEquals('Other Phone', getCurrentContact().PreferredPhone__c);
    }

    /* Validation when there are more than one phone fields but not Preferred Phone
     * Test Scenario: T-3903371
     */
    @isTest
    static void testErrorPrefPhoneAmbiguous() {
        enablePreferredPhone();
        Contact newCont = new Contact(
            FirstName = 'JohnnyTest1',
            LastName = 'JohnnyTest',
            WorkPhone__c = '111111111',
            OtherPhone = '0000000000'
        );

        try {
            Test.startTest();
            insert newCont;
            Test.stopTest();
            System.assert(false, 'Multiple phones without preference specified should error out - when enforced');
        } catch (Exception error) {
            System.assert(error.getMessage().contains(Label.PreferredPhoneRequiredError));
        }

        disablePreferredPhone();
        insert newCont;
        System.assert(true, 'Multiple phones without preference specified should not error out - when unenforced');
    }

    /* Ensure contact edits validate against missing specififed preferred phone(home phone)
     *  Test Scenario: T-3903370
     */
    @isTest
    static void testcontactUpdatePrefPhoneNotBlankUponSettingUpdate() {
        enablePreferredPhone();

        Contact newCont = new Contact(FirstName = 'JohnnyTest1', LastName = 'JohnnyTest', OtherPhone = '0000000000');
        insert newCont;

        Hierarchy_Settings__c settings = enablePreferredPhone();
        settings.Preferred_Phone_Selection__c = 'homePhone';
        UTIL_CustomSettingsFacade.getSettingsForTests(settings);

        newCont.PreferredPhone__c = 'Home phone';
        try {
            Test.startTest();
            update newCont;
            Test.stopTest();
            System.assert(false, 'Missing preferred phone should error out.');
        } catch (Exception error) {
            System.assert(error.getMessage().contains(Label.PreferredPhoneMatchNotNull));
        }

        newCont.HomePhone = '0000000000';
        update newCont;
    }

    /* Validation when Preferred Phone is selected but no other Phone Fields have a value
     *  Test Scenario: T-3903364
     */
    @isTest
    static void testPrefPhoneNotBlankEnforced() {
        enablePreferredPhone();
        try {
            Test.startTest();
            testPrefPhoneNotBlank();
            Test.stopTest();
            System.assert(false, 'Should error out when no phone is indicated.');
        } catch (Exception error) {
            System.assert(error.getMessage().contains(Label.PreferredPhoneMatchNotNull));
        }
    }

    /* Validation when Preferred Phone is unenforced and no phone fields are populated value
     *  Test Scenario: T-3903366
     */
    @isTest
    static void testPrefPhoneNotBlankUnenforced() {
        disablePreferredPhone();
        try {
            Test.startTest();
            insert new Contact(
                FirstName = 'JohnnyTest1',
                LastName = 'JohnnyTest',
                WorkPhone__c = '1234567890',
                HomePhone = '2345678901',
                OtherPhone = '3456789012',
                PreferredPhone__c = 'NONE'
            );
            Test.stopTest();
        } catch (Exception error) {
            System.assert(
                false,
                'When preferred phone is unenforced, contact without specified phone insertion should persist.'
            );
        }
    }

    private static void testPrefPhoneNotBlank() {
        insert new Contact(FirstName = 'JohnnyTest1', LastName = 'JohnnyTest', PreferredPhone__c = 'Work');
    }

    /* Validation when Preferred Phone label doesn't match any of the other fields
     *  Test Scenario: T-3903363
     */
    @isTest
    static void testPrefDiffValue() {
        enablePreferredPhone();

        try {
            Test.startTest();
            insert new Contact(
                FirstName = 'JohnnyTest1',
                LastName = 'JohnnyTest',
                WorkPhone__c = '111111111',
                PreferredPhone__c = 'ForTestingPurposes'
            );
            Test.stopTest();
        } catch (Exception error) {
            System.assert(error.getMessage().contains(Label.PreferredPhoneMatchMustExist));
        }
    }

    /*
    Update Preferred Phone when Phone Clean Up batch job is run. 
    */
    @isTest
    static void testBatchWPreferredPhoneSelection() {
        disablePreferredPhone();

        insert new Contact(
            FirstName = 'JohnnyTest1',
            LastName = 'JohnnyTest',
            OtherPhone = '0000000000',
            HomePhone = '111111111'
        );

        Test.startTest();
        Hierarchy_Settings__c settings = enablePreferredPhone();
        settings.Preferred_Phone_Selection__c = 'homePhone';
        UTIL_CustomSettingsFacade.getSettingsForTests(settings);

        CON_Email_BATCH batch = new CON_Email_BATCH(null);
        Database.executeBatch(batch);
        Test.stopTest();

        Contact newContAfter = getCurrentContact();
        System.assertEquals('Home Phone', newContAfter.PreferredPhone__c);
        System.assertEquals('111111111', newContAfter.Phone);
    }

    /*
    Update Preferred Phone and Phone when Phone Clean Up batch job is run with no selection done in EDA Settings. 
    */
    @isTest
    static void testBatchWNoPreferredPhoneSelection() {
        disablePreferredPhone();

        insert new Contact(
            FirstName = 'JohnnyTest1',
            LastName = 'JohnnyTest',
            OtherPhone = '0000000000',
            HomePhone = '111111111'
        );

        Test.startTest();
        enablePreferredPhone();
        CON_Email_BATCH batch = new CON_Email_BATCH(null);
        Database.executeBatch(batch);
        Test.stopTest();

        Contact newContAfter = getCurrentContact();
        System.assert(newContAfter.PreferredPhone__c != null);
        System.assert(newContAfter.Phone != null);
    }

    /*
    Update Preferred Phone and Phone when Phone Clean Up batch job is run with selection done in EDA Settings
    but value null on contact record.
    */

    @isTest
    static void testBatchWPreferredPhoneSelectionMisMatch() {
        disablePreferredPhone();

        insert new Contact(
            FirstName = 'JohnnyTest1',
            LastName = 'JohnnyTest',
            OtherPhone = '0000000000',
            MobilePhone = '0000000000'
        );

        Test.startTest();
        Hierarchy_Settings__c settings = enablePreferredPhone();
        settings.Preferred_Phone_Selection__c = 'homePhone';
        UTIL_CustomSettingsFacade.getSettingsForTests(settings);

        CON_Email_BATCH batch = new CON_Email_BATCH(null);
        Database.executeBatch(batch);
        Test.stopTest();

        Contact newContAfter = getCurrentContact();
        System.assert(newContAfter.PreferredPhone__c != null);
        System.assert(newContAfter.Phone == '0000000000');
    }

    /*
     Copy value of Standard Phone Field to Other when Preferred Phone is Null, Standard Phone is not null and
     all other phones are null.
    */
    @isTest
    static void testCopyStdPhoneToOther() {
        enablePreferredPhone();

        Test.startTest();
        insert new Contact(FirstName = 'JohnnyTest1', LastName = 'JohnnyTest', Phone = '0000000000');
        Test.stopTest();

        Contact newContAfter = getCurrentContact();
        System.assertEquals('Other Phone', newContAfter.PreferredPhone__c);
        System.assert(newContAfter.OtherPhone == '0000000000');
    }

    /* When Standard Phone is not null and Preferred Phone is enforced update Preferred Phone
       to Other and update Other Phone to the value of Standard Phone.
    */
    @isTest
    static void testUpdatePrefPhoneTOtherBulk() {
        enablePreferredPhone();

        List<Contact> contactsToInsert = new List<Contact>();
        for (Integer i = 0; i < 100; i++) {
            Contact a = new Contact(FirstName = 'TestAccount' + i, LastName = 'JohnnyTest' + i);
            contactsToInsert.add(a);
        }
        insert contactsToInsert;

        Test.startTest();
        for (Contact each : contactsToInsert) {
            each.Phone = '0000000000';
        }
        update contactsToInsert;
        Test.stopTest();

        List<Contact> newContAfterList = [
            SELECT Id, FirstName, LastName, Name, OtherPhone, Phone, PreferredPhone__c
            FROM Contact
        ];

        for (Contact each : newContAfterList) {
            System.assertEquals('0000000000', each.OtherPhone);
            System.assertEquals('Other Phone', each.PreferredPhone__c);
        }
    }

    private static Contact getCurrentContact() {
        return [
            SELECT Id, FirstName, LastName, Name, Phone, WorkPhone__c, OtherPhone, PreferredPhone__c
            FROM Contact
            LIMIT 1
        ];
    }
}
/*
    Copyright (c) 2020, Salesforce.org
    All rights reserved.

    Redistribution and use in source and binary forms, with or without
    modification, are permitted provided that the following conditions are met:
    
    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
    * Neither the name of Salesforce.org nor the names of
      its contributors may be used to endorse or promote products derived
      from this software without specific prior written permission.
 
    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
    "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT 
    LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS 
    FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE 
    COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, 
    INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, 
    BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; 
    LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER 
    CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT 
    LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN 
    ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE 
    POSSIBILITY OF SUCH DAMAGE.
*/
/**
* @author Salesforce.org
* @date 2020
* @group Contacts
* @group-content ../../ApexDocContent/Contacts.htm
* @description Test class for CON_Preferred_TDTM - Preferred Email functionality.
*/
@isTest
private class CON_Preferred_Email_TEST {

    /**************************************************************************************************************************
    ****************************************************** UNIT TESTS *********************************************************
    **************************************************************************************************************************/

    /*************************************************************************************************************
    * @description NULL test for run method to verify null is returned when newList is null
    *************************************************************************************************************/
    @isTest
    private static void runMethodNULLTest() {

        TDTM_Runnable.Action testAction = TDTM_Runnable.Action.AfterUpdate;
        Schema.DescribeSObjectResult objResult = Schema.SObjectType.Contact;

        CON_Preferred_TDTM tdtmClass = new CON_Preferred_TDTM();
        Test.startTest();
            TDTM_Runnable.DmlWrapper dmlWrapperReturned = tdtmClass.run(null, null, testAction, objResult);
        Test.stopTest();

        System.assertEquals(null, dmlWrapperReturned);

    }

    /*************************************************************************************************************
    * @description Test for run method to verify null is returned when newList is empty
    *************************************************************************************************************/
    @isTest
    private static void runMethodEmptyTest() {

        List<Contact> newContactsList = new List<Contact>();
        List<SObject> oldContactList = new List<SObject>();

        TDTM_Runnable.Action testAction = TDTM_Runnable.Action.AfterUpdate;
        Schema.DescribeSObjectResult objResult = Schema.SObjectType.Contact;

        CON_Preferred_TDTM tdtmClass = new CON_Preferred_TDTM();
        Test.startTest();
            TDTM_Runnable.DmlWrapper dmlWrapperReturned = tdtmClass.run(newContactsList, oldContactList, testAction, objResult);
        Test.stopTest();

        System.assertEquals(null, dmlWrapperReturned);

    }

    /*************************************************************************************************************
    * @description Tests runMethod in BeforInsert Context
    *************************************************************************************************************/
    @isTest
    private static void runMethodBeforeInsert() {

        UTIL_CustomSettingsFacade.getSettingsForTests(
            new Hierarchy_Settings__c(Disable_Preferred_Email_Enforcement__c = false)
        );

        List<Contact> contactList = new List<Contact>();

        Contact contact1 = UTIL_UnitTestData_TEST.getUniqueContact(1);
        contact1.Email = 'test@sf.org';

        Contact contact2 = UTIL_UnitTestData_TEST.getUniqueContact(1);
        contact2.Preferred_Email__c = 'Alternate Email';

        contactList.add(contact1);
        contactList.add(contact2);

        CON_Preferred_TDTM tdtmClass = new CON_Preferred_TDTM();
        Test.startTest();
            tdtmClass.run(contactList, null, TDTM_Runnable.Action.BeforeInsert, Schema.SObjectType.Contact);
        Test.stopTest();

        System.assertEquals('Alternate Email', contact1.Preferred_Email__c);
        System.assertEquals(contact1.Email, contact1.AlternateEmail__c);

        System.assertEquals(true, contact2.hasErrors());
        System.assertEquals(Label.PreferredEmailMatchNotNull, contact2.getErrors()[0].getMessage());
              
    }
    
    /*************************************************************************************************************
    * @description Tests runMethod in BeforUpdate Context
    *************************************************************************************************************/
    @isTest
    private static void runMethodBeforeUpdate() {

        List<Contact> oldContactList = new List<Contact>();
        List<Contact> newContactList = new List<Contact>();

        Contact oldContact1 = UTIL_UnitTestData_TEST.getUniqueContact(1);
        oldContact1.Email = '';
        oldContact1.Id = UTIL_UnitTestData_TEST.getFakeId(Contact.sObjectType);

        Contact newContact1 = oldContact1.clone(true);
        newContact1.Email = 'test@sf.org';

        Contact oldContact2 = UTIL_UnitTestData_TEST.getUniqueContact(1);
        oldContact2.Email = '';
        oldContact2.Id = UTIL_UnitTestData_TEST.getFakeId(Contact.sObjectType);

        Contact newContact2 = oldContact2.clone(true);
        newContact2.Preferred_Email__c = 'Alternate Email';

        oldContactList.add(oldContact1);
        oldContactList.add(oldContact2);
        newContactList.add(newContact1);
        newContactList.add(newContact2);

        CON_Preferred_TDTM tdtmClass = new CON_Preferred_TDTM();
        Test.startTest();
            tdtmClass.run(newContactList, oldContactList, TDTM_Runnable.Action.BeforeUpdate, Schema.SObjectType.Contact);
        Test.stopTest();

        System.assertEquals('Alternate Email', newContact1.Preferred_Email__c);
        System.assertEquals(newContact1.Email, newContact1.AlternateEmail__c);
        System.assertEquals(true, newContact2.hasErrors());
        System.assertEquals(Label.PreferredEmailMatchNotNull, newContact2.getErrors()[0].getMessage());

    }
    
    /*************************************************************************************************************
    * @description Tests handleBeforeInsert method under recursion to ensure no Contacts are processed
    *************************************************************************************************************/
    @isTest
    private static void handleBeforeInsertInRecursion() {

        CON_Preferred_TDTM tdtmClass = new CON_Preferred_TDTM();
        tdtmClass.setRecursion();
        Test.startTest();
            List<Contact> returnedContactList = tdtmClass.handleBeforeInsert(UTIL_UnitTestData_TEST.getMultipleTestContacts(5));
        Test.stopTest();

        System.assertEquals(0, returnedContactList.size());
    }
    
    /*************************************************************************************************************
    * @description Tests handleBeforeInsert method
    *************************************************************************************************************/
    @isTest
    private static void handleBeforeInsert() {

        List<Contact> contactList = new List<Contact>();

        Contact contact1 = UTIL_UnitTestData_TEST.getUniqueContact(1);
        contact1.Email = '';
        contactList.add(contact1);

        Contact contact2 = UTIL_UnitTestData_TEST.getUniqueContact(1);
        contact2.Email = 'test@sf.org';
        contactList.add(contact2);

        Contact contact3 = UTIL_UnitTestData_TEST.getUniqueContact(1);
        contact3.Preferred_Email__c = 'Alternate Email';
        contactList.add(contact3);

        CON_Preferred_TDTM tdtmClass = new CON_Preferred_TDTM();
        Test.startTest();
            List<Contact> returnedContactList = tdtmClass.handleBeforeInsert(contactList);
        Test.stopTest();

        System.assertEquals(2, returnedContactList.size(), 'Contact1 should not be in the list');
        System.assertEquals(false, TDTM_ProcessControl.getRecursionFlag(TDTM_ProcessControl.registeredTrigger.CON_Preferred_TDTM));
        
    }

    /*************************************************************************************************************
    * @description Tests handleBeforeInsert method with Preferred Phone
    *************************************************************************************************************/
    @isTest
    private static void handleBeforeInsertWithPreferredPhone() {

        UTIL_CustomSettingsFacade.getSettingsForTests(new Hierarchy_Settings__c
                                                         (Enable_New_Preferred_Phone_Sync__c = false));

        List<Contact> contactList = new List<Contact>();

        Contact contact1 = UTIL_UnitTestData_TEST.getUniqueContact(1);
        contact1.Email = 'test@sf.org';
        contact1.Phone = '';
        contact1.HomePhone = '1234567890';
        contact1.PreferredPhone__c = 'Home Phone';

        contactList.add(contact1);

        CON_Preferred_TDTM tdtmClass = new CON_Preferred_TDTM();
        Test.startTest();
            List<Contact> returnedContactList = tdtmClass.handleBeforeInsert(contactList);
        Test.stopTest();

        System.assertEquals(1, returnedContactList.size());
        System.assertEquals(contact1.HomePhone, returnedContactList[0].Phone);
        System.assertEquals(contact1.Email, returnedContactList[0].AlternateEmail__c);
        System.assertEquals('Alternate Email', returnedContactList[0].Preferred_Email__c);

    }

    /*************************************************************************************************************
    * @description Tests handleBeforeUpdate method under recursion to ensure no Contacts are processed
    *************************************************************************************************************/
    @isTest
    private static void handleBeforeUpdateInRecursion() {

        CON_Preferred_TDTM tdtmClass = new CON_Preferred_TDTM();
        tdtmClass.setRecursion();
        Test.startTest();
            List<Contact> returnedContactList = tdtmClass.handleBeforeUpdate(UTIL_UnitTestData_TEST.getMultipleTestContacts(5), null);
        Test.stopTest();

        System.assertEquals(0, returnedContactList.size());
    }
    
    /*************************************************************************************************************
    * @description Tests handleBeforeUpdate method
    *************************************************************************************************************/
    @isTest
    private static void handleBeforeUpdate() {

        List<Contact> oldList = new List<Contact>();

        Contact contact1 = UTIL_UnitTestData_TEST.getUniqueContact(1);
        contact1.Email = '';
        contact1.Id = UTIL_UnitTestData_TEST.getFakeId(Contact.sObjectType);
        oldList.add(contact1);

        Contact contact2 = UTIL_UnitTestData_TEST.getUniqueContact(1);
        contact2.Email = '';
        contact2.Id = UTIL_UnitTestData_TEST.getFakeId(Contact.sObjectType);
        oldList.add(contact2);

        Contact contact3 = UTIL_UnitTestData_TEST.getUniqueContact(1);
        contact3.Email = '';
        contact3.Id = UTIL_UnitTestData_TEST.getFakeId(Contact.sObjectType);
        oldList.add(contact3);

        Contact newContact1 = contact1.clone(true);
        Contact newContact2 = contact2.clone(true);
        newContact2.Email = 'test@sf.org';
        Contact newContact3 = contact3.clone(true);
        newContact3.Preferred_Email__c = 'Alternate Email';

        List<Contact> newList = new List<Contact>();
        newList.add(newContact1);
        newList.add(newContact2);
        newList.add(newContact3);

        CON_Preferred_TDTM tdtmClass = new CON_Preferred_TDTM();
        Test.startTest();
            List<Contact> returnedContactList = tdtmClass.handleBeforeUpdate(newList, oldList);
        Test.stopTest();

        System.assertEquals(2, returnedContactList.size(), 'Contact1 should not be in the list');
        System.assertEquals(false, TDTM_ProcessControl.getRecursionFlag(TDTM_ProcessControl.registeredTrigger.CON_Preferred_TDTM));

    }

    /*************************************************************************************************************
    * @description Tests handleBeforeUpdate with Preferred Phone
    *************************************************************************************************************/
    @isTest
    private static void handleBeforeUpdateWithPreferredPhone() {

        UTIL_CustomSettingsFacade.getSettingsForTests(new Hierarchy_Settings__c
                                                      (Enable_New_Preferred_Phone_Sync__c = false));

        List<Contact> newContactList = new List<Contact>();
        List<Contact> oldContactList = new List<Contact>();

        Contact contact1 = UTIL_UnitTestData_TEST.getUniqueContact(1);
        contact1.Phone = '';
        contact1.Id = UTIL_UnitTestData_TEST.getFakeId(Contact.sObjectType);
        oldContactList.add(contact1);

        Contact newContact1 = contact1.clone(true);
        contact1.Email = 'test@sf.org';
        contact1.HomePhone = '1234567890';
        contact1.PreferredPhone__c = 'Home Phone';
        newContactList.add(contact1);

        CON_Preferred_TDTM tdtmClass = new CON_Preferred_TDTM();
        Test.startTest();
            List<Contact> returnedContactList = tdtmClass.handleBeforeUpdate(newContactList, oldContactList);
        Test.stopTest();

        System.assertEquals(1, returnedContactList.size());
        System.assertEquals(contact1.HomePhone, returnedContactList[0].Phone);
        System.assertEquals(contact1.Email, returnedContactList[0].AlternateEmail__c);
        System.assertEquals('Alternate Email', returnedContactList[0].Preferred_Email__c);

    }

    /****************************************************************************
    * @description Tests locateContactEmailService method of CON_Preferred_TDTM
    ****************************************************************************/
    @isTest
    private static void locateContactEmailService() {

        CON_Preferred_TDTM tdtmClass = new CON_Preferred_TDTM();
        Test.startTest();
            SRVC_Contact_PreferredEmail preferredEmailService = tdtmClass.locateContactEmailService();
        Test.stopTest();

        SRVC_Contact_PreferredEmail srvcInstance = SRVC_Contact_PreferredEmail.getInstance();

        System.assertEquals(srvcInstance, preferredEmailService);

    }
    
    /****************************************************************************
    * @description Tests locatePreferredEmailMapper method of CON_Preferred_TDTM
    ****************************************************************************/
    @isTest
    private static void locatePreferredEmailMapper() {

        CON_Preferred_TDTM tdtmClass = new CON_Preferred_TDTM();
        Test.startTest();
            MAPR_CON_PreferredEmailFields preferredEmailFields = tdtmClass.locatePreferredEmailMapper();
        Test.stopTest();

        MAPR_CON_PreferredEmailFields srvcInstance = MAPR_CON_PreferredEmailFields.getInstance();

        System.assertEquals(srvcInstance, preferredEmailFields);
        
    }

    /********************************************************
    * @description Tests setRecursion method
    *********************************************************/
    @isTest
    static void setRecursion() {
        CON_Preferred_TDTM tdtmClass = new CON_Preferred_TDTM();

        Test.startTest();
            tdtmClass.setRecursion();
        Test.stopTest();

        Boolean preferredTDTMFlag = TDTM_ProcessControl.getRecursionFlag(
            TDTM_ProcessControl.registeredTrigger.CON_Preferred_TDTM
        );

        System.assertEquals(true, preferredTDTMFlag, 'CON_Preferred_TDTM should be active');
    }

    /********************************************************
    * @description Tests unsetRecursion method
    *********************************************************/
    @isTest
    static void unsetRecursion() {

        CON_Preferred_TDTM tdtmClass = new CON_Preferred_TDTM();
        tdtmClass.setRecursion();

        System.assertEquals(true, TDTM_ProcessControl.getRecursionFlag(
            TDTM_ProcessControl.registeredTrigger.CON_Preferred_TDTM
        ));

        Test.startTest();
            tdtmClass.unsetRecursion();
        Test.stopTest();

        Boolean preferredTDTMFlag = TDTM_ProcessControl.getRecursionFlag(
            TDTM_ProcessControl.registeredTrigger.CON_Preferred_TDTM
        );

        System.assertEquals(false, preferredTDTMFlag, 'CON_Preferred_TDTM should be Inactive');
    }
    
    /********************************************************
    * @description Tests isRecursion method
    *********************************************************/
    @isTest
    static void isRecursion() {

        CON_Preferred_TDTM tdtmClass = new CON_Preferred_TDTM();
        tdtmClass.setRecursion();

        System.assertEquals(true, TDTM_ProcessControl.getRecursionFlag(
            TDTM_ProcessControl.registeredTrigger.CON_Preferred_TDTM
        ));

        Test.startTest();
            tdtmClass.isRecursion();
        Test.stopTest();

        Boolean preferredTDTMFlag = TDTM_ProcessControl.getRecursionFlag(
            TDTM_ProcessControl.registeredTrigger.CON_Preferred_TDTM
        );

        System.assertEquals(true, preferredTDTMFlag, 'CON_Preferred_TDTM should be Active');
    }

    /********************************************************************
    * @description Tests isNewPreferredPhoneFunctionalityEnabled method
    ********************************************************************/
    @isTest
    static void isNewPreferredPhoneFunctionalityEnabled() {
        UTIL_CustomSettingsFacade.getSettingsForTests(new Hierarchy_Settings__c
                                                         (Enable_New_Preferred_Phone_Sync__c = true));
        
        CON_Preferred_TDTM tdtmClass = new CON_Preferred_TDTM();

        Test.startTest();
            Boolean preferredPhoneEnabled = tdtmClass.isNewPreferredPhoneFunctionalityEnabled();
        Test.stopTest();

        System.assertEquals(true, preferredPhoneEnabled, 'Preferred Phone should be enabled');
    }

    /**************************************************************************************************************************
    ****************************************************** FUNCTIONAL TESTS ***************************************************
    **************************************************************************************************************************/

    /*****************************************************************************************************************************
    * @description Tests inserting a Contact with Preferred Email and no Email fields will throw PreferredEmailMatchNotNull Error
    * when Preferred Email Enforcement is Enabled
    *****************************************************************************************************************************/
    @isTest
    static void preferredEmailNotBlankOnInsertWithEnforcementEnabled() {

        UTIL_CustomSettingsFacade.getSettingsForTests(
            new Hierarchy_Settings__c(Disable_Preferred_Email_Enforcement__c = false)
            );
    
        List<Contact> testContactList = UTIL_UnitTestData_TEST.getMultipleTestContacts(2);
        testContactList[0].WorkEmail__c = '';
        testContactList[0].Preferred_Email__c = 'Alternate Email';
        testContactList[1].WorkEmail__c = '';
        testContactList[1].Preferred_Email__c = 'Alternate Email';

        try {
            Test.startTest();
                insert testContactList;
            Test.stopTest();
            System.assert(false, 'Always throw an error when the value corresponding to Preferred Email is Blank.');
        } catch (DmlException error) {
            System.assert(error.getMessage().contains(Label.PreferredEmailMatchNotNull));
        }
    }

    /*****************************************************************************************************************************
    * @description Tests inserting a Contact with Preferred Email and no Email fields will throw PreferredEmailMatchNotNull Error
    * when Preferred Email Enforcement is Disabled
    *****************************************************************************************************************************/
    @isTest 
    static void preferredEmailNotBlankOnInsertWithEnforcementDisabled() {
        UTIL_CustomSettingsFacade.getSettingsForTests(
            new Hierarchy_Settings__c(Disable_Preferred_Email_Enforcement__c = true)
        );

        List<Contact> testContactList = UTIL_UnitTestData_TEST.getMultipleTestContacts(2);
        testContactList[0].WorkEmail__c = '';
        testContactList[0].Preferred_Email__c = 'Alternate Email';
        testContactList[1].WorkEmail__c = '';
        testContactList[1].Preferred_Email__c = 'Alternate Email';

        try {
            Test.startTest();
                insert testContactList;
            Test.stopTest();
            System.assert(false, 'Always throw an error when the value corresponding to Preferred Email is Blank.');
        } catch (DmlException error) {
            System.assert(error.getMessage().contains(Label.PreferredEmailMatchNotNull));
        }
    }

    /*****************************************************************************************************************************
    * @description Tests Updating a Contact with Preferred Email and no Email fields will throw PreferredEmailMatchNotNull Error
    * when Preferred Email Enforcement is Enabled
    *****************************************************************************************************************************/
    @isTest
    static void preferredEmailNotBlankOnUpdateWithEnforcementEnabled() {
        UTIL_CustomSettingsFacade.getSettingsForTests(
            new Hierarchy_Settings__c(Disable_Preferred_Email_Enforcement__c = false)
        );

        List<Contact> testContactList = UTIL_UnitTestData_TEST.getMultipleTestContacts(2);
        testContactList[0].WorkEmail__c = '';
        testContactList[0].Preferred_Email__c = '';
        testContactList[1].WorkEmail__c = '';
        testContactList[1].Preferred_Email__c = '';
        
        insert testContactList;
        testContactList[0].Preferred_Email__c = 'Alternate';
        testContactList[1].Preferred_Email__c = 'Alternate';
        try {
            Test.startTest();
                update testContactList;
            Test.stopTest();
            System.assert(false, 'Always throw an error when the value corresponding to Preferred Email is Blank.');
        } catch (DmlException error) {
            System.assert(error.getMessage().contains(Label.PreferredEmailMatchNotNull));
        }
    }
    
    /*****************************************************************************************************************************
    * @description Tests Updating a Contact with Preferred Email and no Email fields will throw PreferredEmailMatchNotNull Error
    * when Preferred Email Enforcement is Disabled
    *****************************************************************************************************************************/
    @isTest 
    static void preferredEmailNotBlankOnUpdateWithEnforcementDisabled() {
        UTIL_CustomSettingsFacade.getSettingsForTests(
            new Hierarchy_Settings__c(Disable_Preferred_Email_Enforcement__c = true)
        );

        List<Contact> testContactList = UTIL_UnitTestData_TEST.getMultipleTestContacts(2);
        testContactList[0].WorkEmail__c = '';
        testContactList[0].Preferred_Email__c = '';
        testContactList[1].WorkEmail__c = '';
        testContactList[1].Preferred_Email__c = '';
        
        insert testContactList;
        testContactList[0].Preferred_Email__c = 'Alternate';
        testContactList[1].Preferred_Email__c = 'Alternate';
        try {
            Test.startTest();
                update testContactList;
            Test.stopTest();
            System.assert(false, 'Always throw an error when the value corresponding to Preferred Email is Blank.');
        } catch (DmlException error) {
            System.assert(error.getMessage().contains(Label.PreferredEmailMatchNotNull));
        }
    }

    /*********************************************************************************************************************************
    * @description Tests Inserting a Contact with standard Email field populated will update Alternate Email to the value in Standard
    * Email and update Preferred Email to 'Alternate Email' when Preferred Email Enforcement is enabled
    *********************************************************************************************************************************/
    @isTest 
    static void standardEmailNotBlankOnInsert() {
        UTIL_CustomSettingsFacade.getSettingsForTests(
            new Hierarchy_Settings__c(Disable_Preferred_Email_Enforcement__c = false)
            );

        List<Contact> testContactList = UTIL_UnitTestData_TEST.getMultipleTestContacts(2);
        testContactList[0].WorkEmail__c = '';
        testContactList[0].Preferred_Email__c = '';
        testContactList[0].Email = 'test@sf.org';
        testContactList[1].WorkEmail__c = '';
        testContactList[1].Preferred_Email__c = '';
        testContactList[1].Email = 'test@sf.org';

        Test.startTest();
            insert testContactList;
        Test.stopTest();

        List<Contact> updatedContact = [SELECT Id, AlternateEmail__c, Preferred_Email__c FROM Contact];

        System.assertEquals('test@sf.org', updatedContact[0].AlternateEmail__c, 'Alternate Email should be same as standard email');
        System.assertEquals('Alternate Email', updatedContact[0].Preferred_Email__c, 'Preferred Email should be set to Alternate Email');
        System.assertEquals('test@sf.org', updatedContact[1].AlternateEmail__c, 'Alternate Email should be same as standard email');
        System.assertEquals('Alternate Email', updatedContact[1].Preferred_Email__c, 'Preferred Email should be set to Alternate Email');
    }
    
    /*********************************************************************************************************************************
    * @description Tests inserting a Contact with standard Email field populated will not update Alternate Email
    * and Preferred Email when Preferred Email Enforcement is diabled
    *********************************************************************************************************************************/
    @isTest 
    static void standardEmailNotBlankOnInsertNegativeTest() {
        UTIL_CustomSettingsFacade.getSettingsForTests(
            new Hierarchy_Settings__c(Disable_Preferred_Email_Enforcement__c = true)
            );

        List<Contact> testContactList = UTIL_UnitTestData_TEST.getMultipleTestContacts(2);
        testContactList[0].WorkEmail__c = '';
        testContactList[0].Preferred_Email__c = '';
        testContactList[0].Email = 'test@sf.org';
        testContactList[1].WorkEmail__c = '';
        testContactList[1].Preferred_Email__c = '';
        testContactList[1].Email = 'test@sf.org';

        Test.startTest();
            insert testContactList;
        Test.stopTest();

        List<Contact> updatedContactList = [SELECT Id, AlternateEmail__c, Preferred_Email__c FROM Contact];

        System.assertEquals(null, updatedContactList[0].AlternateEmail__c, 'Alternate Email should be cleared');
        System.assertEquals(null, updatedContactList[0].Preferred_Email__c, 'Preferred Email should be cleared');
        System.assertEquals(null, updatedContactList[1].AlternateEmail__c, 'Alternate Email should be cleared');
        System.assertEquals(null, updatedContactList[1].Preferred_Email__c, 'Preferred Email should be cleared');
    }

     /*********************************************************************************************************************************
    * @description Tests Updating a Contact in Batch context with standard Email field populated will update Alternate Email to the 
    * value in Standard Email and update Preferred Email to 'Alternate Email' when Preferred Email Enforcement is enabled
    *********************************************************************************************************************************/
    @isTest 
    static void standardEmailNotBlankOnBatch() {
        UTIL_CustomSettingsFacade.getSettingsForTests(
            new Hierarchy_Settings__c(Disable_Preferred_Email_Enforcement__c = false)
            );

        List<Contact> testContactList = UTIL_UnitTestData_TEST.getMultipleTestContacts(2);
        testContactList[0].WorkEmail__c = '';
        testContactList[0].Preferred_Email__c = '';
        testContactList[0].Email = 'test@sf.org';
        testContactList[1].WorkEmail__c = '';
        testContactList[1].Preferred_Email__c = '';
        testContactList[1].Email = 'test@sf.org';
        
        TDTM_ProcessControl.setRecursionFlag(TDTM_ProcessControl.registeredTrigger.CON_Preferred_TDTM, true);
        insert testContactList;
        TDTM_ProcessControl.setRecursionFlag(TDTM_ProcessControl.registeredTrigger.CON_Preferred_TDTM, false);
        CON_Email_BATCH batch = new CON_Email_BATCH(null);
        
        Test.startTest();
            Database.executeBatch(batch);
        Test.stopTest();

        List<Contact> updatedContactList = [SELECT Id, AlternateEmail__c, Preferred_Email__c FROM Contact];

        System.assertEquals('test@sf.org', updatedContactList[0].AlternateEmail__c, 'Alternate Email should be same as standard email');
        System.assertEquals('Alternate Email', updatedContactList[0].Preferred_Email__c, 'Preferred Email should be alternate email');
        System.assertEquals('test@sf.org', updatedContactList[1].AlternateEmail__c, 'Alternate Email should be same as standard email');
        System.assertEquals('Alternate Email', updatedContactList[1].Preferred_Email__c, 'Preferred Email should be alternate email');

    }
    
    /*********************************************************************************************************************************
    * @description Tests Updating a Contact in Batch context with standard Email field populated will not update Alternate Email
    * and Preferred Email when Preferred Email Enforcement is disbaled
    *********************************************************************************************************************************/
    @isTest 
    static void standardEmailNotBlankOnBatchNegativeTest() {
        UTIL_CustomSettingsFacade.getSettingsForTests(
            new Hierarchy_Settings__c(Disable_Preferred_Email_Enforcement__c = true)
            );

        List<Contact> testContactList = UTIL_UnitTestData_TEST.getMultipleTestContacts(2);
        testContactList[0].WorkEmail__c = '';
        testContactList[0].Preferred_Email__c = '';
        testContactList[0].Email = 'test@sf.org';
        testContactList[1].WorkEmail__c = '';
        testContactList[1].Preferred_Email__c = '';
        testContactList[1].Email = 'test@sf.org';
        
        TDTM_ProcessControl.setRecursionFlag(TDTM_ProcessControl.registeredTrigger.CON_Preferred_TDTM, true);
        insert testContactList;
        TDTM_ProcessControl.setRecursionFlag(TDTM_ProcessControl.registeredTrigger.CON_Preferred_TDTM, false);
        CON_Email_BATCH batch = new CON_Email_BATCH(null);

        Test.startTest();
            Database.executeBatch(batch);
        Test.stopTest();

        List<Contact> updatedContactList = [SELECT Id, AlternateEmail__c, Preferred_Email__c FROM COntact];

        System.assertEquals(null, updatedContactList[0].AlternateEmail__c, 'Alternate Email should be cleared');
        System.assertEquals(null, updatedContactList[0].Preferred_Email__c , 'Preferred Email should be cleared');
        System.assertEquals(null, updatedContactList[1].AlternateEmail__c, 'Alternate Email should be cleared');
        System.assertEquals(null, updatedContactList[1].Preferred_Email__c , 'Preferred Email should be cleared');

    }

    /*********************************************************************************************************************************
    * @description Tests Updating a Contact to populate standard Email field will update Alternate Email to the 
    * value in Standard Email and update Preferred Email to 'Alternate Email' when Preferred Email Enforcement is enabled
    *********************************************************************************************************************************/
    @isTest 
    static void standardEmailNotBlankOnUpdate() {
        UTIL_CustomSettingsFacade.getSettingsForTests(
            new Hierarchy_Settings__c(Disable_Preferred_Email_Enforcement__c = false)
        );

        List<Contact> testContactList = UTIL_UnitTestData_TEST.getMultipleTestContacts(2);
        testContactList[0].WorkEmail__c = '';
        testContactList[0].Preferred_Email__c = '';
        testContactList[1].WorkEmail__c = '';
        testContactList[1].Preferred_Email__c = '';
        
        insert testContactList;
        testContactList[0].Email = 'test@sf.org';
        testContactList[1].Email = 'test@sf.org';
        Test.startTest();
            update testContactList;
        Test.stopTest();

        List<Contact> updatedContactList = [SELECT Id, AlternateEmail__c, Preferred_Email__c FROM Contact];

        System.assertEquals('test@sf.org', updatedContactList[0].AlternateEmail__c, 'Alternate Email should be same as standard email');
        System.assertEquals('Alternate Email', updatedContactList[0].Preferred_Email__c, 'Preferred Email should be alternate email');
        System.assertEquals('test@sf.org', updatedContactList[1].AlternateEmail__c, 'Alternate Email should be same as standard email');
        System.assertEquals('Alternate Email', updatedContactList[1].Preferred_Email__c, 'Preferred Email should be alternate email');
        
    }
    
    /*********************************************************************************************************************************
    * @description Tests Updating a Contact's standard Email field will not update Alternate Email
    * and Preferred Email when Preferred Email Enforcement is disabled
    *********************************************************************************************************************************/
    @isTest 
    static void standardEmailNotBlankOnUpdateNegativeTest() {
        UTIL_CustomSettingsFacade.getSettingsForTests(
            new Hierarchy_Settings__c(Disable_Preferred_Email_Enforcement__c = true)
        );

        List<Contact> testContactList = UTIL_UnitTestData_TEST.getMultipleTestContacts(2);
        testContactList[0].WorkEmail__c = '';
        testContactList[0].Preferred_Email__c = '';
        testContactList[1].WorkEmail__c = '';
        testContactList[1].Preferred_Email__c = '';
        
        insert testContactList;
        testContactList[0].Email = 'test@sf.org';
        testContactList[1].Email = 'test@sf.org';

        Test.startTest();
            update testContactList;
        Test.stopTest();

        List<Contact> updatedContactList = [SELECT Id, AlternateEmail__c, Preferred_Email__c FROM Contact];

        System.assertEquals(null, updatedContactList[0].AlternateEmail__c, 'Alternate Email should be cleared');
        System.assertEquals(null, updatedContactList[0].Preferred_Email__c, 'Preferred Email should be cleared');
        System.assertEquals(null, updatedContactList[1].AlternateEmail__c, 'Alternate Email should be cleared');
        System.assertEquals(null, updatedContactList[1].Preferred_Email__c, 'Preferred Email should be cleared');
        
    }

    /*********************************************************************************************************************************
    * @description Tests Updating a Contact to clear Preferred Email and the value corresponding to the field in Preferred Email will
    * clear the value in standard Email field
    *********************************************************************************************************************************/
    @isTest 
    static void clearEmailFieldsOnUpdate() {
        UTIL_CustomSettingsFacade.getSettingsForTests(
            new Hierarchy_Settings__c(Disable_Preferred_Email_Enforcement__c = false)
            );

        List<Contact> testContactList = UTIL_UnitTestData_TEST.getMultipleTestContacts(2);
        testContactList[0].WorkEmail__c = '';
        testContactList[0].Preferred_Email__c = '';
        testContactList[0].AlternateEmail__c = 'test@sf.org';
        testContactList[1].WorkEmail__c = '';
        testContactList[1].Preferred_Email__c = '';
        testContactList[1].AlternateEmail__c = 'test@sf.org';
        insert testContactList;

        List<Contact> insertedContactList = [SELECT Id, Email, AlternateEmail__c, Preferred_Email__c FROM Contact];

        System.assertEquals('test@sf.org', insertedContactList[0].Email);
        System.assertEquals('Alternate Email', insertedContactList[0].Preferred_Email__c);
        System.assertEquals('test@sf.org', insertedContactList[1].Email);
        System.assertEquals('Alternate Email', insertedContactList[1].Preferred_Email__c);

        insertedContactList[0].AlternateEmail__c = '';
        insertedContactList[0].Preferred_Email__c = null;
        insertedContactList[1].AlternateEmail__c = '';
        insertedContactList[1].Preferred_Email__c = null;
        
        Test.startTest();
            update insertedContactList;
        Test.stopTest();

        List<Contact> updatedContactList = [SELECT Id, AlternateEmail__c, Preferred_Email__c, Email FROM Contact];

        System.assertEquals(null, updatedContactList[0].AlternateEmail__c, 'Alternate Email should be cleared');
        System.assertEquals(null, updatedContactList[0].Preferred_Email__c, 'Preferred Email should be cleared');
        System.assertEquals(null, updatedContactList[0].Email, 'Standard Email should be cleared');
        System.assertEquals(null, updatedContactList[1].AlternateEmail__c, 'Alternate Email should be cleared');
        System.assertEquals(null, updatedContactList[1].Preferred_Email__c, 'Preferred Email should be cleared');
        System.assertEquals(null, updatedContactList[1].Email, 'Standard Email should be cleared');
    } 
    
    /*********************************************************************************************************************************
    * @description Tests Updating a Contact to clear Preferred Email and all other custom email fields will not clear the value in
    * standard email field
    *********************************************************************************************************************************/
    @isTest 
    static void clearEmailFieldsOnUpdateNegative() {
        UTIL_CustomSettingsFacade.getSettingsForTests(
            new Hierarchy_Settings__c(Disable_Preferred_Email_Enforcement__c = false)
            );

        List<Contact> testContactList = UTIL_UnitTestData_TEST.getMultipleTestContacts(2);
        testContactList[0].WorkEmail__c = '';
        testContactList[0].Preferred_Email__c = '';
        testContactList[0].AlternateEmail__c = 'test@sf.org';
        testContactList[1].WorkEmail__c = '';
        testContactList[1].Preferred_Email__c = '';
        testContactList[1].AlternateEmail__c = 'test@sf.org';
        insert testContactList;

        List<Contact> insertedContactList = [SELECT Id, Email, AlternateEmail__c, Preferred_Email__c FROM Contact];

        System.assertEquals('test@sf.org', insertedContactList[0].Email);
        System.assertEquals('Alternate Email', insertedContactList[0].Preferred_Email__c);
        System.assertEquals('test@sf.org', insertedContactList[1].Email);
        System.assertEquals('Alternate Email', insertedContactList[1].Preferred_Email__c);

        MAPR_CON_PreferredEmailFields.preferredEmailFieldSettingsModel = null;
        UTIL_CustomSettingsFacade.getSettingsForTests(
            new Hierarchy_Settings__c(Disable_Preferred_Email_Enforcement__c = true)
        );        


        insertedContactList[0].AlternateEmail__c = '';
        insertedContactList[0].Preferred_Email__c = null;
        insertedContactList[1].AlternateEmail__c = '';
        insertedContactList[1].Preferred_Email__c = null;
        
        Test.startTest();
            update insertedContactList;
        Test.stopTest();

        List<Contact> updatedContactList = [SELECT Id, AlternateEmail__c, Preferred_Email__c, Email FROM Contact];

        System.assertEquals(null, updatedContactList[0].AlternateEmail__c, 'Alternate Email should be cleared');
        System.assertEquals(null, updatedContactList[0].Preferred_Email__c, 'Preferred Email should be cleared');
        System.assertEquals('test@sf.org', updatedContactList[0].Email, 'Standard Email should not be cleared');
        System.assertEquals(null, updatedContactList[1].AlternateEmail__c, 'Alternate Email should be cleared');
        System.assertEquals(null, updatedContactList[1].Preferred_Email__c, 'Preferred Email should be cleared');
        System.assertEquals('test@sf.org', updatedContactList[1].Email, 'Standard Email should not be cleared');

    }

    /*********************************************************************************************************************************
    * @description Tests Updating a Contact by clearing Preferred Email and other custom email fields, leaving one email field populated
    * will not repopule values in Standard Email and Preferred Email when Preferred Email Enforcement is disabled
    *********************************************************************************************************************************/
    @isTest 
    static void clearStandEmailAndSomeEmailFieldsOnUpdateTest() {
        UTIL_CustomSettingsFacade.getSettingsForTests(
            new Hierarchy_Settings__c(Disable_Preferred_Email_Enforcement__c = false)
            );

        List<Contact> testContactList = UTIL_UnitTestData_TEST.getMultipleTestContacts(2);
        testContactList[0].WorkEmail__c = 'demo@sf.org';
        testContactList[0].Preferred_Email__c = 'Work Email';
        testContactList[0].AlternateEmail__c = 'test@sf.org';
        testContactList[1].WorkEmail__c = 'demo@sf.org';
        testContactList[1].Preferred_Email__c = 'Work Email';
        testContactList[1].AlternateEmail__c = 'test@sf.org';
        insert testContactList;

        List<Contact> insertedContactList = [SELECT Id, Email, AlternateEmail__c, Preferred_Email__c FROM Contact];

        System.assertEquals('demo@sf.org', insertedContactList[0].Email, 'Standard Email should be same as Work Email');
        System.assertEquals('demo@sf.org', insertedContactList[1].Email, 'Standard Email should be same as Work Email');

        MAPR_CON_PreferredEmailFields.preferredEmailFieldSettingsModel = null;
        UTIL_CustomSettingsFacade.getSettingsForTests(
            new Hierarchy_Settings__c(Disable_Preferred_Email_Enforcement__c = true)
        );        

        // Clear Alternate Email, Preferred Email and Standard Email leaving only work email populated
        insertedContactList[0].AlternateEmail__c = '';
        insertedContactList[0].Preferred_Email__c = null;
        insertedContactList[0].Email = null;
        insertedContactList[1].AlternateEmail__c = '';
        insertedContactList[1].Preferred_Email__c = null;
        insertedContactList[1].Email = null;

        Test.startTest();
            update insertedContactList;
        Test.stopTest();

        List<Contact> updatedContactList = [SELECT Id, AlternateEmail__c, Preferred_Email__c, WorkEmail__c, Email FROM Contact];

        System.assertEquals('demo@sf.org', updatedContactList[0].WorkEmail__c, 'Work Email should not be cleared');
        System.assertEquals('demo@sf.org', updatedContactList[1].WorkEmail__c, 'Work Email should not be cleared');
        System.assertEquals(null, updatedContactList[0].AlternateEmail__c, 'Alternate Email should not be re-populated');
        System.assertEquals(null, updatedContactList[0].Preferred_Email__c, 'Preferred Email should not be re-populated');
        System.assertEquals(null, updatedContactList[0].Email, 'Standard Email should not not be re-populated');
        System.assertEquals(null, updatedContactList[1].AlternateEmail__c, 'Alternate Email should not be re-populated');
        System.assertEquals(null, updatedContactList[1].Preferred_Email__c, 'Preferred Email should not be re-populated');
        System.assertEquals(null, updatedContactList[1].Email, 'Standard Email should not be re-populated');

    }

    
    /*************************************************************************************************************************
    * @description Tests Inserting a Contact with only one custom Email field will set it as Preferred Email and copy the value 
    * to standard the Email field when Preferred Email Enforcement is Enabled
    **************************************************************************************************************************/
    @isTest
    static void singleEmailSmartSetOnInsert() {
        UTIL_CustomSettingsFacade.getSettingsForTests(
            new Hierarchy_Settings__c(Disable_Preferred_Email_Enforcement__c = false)
        );

        List<Contact> testContactList = UTIL_UnitTestData_TEST.getMultipleTestContacts(2);
        testContactList[0].WorkEmail__c = '';
        testContactList[0].Preferred_Email__c = '';
        testContactList[0].AlternateEmail__c = 'test@sf.org';
        testContactList[1].WorkEmail__c = '';
        testContactList[1].Preferred_Email__c = '';
        testContactList[1].AlternateEmail__c = 'test@sf.org';

        Test.startTest();
            insert testContactList;
        Test.stopTest();

        List<Contact> updatedContactList = [SELECT Id, Email, Preferred_Email__c FROM Contact];
        System.assertEquals('test@sf.org', updatedContactList[0].Email, 'Email should be populated with Alternate Email value');
        System.assertEquals('Alternate Email', updatedContactList[0].Preferred_Email__c, 'Preferred Email shoule be Alternate Email');
        System.assertEquals('test@sf.org', updatedContactList[1].Email, 'Email should be populated with Alternate Email value');
        System.assertEquals('Alternate Email', updatedContactList[1].Preferred_Email__c, 'Preferred Email shoule be Alternate Email');

    }
    
    /*************************************************************************************************************************
    * @description Tests Inserting a Contact with only one custom Email field not set Preferred Email and will not copy the value 
    * to standard the Email field when Preferred Email Enforcement is disabled
    **************************************************************************************************************************/
    @isTest 
    static void singleEmailSmartSetOnInsertNegativeTest() {
        UTIL_CustomSettingsFacade.getSettingsForTests(
            new Hierarchy_Settings__c(Disable_Preferred_Email_Enforcement__c = true)
        );

        List<Contact> testContactList = UTIL_UnitTestData_TEST.getMultipleTestContacts(2);
        testContactList[0].WorkEmail__c = '';
        testContactList[0].Preferred_Email__c = '';
        testContactList[0].AlternateEmail__c = 'test@sf.org';
        testContactList[1].WorkEmail__c = '';
        testContactList[1].Preferred_Email__c = '';
        testContactList[1].AlternateEmail__c = 'test@sf.org';

        Test.startTest();
            insert testContactList;
        Test.stopTest();

        List<Contact> updatedContactList = [SELECT Id, Email, Preferred_Email__c FROM Contact];
        System.assertEquals(null, updatedContactList[0].Email, 'Standard Email should not be popualted');
        System.assertEquals(null, updatedContactList[0].Preferred_Email__c, 'Preferred Email should not be popualted');
        System.assertEquals(null, updatedContactList[1].Email, 'Standard Email should not be popualted');
        System.assertEquals(null, updatedContactList[1].Preferred_Email__c, 'Preferred Email should not be popualted');

    }
    
    /*************************************************************************************************************************
    * @description Tests Updating a Contact with only one custom Email field will it as Preferred Email and copy the value 
    * to standard the Email field when Preferred Email Enforcement is Enabled
    **************************************************************************************************************************/
    @isTest 
    static void singleEmailSmartSetOnUpdate() {
        UTIL_CustomSettingsFacade.getSettingsForTests(
            new Hierarchy_Settings__c(Disable_Preferred_Email_Enforcement__c = false)
        );

        List<Contact> testContactList = UTIL_UnitTestData_TEST.getMultipleTestContacts(2);
        testContactList[0].WorkEmail__c = '';
        testContactList[0].Preferred_Email__c = '';
        testContactList[1].WorkEmail__c = '';
        testContactList[1].Preferred_Email__c = '';
        insert testContactList;

        testContactList[0].AlternateEmail__c = 'test@sf.org';
        testContactList[1].AlternateEmail__c = 'test@sf.org';
        
        Test.startTest();
            update testContactList;
        Test.stopTest();

        List<Contact> updatedContactList = [SELECT Id, Email, Preferred_Email__c FROM Contact];
        System.assertEquals('test@sf.org', updatedContactList[0].Email,  'Email should be populated with Alternate Email value');
        System.assertEquals('Alternate Email', updatedContactList[0].Preferred_Email__c, 'Preferred Email should not be popualted');
        System.assertEquals('test@sf.org', updatedContactList[1].Email, 'Email should be populated with Alternate Email value');
        System.assertEquals('Alternate Email', updatedContactList[1].Preferred_Email__c, 'Preferred Email should not be popualted');

    }
    
    /*************************************************************************************************************************
    * @description Tests Updating a Contact with only one custom Email field will not set Preferred Email and will not copy 
    * the value to standard the Email field when Preferred Email Enforcement is disbaled
    **************************************************************************************************************************/
    @isTest 
    static void singleEmailSmartSetOnUpdateNegativeTest() {
        UTIL_CustomSettingsFacade.getSettingsForTests(
            new Hierarchy_Settings__c(Disable_Preferred_Email_Enforcement__c = true)
        );

        List<Contact> testContactList = UTIL_UnitTestData_TEST.getMultipleTestContacts(2);
        testContactList[0].WorkEmail__c = '';
        testContactList[0].Preferred_Email__c = '';
        testContactList[1].WorkEmail__c = '';
        testContactList[1].Preferred_Email__c = '';
        insert testContactList;

        testContactList[0].AlternateEmail__c = 'test@sf.org';
        testContactList[1].AlternateEmail__c = 'test@sf.org';
        Test.startTest();
            update testContactList;
        Test.stopTest();

        List<Contact> updatedContactList = [SELECT Id, Email, Preferred_Email__c FROM Contact];
        System.assertEquals(null, updatedContactList[0].Email, 'Standard Email should not be popualted');
        System.assertEquals(null, updatedContactList[0].Preferred_Email__c, 'Preferred Email should not be popualted');
        System.assertEquals(null, updatedContactList[1].Email, 'Standard Email should not be popualted');
        System.assertEquals(null, updatedContactList[1].Preferred_Email__c, 'Preferred Email should not be popualted');

    }
    
    /*************************************************************************************************************************
    * @description Tests Inserting a Contact with more than one custom Email fields will throw PreferredEmailRequiredError
    * when Preferred Email Enforcement is Enabled
    **************************************************************************************************************************/
    @isTest 
    static void multipleEmailsOnInsert() {
        UTIL_CustomSettingsFacade.getSettingsForTests(
            new Hierarchy_Settings__c(Disable_Preferred_Email_Enforcement__c = false)
        );

        List<Contact> testContactList = UTIL_UnitTestData_TEST.getMultipleTestContacts(2);
        testContactList[0].Preferred_Email__c = '';
        testContactList[0].AlternateEmail__c = 'test@sf.org';
        testContactList[0].WorkEmail__c = 'test@sf.org';
        testContactList[1].Preferred_Email__c = '';
        testContactList[1].AlternateEmail__c = 'test@sf.org';
        testContactList[1].WorkEmail__c = 'test@sf.org';

        try {
            Test.startTest();
                insert testContactList;
            Test.stopTest();
            System.assert(false, 'Always throw an error when multiple email fields have value and when Preferred Email is Blank.');
        } catch (DmlException  error) {
            System.assert(error.getMessage().contains(Label.PreferredEmailRequiredError));
        }
    }
    
    /***********************************************************************************************************************************
    * @description Tests inserting a Contact with more than one custom Email fields will not throw any error and not set Preferred Email
    * and standard Email field when Preferred Email Enforcement is disabled
    ************************************************************************************************************************************/
    @isTest 
    static void multipleEmailsOnInsertNegativeTest() {
        UTIL_CustomSettingsFacade.getSettingsForTests(
            new Hierarchy_Settings__c(Disable_Preferred_Email_Enforcement__c = true)
        );

        List<Contact> testContactList = UTIL_UnitTestData_TEST.getMultipleTestContacts(2);
        testContactList[0].Preferred_Email__c = '';
        testContactList[0].AlternateEmail__c = 'test@sf.org';
        testContactList[0].WorkEmail__c = 'test@sf.org';
        testContactList[1].Preferred_Email__c = '';
        testContactList[1].AlternateEmail__c = 'test@sf.org';
        testContactList[1].WorkEmail__c = 'test@sf.org';

        Test.startTest();
            insert testContactList;
        Test.stopTest();

        List<Contact> insertedContactList = [SELECT Id, Email, Preferred_Email__c FROM Contact];
        System.assertEquals(null, insertedContactList[0].Preferred_Email__c, 'Preferred Email should not be popualted');
        System.assertEquals(null, insertedContactList[0].Email, 'Standard Email should not be popualted');
        System.assertEquals(null, insertedContactList[1].Preferred_Email__c, 'Preferred Email should not be popualted');
        System.assertEquals(null, insertedContactList[1].Email, 'Standard Email should not be popualted');

    }
    
    /*************************************************************************************************************************
    * @description Tests updating a Contact with more than one custom Email fields will throw PreferredEmailRequiredError
    * when Preferred Email Enforcement is Enabled
    **************************************************************************************************************************/
    @isTest 
    static void multipleEmailsOnUpdate() {
        UTIL_CustomSettingsFacade.getSettingsForTests(
            new Hierarchy_Settings__c(Disable_Preferred_Email_Enforcement__c = false)
        );

        List<Contact> testContactList = UTIL_UnitTestData_TEST.getMultipleTestContacts(2);
        testContactList[0].WorkEmail__c = '';
        testContactList[0].Preferred_Email__c = '';
        testContactList[1].WorkEmail__c = '';
        testContactList[1].Preferred_Email__c = '';
        insert testContactList;

        try {
            testContactList[0].AlternateEmail__c = 'test@sf.org';
            testContactList[0].WorkEmail__c = 'test@sf.org';
            testContactList[1].AlternateEmail__c = 'test@sf.org';
            testContactList[1].WorkEmail__c = 'test@sf.org';
            Test.startTest();
                update testContactList;
            Test.stopTest();
            System.assert(false, 'Always throw an error when multiple email fields have value and when Preferred Email is Blank.');
        } catch (DmlException  error) {
            System.assert(error.getMessage().contains(Label.PreferredEmailRequiredError));
        }
    }
    
    /*************************************************************************************************************************
    * @description Tests updating a Contact with more than one custom Email fields will not throw any Error
    * and will not set Preferred Email or standarad email when Preferred Email Enforcement is Disbaled
    **************************************************************************************************************************/
    @isTest 
    static void multipleEmailsOnUpdateNegativeTest() {
        UTIL_CustomSettingsFacade.getSettingsForTests(
            new Hierarchy_Settings__c(Disable_Preferred_Email_Enforcement__c = true)
        );

        List<Contact> testContactList = UTIL_UnitTestData_TEST.getMultipleTestContacts(2);
        testContactList[0].WorkEmail__c = '';
        testContactList[0].Preferred_Email__c = '';
        testContactList[1].WorkEmail__c = '';
        testContactList[1].Preferred_Email__c = '';
        insert testContactList;

        testContactList[0].AlternateEmail__c = 'test@sf.org';
        testContactList[0].WorkEmail__c = 'test@sf.org';
        testContactList[1].AlternateEmail__c = 'test@sf.org';
        testContactList[1].WorkEmail__c = 'test@sf.org';
        
        Test.startTest();
            update testContactList;
        Test.stopTest();

        List<Contact> updatedContactList = [SELECT Id, preferred_Email__c, Email FROM Contact];
        System.assertEquals(null, updatedContactList[0].preferred_Email__c, 'Preferred Email should not be popualted');
        System.assertEquals(null, updatedContactList[0].Email, 'Standard Email should not be popualted');
        System.assertEquals(null, updatedContactList[1].preferred_Email__c, 'Preferred Email should not be popualted');
        System.assertEquals(null, updatedContactList[1].Email, 'Standard Email should not be popualted');

    }

    /************************************************************************************************************************************
    * @description Tests inserting a Contact with one custom Email field and Preferred Email which doesn't correspond to preferred Email
    * will throw PreferredEmailMatchNotNull when Preferred Email Enforcement is Enabled
    *************************************************************************************************************************************/
    @isTest 
    static void insertWithPreferredEmailMatchNotNullErrorWithEnforcementEnabled() {

        UTIL_CustomSettingsFacade.getSettingsForTests(
            new Hierarchy_Settings__c(Disable_Preferred_Email_Enforcement__c = false)
        );

        List<Contact> testContactList = UTIL_UnitTestData_TEST.getMultipleTestContacts(2);
        testContactList[0].Email = '';
        testContactList[0].Preferred_Email__c = 'Alternate Email';
        testContactList[0].WorkEmail__c = 'test@sf.org';
        testContactList[1].Email = '';
        testContactList[1].Preferred_Email__c = 'Alternate Email';
        testContactList[1].WorkEmail__c = 'test@sf.org';

        try {
            Test.startTest();
                insert testContactList;
            Test.stopTest();
            System.assert(false, 'Always throw an error when the value corresponding to Preferred Email is Blank.');
        } catch (DmlException error) {
            System.assert(error.getMessage().contains(Label.PreferredEmailMatchNotNull));
        }
    }

    /************************************************************************************************************************************
    * @description Tests inserting a Contact with one custom Email field and Preferred Email which doesn't correspond to preferred Email
    * will throw PreferredEmailMatchNotNull when Preferred Email Enforcement is Disabled
    *************************************************************************************************************************************/
    @isTest 
    static void insertWithPreferredEmailMatchNotNullErrorWithEnforcementDisabled() {

        UTIL_CustomSettingsFacade.getSettingsForTests(
            new Hierarchy_Settings__c(Disable_Preferred_Email_Enforcement__c = true)
        );

        List<Contact> testContactList = UTIL_UnitTestData_TEST.getMultipleTestContacts(2);
        testContactList[0].Email = '';
        testContactList[0].Preferred_Email__c = 'Alternate Email';
        testContactList[0].WorkEmail__c = 'test@sf.org';
        testContactList[1].Email = '';
        testContactList[1].Preferred_Email__c = 'Alternate Email';
        testContactList[1].WorkEmail__c = 'test@sf.org';

        try {
            Test.startTest();
                insert testContactList;
            Test.stopTest();
            System.assert(false, 'Always throw an error when the value corresponding to Preferred Email is Blank.');
        } catch (DmlException error) {
            System.assert(error.getMessage().contains(Label.PreferredEmailMatchNotNull));
        }
    }

    /************************************************************************************************************************************
    * @description Tests upating a Contact with one custom Email field and Preferred Email which doesn't correspond to preferred Email
    * will throw PreferredEmailMatchNotNull when Preferred Email Enforcement is Enabled
    *************************************************************************************************************************************/
    @isTest 
    static void updateWithPreferredEmailMatchNotNullErrorWithEnforcementEnabled() {

        UTIL_CustomSettingsFacade.getSettingsForTests(
            new Hierarchy_Settings__c(Disable_Preferred_Email_Enforcement__c = false)
        );

        List<Contact> testContactList = UTIL_UnitTestData_TEST.getMultipleTestContacts(2);
        testContactList[0].Email = '';
        testContactList[0].Preferred_Email__c = '';
        testContactList[0].WorkEmail__c = '';
        testContactList[1].Email = '';
        testContactList[1].Preferred_Email__c = '';
        testContactList[1].WorkEmail__c = '';
        insert testContactList;

        testContactList[0].Preferred_Email__c = 'Alternate Email';
        testContactList[0].WorkEmail__c = 'test@sf.org';
        testContactList[1].Preferred_Email__c = 'Alternate Email';
        testContactList[1].WorkEmail__c = 'test@sf.org';
        
        try {
            Test.startTest();
                update testContactList;
            Test.stopTest();
            System.assert(false, 'Always throw an error when the value corresponding to Preferred Email is Blank.');
        } catch (DmlException error) {
            System.assert(error.getMessage().contains(Label.PreferredEmailMatchNotNull));
        }
    }

    /************************************************************************************************************************************
    * @description Tests upating a Contact with one custom Email field and Preferred Email which doesn't correspond to preferred Email
    * will throw PreferredEmailMatchNotNull when Preferred Email Enforcement is disabled
    *************************************************************************************************************************************/
    @isTest 
    static void updateWithPreferredEmailMatchNotNullErrorWithEnforcementDisabled() {

        UTIL_CustomSettingsFacade.getSettingsForTests(
            new Hierarchy_Settings__c(Disable_Preferred_Email_Enforcement__c = true)
        );

        List<Contact> testContactList = UTIL_UnitTestData_TEST.getMultipleTestContacts(2);
        testContactList[0].Email = '';
        testContactList[0].Preferred_Email__c = '';
        testContactList[0].WorkEmail__c = '';
        testContactList[1].Email = '';
        testContactList[1].Preferred_Email__c = '';
        testContactList[1].WorkEmail__c = '';
        insert testContactList;

        testContactList[0].Preferred_Email__c = 'Alternate Email';
        testContactList[0].WorkEmail__c = 'test@sf.org';
        testContactList[1].Preferred_Email__c = 'Alternate Email';
        testContactList[1].WorkEmail__c = 'test@sf.org';
        
        try {
            Test.startTest();
                update testContactList;
            Test.stopTest();
            System.assert(false, 'Always throw an error when the value corresponding to Preferred Email is Blank.');
        } catch (DmlException error) {
            System.assert(error.getMessage().contains(Label.PreferredEmailMatchNotNull));
        }
    }

    /************************************************************************************************************************************
    * @description Tests inserting a Contact with one custom Email field and Preferred Email which corresponds to preferred Email
    * will update Standard Email field to the value in custom Email field when Preferred Email Enforcement is enabled
    *************************************************************************************************************************************/
    @isTest 
    static void copyValueToStandardFieldOnInsertWithEnforcementEnabled() {

        UTIL_CustomSettingsFacade.getSettingsForTests(
            new Hierarchy_Settings__c(Disable_Preferred_Email_Enforcement__c = false)
        );

        List<Contact> testContactList = UTIL_UnitTestData_TEST.getMultipleTestContacts(2);
        testContactList[0].Preferred_Email__c = 'Work Email';
        testContactList[0].WorkEmail__c = 'test@sf.org';
        testContactList[0].Email = '';
        testContactList[1].Preferred_Email__c = 'Work Email';
        testContactList[1].WorkEmail__c = 'test@sf.org';
        testContactList[1].Email = '';

        Test.startTest();
            insert testContactList;
        Test.stopTest();

        List<Contact> updatedContactList = [SELECT Id, Email FROM Contact];
        System.assertEquals(testContactList[0].WorkEmail__c, updatedContactList[0].Email);
        System.assertEquals(testContactList[1].WorkEmail__c, updatedContactList[1].Email);

    }

    /************************************************************************************************************************************
    * @description Tests inserting a Contact with one custom Email field and Preferred Email which corresponds to preferred Email
    * will update Standard Email field to the value in custom Email field when Preferred Email Enforcement is disabled
    *************************************************************************************************************************************/
    @isTest 
    static void copyValueToStandardFieldOnInsertWithEnforcementDisabled() {

        UTIL_CustomSettingsFacade.getSettingsForTests(
            new Hierarchy_Settings__c(Disable_Preferred_Email_Enforcement__c = true)
        );

        List<Contact> testContactList = UTIL_UnitTestData_TEST.getMultipleTestContacts(2);
        testContactList[0].Preferred_Email__c = 'Work Email';
        testContactList[0].WorkEmail__c = 'test@sf.org';
        testContactList[0].Email = '';
        testContactList[1].Preferred_Email__c = 'Work Email';
        testContactList[1].WorkEmail__c = 'test@sf.org';
        testContactList[1].Email = '';

        Test.startTest();
            insert testContactList;
        Test.stopTest();

        List<Contact> updatedContactList = [SELECT Id, Email FROM Contact];
        System.assertEquals('test@sf.org', updatedContactList[0].Email, 'Email should be same as Work Email');
        System.assertEquals('test@sf.org', updatedContactList[1].Email, 'Email should be same as Work Email');

    }

    /************************************************************************************************************************************
    * @description Tests updating a Contact with one custom Email field and Preferred Email which corresponds to preferred Email
    * will update Standard Email field to the value in custom Email field when Preferred Email Enforcement is enabled
    *************************************************************************************************************************************/
    @isTest 
    static void copyValueToStandardFieldOnUpdateWithEnforcementEnabled() {

        UTIL_CustomSettingsFacade.getSettingsForTests(
            new Hierarchy_Settings__c(Disable_Preferred_Email_Enforcement__c = false)
        );

        List<Contact> testContactList = UTIL_UnitTestData_TEST.getMultipleTestContacts(2);
        testContactList[0].Email = '';
        testContactList[0].WorkEmail__c = '';
        testContactList[0].Preferred_Email__c = '';
        testContactList[1].Email = '';
        testContactList[1].WorkEmail__c = '';
        testContactList[1].Preferred_Email__c = '';
        insert testContactList;

        testContactList[0].Preferred_Email__c = 'Work Email';
        testContactList[0].WorkEmail__c = 'test@sf.org';
        testContactList[1].Preferred_Email__c = 'Work Email';
        testContactList[1].WorkEmail__c = 'test@sf.org';
        Test.startTest();
            update testContactList;
        Test.stopTest();

        List<Contact> updatedContactList = [SELECT Id, Email FROM Contact];
        System.assertEquals('test@sf.org', updatedContactList[0].Email, 'Email should be same as Work Email');
        System.assertEquals('test@sf.org', updatedContactList[1].Email, 'Email should be same as Work Email');

    }

    /************************************************************************************************************************************
    * @description Tests updating a Contact with one custom Email field and Preferred Email which corresponds to preferred Email
    * will update Standard Email field to the value in custom Email field when Preferred Email Enforcement is disabled
    *************************************************************************************************************************************/
    @isTest 
    static void copyValueToStandardFieldOnUpdateWithEnforcementDisabled() {

        UTIL_CustomSettingsFacade.getSettingsForTests(
            new Hierarchy_Settings__c(Disable_Preferred_Email_Enforcement__c = true)
        );

        List<Contact> testContactList = UTIL_UnitTestData_TEST.getMultipleTestContacts(2);
        testContactList[0].Email = '';
        testContactList[0].WorkEmail__c = '';
        testContactList[0].Preferred_Email__c = '';
        testContactList[1].Email = '';
        testContactList[1].WorkEmail__c = '';
        testContactList[1].Preferred_Email__c = '';
        insert testContactList;

        testContactList[0].Preferred_Email__c = 'Work Email';
        testContactList[0].WorkEmail__c = 'test@sf.org';
        testContactList[1].Preferred_Email__c = 'Work Email';
        testContactList[1].WorkEmail__c = 'test@sf.org';
        Test.startTest();
            update testContactList;
        Test.stopTest();

        List<Contact> updatedContactList = [SELECT Id, Email FROM Contact];
        System.assertEquals('test@sf.org', updatedContactList[0].Email, 'Email should be same as Work Email');
        System.assertEquals('test@sf.org', updatedContactList[1].Email, 'Email should be same as Work Email');

    }

    /************************************************************************************************************************************
    * @description Tests inserting a Contact with one custom Email field and Preferred Email which doesn't corresponds to any of the
    * custom email fields will throw PreferredEmailMatchMustExist error when Preferred Email Enforcement is Enabled
    *************************************************************************************************************************************/
    @isTest 
    static void fieldNotFoundOnInsertWithEnforcementEnabled() {

        UTIL_CustomSettingsFacade.getSettingsForTests(
            new Hierarchy_Settings__c(Disable_Preferred_Email_Enforcement__c = false)
        );

        List<Contact> testContactList = UTIL_UnitTestData_TEST.getMultipleTestContacts(2);
        testContactList[0].Preferred_Email__c = 'Test sf Email';
        testContactList[0].WorkEmail__c = 'test@sf.org';
        testContactList[1].Preferred_Email__c = 'Test sf Email';
        testContactList[1].WorkEmail__c = 'test@sf.org';

        try {
        Test.startTest();
            insert testContactList;
        Test.stopTest();
        System.assert(false, 'Always throw an error when the field corresponding to Preferred Email is not found.');
        } catch (DmlException error) {
             System.assert(error.getMessage().contains(Label.PreferredEmailMatchMustExist));
        }
    }
    
    /************************************************************************************************************************************
    * @description Tests inserting a Contact with one custom Email field and Preferred Email which doesn't corresponds to any of the
    * custom email fields will throw PreferredEmailMatchMustExist error when Preferred Email Enforcement is Disabled
    *************************************************************************************************************************************/
    @isTest 
    static void fieldNotFoundOnInsertWithEnforcementDisabled() {

        UTIL_CustomSettingsFacade.getSettingsForTests(
            new Hierarchy_Settings__c(Disable_Preferred_Email_Enforcement__c = true)
        );

        List<Contact> testContactList = UTIL_UnitTestData_TEST.getMultipleTestContacts(2);
        testContactList[0].Preferred_Email__c = 'Test sf Email';
        testContactList[0].WorkEmail__c = 'test@sf.org';
        testContactList[1].Preferred_Email__c = 'Test sf Email';
        testContactList[1].WorkEmail__c = 'test@sf.org';

        try {
        Test.startTest();
            insert testContactList;
        Test.stopTest();
        System.assert(false, 'Always throw an error when the field corresponding to Preferred Email is not found.');
        } catch (DmlException error) {
             System.assert(error.getMessage().contains(Label.PreferredEmailMatchMustExist));
        }
    }

    /************************************************************************************************************************************
    * @description Tests updating  a Contact with one custom Email field and Preferred Email which doesn't corresponds to any of the
    * custom email fields will throw PreferredEmailMatchMustExist error when Preferred Email Enforcement is Enabled
    *************************************************************************************************************************************/
    @isTest 
    static void fieldNotFoundOnUpdateWithEnforcementEnabled() {

        UTIL_CustomSettingsFacade.getSettingsForTests(
            new Hierarchy_Settings__c(Disable_Preferred_Email_Enforcement__c = false)
        );

        List<Contact> testContactList = UTIL_UnitTestData_TEST.getMultipleTestContacts(2);
        testContactList[0].WorkEmail__c = '';
        testContactList[0].Preferred_Email__c = null; 
        testContactList[1].WorkEmail__c = '';
        testContactList[1].Preferred_Email__c = null; 
        insert testContactList;

        testContactList[0].Preferred_Email__c = 'Test sf Email';
        testContactList[0].WorkEmail__c = 'test@sf.org';
        testContactList[1].Preferred_Email__c = 'Test sf Email';
        testContactList[1].WorkEmail__c = 'test@sf.org';

        try {
            Test.startTest();
                update  testContactList[0];
            Test.stopTest();
            System.assert(false, 'Always throw an error when the field corresponding to Preferred Email is not found.');
        } catch (DmlException error) {
            System.assert(error.getMessage().contains(Label.PreferredEmailMatchMustExist));
        }
    }

    /************************************************************************************************************************************
    * @description Tests updating a Contact with one custom Email field and Preferred Email which doesn't corresponds to any of the
    * custom email fields will throw PreferredEmailMatchMustExist error when Preferred Email Enforcement is Disabled
    *************************************************************************************************************************************/
    @isTest 
    static void fieldNotFoundOnUpdateWithEnforcementDisabled() {

        UTIL_CustomSettingsFacade.getSettingsForTests(
            new Hierarchy_Settings__c(Disable_Preferred_Email_Enforcement__c = true)
        );
        List<Contact> testContactList = UTIL_UnitTestData_TEST.getMultipleTestContacts(2);
        testContactList[0].WorkEmail__c = '';
        testContactList[0].Preferred_Email__c = null; 
        testContactList[1].WorkEmail__c = '';
        testContactList[1].Preferred_Email__c = null; 
        insert testContactList;

        testContactList[0].Preferred_Email__c = 'Test sf Email';
        testContactList[0].WorkEmail__c = 'test@sf.org';
        testContactList[1].Preferred_Email__c = 'Test sf Email';
        testContactList[1].WorkEmail__c = 'test@sf.org';
        
        try {
            Test.startTest();
                update  testContactList[0];
            Test.stopTest();
            System.assert(false, 'Always throw an error when the field corresponding to Preferred Email is not found.');
        } catch (DmlException error) {
            System.assert(error.getMessage().contains(Label.PreferredEmailMatchMustExist));
        }
    }

    /************************************************************************************************************************************
    * @description Tests updating a Contact in Batch context with the value of standard Email field not matching with any of the values in
    * custom email fields will update Preferred Email to the label preferredBatchDefaultEmail when Preferred Email Enforcement is enabled
    *************************************************************************************************************************************/
    @isTest 
    static void updatePreferredEmailToEmailStandardBatch() {
        UTIL_CustomSettingsFacade.getSettingsForTests(
            new Hierarchy_Settings__c(Disable_Preferred_Email_Enforcement__c = false)
        );

        TDTM_ProcessControl.setRecursionFlag(TDTM_ProcessControl.registeredTrigger.CON_Preferred_TDTM, true);

        List<Contact> testContactList = UTIL_UnitTestData_TEST.getMultipleTestContacts(2);
        testContactList[0].Email = 'TestingEmail@sf.org';
        testContactList[0].WorkEmail__c = 'test@sf.org';
        testContactList[0].Preferred_Email__c = null;
        testContactList[1].Email = 'TestingEmail@sf.org';
        testContactList[1].WorkEmail__c = 'test@sf.org';
        testContactList[1].Preferred_Email__c = null;
        insert testContactList;

        TDTM_ProcessControl.setRecursionFlag(TDTM_ProcessControl.registeredTrigger.CON_Preferred_TDTM, false);  
        CON_Email_BATCH batch = new CON_Email_BATCH(null);
        Test.startTest();
            Database.executeBatch(batch);
        Test.stopTest();

        List<Contact> contactAfterBatchUpdateList = [SELECT Id, Preferred_Email__c FROM Contact];

        System.assertEquals(Label.preferredBatchDefaultEmail, contactAfterBatchUpdateList[0].Preferred_Email__c, 'Email should be populated with default email');
        System.assertEquals(Label.preferredBatchDefaultEmail, contactAfterBatchUpdateList[1].Preferred_Email__c, 'Email should be populated with default email');

    }

    /************************************************************************************************************************************
    * @description Tests updating a Contact in Batch context with the value of standard Email field not matching with any of the values in
    * custom email fields will not update Preferred Email when Preferred Email Enforcement is disabled
    *************************************************************************************************************************************/
    @isTest 
    static void updatePreferredEmailToEmailStandardBatchNegativeTest() {
        UTIL_CustomSettingsFacade.getSettingsForTests(
            new Hierarchy_Settings__c(Disable_Preferred_Email_Enforcement__c = false)
        );

        TDTM_ProcessControl.setRecursionFlag(TDTM_ProcessControl.registeredTrigger.CON_Preferred_TDTM, true);

        List<Contact> testContactList = UTIL_UnitTestData_TEST.getMultipleTestContacts(2);
        testContactList[0].Email = 'TestingEmail@sf.org';
        testContactList[0].WorkEmail__c = 'test@sf.org';
        testContactList[0].Preferred_Email__c = null;
        testContactList[1].Email = 'TestingEmail@sf.org';
        testContactList[1].WorkEmail__c = 'test@sf.org';
        testContactList[1].Preferred_Email__c = null;
        insert testContactList;

        TDTM_ProcessControl.setRecursionFlag(TDTM_ProcessControl.registeredTrigger.CON_Preferred_TDTM, false);

        UTIL_CustomSettingsFacade.getSettingsForTests(
            new Hierarchy_Settings__c(Disable_Preferred_Email_Enforcement__c = true)
        );

        CON_Email_BATCH batch = new CON_Email_BATCH(null);
        Test.startTest();
            Database.executeBatch(batch);
        Test.stopTest();

        List<Contact> contactAfterBatchUpdateList = [SELECT Id, Preferred_Email__c FROM Contact];

        System.assertEquals(null, contactAfterBatchUpdateList[0].Preferred_Email__c, 'Preferred Email should be null');
        System.assertEquals(null, contactAfterBatchUpdateList[1].Preferred_Email__c, 'Preferred Email should be null');

    }
    
    /************************************************************************************************************************************
    * @description Tests updating a Contact in Batch context with the value of standard Email field matching with any of the values in
    * custom email fields will update Preferred Email to the first available custom email field's label when Preferred Email Enforcement is enabled
    *************************************************************************************************************************************/
    @isTest 
    static void updatePreferredEmailToFirstMatchingEmailFieldBatch() {
        UTIL_CustomSettingsFacade.getSettingsForTests(
            new Hierarchy_Settings__c(Disable_Preferred_Email_Enforcement__c = false)
        );

        TDTM_ProcessControl.setRecursionFlag(TDTM_ProcessControl.registeredTrigger.CON_Preferred_TDTM, true);

        List<Contact> testContactList = UTIL_UnitTestData_TEST.getMultipleTestContacts(2);
        testContactList[0].Email = 'test@sf.org';
        testContactList[0].WorkEmail__c = 'test@sf.org';
        testContactList[0].UniversityEmail__c = 'testUniv@sf.org';
        testContactList[0].Preferred_Email__c = null;
        testContactList[1].Email = 'test@sf.org';
        testContactList[1].WorkEmail__c = 'test@sf.org';
        testContactList[1].UniversityEmail__c = 'testUniv@sf.org';
        testContactList[1].Preferred_Email__c = null;
        insert testContactList;

        TDTM_ProcessControl.setRecursionFlag(TDTM_ProcessControl.registeredTrigger.CON_Preferred_TDTM, false);  
        CON_Email_BATCH batch = new CON_Email_BATCH(null);
        Test.startTest();
            Database.executeBatch(batch);
        Test.stopTest();

        List<Contact> contactAfterBatchUpdateList = [SELECT Id, Preferred_Email__c FROM Contact];

        System.assertEquals('Work Email', contactAfterBatchUpdateList[0].Preferred_Email__c, 'Preferred Email should be Work Email');
        System.assertEquals('Work Email', contactAfterBatchUpdateList[1].Preferred_Email__c, 'Preferred Email should be Work Email');

    }

    /************************************************************************************************************************************
    * @description Tests updating a Contact in Batch context with the value of standard Email field matching with any of the values in
    * custom email fields will not update Preferred Email when Preferred Email Enforcement is disabled
    *************************************************************************************************************************************/
    @isTest 
    static void updatePreferredEmailToFirstMatchingEmailFieldBatchNegativeTest() {
        UTIL_CustomSettingsFacade.getSettingsForTests(
            new Hierarchy_Settings__c(Disable_Preferred_Email_Enforcement__c = false)
        );

        TDTM_ProcessControl.setRecursionFlag(TDTM_ProcessControl.registeredTrigger.CON_Preferred_TDTM, true);

        List<Contact> testContactList = UTIL_UnitTestData_TEST.getMultipleTestContacts(2);
        testContactList[0].Email = 'test@sf.org';
        testContactList[0].WorkEmail__c = 'test@sf.org';
        testContactList[0].UniversityEmail__c = 'testUniv@sf.org';
        testContactList[0].Preferred_Email__c = null;
        testContactList[1].Email = 'test@sf.org';
        testContactList[1].WorkEmail__c = 'test@sf.org';
        testContactList[1].UniversityEmail__c = 'testUniv@sf.org';
        testContactList[1].Preferred_Email__c = null;
        insert testContactList;

        TDTM_ProcessControl.setRecursionFlag(TDTM_ProcessControl.registeredTrigger.CON_Preferred_TDTM, false);

        UTIL_CustomSettingsFacade.getSettingsForTests(
            new Hierarchy_Settings__c(Disable_Preferred_Email_Enforcement__c = true)
        );

        CON_Email_BATCH batch = new CON_Email_BATCH(null);
        Test.startTest();
            Database.executeBatch(batch);
        Test.stopTest();

        List<Contact> contactAfterBatchUpdateList = [SELECT Id, Preferred_Email__c FROM Contact];

        System.assertEquals(null, contactAfterBatchUpdateList[0].Preferred_Email__c, 'Preferred Email should be null');
        System.assertEquals(null, contactAfterBatchUpdateList[1].Preferred_Email__c, 'Preferred Email should be null');

    }
    
    /************************************************************************************************************************************
    * @description Tests updating a Contact in Batch context with only one custom email field will update Preferred Email to the label 
    * corresponding to the custom email field with value when Standard Email field is blank and Preferred Email Enforcement is enabled
    *************************************************************************************************************************************/
    @isTest 
    static void updatePreferredEmailSmartSetBatch() {
        UTIL_CustomSettingsFacade.getSettingsForTests(
            new Hierarchy_Settings__c(Disable_Preferred_Email_Enforcement__c = false)
        );

        TDTM_ProcessControl.setRecursionFlag(TDTM_ProcessControl.registeredTrigger.CON_Preferred_TDTM, true);

        List<Contact> testContactList = UTIL_UnitTestData_TEST.getMultipleTestContacts(2);
        testContactList[0].Email = '';
        testContactList[0].WorkEmail__c = 'test@sf.org';
        testContactList[0].Preferred_Email__c = null;
        testContactList[1].Email = '';
        testContactList[1].WorkEmail__c = 'test@sf.org';
        testContactList[1].Preferred_Email__c = null;
        insert testContactList;

        List<Contact> contactAfterInsertList = [SELECT Id, Preferred_Email__c, Email FROM Contact];

        System.assertEquals(null, contactAfterInsertList[0].Preferred_Email__c);
        System.assertEquals(null, contactAfterInsertList[0].Email);
        System.assertEquals(null, contactAfterInsertList[1].Preferred_Email__c);
        System.assertEquals(null, contactAfterInsertList[1].Email);

        TDTM_ProcessControl.setRecursionFlag(TDTM_ProcessControl.registeredTrigger.CON_Preferred_TDTM, false);  
        CON_Email_BATCH batch = new CON_Email_BATCH(null);
        Test.startTest();
            Database.executeBatch(batch);
        Test.stopTest();

        List<Contact> contactAfterBatchUpdateList = [SELECT Id, Preferred_Email__c, Email FROM Contact];

        System.assertEquals('Work Email', contactAfterBatchUpdateList[0].Preferred_Email__c, 'Preferred Email should work email');
        System.assertEquals('test@sf.org', contactAfterBatchUpdateList[0].Email, 'Standard Email should be same as work email');
        System.assertEquals('Work Email', contactAfterBatchUpdateList[1].Preferred_Email__c, 'Preferred Email should work email');
        System.assertEquals('test@sf.org', contactAfterBatchUpdateList[1].Email, 'Standard Email should be same as work email');

    }

    /************************************************************************************************************************************
    * @description Tests updating a Contact in Batch context with only one custom email field will not update Preferred Email and 
    * standard email fields Preferred Email Enforcement is disbaled
    *************************************************************************************************************************************/
    @isTest 
    static void updatePreferredEmailSmartSetBatchNegativeTest() {
        UTIL_CustomSettingsFacade.getSettingsForTests(
            new Hierarchy_Settings__c(Disable_Preferred_Email_Enforcement__c = false)
        );

        TDTM_ProcessControl.setRecursionFlag(TDTM_ProcessControl.registeredTrigger.CON_Preferred_TDTM, true);

        List<Contact> testContactList = UTIL_UnitTestData_TEST.getMultipleTestContacts(2);
        testContactList[0].Email = '';
        testContactList[0].WorkEmail__c = 'test@sf.org';
        testContactList[0].Preferred_Email__c = null;
        testContactList[1].Email = '';
        testContactList[1].WorkEmail__c = 'test@sf.org';
        testContactList[1].Preferred_Email__c = null;
        insert testContactList;

        List<Contact> contactAfterInsert = [SELECT Id, Preferred_Email__c, Email FROM Contact];

        System.assertEquals(null, contactAfterInsert[0].Preferred_Email__c);
        System.assertEquals(null, contactAfterInsert[0].Email);
        System.assertEquals(null, contactAfterInsert[1].Preferred_Email__c);
        System.assertEquals(null, contactAfterInsert[1].Email);

        TDTM_ProcessControl.setRecursionFlag(TDTM_ProcessControl.registeredTrigger.CON_Preferred_TDTM, false);

        UTIL_CustomSettingsFacade.getSettingsForTests(
            new Hierarchy_Settings__c(Disable_Preferred_Email_Enforcement__c = true)
        );

        CON_Email_BATCH batch = new CON_Email_BATCH(null);
        Test.startTest();
            Database.executeBatch(batch);
        Test.stopTest();

        List<Contact> contactAfterBatchUpdateList = [SELECT Id, Preferred_Email__c, Email FROM Contact];

        System.assertEquals(null, contactAfterBatchUpdateList[0].Preferred_Email__c, 'Preferred Email should be null');
        System.assertEquals(null, contactAfterBatchUpdateList[0].Email, 'Standard Email is null');
        System.assertEquals(null, contactAfterBatchUpdateList[1].Preferred_Email__c, 'Preferred Email should be null');
        System.assertEquals(null, contactAfterBatchUpdateList[1].Email, 'Standard Email is null');

    }

    /***************************************************************************************************************************************************
    * @description Tests updating a Contact in Batch context with more than one custom email field will update Preferred Email to the label 
    * corresponding to the first available custom email field with value when Standard Email field is blank and Preferred Email Enforcement is enabled
    **************************************************************************************************************************************************/
    @isTest 
    static void updatePreferredEmailWhenMulitpleEmailsBatch() {
        UTIL_CustomSettingsFacade.getSettingsForTests(
            new Hierarchy_Settings__c(Disable_Preferred_Email_Enforcement__c = false)
        );

        TDTM_ProcessControl.setRecursionFlag(TDTM_ProcessControl.registeredTrigger.CON_Preferred_TDTM, true);

        List<Contact> testContactList = UTIL_UnitTestData_TEST.getMultipleTestContacts(2);
        testContactList[0].Email = '';
        testContactList[0].WorkEmail__c = 'test@sf.org';
        testContactList[0].UniversityEmail__c = 'test@sf.org';
        testContactList[0].Preferred_Email__c = null;
        testContactList[1].Email = '';
        testContactList[1].WorkEmail__c = 'test@sf.org';
        testContactList[1].UniversityEmail__c = 'test@sf.org';
        testContactList[1].Preferred_Email__c = null;
        insert testContactList;

        List<Contact> contactAfterInsertList = [SELECT Id, Preferred_Email__c, Email FROM Contact];

        System.assertEquals(null, contactAfterInsertList[0].Preferred_Email__c);
        System.assertEquals(null, contactAfterInsertList[0].Email);
        System.assertEquals(null, contactAfterInsertList[1].Preferred_Email__c);
        System.assertEquals(null, contactAfterInsertList[1].Email);

        TDTM_ProcessControl.setRecursionFlag(TDTM_ProcessControl.registeredTrigger.CON_Preferred_TDTM, false);  
        CON_Email_BATCH batch = new CON_Email_BATCH(null);

        Test.startTest();
            Database.executeBatch(batch);
        Test.stopTest();

        List<Contact> contactAfterBatchUpdateList = [SELECT Id, Preferred_Email__c, Email FROM Contact];

        System.assertNotEquals(null, contactAfterBatchUpdateList[0].Preferred_Email__c, 'Preferred Email should be null');
        System.assertEquals('test@sf.org', contactAfterBatchUpdateList[0].Email, 'Standard Email should be same as work email');
        System.assertNotEquals(null, contactAfterBatchUpdateList[1].Preferred_Email__c, 'Preferred Email should be null');
        System.assertEquals('test@sf.org', contactAfterBatchUpdateList[1].Email, 'Standard Email should be same as work email');

    }
    
    /***************************************************************************************************************************************************
    * @description Tests updating a Contact in Batch context with more than one custom email field will not update Preferred Email 
    * and Standard Email fields when Preferred Email Enforcement is disabled
    **************************************************************************************************************************************************/
    @isTest 
    static void updatePreferredEmailWhenMulitpleEmailsBatchNegativeTest() {
        UTIL_CustomSettingsFacade.getSettingsForTests(
            new Hierarchy_Settings__c(Disable_Preferred_Email_Enforcement__c = false)
        );

        TDTM_ProcessControl.setRecursionFlag(TDTM_ProcessControl.registeredTrigger.CON_Preferred_TDTM, true);
        List<Contact> testContactList = UTIL_UnitTestData_TEST.getMultipleTestContacts(2);
        testContactList[0].Email = '';
        testContactList[0].WorkEmail__c = 'test@sf.org';
        testContactList[0].UniversityEmail__c = 'test@sf.org';
        testContactList[0].Preferred_Email__c = null;
        testContactList[1].Email = '';
        testContactList[1].WorkEmail__c = 'test@sf.org';
        testContactList[1].UniversityEmail__c = 'test@sf.org';
        testContactList[1].Preferred_Email__c = null;
        insert testContactList;

        List<Contact> contactAfterInsertList = [SELECT Id, Preferred_Email__c, Email FROM Contact];

        System.assertEquals(null, contactAfterInsertList[0].Preferred_Email__c);
        System.assertEquals(null, contactAfterInsertList[0].Email);
        System.assertEquals(null, contactAfterInsertList[1].Preferred_Email__c);
        System.assertEquals(null, contactAfterInsertList[1].Email);


         UTIL_CustomSettingsFacade.getSettingsForTests(
            new Hierarchy_Settings__c(Disable_Preferred_Email_Enforcement__c = true)
        );

        CON_Email_BATCH batch = new CON_Email_BATCH(null);
        Test.startTest();
            Database.executeBatch(batch);
        Test.stopTest();

        List<Contact> contactAfterBatchUpdateList = [SELECT Id, Preferred_Email__c, Email FROM Contact];

        System.assertEquals(null, contactAfterBatchUpdateList[0].Preferred_Email__c, 'Preferred Email should be null');
        System.assertEquals(null, contactAfterBatchUpdateList[0].Email, 'Standard Email should be null');
        System.assertEquals(null, contactAfterBatchUpdateList[1].Preferred_Email__c, 'Preferred Email should be null');
        System.assertEquals(null, contactAfterBatchUpdateList[1].Email, 'Standard Email should be null');

    }

    /**************************************************************************************************************************
    ******************************************* BULK FUNCTIONAL TESTS *********************************************************
    **************************************************************************************************************************/

    /*****************************************************************************************************************************
    * @description Bulk test for Preferred Email in Insert context when Preferred Email Enforcement is enabled 
    *****************************************************************************************************************************/
    @isTest 
    static void bulkTestToCoverAllPreferredEmailBeforeInsertScenariosWithEnforcementEnabled() {

        UTIL_CustomSettingsFacade.getSettingsForTests(
            new Hierarchy_Settings__c(Disable_Preferred_Email_Enforcement__c = false)
        );

        Contact testContact1 = UTIL_UnitTestData_TEST.getUniqueContact(1);
        testContact1.Email = '';
        testContact1.Preferred_Email__c = 'Alternate Email';

        Contact testContact2 = UTIL_UnitTestData_TEST.getUniqueContact(1);
        testContact2.Email = 'test@sf.org';

        Contact testContact3 = UTIL_UnitTestData_TEST.getUniqueContact(1);
        testContact3.Email = '';
        testContact3.AlternateEmail__c = 'test@sf.org';

        Contact testContact4 = UTIL_UnitTestData_TEST.getUniqueContact(1);
        testContact4.Email = '';
        testContact4.AlternateEmail__c = 'test@sf.org';
        testContact4.WorkEmail__c = 'test@sf.org';

        Contact testContact5 = UTIL_UnitTestData_TEST.getUniqueContact(1);
        testContact5.Email = '';
        testContact5.Preferred_Email__c = 'Alternate Email';
        testContact5.WorkEmail__c = 'test@sf.org';

        Contact testContact6 = UTIL_UnitTestData_TEST.getUniqueContact(1);
        testContact6.Preferred_Email__c = 'Alternate Email';
        testContact6.AlternateEmail__c = 'test@sf.org';
        testContact6.Email = '';

        Contact testContact7 = UTIL_UnitTestData_TEST.getUniqueContact(1);
        testContact7.Preferred_Email__c = 'Test sf Email';
        testContact7.WorkEmail__c = 'test@sf.org';

        Contact testContact8 = testContact6.clone(false);
        Contact testContact9 = testContact2.clone(false);

        List<Contact> contactsToBeInserted = new List<Contact> {
            testContact1, testContact2, testContact3, testContact4, testContact5, testContact6, testContact7, testContact8, testContact9
                };
    
        List<Database.saveResult> results = Database.insert(contactsToBeInserted, false);

        System.assertEquals(true, results[1].success);
        System.assertEquals(true, results[2].success);
        System.assertEquals(true, results[5].success);
        System.assertEquals(true, results[7].success);
        System.assertEquals(true, results[8].success);
        System.assertEquals(Label.PreferredEmailMatchNotNull, results[0].errors[0].message);
        System.assertEquals(Label.PreferredEmailRequiredError, results[3].errors[0].message);
        System.assertEquals(Label.PreferredEmailMatchNotNull, results[4].errors[0].message);
        System.assertEquals(Label.PreferredEmailMatchMustExist, results[6].errors[0].message);

        for (Contact contact : [SELECT Id, Preferred_Email__c, Email, AlternateEmail__c FROM Contact WHERE 
                                Id =: results[1].getId() OR 
                                Id =: results[2].getId() OR
                                Id =: results[5].getId()]) {
                                    
           System.assertEquals(contact.AlternateEmail__c, contact.Email);
           System.assertEquals('Alternate Email', contact.Preferred_Email__c);
        }

    }   

    /*****************************************************************************************************************************
    * @description Bulk test for Preferred Email in Insert context when Preferred Email Enforcement is disabled 
    *****************************************************************************************************************************/
    @isTest 
    static void bulkTestToCoverAllPreferredEmailBeforeInsertScenariosWithEnforcementDisbaled() {

        UTIL_CustomSettingsFacade.getSettingsForTests(
            new Hierarchy_Settings__c(Disable_Preferred_Email_Enforcement__c = true)
        );

        Contact testContact1 = UTIL_UnitTestData_TEST.getUniqueContact(1);
        testContact1.Email = '';
        testContact1.Preferred_Email__c = 'Alternate Email';

        Contact testContact2 = UTIL_UnitTestData_TEST.getUniqueContact(1);
        testContact2.Email = 'test@sf.org';

        Contact testContact3 = UTIL_UnitTestData_TEST.getUniqueContact(1);
        testContact3.Email = '';
        testContact3.AlternateEmail__c = 'test@sf.org';

        Contact testContact4 = UTIL_UnitTestData_TEST.getUniqueContact(1);
        testContact4.Email = '';
        testContact4.AlternateEmail__c = 'test@sf.org';
        testContact4.WorkEmail__c = 'test@sf.org';

        Contact testContact5 = UTIL_UnitTestData_TEST.getUniqueContact(1);
        testContact5.Email = '';
        testContact5.Preferred_Email__c = 'Alternate Email';
        testContact5.WorkEmail__c = 'test@sf.org';

        Contact testContact6 = UTIL_UnitTestData_TEST.getUniqueContact(1);
        testContact6.Preferred_Email__c = 'Alternate Email';
        testContact6.AlternateEmail__c = 'test@sf.org';
        testContact6.Email = '';

        Contact testContact7 = UTIL_UnitTestData_TEST.getUniqueContact(1);
        testContact7.Preferred_Email__c = 'Test sf Email';
        testContact7.WorkEmail__c = 'test@sf.org';

        List<Contact> contactsToBeInserted = new List<Contact> {
            testContact1, testContact2, testContact3, testContact4, testContact5, testContact6, testContact7
                };
       
        List<Database.saveResult> results = Database.insert(contactsToBeInserted, false);

        for (Database.saveResult eachResult: results) {
            if (eachResult != results[0] && eachResult != results[4] && eachResult != results[6]) {
                System.assertEquals(true, eachResult.success);   
            } else if (eachResult == results[0] || eachResult == results[4]) {
                System.assertEquals(Label.PreferredEmailMatchNotNull, results[0].errors[0].message);
                System.assertEquals(Label.PreferredEmailMatchNotNull, results[4].errors[0].message);
            } else {
                System.assertEquals(Label.PreferredEmailMatchMustExist, results[6].errors[0].message);
            }
        }
    }

    /*****************************************************************************************************************************
    * @description Bulk test for Preferred Email in Update context when Preferred Email Enforcement is enabled 
    *****************************************************************************************************************************/
    @isTest 
    static void bulkTestToCoverAllPreferredEmailBeforeUpdateScenariosWithEnforcementEnabled() {

        UTIL_CustomSettingsFacade.getSettingsForTests(
            new Hierarchy_Settings__c(Disable_Preferred_Email_Enforcement__c = false)
        );

        Contact testContact1 = UTIL_UnitTestData_TEST.getUniqueContact(1);
        testContact1.Email = '';

        Contact testContact2 = UTIL_UnitTestData_TEST.getUniqueContact(1);
        testContact2.Email = '';

        Contact testContact3 = UTIL_UnitTestData_TEST.getUniqueContact(1);
        testContact3.Email = '';

        Contact testContact4 = UTIL_UnitTestData_TEST.getUniqueContact(1);
        testContact4.Email = '';

        Contact testContact5 = UTIL_UnitTestData_TEST.getUniqueContact(1);
        testContact5.Email = '';

        Contact testContact6 = UTIL_UnitTestData_TEST.getUniqueContact(1);
        testContact6.Email = '';

        Contact testContact7 = UTIL_UnitTestData_TEST.getUniqueContact(1);
        testContact7.Email = '';

        Contact testContact8 = testContact6.clone(false);
        Contact testContact9 = testContact2.clone(false);

        List<Contact> contactsToBeInserted = new List<Contact> {
            testContact1, testContact2, testContact3, testContact4, testContact5, testContact6, testContact7, testContact8, testContact9
                };

        insert contactsToBeInserted;

        List<Contact> insertedContactList = [SELECT Id FROM Contact];
        System.assertEquals(9, insertedContactList.size());

        testContact1.Preferred_Email__c = 'Alternate Email';
        testContact2.Email = 'test@sf.org';
        testContact3.AlternateEmail__c = 'test@sf.org';
        testContact4.AlternateEmail__c = 'test@sf.org';
        testContact4.WorkEmail__c = 'test@sf.org';
        testContact5.Preferred_Email__c = 'Alternate Email';
        testContact5.WorkEmail__c = 'test@sf.org';
        testContact6.Preferred_Email__c = 'Alternate Email';
        testContact6.AlternateEmail__c = 'test@sf.org';
        testContact7.Preferred_Email__c = 'Test sf Email';
        testContact7.WorkEmail__c = 'test@sf.org';
        testContact8.Preferred_Email__c = 'Alternate Email';
        testContact8.AlternateEmail__c = 'test@sf.org';
        testContact9.Email = 'test@sf.org';

        List<Contact> contactsToBeUpdated = new List<Contact> {
            testContact1, testContact2, testContact3, testContact4, testContact5, testContact6, testContact7, testContact8, testContact9
                };

        List<Database.saveResult> results = Database.update(contactsToBeUpdated, false);

        System.assertEquals(true, results[1].success);
        System.assertEquals(true, results[2].success);
        System.assertEquals(true, results[5].success);
        System.assertEquals(true, results[7].success);
        System.assertEquals(true, results[8].success);
        System.assertEquals(Label.PreferredEmailMatchNotNull, results[0].errors[0].message);
        System.assertEquals(Label.PreferredEmailRequiredError, results[3].errors[0].message);
        System.assertEquals(Label.PreferredEmailMatchNotNull, results[4].errors[0].message);
        System.assertEquals(Label.PreferredEmailMatchMustExist, results[6].errors[0].message);

        for (Contact contact : [SELECT Id, Preferred_Email__c, Email, AlternateEmail__c FROM Contact WHERE 
                                Id =: results[1].getId() OR 
                                Id =: results[2].getId() OR
                                Id =: results[5].getId()]) {
                                    
           System.assertEquals(contact.AlternateEmail__c, contact.Email);
           System.assertEquals('Alternate Email', contact.Preferred_Email__c);
        }

    }

    /*****************************************************************************************************************************
    * @description Bulk test for Preferred Email in Update context when Preferred Email Enforcement is disabled 
    *****************************************************************************************************************************/
    @isTest 
    static void bulkTestToCoverAllPreferredEmailBeforeUpdateScenariosWithEnforcementDisabled() {

        UTIL_CustomSettingsFacade.getSettingsForTests(
            new Hierarchy_Settings__c(Disable_Preferred_Email_Enforcement__c = true)
        );

        Contact testContact1 = UTIL_UnitTestData_TEST.getUniqueContact(1);
        testContact1.Email = '';
        
        Contact testContact2 = UTIL_UnitTestData_TEST.getUniqueContact(1);
        testContact2.Email = '';

        Contact testContact3 = UTIL_UnitTestData_TEST.getUniqueContact(1);
        testContact3.Email = '';

        Contact testContact4 = UTIL_UnitTestData_TEST.getUniqueContact(1);
        testContact4.Email = '';

        Contact testContact5 = UTIL_UnitTestData_TEST.getUniqueContact(1);
        testContact5.Email = '';

        Contact testContact6 = UTIL_UnitTestData_TEST.getUniqueContact(1);
        testContact6.Email = '';

        Contact testContact7 = UTIL_UnitTestData_TEST.getUniqueContact(1);
        testContact7.Email = '';

        List<Contact> contactsToBeInserted = new List<Contact> {
            testContact1, testContact2, testContact3, testContact4, testContact5, testContact6, testContact7
                };

        insert contactsToBeInserted;

        List<Contact> insertedContactList = [SELECT Id FROM Contact];
        System.assertEquals(7, insertedContactList.size());

        testContact1.Preferred_Email__c = 'Alternate Email';
        testContact2.Email = 'test@sf.org';
        testContact3.AlternateEmail__c = 'test@sf.org';
        testContact4.AlternateEmail__c = 'test@sf.org';
        testContact4.WorkEmail__c = 'test@sf.org';
        testContact5.Preferred_Email__c = 'Alternate Email';
        testContact5.WorkEmail__c = 'test@sf.org';
        testContact6.Preferred_Email__c = 'Alternate Email';
        testContact6.AlternateEmail__c = 'test@sf.org';
        testContact7.Preferred_Email__c = 'Test sf Email';
        testContact7.WorkEmail__c = 'test@sf.org';

        List<Contact> contactsToBeUpdated = new List<Contact> {
            testContact1, testContact2, testContact3, testContact4, testContact5, testContact6, testContact7
                };

        List<Database.saveResult> results = Database.update(contactsToBeUpdated, false);

        for (Database.saveResult eachResult: results) {
            if (eachResult != results[0] && eachResult != results[4] && eachResult != results[6]) {
                System.assertEquals(true, eachResult.success);   
            } else if (eachResult == results[0] || eachResult == results[4]) {
                System.assertEquals(Label.PreferredEmailMatchNotNull, results[0].errors[0].message);
                System.assertEquals(Label.PreferredEmailMatchNotNull, results[4].errors[0].message);
            } else {
                System.assertEquals(Label.PreferredEmailMatchMustExist, results[6].errors[0].message);
            }
        }
        
    }

    /*****************************************************************************************************************************
    * @description Bulk test for Preferred Email in Batch context when Preferred Email Enforcement is enabled 
    *****************************************************************************************************************************/
    @isTest 
    static void preferredEMailBatchBulkTest() {

        UTIL_CustomSettingsFacade.getSettingsForTests(
            new Hierarchy_Settings__c(Disable_Preferred_Email_Enforcement__c = false)
        );

        // Get contacts set up
        List<Contact> contactList = UTIL_UnitTestData_API.getMultipleTestContacts(10);
        for (Integer i = 0; i < 10; i++) {

            contactList[i].LastName = 'ToAvoidDupeRule' + i;//Avoid duplicate matching
            contactList[i].WorkEmail__c = ''; // clear email field set in getMultipleTestContacts
            contactList[i].Preferred_Email__c = ''; // clear preferred field set in getMultipleTestContacts
            System.assert(contactList[i].email == null);
        }

        insert contactList;

        List<String> contIds = new List<String>();

        List<Contact> contacts = [SELECT Id, Name, Preferred_Email__c, Email, AlternateEmail__c,UniversityEmail__c, WorkEmail__c FROM Contact];

        String caseOneId;
        String caseTwoId;

        // Process the contact for testing
        if(contacts.size() > 0) {

            for (Integer i = 0; i < contacts.size(); i++) {

                // Setup special Case 1
                if(i==5) {
                    contacts[5].Email = 'uniquwemailtest5nomatch@domainemail.com';
                    contacts[5].AlternateEmail__c = 'alternate5@domainemail.com';
                    contacts[5].UniversityEmail__c = null;
                    contacts[5].WorkEmail__c = null;
                    contacts[5].Preferred_Email__c = '';
                    caseOneId = contacts[5].Id;

                // Setup special Case 2
                } else if (i==6) {
                    contacts[6].AlternateEmail__c = 'alternate6@domainemail.com';
                    contacts[6].Email = '';
                    contacts[6].WorkEmail__c = null;
                    contacts[6].Preferred_Email__c = '';
                    caseTwoId = contacts[6].Id;

                } else {
                    contacts[i].Email = 'emailtest' + i + '@domainemail.com';
                    contacts[i].UniversityEmail__c = null;
                    contacts[i].WorkEmail__c = null;
                    contacts[i].AlternateEmail__c = null;
                    contacts[i].Preferred_Email__c = null;
                    contIds.add(contacts[i].Id);
                }
            }

            TDTM_ProcessControl.setRecursionFlag(TDTM_ProcessControl.registeredTrigger.CON_Preferred_TDTM, true);
            update contacts;
        }

        TDTM_ProcessControl.setRecursionFlag(TDTM_ProcessControl.registeredTrigger.CON_Preferred_TDTM, false);
        // Run Batch
        Test.startTest();
            CON_Email_BATCH contbatch = new CON_Email_BATCH(null);
        Database.executeBatch( contbatch );
        Test.stopTest();

        // After batch run assert leaving off the two contacts for special cases
        contacts = [SELECT Id, Name, Email, AlternateEmail__c FROM Contact WHERE Id in: contIds AND Id!=:caseOneId AND Id !=: caseTwoId];
        for(Contact contact : contacts) {
            System.assertEquals(contact.AlternateEmail__c , contact.Email );
        }

        // Check special Case 1
        Contact contactOne = [SELECT Id, Name, Email, AlternateEmail__c, Preferred_Email__c FROM Contact WHERE Id =:caseOneId LIMIT 1];
        System.assertEquals('uniquwemailtest5nomatch@domainemail.com', contactOne.Email);
        System.assertEquals(Label.preferredBatchDefaultEmail, contactOne.Preferred_Email__c);

        // Check special Case 2
        Contact contactTwo = [SELECT Id, Name, Email, AlternateEmail__c, Preferred_Email__c FROM Contact WHERE Id =:caseTwoId LIMIT 1];
        System.assertEquals(contactTwo.Email, contactTwo.AlternateEmail__c);
        System.assertEquals('Alternate Email', contactTwo.Preferred_Email__c);

    }

    /**************************************************************************************************************************
    ******************************************* LEAD CONVERSION TEST *********************************************************
    **************************************************************************************************************************/
    @isTest 
    static void testLeadConversion() {
        // create a Lead
        Lead testLead = new Lead(
            FirstName='Joshua',
            LastName='McTesterman',
            Email='mctesterman@mctesersite.com',
            Company='Test',
            Status='Inquiry'
        );

        insert testLead;

        Database.LeadConvert convertedLead = new Database.LeadConvert();
        convertedLead.setLeadId(testLead.Id);

        LeadStatus convertStatus = [SELECT Id, MasterLabel FROM LeadStatus WHERE IsConverted=true LIMIT 1];
        convertedLead.setConvertedStatus(convertStatus.MasterLabel);

        Test.startTest();		
            Database.LeadConvertResult convertedLeadResult = Database.convertLead(convertedLead);
        Test.stopTest();

        Contact contact = [SELECT Id, Name, Email FROM Contact WHERE Id =:convertedLeadResult.getContactId() LIMIT 1];

        System.assertEquals(contact.Email, testLead.Email);
    }
}
/*
    Copyright (c) 2015, Salesforce.org
    All rights reserved.

    Redistribution and use in source and binary forms, with or without
    modification, are permitted provided that the following conditions are met:

    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
    * Neither the name of Salesforce.org nor the names of
      its contributors may be used to endorse or promote products derived
      from this software without specific prior written permission.

    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
    "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
    LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
    FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
    COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
    INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
    BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
    LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
    CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
    LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
    ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
    POSSIBILITY OF SUCH DAMAGE.
*/
/**
 * @author Salesforce.org
 * @date 2015
 * @group Contacts
 * @group-content ../../ApexDocContent/Contacts.htm
 * @description Test for Contact primary affilation fields functionality.
 */
@isTest
private with sharing class CON_PrimaryAffls_TEST {
    private static Integer contactCount = 100; // used to determine number of test contact records to create

    /**************************************************************************************************************************
     ****************************************************** UNIT TESTS *********************************************************
     **************************************************************************************************************************/

    /********************************************************
     * @description Tests setAffiliationUpdateRecursion method
     *********************************************************/
    @isTest
    static void setAffiliationUpdateRecursion() {
        CON_PrimaryAffls_TDTM tdtmClass = new CON_PrimaryAffls_TDTM();

        Test.startTest();
        tdtmClass.setAffiliationUpdateRecursion();
        Test.stopTest();

        Boolean keyLookupUpdated = TDTM_ProcessControl.getRecursionFlag(
            TDTM_ProcessControl.registeredTrigger.CON_PrimaryAffls_TDTM_keyAfflLookupUpdated
        );

        System.assertEquals(true, keyLookupUpdated, 'keyLookupUpdated should be active for CON_PrimaryAffls_TDTM');
    }

    /******************************************************
     * @description Tests setInsertRecursion method
     *******************************************************/
    @isTest
    static void setInsertRecursion() {
        CON_PrimaryAffls_TDTM tdtmClass = new CON_PrimaryAffls_TDTM();

        Test.startTest();
        tdtmClass.setInsertRecursion();
        Test.stopTest();

        Boolean afterInsert = TDTM_ProcessControl.getRecursionFlag(
            TDTM_ProcessControl.registeredTrigger.CON_PrimaryAffls_TDTM_After_Insert
        );

        System.assertEquals(true, afterInsert, 'afterInsert should be active for CON_PrimaryAffls_TDTM');
    }

    /*******************************************************
     * @description Tests setUpdateRecursion method
     ********************************************************/
    @isTest
    static void setUpdateRecursion() {
        CON_PrimaryAffls_TDTM tdtmClass = new CON_PrimaryAffls_TDTM();

        Test.startTest();
        tdtmClass.setUpdateRecursion();
        Test.stopTest();

        Boolean afterUpdate = TDTM_ProcessControl.getRecursionFlag(
            TDTM_ProcessControl.registeredTrigger.CON_PrimaryAffls_TDTM_After_Update
        );

        System.assertEquals(true, afterUpdate, 'afterUpdate should be active for CON_PrimaryAffls_TDTM');
    }

    /*******************************************************
     * @description Tests unsetInsertRecursion method
     ********************************************************/
    @isTest
    static void unsetInsertRecursion() {
        CON_PrimaryAffls_TDTM tdtmClass = new CON_PrimaryAffls_TDTM();
        tdtmClass.setInsertRecursion();

        Test.startTest();
        tdtmClass.unsetInsertRecursion();
        Test.stopTest();

        Boolean isInsertRecursion = TDTM_ProcessControl.getRecursionFlag(
            TDTM_ProcessControl.registeredTrigger.CON_PrimaryAffls_TDTM_After_Insert
        );

        System.assertEquals(
            false,
            isInsertRecursion,
            'Insert recursion should not be active for CON_PrimaryAffls_TDTM'
        );
    }

    /*******************************************************
     * @description Tests unsetInsert recursion method
     *******************************************************/
    @isTest
    static void unsetUpdateRecursion() {
        CON_PrimaryAffls_TDTM tdtmClass = new CON_PrimaryAffls_TDTM();
        tdtmClass.setUpdateRecursion();

        Test.startTest();
        tdtmClass.unsetUpdateRecursion();
        Test.stopTest();

        Boolean isUpdateRecursion = TDTM_ProcessControl.getRecursionFlag(
            TDTM_ProcessControl.registeredTrigger.CON_PrimaryAffls_TDTM_After_Insert
        );

        System.assertEquals(
            false,
            isUpdateRecursion,
            'Update recursion should not be active for CON_PrimaryAffls_TDTM'
        );
    }

    /*******************************************************
     * @description Tests isInsertRecursion method
     *******************************************************/
    @isTest
    static void isInsertRecursion() {
        CON_PrimaryAffls_TDTM tdtmClass = new CON_PrimaryAffls_TDTM();
        tdtmClass.setInsertRecursion();

        Test.startTest();
        Boolean isInsertRecursion = tdtmClass.isInsertRecursion();
        Test.stopTest();

        System.assertEquals(true, isInsertRecursion, 'Insert recursion should not be active for CON_PrimaryAffls_TDTM');
    }

    /*******************************************************
     * @description Tests IsUpdateRecursion method for
     * CON_PrimaryAffls_TDTM_After_Update flag
     *******************************************************/
    @isTest
    static void isupdateRecursionForAfterUpdate() {
        CON_PrimaryAffls_TDTM tdtmClass = new CON_PrimaryAffls_TDTM();
        tdtmClass.setUpdateRecursion();

        Test.startTest();
        Boolean isUpdateRecursion = tdtmClass.isUpdateRecursion();
        Test.stopTest();

        System.assertEquals(true, isUpdateRecursion, 'Update recursion should not be active for CON_PrimaryAffls_TDTM');
    }

    /*******************************************************
     * @description Tests IsUpdateRecursion method for
     * AFFL_AccRecordType_TDTM flag
     *******************************************************/
    @isTest
    static void isupdateRecursionForAfflAccRecType() {
        CON_PrimaryAffls_TDTM tdtmClass = new CON_PrimaryAffls_TDTM();
        TDTM_ProcessControl.setRecursionFlag(TDTM_ProcessControl.registeredTrigger.AFFL_AccRecordType_TDTM, true);

        Test.startTest();
        Boolean isUpdateRecursion = tdtmClass.isUpdateRecursion();
        Test.stopTest();

        System.assertEquals(true, isUpdateRecursion, 'Update recursion should not be active for CON_PrimaryAffls_TDTM');
    }

    /*******************************************************
     * @description Tests isAffiliationUpdateRecursion method
     *******************************************************/
    @isTest
    static void isAffiliationUpdateRecursion() {
        CON_PrimaryAffls_TDTM tdtmClass = new CON_PrimaryAffls_TDTM();
        tdtmClass.setUpdateRecursion();

        Test.startTest();
        Boolean isAffiliationUpdateRecursion = tdtmClass.isAffiliationUpdateRecursion();
        Test.stopTest();

        System.assertEquals(
            true,
            isAffiliationUpdateRecursion,
            'Update recursion should not be active for CON_PrimaryAffls_TDTM'
        );
    }

    /*******************************************************
     * @description Tests resetAffiliationUpdateRecursion will
     * reset CON_PrimaryAffls_TDTM_keyAfflLookupUpdated flag
     *******************************************************/
    @isTest
    static void resetAffiliationUpdateRecursion() {
        CON_PrimaryAffls_TDTM tdtmClass = new CON_PrimaryAffls_TDTM();
        tdtmClass.setAffiliationUpdateRecursion();

        System.assertEquals(
            true,
            TDTM_ProcessControl.getRecursionFlag(
                TDTM_ProcessControl.registeredTrigger.CON_PrimaryAffls_TDTM_keyAfflLookupUpdated
            ),
            'update recurssion should be true'
        );

        Test.startTest();
        tdtmClass.resetAffiliationUpdateRecursion();
        Test.stopTest();

        System.assertEquals(
            false,
            TDTM_ProcessControl.getRecursionFlag(
                TDTM_ProcessControl.registeredTrigger.CON_PrimaryAffls_TDTM_keyAfflLookupUpdated
            ),
            'Update recursion should be reset'
        );
    }

    /*************************************************************************************************************
     * @description Tests locateAffiliationSettingMapper method of CON_PrimaryAffls_TDTM
     *************************************************************************************************************/
    @isTest
    private static void locateAffiliationSettingMapperTest() {
        CON_PrimaryAffls_TDTM tdtmClass = new CON_PrimaryAffls_TDTM();
        Test.startTest();
        MAPR_PrimaryAffiliations primaryAfflInstance = tdtmClass.locateAffiliationSettingMapper();
        Test.stopTest();

        MAPR_PrimaryAffiliations maprInstance = MAPR_PrimaryAffiliations.getInstance();

        System.assertEquals(maprInstance, primaryAfflInstance);
    }

    /*************************************************************************************************************
     * @description Tests locateContactAffiliationService method of CON_PrimaryAffls_TDTM
     **************************************************************************************************************/
    @isTest
    private static void locateContactAffiliationService() {
        CON_PrimaryAffls_TDTM tdtmClass = new CON_PrimaryAffls_TDTM();
        Test.startTest();
        SRVC_Contact_PrimaryAffiliations primaryAfflInstance = tdtmClass.locateContactAffiliationService();
        Test.stopTest();

        SRVC_Contact_PrimaryAffiliations srvcInstance = SRVC_Contact_PrimaryAffiliations.getInstance();

        System.assertEquals(srvcInstance, primaryAfflInstance);
    }

    /*************************************************************************************************************
     * @description NULL test for run method to verify new DmlWrapper(); is returned when newList is null
     *************************************************************************************************************/
    @isTest
    private static void runMethodNULLTest() {
        TDTM_Runnable.Action testAction = TDTM_Runnable.Action.AfterUpdate;
        Schema.DescribeSObjectResult objResult = Schema.SObjectType.Contact;

        CON_PrimaryAffls_TDTM tdtmClass = new CON_PrimaryAffls_TDTM();
        Test.startTest();
        TDTM_Runnable.DmlWrapper dmlWrapperReturned = tdtmClass.run(null, null, testAction, objResult);
        Test.stopTest();

        System.assertEquals(0, dmlWrapperReturned.objectsToInsert.size());
    }

    /*************************************************************************************************************
     * @description Test for run method to verify new DmlWrapper(); is returned when newList is empty
     *************************************************************************************************************/
    @isTest
    private static void runMethodEmptyTest() {
        List<Contact> newContactsList = new List<Contact>();
        List<SObject> oldContactList = new List<SObject>();

        TDTM_Runnable.Action testAction = TDTM_Runnable.Action.AfterUpdate;
        Schema.DescribeSObjectResult objResult = Schema.SObjectType.Contact;

        CON_PrimaryAffls_TDTM tdtmClass = new CON_PrimaryAffls_TDTM();
        Test.startTest();
        TDTM_Runnable.DmlWrapper dmlWrapperReturned = tdtmClass.run(
            newContactsList,
            oldContactList,
            testAction,
            objResult
        );
        Test.stopTest();

        System.assertEquals(0, dmlWrapperReturned.objectsToInsert.size());
    }

    /*************************************************************************************************************
     * @description Positive test method for run method afterInsert to ensure affiliations are created on insert
     *************************************************************************************************************/
    @isTest
    static void runMethodTestForAfterInsert() {
        String namespace = UTIL_Namespace.getNamespace();
        String prefix = (String.isNotBlank(namespace)) ? namespace + '__' : '';

        List<Affl_Mappings__c> mappings = new List<Affl_Mappings__c>();
        mappings.add(
            new Affl_Mappings__c(
                Name = 'Business Organization',
                Account_Record_Type__c = 'Business_Organization',
                Primary_Affl_Field__c = prefix + 'Primary_Organization__c'
            )
        );
        mappings.add(
            new Affl_Mappings__c(
                Name = 'Household Account',
                Account_Record_Type__c = 'HH_Account',
                Primary_Affl_Field__c = prefix + 'Primary_Household__c'
            )
        );
        insert mappings;

        Account businessAccount1 = UTIL_UnitTestData_TEST.getMultipleTestAccounts(
            1,
            UTIL_Describe_API.getBizAccRecTypeID()
        )[0];
        insert businessAccount1;

        Schema.DescribeSObjectResult contactDescribeResult = UTIL_Describe.getObjectDescribe('Contact');

        List<Contact> newContactList = new List<Contact>();

        for (integer i = 0; i < 5; i++) {
            Contact contactWithPrimaryBusinessOrg = UTIL_UnitTestData_TEST.getUniqueContact(i);
            contactWithPrimaryBusinessOrg.Primary_Organization__c = businessAccount1.Id;
            newContactList.add(contactWithPrimaryBusinessOrg);
        }

        insert newContactList;

        List<Affiliation__c> affiliationAfterInsertList = [SELECT Id FROM Affiliation__c];

        System.assertEquals(5, affiliationAfterInsertList.size());

        CON_PrimaryAffls_TDTM tdtmClass = new CON_PrimaryAffls_TDTM();

        Test.startTest();
        TDTM_Runnable.DmlWrapper dmlWrapper = tdtmClass.run(
            (List<SObject>) newContactList,
            null,
            TDTM_Runnable.Action.AfterInsert,
            contactDescribeResult
        );
        Test.stopTest();

        List<Affiliation__c> affiliationList = [SELECT Id FROM Affiliation__c];

        System.assertEquals(10, affiliationList.size(), '5 more affiliation records should be inserted');
    }

    /*************************************************************************************************************
     * @description Positive test method for run method afterUpdate to ensure affiliations are created
     * when contact is updated with Primary Field
     **************************************************************************************************************/
    @isTest
    static void runMethodTestForAfterUpdate() {
        String namespace = UTIL_Namespace.getNamespace();
        String prefix = (String.isNotBlank(namespace)) ? namespace + '__' : '';

        List<Affl_Mappings__c> mappings = new List<Affl_Mappings__c>();
        mappings.add(
            new Affl_Mappings__c(
                Name = 'Business Organization',
                Account_Record_Type__c = 'Business_Organization',
                Primary_Affl_Field__c = prefix + 'Primary_Organization__c'
            )
        );
        mappings.add(
            new Affl_Mappings__c(
                Name = 'Household Account',
                Account_Record_Type__c = 'HH_Account',
                Primary_Affl_Field__c = prefix + 'Primary_Household__c'
            )
        );
        insert mappings;

        Account businessAccount1 = UTIL_UnitTestData_TEST.getMultipleTestAccounts(
            1,
            UTIL_Describe_API.getBizAccRecTypeID()
        )[0];
        insert businessAccount1;

        Schema.DescribeSObjectResult contactDescribeResult = UTIL_Describe.getObjectDescribe('Contact');

        List<Contact> oldContactList = new List<Contact>();

        for (integer i = 0; i < 5; i++) {
            Contact contactWithPrimaryBusinessOrg = UTIL_UnitTestData_TEST.getUniqueContact(i);
            oldContactList.add(contactWithPrimaryBusinessOrg);
        }

        insert oldContactList;

        List<Contact> newContactList = new List<Contact>();
        for (Contact eachContact : oldContactList) {
            Contact newContact = eachContact.Clone(false);
            newContact.Id = eachContact.Id;
            newContact.Primary_organization__c = businessAccount1.Id;
            newContactList.add(newContact);
        }

        CON_PrimaryAffls_TDTM tdtmClass = new CON_PrimaryAffls_TDTM();

        Test.startTest();
        TDTM_Runnable.DmlWrapper dmlWrapper = tdtmClass.run(
            (List<SObject>) newContactList,
            (List<SObject>) oldContactList,
            TDTM_Runnable.Action.Afterupdate,
            contactDescribeResult
        );
        Test.stopTest();

        List<Affiliation__c> affiliationList = [SELECT Id FROM Affiliation__c];

        System.assertEquals(5, affiliationList.size());
    }

    /*************************************************************************************************************
     * @description Positive test method for handleAfterInsertMethod to ensure affiliations are inserted when
     * Primary field is populated
     *************************************************************************************************************/
    @isTest
    static void handleAfterInsertWithPrimaryBusinessOrg() {
        String namespace = UTIL_Namespace.getNamespace();
        String prefix = (String.isNotBlank(namespace)) ? namespace + '__' : '';

        List<Affl_Mappings__c> mappings = new List<Affl_Mappings__c>();
        mappings.add(
            new Affl_Mappings__c(
                Name = 'Business Organization',
                Account_Record_Type__c = 'Business_Organization',
                Primary_Affl_Field__c = prefix + 'Primary_Organization__c'
            )
        );
        mappings.add(
            new Affl_Mappings__c(
                Name = 'Household Account',
                Account_Record_Type__c = 'HH_Account',
                Primary_Affl_Field__c = prefix + 'Primary_Household__c'
            )
        );
        insert mappings;

        List<Account> businessAccounts = UTIL_UnitTestData_TEST.getMultipleTestAccounts(
            2,
            UTIL_Describe_API.getBizAccRecTypeID()
        );
        insert businessAccounts;

        Schema.DescribeSObjectResult contactDescribeResult = UTIL_Describe.getObjectDescribe('Contact');

        List<Contact> oldContactList = new List<Contact>();

        for (integer i = 0; i < 5; i++) {
            Contact contactWithPrimaryBusinessOrg = UTIL_UnitTestData_TEST.getUniqueContact(i);
            contactWithPrimaryBusinessOrg.Primary_organization__c = businessAccounts[0].Id;
            oldContactList.add(contactWithPrimaryBusinessOrg);
        }

        insert oldContactList;

        List<Affiliation__c> affiliationList = [SELECT Id FROM Affiliation__c];

        System.assertEquals(5, affiliationList.size());

        CON_PrimaryAffls_TDTM tdtmClass = new CON_PrimaryAffls_TDTM();

        Test.startTest();
        tdtmClass.handleAfterInsert(oldContactList);
        Test.stopTest();

        List<Affiliation__c> affiliationAfterCallList = [SELECT Id FROM Affiliation__c];

        System.assertEquals(10, affiliationAfterCallList.size());
        System.assertEquals(
            false,
            TDTM_ProcessControl.getRecursionFlag(
                TDTM_ProcessControl.registeredTrigger.CON_PrimaryAffls_TDTM_After_Insert
            ),
            'Recursion flag should be unset.'
        );
    }

    /*************************************************************************************************************
     * @description Negative test method for run method afterUpdate to ensure no affiliatons are inserted when
     * Primary field is not populated
     **************************************************************************************************************/
    @isTest
    static void handleAfterInsertWithNoPrimaryField() {
        String namespace = UTIL_Namespace.getNamespace();
        String prefix = (String.isNotBlank(namespace)) ? namespace + '__' : '';

        List<Affl_Mappings__c> mappings = new List<Affl_Mappings__c>();
        mappings.add(
            new Affl_Mappings__c(
                Name = 'Business Organization',
                Account_Record_Type__c = 'Business_Organization',
                Primary_Affl_Field__c = prefix + 'Primary_Organization__c'
            )
        );
        mappings.add(
            new Affl_Mappings__c(
                Name = 'Household Account',
                Account_Record_Type__c = 'HH_Account',
                Primary_Affl_Field__c = prefix + 'Primary_Household__c'
            )
        );
        insert mappings;

        List<Account> businessAccounts = UTIL_UnitTestData_TEST.getMultipleTestAccounts(
            2,
            UTIL_Describe_API.getBizAccRecTypeID()
        );
        insert businessAccounts;

        Schema.DescribeSObjectResult contactDescribeResult = UTIL_Describe.getObjectDescribe('Contact');

        List<Contact> oldContactList = new List<Contact>();

        for (integer i = 0; i < 5; i++) {
            Contact contactWithPrimaryBusinessOrg = UTIL_UnitTestData_TEST.getUniqueContact(i);
            oldContactList.add(contactWithPrimaryBusinessOrg);
        }

        insert oldContactList;

        List<Affiliation__c> affiliationList = [SELECT Id FROM Affiliation__c];

        System.assertEquals(0, affiliationList.size());

        CON_PrimaryAffls_TDTM tdtmClass = new CON_PrimaryAffls_TDTM();

        Test.startTest();
        tdtmClass.handleAfterInsert(oldContactList);
        Test.stopTest();

        List<Affiliation__c> affiliationAfterCallList = [SELECT Id FROM Affiliation__c];

        System.assertEquals(0, affiliationAfterCallList.size());
        System.assertEquals(
            false,
            TDTM_ProcessControl.getRecursionFlag(
                TDTM_ProcessControl.registeredTrigger.CON_PrimaryAffls_TDTM_After_Insert
            ),
            'Recursion flag should be unset.'
        );
    }

    /*************************************************************************************************************
     * @description Test method for run method afterUpdate doesn't create affiliations when flag is on
     **************************************************************************************************************/
    @isTest
    static void handleAfterInsertWithFlagOn() {
        String namespace = UTIL_Namespace.getNamespace();
        String prefix = (String.isNotBlank(namespace)) ? namespace + '__' : '';

        List<Affl_Mappings__c> mappings = new List<Affl_Mappings__c>();
        mappings.add(
            new Affl_Mappings__c(
                Name = 'Business Organization',
                Account_Record_Type__c = 'Business_Organization',
                Primary_Affl_Field__c = prefix + 'Primary_Organization__c'
            )
        );
        mappings.add(
            new Affl_Mappings__c(
                Name = 'Household Account',
                Account_Record_Type__c = 'HH_Account',
                Primary_Affl_Field__c = prefix + 'Primary_Household__c'
            )
        );
        insert mappings;

        List<Account> businessAccounts = UTIL_UnitTestData_TEST.getMultipleTestAccounts(
            2,
            UTIL_Describe_API.getBizAccRecTypeID()
        );
        insert businessAccounts;

        Schema.DescribeSObjectResult contactDescribeResult = UTIL_Describe.getObjectDescribe('Contact');

        List<Contact> oldContactList = new List<Contact>();

        for (integer i = 0; i < 5; i++) {
            Contact contactWithPrimaryBusinessOrg = UTIL_UnitTestData_TEST.getUniqueContact(i);
            contactWithPrimaryBusinessOrg.Primary_Organization__c = businessAccounts[0].Id;
            oldContactList.add(contactWithPrimaryBusinessOrg);
        }

        CON_PrimaryAffls_TDTM tdtmClass = new CON_PrimaryAffls_TDTM();
        tdtmClass.setInsertRecursion();

        Test.startTest();
        tdtmClass.handleAfterInsert(oldContactList);
        Test.stopTest();

        List<Affiliation__c> affiliationAfterCallList = [SELECT Id FROM Affiliation__c];

        System.assertEquals(0, affiliationAfterCallList.size());
    }

    /*************************************************************************************************************
     * @description Positive test method for run method after Update to ensure affiliations are not created when
     * flag is on
     **************************************************************************************************************/
    @isTest
    static void handleAfterUpdateWithFlagOn() {
        String namespace = UTIL_Namespace.getNamespace();
        String prefix = (String.isNotBlank(namespace)) ? namespace + '__' : '';

        List<Affl_Mappings__c> mappings = new List<Affl_Mappings__c>();
        mappings.add(
            new Affl_Mappings__c(
                Name = 'Business Organization',
                Account_Record_Type__c = 'Business_Organization',
                Primary_Affl_Field__c = prefix + 'Primary_Organization__c'
            )
        );
        mappings.add(
            new Affl_Mappings__c(
                Name = 'Household Account',
                Account_Record_Type__c = 'HH_Account',
                Primary_Affl_Field__c = prefix + 'Primary_Household__c'
            )
        );
        insert mappings;

        List<Account> businessAccounts = UTIL_UnitTestData_TEST.getMultipleTestAccounts(
            2,
            UTIL_Describe_API.getBizAccRecTypeID()
        );
        insert businessAccounts;

        Schema.DescribeSObjectResult contactDescribeResult = UTIL_Describe.getObjectDescribe('Contact');

        List<Contact> oldContactList = new List<Contact>();

        for (integer i = 0; i < 5; i++) {
            Contact contactWithPrimaryBusinessOrg = UTIL_UnitTestData_TEST.getUniqueContact(i);
            oldContactList.add(contactWithPrimaryBusinessOrg);
        }

        List<Contact> newContactsList = new List<Contact>();
        for (Contact oldContact : oldContactList) {
            Contact newContact = oldContact.Clone(false);
            newContact.Id = oldContact.Id;
            newContact.Primary_Organization__c = businessAccounts[0].Id;
            newContactsList.add(newContact);
        }

        CON_PrimaryAffls_TDTM tdtmClass = new CON_PrimaryAffls_TDTM();
        tdtmClass.setUpdateRecursion();

        Test.startTest();
        tdtmClass.handleAfterUpdate(oldContactList, newContactsList);
        Test.stopTest();

        List<Affiliation__c> affiliationAfterCallList = [SELECT Id FROM Affiliation__c];

        System.assertEquals(0, affiliationAfterCallList.size());
    }

    /*************************************************************************************************************
     * @description Positive test method for run method afterUpdate to ensure affiliations are created when
     * Contacts are updated with Primary field
     **************************************************************************************************************/
    @isTest
    static void handleAfterUpdateInsertOnly() {
        String namespace = UTIL_Namespace.getNamespace();
        String prefix = (String.isNotBlank(namespace)) ? namespace + '__' : '';

        List<Affl_Mappings__c> mappings = new List<Affl_Mappings__c>();
        mappings.add(
            new Affl_Mappings__c(
                Name = 'Business Organization',
                Account_Record_Type__c = 'Business_Organization',
                Primary_Affl_Field__c = prefix + 'Primary_Organization__c'
            )
        );
        mappings.add(
            new Affl_Mappings__c(
                Name = 'Household Account',
                Account_Record_Type__c = 'HH_Account',
                Primary_Affl_Field__c = prefix + 'Primary_Household__c'
            )
        );
        insert mappings;

        List<Account> businessAccounts = UTIL_UnitTestData_TEST.getMultipleTestAccounts(
            2,
            UTIL_Describe_API.getBizAccRecTypeID()
        );
        insert businessAccounts;

        Schema.DescribeSObjectResult contactDescribeResult = UTIL_Describe.getObjectDescribe('Contact');

        List<Contact> oldContactList = new List<Contact>();

        for (integer i = 0; i < 5; i++) {
            Contact contactWithPrimaryBusinessOrg = UTIL_UnitTestData_TEST.getUniqueContact(i);
            oldContactList.add(contactWithPrimaryBusinessOrg);
        }

        insert oldContactList;

        List<Affiliation__c> affiliationList = [SELECT Id FROM Affiliation__c];

        System.assertEquals(0, affiliationList.size());

        List<Contact> newContactsList = new List<Contact>();
        for (Contact oldContact : oldContactList) {
            Contact newContact = oldContact.Clone(false);
            newContact.Id = oldContact.Id;
            newContact.Primary_Organization__c = businessAccounts[0].Id;
            newContactsList.add(newContact);
        }

        CON_PrimaryAffls_TDTM tdtmClass = new CON_PrimaryAffls_TDTM();

        Test.startTest();
        tdtmClass.handleAfterUpdate(oldContactList, newContactsList);
        Test.stopTest();

        List<Affiliation__c> affiliationAfterCallList = [SELECT Id FROM Affiliation__c];

        System.assertEquals(5, affiliationAfterCallList.size());

        System.assertEquals(
            false,
            TDTM_ProcessControl.getRecursionFlag(
                TDTM_ProcessControl.registeredTrigger.CON_PrimaryAffls_TDTM_After_Update
            ),
            'Recursion flag should be unset.'
        );
    }

    /*************************************************************************************************************
     * @description Positive test method for run method afterUpdate to ensure affiliations are updated when
     * Contacts are cleared with Primary fields
     **************************************************************************************************************/
    @isTest
    static void handleAfterUpdateUpdatesOnly() {
        String namespace = UTIL_Namespace.getNamespace();
        String prefix = (String.isNotBlank(namespace)) ? namespace + '__' : '';

        List<Affl_Mappings__c> mappings = new List<Affl_Mappings__c>();
        mappings.add(
            new Affl_Mappings__c(
                Name = 'Business Organization',
                Account_Record_Type__c = 'Business_Organization',
                Primary_Affl_Field__c = prefix + 'Primary_Organization__c'
            )
        );
        mappings.add(
            new Affl_Mappings__c(
                Name = 'Household Account',
                Account_Record_Type__c = 'HH_Account',
                Primary_Affl_Field__c = prefix + 'Primary_Household__c'
            )
        );
        insert mappings;

        List<Account> businessAccounts = UTIL_UnitTestData_TEST.getMultipleTestAccounts(
            2,
            UTIL_Describe_API.getBizAccRecTypeID()
        );
        insert businessAccounts;

        Schema.DescribeSObjectResult contactDescribeResult = UTIL_Describe.getObjectDescribe('Contact');

        List<Contact> oldContactList = new List<Contact>();

        for (integer i = 0; i < 5; i++) {
            Contact contactWithPrimaryBusinessOrg = UTIL_UnitTestData_TEST.getUniqueContact(i);
            contactWithPrimaryBusinessOrg.Primary_Organization__c = businessAccounts[0].Id;
            oldContactList.add(contactWithPrimaryBusinessOrg);
        }

        insert oldContactList;

        List<Affiliation__c> affiliationList = [SELECT Id FROM Affiliation__c WHERE Primary__c = TRUE];

        System.assertEquals(5, affiliationList.size());

        List<Contact> newContactsList = new List<Contact>();
        for (Contact oldContact : oldContactList) {
            Contact newContact = oldContact.Clone(false);
            newContact.Id = oldContact.Id;
            newContact.Primary_Organization__c = null;
            newContactsList.add(newContact);
        }

        CON_PrimaryAffls_TDTM tdtmClass = new CON_PrimaryAffls_TDTM();

        Test.startTest();
        tdtmClass.handleAfterUpdate(oldContactList, newContactsList);
        Test.stopTest();

        List<Affiliation__c> affiliationAfterCallList = [SELECT Id, Primary__c FROM Affiliation__c];

        System.assertEquals(5, affiliationAfterCallList.size());

        for (Affiliation__c each : affiliationAfterCallList) {
            System.assertEquals(false, each.Primary__c);
        }

        System.assertEquals(
            false,
            TDTM_ProcessControl.getRecursionFlag(
                TDTM_ProcessControl.registeredTrigger.CON_PrimaryAffls_TDTM_After_Update
            ),
            'Recursion flag should be unset.'
        );
    }

    /*************************************************************************************************************
     * @description Positive test method for run method afterUpdate to test inserts and updates of affiliations
     **************************************************************************************************************/
    @isTest
    static void handleAfterUpdateInsertAndUpdates() {
        String namespace = UTIL_Namespace.getNamespace();
        String prefix = (String.isNotBlank(namespace)) ? namespace + '__' : '';

        List<Affl_Mappings__c> mappings = new List<Affl_Mappings__c>();
        mappings.add(
            new Affl_Mappings__c(
                Name = 'Business Organization',
                Account_Record_Type__c = 'Business_Organization',
                Primary_Affl_Field__c = prefix + 'Primary_Organization__c'
            )
        );
        mappings.add(
            new Affl_Mappings__c(
                Name = 'Household Account',
                Account_Record_Type__c = 'HH_Account',
                Primary_Affl_Field__c = prefix + 'Primary_Household__c'
            )
        );
        insert mappings;

        List<Account> businessAccounts = UTIL_UnitTestData_TEST.getMultipleTestAccounts(
            2,
            UTIL_Describe_API.getBizAccRecTypeID()
        );
        insert businessAccounts;

        Schema.DescribeSObjectResult contactDescribeResult = UTIL_Describe.getObjectDescribe('Contact');

        List<Contact> oldContactList = new List<Contact>();

        for (integer i = 0; i < 5; i++) {
            Contact contactWithPrimaryBusinessOrg = UTIL_UnitTestData_TEST.getUniqueContact(i);
            contactWithPrimaryBusinessOrg.Primary_Organization__c = businessAccounts[0].Id;
            oldContactList.add(contactWithPrimaryBusinessOrg);
        }

        insert oldContactList;

        List<Affiliation__c> affiliationList = [SELECT Id FROM Affiliation__c WHERE Primary__c = TRUE];

        System.assertEquals(5, affiliationList.size());

        List<Contact> newContactsList = new List<Contact>();
        for (Contact oldContact : oldContactList) {
            Contact newContact = oldContact.Clone(false);
            newContact.Id = oldContact.Id;
            newContact.Primary_Organization__c = businessAccounts[1].Id;
            newContactsList.add(newContact);
        }

        CON_PrimaryAffls_TDTM tdtmClass = new CON_PrimaryAffls_TDTM();

        Test.startTest();
        tdtmClass.handleAfterUpdate(oldContactList, newContactsList);
        Test.stopTest();

        List<Contact> contactList = [
            SELECT Id, (SELECT Id, Contact__c, Account__c, Primary__c FROM Affl_Accounts__r)
            FROM Contact
        ];
        System.assertEquals(5, contactList.size());
        for (Contact eachContact : contactList) {
            System.assertEquals(2, eachContact.Affl_Accounts__r.size());
            for (Affiliation__c affiliation : eachContact.Affl_Accounts__r) {
                if (affiliation.Account__c == businessAccounts[1].Id) {
                    System.assertEquals(true, affiliation.Primary__c);
                }
                System.assertEquals(eachContact.Id, affiliation.Contact__c);
            }
        }

        System.assertEquals(
            false,
            TDTM_ProcessControl.getRecursionFlag(
                TDTM_ProcessControl.registeredTrigger.CON_PrimaryAffls_TDTM_After_Update
            ),
            'Recursion flag should be unset.'
        );
    }

    /**************************************************************************************************************************
     ****************************************************** FUNCTIONAL TESTS ***************************************************
     **************************************************************************************************************************/

    /**************************************************************************************************************************************
     * @description Helper method to generate error message associated with a mapping to a field that does not lookup to Account.
     * @param  affiliationMapping An affiliation mapping with an invalid lookup field mapping.
     * @return The expected error message associated with the generated model.
     **************************************************************************************************************************************/
    private static String getExpectedInvalidFieldMappingErrorMessage(Affl_Mappings__c affiliationMapping) {
        List<String> params = new List<String>{
            Label.stgColContactPrimaryAfflField,
            affiliationMapping.Primary_Affl_Field__c
        };

        return StringHandlingService.getInstance()
            .formatStringWithApostrophesAndParameters(label.invalidContactFieldInAffiliationMapping, params);
    }

    /**************************************************************************************************************************************
     * @description Helper method to generate error message associated with a mapping to an invalid record type.
     * @param  affiliationMapping An affiliation mapping with an invalid record type mapping.
     * @return The expected error message associated with the generated model.
     **************************************************************************************************************************************/
    private static String getExpectedInvalidRTMappingErrorMessage(Affl_Mappings__c affiliationMapping) {
        List<String> params = new List<String>{
            Label.stgColAccountRecordType,
            affiliationMapping.Account_Record_Type__c
        };

        return StringHandlingService.getInstance()
            .formatStringWithApostrophesAndParameters(Label.invalidRecordTypeInAffiliationMapping, params);
    }

    /*************************************************************************************************************
     * @description Test case to verify that inserting a contact with a primary affiliation field populated with record type
     * validation enabled, a valid Contact field mapping and invalid Record Type mapping throws an error.
     **************************************************************************************************************/
    @isTest
    private static void insertContactAfflInvalidRecordTypeError() {
        List<Contact> testContactsList = UTIL_UnitTestData_TEST.getMultipleTestContacts(100);

        UTIL_CustomSettings_API.getSettingsForTests(
            new Hierarchy_Settings__c(Affiliation_Record_Type_Enforced__c = true)
        );

        List<Affl_Mappings__c> mappings = new List<Affl_Mappings__c>();
        mappings.add(
            new Affl_Mappings__c(
                Name = 'Business Organization',
                Account_Record_Type__c = 'Not a Valid RecordType',
                Primary_Affl_Field__c = UTIL_Namespace.StrTokenNSPrefix('Primary_Organization__c')
            )
        );
        mappings.add(
            new Affl_Mappings__c(
                Name = 'Household Account',
                Account_Record_Type__c = 'HH_Account',
                Primary_Affl_Field__c = UTIL_Namespace.StrTokenNSPrefix('Primary_Household__c')
            )
        );
        insert mappings;

        // insert business account
        Account businessAccount1 = UTIL_UnitTestData_TEST.getMultipleTestAccounts(
            1,
            UTIL_Describe_API.getBizAccRecTypeID()
        )[0];
        insert businessAccount1;

        for (Contact con : testContactsList) {
            con.Primary_Organization__c = businessAccount1.Id;
        }

        Test.startTest();
        Database.SaveResult[] saveResultsList = Database.insert(testContactsList, false);
        Test.stopTest();

        for (Database.SaveResult saveResult : saveResultsList) {
            System.assertEquals(
                CON_PrimaryAffls_TEST.getExpectedInvalidRTMappingErrorMessage(mappings[0]),
                saveResult.getErrors()[0].getMessage(),
                'Invalid Record Type mapping should throw an error when validation is enabled.'
            );
        }
    }

    /*************************************************************************************************************
     * @description Test case to verify that inserting a Contact with a primary affiliation field populated with record type
     * validation enabled, a valid Contact field mapping that is not a lookup to Account and valid Record Type mapping throws an error.
     **************************************************************************************************************/
    @isTest
    private static void insertContactAfflInvalidFieldMappingError() {
        List<Contact> testContactsList = UTIL_UnitTestData_TEST.getMultipleTestContacts(100);
        for (Contact con : testContactsList) {
            con.Gender__c = 'Decline to State';
        }

        UTIL_CustomSettings_API.getSettingsForTests(
            new Hierarchy_Settings__c(Affiliation_Record_Type_Enforced__c = true)
        );

        List<Affl_Mappings__c> mappings = new List<Affl_Mappings__c>();
        mappings.add(
            new Affl_Mappings__c(
                Name = 'Business Organization',
                Account_Record_Type__c = 'Business_Organization',
                Primary_Affl_Field__c = UTIL_Namespace.StrTokenNSPrefix('Gender__c')
            )
        );
        mappings.add(
            new Affl_Mappings__c(
                Name = 'Household Account',
                Account_Record_Type__c = 'HH_Account',
                Primary_Affl_Field__c = UTIL_Namespace.StrTokenNSPrefix('Primary_Household__c')
            )
        );
        insert mappings;

        String errorMessageText = CON_PrimaryAffls_TEST.getExpectedInvalidFieldMappingErrorMessage(mappings[0]);

        Test.startTest();
        Database.SaveResult[] saveResultsList = Database.insert(testContactsList, false);
        Test.stopTest();

        for (Database.SaveResult saveResult : saveResultsList) {
            System.assertEquals(
                errorMessageText,
                saveResult.getErrors()[0].getMessage(),
                'Invalid Record Type mapping should throw an error when validation is enabled.'
            );
        }
    }

    /*************************************************************************************************************
     * @description Test case to verify that inserting a Contact with a primary affiliation field populated with record type
     * validation enabled, a valid Contact field mapping to a non-lookup field and invalid Record Type mapping throws
     * an error when the mapped field is populated.
     **************************************************************************************************************/
    @isTest
    private static void insertContactAfflInvalidRTAndInvalidFieldMappingFieldPopulatedInvalidRecordTypeError() {
        List<Contact> testContactsList = UTIL_UnitTestData_TEST.getMultipleTestContacts(100);

        UTIL_CustomSettings_API.getSettingsForTests(
            new Hierarchy_Settings__c(Affiliation_Record_Type_Enforced__c = true)
        );

        List<Affl_Mappings__c> mappings = new List<Affl_Mappings__c>();
        mappings.add(
            new Affl_Mappings__c(
                Name = 'Business Organization',
                Account_Record_Type__c = 'Not a Valid RecordType',
                Primary_Affl_Field__c = 'FirstName'
            )
        );
        mappings.add(
            new Affl_Mappings__c(
                Name = 'Household Account',
                Account_Record_Type__c = 'HH_Account',
                Primary_Affl_Field__c = UTIL_Namespace.StrTokenNSPrefix('Primary_Household__c')
            )
        );
        insert mappings;

        String errorMessageText = CON_PrimaryAffls_TEST.getExpectedInvalidRTMappingErrorMessage(mappings[0]);

        Test.startTest();
        Database.SaveResult[] saveResultsList = Database.insert(testContactsList, false);
        Test.stopTest();

        for (Database.SaveResult saveResult : saveResultsList) {
            System.assertEquals(
                errorMessageText,
                saveResult.getErrors()[0].getMessage(),
                'Invalid Record Type mapping should throw an error when validation is enabled.'
            );
        }
    }

    /*************************************************************************************************************
     * @description Ensure affiliations are created on Contact insert.
     **************************************************************************************************************/
    @isTest
    private static void insertContactPrimaryAfflWAccRecTypeUnenforced_English() {
        Test.startTest();
        createAffiliationsOnBulkContactInsert();
        Test.stopTest();
    }

    /*************************************************************************************************************
     * @description For a spanish user, ensure affiliations are created on Contact insert.
     * Test Scenario: T-3939029
     **************************************************************************************************************/
    @isTest
    private static void insertContactPrimaryAfflWAccRecTypeUnenforced_Spanish() {
        Profile systemAdministratorProfile = [SELECT Id FROM Profile WHERE Name = 'System Administrator'];

        System.runAs(UTIL_UnitTestData_TEST.createNewUserForTests(
            System.now().getTime() + '@testerson.com',
            systemAdministratorProfile.Id,
            'es'
        )) {
            Test.startTest();
            createAffiliationsOnBulkContactInsert();
            Test.stopTest();
        }
    }

    /*************************************************************************************************************
     * @description Test case to for a spanish user, verify that updating a primary affiliation field on Contact
     * with record type validation disabled, a valid Contact field mapping to a lookup field and invalid Record
     * Type mapping does not throw an error when the mapped field is not populated.
     * Test Scenario: T-3939030
     **************************************************************************************************************/
    @isTest
    private static void updateContactPrimaryAfflWAccRecTypeUnenforced_Spanish() {
        Profile systemAdministratorProfile = [SELECT Id FROM Profile WHERE Name = 'System Administrator'];

        System.runAs(UTIL_UnitTestData_TEST.createNewUserForTests(
            System.now().getTime() + '@testerson.com',
            systemAdministratorProfile.Id,
            'es'
        )) {
            updateContactAfflInvalidRTAndValidFieldMappingFieldNotPopulatedNoValidationPositive();
        }
    }

    /*************************************************************************************************************
     * @description For a spanish user, ensure affiliations are created on Contact insert, additionally
     * ensure affiliations are updated upon contact primary affiliation reassignment.
     * Test Scenario: T-3939026
     **************************************************************************************************************/
    @isTest
    private static void updateMultipleContactPrimaryAfflWAccRecTypeUnenforced_Spanish() {
        Profile systemAdministratorProfile = [SELECT Id FROM Profile WHERE Name = 'System Administrator'];

        System.runAs(UTIL_UnitTestData_TEST.createNewUserForTests(
            System.now().getTime() + '@testerson.com',
            systemAdministratorProfile.Id,
            'es'
        )) {
            createAffiliationsOnBulkContactInsert();

            // insert secondary business account
            Account businessAccount2 = UTIL_UnitTestData_TEST.getMultipleTestAccounts(
                1,
                UTIL_Describe_API.getBizAccRecTypeID()
            )[0];
            insert businessAccount2;

            List<Contact> contactsList = [
                SELECT Id, Primary_Organization__c, (SELECT Account__c, Contact__c, Primary__c FROM Affl_Accounts__r)
                FROM Contact
            ];

            System.assertEquals(100, contactsList.size());
            // Reassign the primary business accounts.
            for (Contact currentContact : contactsList) {
                currentContact.Primary_Organization__c = businessAccount2.Id;
            }

            Test.startTest();
            update contactsList;
            Test.stopTest();

            //Ensure Affiliations appropriately reflect new mapping.
            Integer activeAffiliations = [SELECT COUNT() FROM Affiliation__c WHERE Primary__c = TRUE];
            Integer inactiveAffiliations = [SELECT COUNT() FROM Affiliation__c WHERE Primary__c = FALSE];

            System.assertEquals(100, activeAffiliations);
            System.assertEquals(100, inactiveAffiliations);
        }
    }

    /*************************************************************************************************************
     * @description Test case to verify that insert a Contact with primary affiliation field populated with record type
     * validation disabled, a valid Contact field mapping to a non-lookup field and invalid Record Type mapping throws
     * an error when the mapped field is populated.
     **************************************************************************************************************/
    @isTest
    private static void insertContactAfflInvalidRTAndInvalidFieldMappingFieldPopulatedInvalidValidationOffFieldError() {
        List<Contact> testContactsList = UTIL_UnitTestData_TEST.getMultipleTestContacts(100);

        UTIL_CustomSettings_API.getSettingsForTests(
            new Hierarchy_Settings__c(Affiliation_Record_Type_Enforced__c = false)
        );

        List<Affl_Mappings__c> mappings = new List<Affl_Mappings__c>();
        mappings.add(
            new Affl_Mappings__c(
                Name = 'Business Organization',
                Account_Record_Type__c = 'Not a Valid RecordType',
                Primary_Affl_Field__c = 'FirstName'
            )
        );
        mappings.add(
            new Affl_Mappings__c(
                Name = 'Household Account',
                Account_Record_Type__c = 'HH_Account',
                Primary_Affl_Field__c = UTIL_Namespace.StrTokenNSPrefix('Primary_Household__c')
            )
        );
        insert mappings;

        String errorMessageText = CON_PrimaryAffls_TEST.getExpectedInvalidFieldMappingErrorMessage(mappings[0]);

        Test.startTest();
        Database.SaveResult[] saveResultsList = Database.insert(testContactsList, false);
        Test.stopTest();

        for (Database.SaveResult saveResult : saveResultsList) {
            System.assertEquals(
                errorMessageText,
                saveResult.getErrors()[0].getMessage(),
                'Invalid Record Type mapping should throw an error when validation is enabled.'
            );
        }
    }

    /*************************************************************************************************************
     * @description Test case to verify that inserting a Contact where the mapped primary affiliation field is not
     * populated, with record type validation is disabled, a valid Contact field mapped to a non-lookup field, and an
     * invalid Record Type mapping does not throw an error and does not create an affiliation record.
     **************************************************************************************************************/
    @isTest
    private static void insertContactAfflInvalidRTAndInvalidFieldMappingFieldNotPopulatedNoError() {
        List<Contact> testContactsList = UTIL_UnitTestData_TEST.getMultipleTestContacts(100);

        UTIL_CustomSettings_API.getSettingsForTests(
            new Hierarchy_Settings__c(Affiliation_Record_Type_Enforced__c = false)
        );

        List<Affl_Mappings__c> mappings = new List<Affl_Mappings__c>();
        mappings.add(
            new Affl_Mappings__c(
                Name = 'Business Organization',
                Account_Record_Type__c = 'Not a Valid RecordType',
                Primary_Affl_Field__c = UTIL_Namespace.StrTokenNSPrefix('Gender__c')
            )
        );
        mappings.add(
            new Affl_Mappings__c(
                Name = 'Household Account',
                Account_Record_Type__c = 'HH_Account',
                Primary_Affl_Field__c = UTIL_Namespace.StrTokenNSPrefix('Primary_Household__c')
            )
        );
        insert mappings;

        Test.startTest();
        insert testContactsList;
        Test.stopTest();

        List<Contact> testContactResultsList = [
            SELECT Id, Primary_Organization__c, (SELECT Id FROM Contact.Affl_Accounts__r)
            FROM Contact
            WHERE Id IN :testContactsList
        ];

        System.assertEquals(100, testContactResultsList.size(), 'Contact records should be created.');

        for (Contact contact : testContactResultsList) {
            System.assertEquals(
                true,
                String.isBlank(contact.Primary_Organization__c),
                'Primary Organization field should be blank.'
            );
            System.assertEquals(
                0,
                contact.Affl_Accounts__r.size(),
                'No related affiliation records should be created.'
            );
        }
    }

    /*************************************************************************************************************
     * @description Test case to verify that updating a primary affiliation field on Contact with record type
     * validation disabled, a valid Contact field mapping to a non-lookup field and invalid Record Type mapping does not
     * throw an error when the mapped field is not populated.
     **************************************************************************************************************/
    @isTest
    private static void insertContactAfflInvalidRTAndInvalidFieldMappingFieldNotPopulatedPositive() {
        List<Contact> testContactsList = UTIL_UnitTestData_TEST.getMultipleTestContacts(100);

        UTIL_CustomSettings_API.getSettingsForTests(
            new Hierarchy_Settings__c(Affiliation_Record_Type_Enforced__c = false)
        );

        List<Affl_Mappings__c> mappings = new List<Affl_Mappings__c>();
        mappings.add(
            new Affl_Mappings__c(
                Name = 'Business Organization',
                Account_Record_Type__c = 'Not a Valid RecordType',
                Primary_Affl_Field__c = UTIL_Namespace.StrTokenNSPrefix('Gender__c')
            )
        );
        mappings.add(
            new Affl_Mappings__c(
                Name = 'Household Account',
                Account_Record_Type__c = 'HH_Account',
                Primary_Affl_Field__c = UTIL_Namespace.StrTokenNSPrefix('Primary_Household__c')
            )
        );
        insert mappings;

        Test.startTest();
        insert testContactsList;
        Test.stopTest();

        List<Contact> testContactResultsList = [
            SELECT Id, Primary_Organization__c, (SELECT Id FROM Contact.Affl_Accounts__r)
            FROM Contact
            WHERE Id IN :testContactsList
        ];

        System.assertEquals(100, testContactResultsList.size());

        for (Contact contact : testContactResultsList) {
            System.assertEquals(
                true,
                String.isBlank(contact.Primary_Organization__c),
                'Primary Organization field should be blank.'
            );
            System.assertEquals(
                0,
                contact.Affl_Accounts__r.size(),
                'No related affiliation records should be created.'
            );
        }
    }

    /*************************************************************************************************************
     * @description Test case to verify that updating a primary affiliation field on Contact with record type
     * validation enabled, a valid Contact field mapping and invalid Record Type mapping throws an error.
     **************************************************************************************************************/
    @isTest
    private static void updateContactAfflInvalidRecordTypeError() {
        Hierarchy_Settings__c hs = UTIL_CustomSettings_API.getSettingsForTests(
            new Hierarchy_Settings__c(Affiliation_Record_Type_Enforced__c = true)
        );

        List<Affl_Mappings__c> mappings = new List<Affl_Mappings__c>();
        mappings.add(
            new Affl_Mappings__c(
                Name = 'Business Organization',
                Account_Record_Type__c = 'Not a Valid RecordType',
                Primary_Affl_Field__c = UTIL_Namespace.StrTokenNSPrefix('Primary_Organization__c')
            )
        );
        mappings.add(
            new Affl_Mappings__c(
                Name = 'Household Account',
                Account_Record_Type__c = 'HH_Account',
                Primary_Affl_Field__c = UTIL_Namespace.StrTokenNSPrefix('Primary_Household__c')
            )
        );
        insert mappings;

        // insert business account
        Account businessAccount1 = UTIL_UnitTestData_TEST.getMultipleTestAccounts(
            1,
            UTIL_Describe_API.getBizAccRecTypeID()
        )[0];
        insert businessAccount1;

        List<Contact> testContactsList = UTIL_UnitTestData_TEST.getMultipleTestContacts(100);
        insert testContactsList;

        for (Contact con : testContactsList) {
            con.Primary_Organization__c = businessAccount1.Id;
        }

        String errorMessageText = CON_PrimaryAffls_TEST.getExpectedInvalidRTMappingErrorMessage(mappings[0]);

        Test.startTest();
        Database.SaveResult[] saveResultsList = Database.update(testContactsList, false);
        Test.stopTest();

        for (Database.SaveResult saveResult : saveResultsList) {
            System.assertEquals(
                errorMessageText,
                saveResult.getErrors()[0].getMessage(),
                'Invalid Record Type mapping should throw an error when validation is enabled.'
            );
        }
    }

    /*************************************************************************************************************
     * @description Test case to verify that updating a primary affiliation field on Contact with record type
     * validation enabled, a valid Contact field mapping that is not a lookup to Account and valid Record Type mapping throws an error.
     **************************************************************************************************************/
    @isTest
    private static void updateContactAfflInvalidFieldMappingError() {
        UTIL_CustomSettings_API.getSettingsForTests(
            new Hierarchy_Settings__c(Affiliation_Record_Type_Enforced__c = true)
        );

        List<Affl_Mappings__c> mappings = new List<Affl_Mappings__c>();
        mappings.add(
            new Affl_Mappings__c(
                Name = 'Business Organization',
                Account_Record_Type__c = 'Business_Organization',
                Primary_Affl_Field__c = UTIL_Namespace.StrTokenNSPrefix('Gender__c')
            )
        );
        mappings.add(
            new Affl_Mappings__c(
                Name = 'Household Account',
                Account_Record_Type__c = 'HH_Account',
                Primary_Affl_Field__c = UTIL_Namespace.StrTokenNSPrefix('Primary_Household__c')
            )
        );
        insert mappings;

        // insert business account
        Account businessAccount1 = UTIL_UnitTestData_TEST.getMultipleTestAccounts(
            1,
            UTIL_Describe_API.getBizAccRecTypeID()
        )[0];
        insert businessAccount1;

        List<Contact> testContactsList = UTIL_UnitTestData_TEST.getMultipleTestContacts(100);
        insert testContactsList;

        for (Contact con : testContactsList) {
            con.Primary_Organization__c = businessAccount1.Id;
            con.Gender__c = 'Decline to State';
        }

        String errorMessageText = CON_PrimaryAffls_TEST.getExpectedInvalidFieldMappingErrorMessage(mappings[0]);

        Test.startTest();
        Database.SaveResult[] saveResultsList = Database.update(testContactsList, false);
        Test.stopTest();

        for (Database.SaveResult saveResult : saveResultsList) {
            System.assertEquals(
                errorMessageText,
                saveResult.getErrors()[0].getMessage(),
                'Invalid Record Type mapping should throw an error when validation is enabled.'
            );
        }
    }

    /*************************************************************************************************************
     * @description Test case to verify that updating a primary affiliation field on Contact with record type
     * validation enabled, a valid Contact field mapping to a non-lookup field and invalid Record Type mapping throws
     * an error when the mapped field is populated.
     **************************************************************************************************************/
    @isTest
    private static void updateContactAfflInvalidRTAndInvalidFieldMappingFieldPopulatedInvalidRecordTypeError() {
        UTIL_CustomSettings_API.getSettingsForTests(
            new Hierarchy_Settings__c(Affiliation_Record_Type_Enforced__c = true)
        );

        List<Affl_Mappings__c> mappings = new List<Affl_Mappings__c>();
        mappings.add(
            new Affl_Mappings__c(
                Name = 'Business Organization',
                Account_Record_Type__c = 'Not a Valid RecordType',
                Primary_Affl_Field__c = UTIL_Namespace.StrTokenNSPrefix('Gender__c')
            )
        );
        mappings.add(
            new Affl_Mappings__c(
                Name = 'Household Account',
                Account_Record_Type__c = 'HH_Account',
                Primary_Affl_Field__c = UTIL_Namespace.StrTokenNSPrefix('Primary_Household__c')
            )
        );
        insert mappings;

        List<Contact> testContactsList = UTIL_UnitTestData_TEST.getMultipleTestContacts(100);
        insert testContactsList;

        for (Contact con : testContactsList) {
            con.Gender__c = 'Decline to State';
        }

        String errorMessageText = CON_PrimaryAffls_TEST.getExpectedInvalidRTMappingErrorMessage(mappings[0]);

        Test.startTest();
        Database.SaveResult[] saveResultsList = Database.update(testContactsList, false);
        Test.stopTest();

        for (Database.SaveResult saveResult : saveResultsList) {
            System.assertEquals(
                errorMessageText,
                saveResult.getErrors()[0].getMessage(),
                'Invalid Record Type mapping should throw an error when validation is enabled.'
            );
        }
    }

    /*************************************************************************************************************
     * @description Test case to verify that updating a primary affiliation field on Contact with record type
     * validation enabled, a valid Contact field mapping to a non-lookup field and invalid Record Type mapping does not
     * throw an error when the mapped field is not populated.
     **************************************************************************************************************/
    @isTest
    private static void updateContactAfflInvalidRTAndInvalidFieldMappingFieldNotPopulatedPositive() {
        List<Contact> testContactsList = UTIL_UnitTestData_TEST.getMultipleTestContacts(100);
        for (Contact con : testContactsList) {
            con.FirstName = '';
        }
        insert testContactsList;

        UTIL_CustomSettings_API.getSettingsForTests(
            new Hierarchy_Settings__c(Affiliation_Record_Type_Enforced__c = true)
        );

        List<Affl_Mappings__c> mappings = new List<Affl_Mappings__c>();
        mappings.add(
            new Affl_Mappings__c(
                Name = 'Business Organization',
                Account_Record_Type__c = 'Not a Valid RecordType',
                Primary_Affl_Field__c = UTIL_Namespace.StrTokenNSPrefix('FirstName')
            )
        );
        mappings.add(
            new Affl_Mappings__c(
                Name = 'Household Account',
                Account_Record_Type__c = 'HH_Account',
                Primary_Affl_Field__c = UTIL_Namespace.StrTokenNSPrefix('Primary_Household__c')
            )
        );
        insert mappings;

        // insert business account
        Account businessAccount1 = UTIL_UnitTestData_TEST.getMultipleTestAccounts(
            1,
            UTIL_Describe_API.getBizAccRecTypeID()
        )[0];
        insert businessAccount1;

        for (Contact con : testContactsList) {
            con.Primary_Organization__c = businessAccount1.Id;
        }

        Test.startTest();
        update testContactsList;
        Test.stopTest();

        List<Contact> testContactResultsList = [
            SELECT Id, Primary_Organization__c
            FROM Contact
            WHERE Id IN :testContactsList
        ];

        for (Contact con : testContactResultsList) {
            System.assertEquals(businessAccount1.Id, con.Primary_Organization__c);
        }
    }

    /*************************************************************************************************************
     * @description Test case to verify that updating a primary affiliation field on Contact with record type
     * validation disabled, a valid Contact field mapping to a lookup field and invalid Record Type mapping does not
     * throw an error when the mapped field is not populated.
     * Test Scenario: T-3939018
     **************************************************************************************************************/
    @isTest
    private static void updateContactAfflInvalidRTAndValidFieldMappingFieldNotPopulatedNoValidationPositive() {
        User u = [SELECT toLabel(LanguageLocaleKey) FROM User WHERE Id = :UserInfo.getUserId()];
        List<Contact> testContactsList = UTIL_UnitTestData_TEST.getMultipleTestContacts(100, u.LanguageLocaleKey);
        insert testContactsList;

        UTIL_CustomSettings_API.getSettingsForTests(
            new Hierarchy_Settings__c(Affiliation_Record_Type_Enforced__c = false)
        );

        List<Affl_Mappings__c> mappings = new List<Affl_Mappings__c>();
        mappings.add(
            new Affl_Mappings__c(
                Name = 'Business Organization',
                Account_Record_Type__c = 'Not a Valid RecordType',
                Primary_Affl_Field__c = UTIL_Namespace.StrTokenNSPrefix('Primary_Organization__c')
            )
        );
        mappings.add(
            new Affl_Mappings__c(
                Name = 'Household Account',
                Account_Record_Type__c = 'HH_Account',
                Primary_Affl_Field__c = UTIL_Namespace.StrTokenNSPrefix('Primary_Household__c')
            )
        );
        insert mappings;

        // insert business account
        Account businessAccount1 = UTIL_UnitTestData_TEST.getMultipleTestAccounts(
            1,
            UTIL_Describe_API.getBizAccRecTypeID()
        )[0];
        insert businessAccount1;

        for (Contact con : testContactsList) {
            con.Primary_Organization__c = businessAccount1.Id;
        }

        Test.startTest();
        update testContactsList;
        Test.stopTest();

        List<Contact> testContactResultsList = [
            SELECT Id, Primary_Organization__c
            FROM Contact
            WHERE Id IN :testContactsList
        ];

        for (Contact con : testContactResultsList) {
            System.assertEquals(businessAccount1.Id, con.Primary_Organization__c);
        }
    }

    /*************************************************************************************************************
     * @description Test case to verify that updating a primary affiliation field on Contact with record type
     * validation disabled, a valid Contact field mapping to a lookup field and invalid Record Type mapping does not
     * throw an error when the mapped field is not populated.
     **************************************************************************************************************/
    @isTest
    private static void updateContactAfflInvalidRTAndInValidFieldMappingFieldNotPopulatedNoValidationPositive() {
        UTIL_CustomSettings_API.getSettingsForTests(
            new Hierarchy_Settings__c(Affiliation_Record_Type_Enforced__c = false)
        );

        List<Affl_Mappings__c> mappings = new List<Affl_Mappings__c>();
        mappings.add(
            new Affl_Mappings__c(
                Name = 'Business Organization',
                Account_Record_Type__c = 'Not a Valid RecordType',
                Primary_Affl_Field__c = UTIL_Namespace.StrTokenNSPrefix('Gender__c')
            )
        );
        mappings.add(
            new Affl_Mappings__c(
                Name = 'Household Account',
                Account_Record_Type__c = 'HH_Account',
                Primary_Affl_Field__c = UTIL_Namespace.StrTokenNSPrefix('Primary_Household__c')
            )
        );
        insert mappings;

        List<Contact> testContactsList = UTIL_UnitTestData_TEST.getMultipleTestContacts(100);
        insert testContactsList;

        for (Contact con : testContactsList) {
            con.Gender__c = 'Decline to State';
        }

        String errorMessageText = CON_PrimaryAffls_TEST.getExpectedInvalidFieldMappingErrorMessage(mappings[0]);

        Test.startTest();
        Database.SaveResult[] saveResultsList = Database.update(testContactsList, false);
        Test.stopTest();

        for (Database.SaveResult saveResult : saveResultsList) {
            System.assertEquals(
                errorMessageText,
                saveResult.getErrors()[0].getMessage(),
                'Invalid Record Type mapping should throw an error when validation is enabled.'
            );
        }
    }

    /*************************************************************************************************************
     * @description Test case to verify that updating a primary affiliation field on Contact with record type
     * validation disabled, a valid Contact field mapping to a lookup field and invalid Record Type mapping does not
     * throw an error when the mapped field is not populated.
     **************************************************************************************************************/
    @isTest
    private static void updateContactAfflValidRTAndValidFieldMappingFieldPopulatedNoValidationPositive() {
        List<Contact> testContactsList = UTIL_UnitTestData_TEST.getMultipleTestContacts(100);
        insert testContactsList;

        UTIL_CustomSettings_API.getSettingsForTests(
            new Hierarchy_Settings__c(Affiliation_Record_Type_Enforced__c = false)
        );

        List<Affl_Mappings__c> mappings = new List<Affl_Mappings__c>();
        mappings.add(
            new Affl_Mappings__c(
                Name = 'Business Organization',
                Account_Record_Type__c = 'Business_Organization',
                Primary_Affl_Field__c = UTIL_Namespace.StrTokenNSPrefix('Primary_Organization__c')
            )
        );
        mappings.add(
            new Affl_Mappings__c(
                Name = 'Household Account',
                Account_Record_Type__c = 'HH_Account',
                Primary_Affl_Field__c = UTIL_Namespace.StrTokenNSPrefix('Primary_Household__c')
            )
        );
        insert mappings;

        Account businessAccount = UTIL_UnitTestData_TEST.getMultipleTestAccounts(
            1,
            UTIL_Describe_API.getBizAccRecTypeID()
        )[0];
        insert businessAccount;

        for (Contact con : testContactsList) {
            con.Primary_Organization__c = businessAccount.Id;
        }

        Test.startTest();
        update testContactsList;
        Test.stopTest();

        List<Contact> testContactResultsList = [
            SELECT Id, Primary_Organization__c
            FROM Contact
            WHERE Id IN :testContactsList
        ];

        for (Contact con : testContactResultsList) {
            System.assertEquals(businessAccount.Id, con.Primary_Organization__c);
        }
    }

    private static void createAffiliationsOnBulkContactInsert() {
        UTIL_CustomSettings_API.getSettingsForTests(
            new Hierarchy_Settings__c(Affiliation_Record_Type_Enforced__c = false)
        );

        // insert mappings
        List<Affl_Mappings__c> mappings = new List<Affl_Mappings__c>();
        mappings.add(
            new Affl_Mappings__c(
                Name = 'Business Organization',
                Account_Record_Type__c = 'Business_Organization',
                Primary_Affl_Field__c = UTIL_Namespace.StrTokenNSPrefix('Primary_Organization__c')
            )
        );
        mappings.add(
            new Affl_Mappings__c(
                Name = 'Household Account',
                Account_Record_Type__c = 'HH_Account',
                Primary_Affl_Field__c = UTIL_Namespace.StrTokenNSPrefix('Primary_Household__c')
            )
        );
        insert mappings;

        // insert business account
        Account businessAccount1 = UTIL_UnitTestData_TEST.getMultipleTestAccounts(
            1,
            UTIL_Describe_API.getBizAccRecTypeID()
        )[0];
        insert businessAccount1;

        List<Contact> contactsToBeInserted = new List<Contact>();
        for (integer i = 0; i < contactCount; i++) {
            Contact contactWithPrimaryBusinessOrg = UTIL_UnitTestData_TEST.getUniqueContact(i);
            contactWithPrimaryBusinessOrg.Primary_Organization__c = businessAccount1.Id;
            contactsToBeInserted.add(contactWithPrimaryBusinessOrg);
        }

        insert contactsToBeInserted;
        Map<Id, Contact> ContactsById = new Map<Id, Contact>(contactsToBeInserted);

        //Ensure Primary Business Organization affiliations are created for each Contact
        List<Contact> updatedContactList = [
            SELECT Id, Primary_Organization__c, (SELECT Account__c, Contact__c, Primary__c FROM Affl_Accounts__r)
            FROM Contact
            WHERE Id IN :ContactsById.keySet()
        ];

        System.assertEquals(100, updatedContactList.size());
        for (Contact eachUpdatedContact : updatedContactList) {
            System.assertEquals(1, eachUpdatedContact.Affl_Accounts__r.size());
            for (Affiliation__c affiliation : eachUpdatedContact.Affl_Accounts__r) {
                System.assertEquals(businessAccount1.Id, affiliation.Account__c);
                System.assertEquals(eachUpdatedContact.Id, affiliation.Contact__c);
                System.assertEquals(true, affiliation.Primary__c);
            }
        }
    }

    /*************************************************************************************************************
     * @description Positive bulk test to ensure affiliations are created on Contact update
     **************************************************************************************************************/
    @isTest
    private static void createAffiliationsOnBulkContactupdate() {
        // insert mappings
        List<Affl_Mappings__c> mappings = new List<Affl_Mappings__c>();
        mappings.add(
            new Affl_Mappings__c(
                Name = 'Business Organization',
                Account_Record_Type__c = 'Business_Organization',
                Primary_Affl_Field__c = UTIL_Namespace.StrTokenNSPrefix('Primary_Organization__c')
            )
        );
        mappings.add(
            new Affl_Mappings__c(
                Name = 'Household Account',
                Account_Record_Type__c = 'HH_Account',
                Primary_Affl_Field__c = UTIL_Namespace.StrTokenNSPrefix('Primary_Household__c')
            )
        );
        insert mappings;

        // insert business account
        Account businessAccount1 = UTIL_UnitTestData_TEST.getMultipleTestAccounts(
            1,
            UTIL_Describe_API.getBizAccRecTypeID()
        )[0];
        insert businessAccount1;

        List<Contact> contactsToBeInserted = new List<Contact>();
        for (integer i = 0; i < contactCount; i++) {
            Contact contactWithPrimaryBusinessOrg = UTIL_UnitTestData_TEST.getUniqueContact(i);
            contactsToBeInserted.add(contactWithPrimaryBusinessOrg);
        }

        insert contactsToBeInserted;

        List<Contact> contactToBeUpdatedList = new List<Contact>();

        for (Contact contactToBeUpdated : contactsToBeInserted) {
            contactToBeUpdated.Primary_Organization__c = businessAccount1.Id;
            contactToBeUpdatedList.add(contactToBeUpdated);
        }

        Test.startTest();
        update contactToBeUpdatedList;
        Test.stopTest();
        Map<Id, Contact> ContactsById = new Map<Id, Contact>(contactToBeUpdatedList);

        //Ensure Primary Business Organization affiliations are created for each Contact
        List<Contact> updatedContactList = [
            SELECT Id, Primary_Organization__c, (SELECT Account__c, Contact__c, Primary__c FROM Affl_Accounts__r)
            FROM Contact
            WHERE Id IN :ContactsById.keySet()
        ];

        System.assertEquals(100, updatedContactList.size());
        for (Contact eachUpdatedContact : updatedContactList) {
            System.assertEquals(1, eachUpdatedContact.Affl_Accounts__r.size());
            for (Affiliation__c affiliation : eachUpdatedContact.Affl_Accounts__r) {
                System.assertEquals(businessAccount1.Id, affiliation.Account__c);
                System.assertEquals(eachUpdatedContact.Id, affiliation.Contact__c);
                System.assertEquals(true, affiliation.Primary__c);
            }
        }
    }

    /****************************************************************************************************************
     * @description Tests to ensure that when a Contact is inserted with a primary affiliation field populated, the
     * Contact is created, but no associated affiliation record is inserted when Record Type validation is On with
     * an invalid contact field mapping and valid Record Type mapping.
     **************************************************************************************************************/
    @isTest
    private static void createAffiliationsOnBulkContactInsertWithWrongMappingsWithValidationOn() {
        UTIL_CustomSettings_API.getSettingsForTests(
            new Hierarchy_Settings__c(Affiliation_Record_Type_Enforced__c = true)
        );

        // insert mappings
        List<Affl_Mappings__c> mappings = new List<Affl_Mappings__c>();
        mappings.add(
            new Affl_Mappings__c(
                Name = 'Business Organization',
                Account_Record_Type__c = 'Business_Organization',
                Primary_Affl_Field__c = UTIL_Namespace.StrTokenNSPrefix('Primary_Organization__c' + 'test')
            )
        );
        mappings.add(
            new Affl_Mappings__c(
                Name = 'Household Account',
                Account_Record_Type__c = 'HH_Account',
                Primary_Affl_Field__c = UTIL_Namespace.StrTokenNSPrefix('Primary_Household__c')
            )
        );
        insert mappings;

        // insert business account
        Account businessAccount1 = UTIL_UnitTestData_TEST.getMultipleTestAccounts(
            1,
            UTIL_Describe_API.getBizAccRecTypeID()
        )[0];
        insert businessAccount1;

        List<Contact> contactsToBeInserted = new List<Contact>();
        for (integer i = 0; i < contactCount; i++) {
            Contact contactWithPrimaryBusinessOrg = UTIL_UnitTestData_TEST.getUniqueContact(i);
            contactWithPrimaryBusinessOrg.Primary_Organization__c = businessAccount1.Id;
            contactsToBeInserted.add(contactWithPrimaryBusinessOrg);
        }

        Test.startTest();
        insert contactsToBeInserted;
        Test.stopTest();

        List<Contact> conList = [
            SELECT Id, (SELECT Id FROM Affl_Accounts__r)
            FROM Contact
            WHERE Id IN :contactsToBeInserted
        ];

        System.assertEquals(100, conList.size(), 'Five Contacts should be created.');

        for (Contact con : conList) {
            System.assertEquals(
                true,
                con.Affl_Accounts__r.isEmpty(),
                'Enabling record type validation with invalid mapping should prevent creation of affiliation records.'
            );
        }
    }

    /****************************************************************************************************************
     * @description Tests to ensure that when a Contact is inserted with a primary affiliation field populated, but the
     * mapping is to a field that is not of type lookup to Account, an invalidContactFieldInAffiliationMapping error is thrown.
     **************************************************************************************************************/
    @isTest
    private static void insertContactWithValidRecordTypeMappingAndInvalidFieldMappingToAccountLookup() {
        UTIL_CustomSettings_API.getSettingsForTests(
            new Hierarchy_Settings__c(Affiliation_Record_Type_Enforced__c = true)
        );

        // insert mappings
        List<Affl_Mappings__c> mappings = new List<Affl_Mappings__c>();
        mappings.add(
            new Affl_Mappings__c(
                Name = 'Business Organization',
                Account_Record_Type__c = 'Business_Organization',
                Primary_Affl_Field__c = 'ReportsToId'
            )
        );
        mappings.add(
            new Affl_Mappings__c(
                Name = 'Household Account',
                Account_Record_Type__c = 'HH_Account',
                Primary_Affl_Field__c = UTIL_Namespace.StrTokenNSPrefix('Primary_Household__c')
            )
        );
        insert mappings;

        Contact reportToContact = UTIL_UnitTestData_TEST.getUniqueContact(contactCount + 5);
        insert reportToContact;

        List<Contact> contactsToBeInserted = new List<Contact>();
        for (integer i = 0; i < contactCount; i++) {
            Contact con = UTIL_UnitTestData_TEST.getUniqueContact(i);
            con.ReportsToId = reportToContact.Id;
            contactsToBeInserted.add(con);
        }

        String errorMessageText = CON_PrimaryAffls_TEST.getinvalidContactFieldInAffiliationMappingMessage(
            'ReportsToId'
        );

        Test.startTest();
        Database.SaveResult[] saveResultsList = Database.insert(contactsToBeInserted, false);
        Test.stopTest();

        for (Database.SaveResult saveResult : saveResultsList) {
            System.assertEquals(
                errorMessageText,
                saveResult.getErrors()[0].getMessage(),
                'An invalidContactFieldInAffiliationMapping error should be thrown.'
            );
        }
    }

    /****************************************************************************************************************
     * @description Tests to ensure that when a Contact is inserted with a primary affiliation field populated, the
     * mapping is to a field that is not of type lookup to Account, Record Type mapping is invalid and validation is
     * enabled, an invalidRecordTypeInAffiliationMapping error is thrown.
     **************************************************************************************************************/
    @isTest
    private static void insertContactWithInvalidRTMappingAndInvalidFieldMappingToAccountLookupValidationOn() {
        UTIL_CustomSettings_API.getSettingsForTests(
            new Hierarchy_Settings__c(Affiliation_Record_Type_Enforced__c = true)
        );

        // insert mappings
        List<Affl_Mappings__c> mappings = new List<Affl_Mappings__c>();
        mappings.add(
            new Affl_Mappings__c(
                Name = 'Business Organization',
                Account_Record_Type__c = 'Business_Organization_Invalid',
                Primary_Affl_Field__c = 'ReportsToId'
            )
        );
        mappings.add(
            new Affl_Mappings__c(
                Name = 'Household Account',
                Account_Record_Type__c = 'HH_Account',
                Primary_Affl_Field__c = UTIL_Namespace.StrTokenNSPrefix('Primary_Household__c')
            )
        );
        insert mappings;

        Contact reportToContact = UTIL_UnitTestData_TEST.getUniqueContact(contactCount + 5);
        insert reportToContact;

        List<Contact> contactsToBeInserted = new List<Contact>();
        for (integer i = 0; i < contactCount; i++) {
            Contact con = UTIL_UnitTestData_TEST.getUniqueContact(i);
            con.ReportsToId = reportToContact.Id;
            contactsToBeInserted.add(con);
        }

        String errorMessageText = CON_PrimaryAffls_TEST.getInvalidRecordTypeInAffiliationMappingMessage(
            'Business_Organization_Invalid'
        );

        Test.startTest();
        Database.SaveResult[] saveResultsList = Database.insert(contactsToBeInserted, false);
        Test.stopTest();

        for (Database.SaveResult saveResult : saveResultsList) {
            System.assertEquals(
                errorMessageText,
                saveResult.getErrors()[0].getMessage(),
                'An invalidRecordTypeInAffiliationMapping error should be thrown.'
            );
        }
    }

    /****************************************************************************************************************
     * @description Tests to ensure that when a Contact is inserted with a primary affiliation field populated,  the
     * mapping is to a field that is not of type lookup to Account, Record Type mapping is invalid and validation is
     * disabled, an invalidContactFieldInAffiliationMapping error is thrown.
     **************************************************************************************************************/
    @isTest
    private static void insertContactWithInvalidRTMappingAndInvalidFieldMappingToAccountLookupValidationOff() {
        UTIL_CustomSettings_API.getSettingsForTests(
            new Hierarchy_Settings__c(Affiliation_Record_Type_Enforced__c = false)
        );

        // insert mappings
        List<Affl_Mappings__c> mappings = new List<Affl_Mappings__c>();
        mappings.add(
            new Affl_Mappings__c(
                Name = 'Business Organization',
                Account_Record_Type__c = 'Business_Organization_Invalid',
                Primary_Affl_Field__c = 'ReportsToId'
            )
        );
        mappings.add(
            new Affl_Mappings__c(
                Name = 'Household Account',
                Account_Record_Type__c = 'HH_Account',
                Primary_Affl_Field__c = UTIL_Namespace.StrTokenNSPrefix('Primary_Household__c')
            )
        );
        insert mappings;

        Contact reportToContact = UTIL_UnitTestData_TEST.getUniqueContact(contactCount + 5);
        insert reportToContact;

        List<Contact> contactsToBeInserted = new List<Contact>();
        for (integer i = 0; i < contactCount; i++) {
            Contact con = UTIL_UnitTestData_TEST.getUniqueContact(i);
            con.ReportsToId = reportToContact.Id;
            contactsToBeInserted.add(con);
        }

        String errorMessageText = CON_PrimaryAffls_TEST.getinvalidContactFieldInAffiliationMappingMessage(
            'ReportsToId'
        );

        Test.startTest();
        Database.SaveResult[] saveResultsList = Database.insert(contactsToBeInserted, false);
        Test.stopTest();

        for (Database.SaveResult saveResult : saveResultsList) {
            System.assertEquals(
                errorMessageText,
                saveResult.getErrors()[0].getMessage(),
                'An invalidContactFieldInAffiliationMapping error should be thrown.'
            );
        }
    }

    /****************************************************************************************************************
     * @description Tests to ensure that when a Contact is inserted without a primary affiliation field populated,  the
     * mapping is to a field that is not of type lookup to Account, Record Type mapping is invalid and validation is
     * disabled, no error is thrown and the insert completes as expected.
     **************************************************************************************************************/
    @isTest
    private static void insertContactWithNoPrimaryAfflFieldPopulated() {
        UTIL_CustomSettings_API.getSettingsForTests(
            new Hierarchy_Settings__c(Affiliation_Record_Type_Enforced__c = false)
        );

        // insert mappings
        List<Affl_Mappings__c> mappings = new List<Affl_Mappings__c>();
        mappings.add(
            new Affl_Mappings__c(
                Name = 'Business Organization',
                Account_Record_Type__c = 'Business_Organization_Invalid',
                Primary_Affl_Field__c = UTIL_Namespace.StrTokenNSPrefix('ReportsToId')
            )
        );
        mappings.add(
            new Affl_Mappings__c(
                Name = 'Household Account',
                Account_Record_Type__c = 'HH_Account',
                Primary_Affl_Field__c = UTIL_Namespace.StrTokenNSPrefix('Primary_Household__c')
            )
        );
        insert mappings;

        List<Contact> contactsToBeInserted = new List<Contact>();
        for (integer i = 0; i < contactCount; i++) {
            Contact con = UTIL_UnitTestData_TEST.getUniqueContact(i);
            con.Gender__c = 'Decline to State';
            contactsToBeInserted.add(con);
        }

        String errorMessageText = CON_PrimaryAffls_TEST.getinvalidContactFieldInAffiliationMappingMessage(
            'ReportsToId'
        );

        Test.startTest();
        insert contactsToBeInserted;
        Test.stopTest();

        List<Contact> contactResultsList = [SELECT Id, Gender__c FROM Contact WHERE Id IN :contactsToBeInserted];

        System.assertEquals(contactCount, contactResultsList.size(), 'Contacts should insert successfully.');

        for (Contact con : contactResultsList) {
            System.assertEquals(
                'Decline to State',
                con.Gender__c,
                'Gender__c field should be set to \'Decline to State\'.'
            );
        }
    }

    /****************************************************************************************************************
     * @description Tests to ensure that when a Contact is updated with a primary affiliation field populated, but the
     * mapping is to a field that is not of type lookup to Account, an invalidContactFieldInAffiliationMapping error is thrown.
     **************************************************************************************************************/
    @isTest
    private static void updateContactWithValidRecordTypeMappingAndInvalidFieldMappingToAccountLookup() {
        UTIL_CustomSettings_API.getSettingsForTests(
            new Hierarchy_Settings__c(Affiliation_Record_Type_Enforced__c = true)
        );

        // insert mappings
        List<Affl_Mappings__c> mappings = new List<Affl_Mappings__c>();
        mappings.add(
            new Affl_Mappings__c(
                Name = 'Business Organization',
                Account_Record_Type__c = 'Business_Organization',
                Primary_Affl_Field__c = 'ReportsToId'
            )
        );
        mappings.add(
            new Affl_Mappings__c(
                Name = 'Household Account',
                Account_Record_Type__c = 'HH_Account',
                Primary_Affl_Field__c = UTIL_Namespace.StrTokenNSPrefix('Primary_Household__c')
            )
        );
        insert mappings;

        Contact reportToContact = UTIL_UnitTestData_TEST.getUniqueContact(contactCount + 5);
        insert reportToContact;

        List<Contact> contactsToBeInserted = new List<Contact>();
        for (integer i = 0; i < contactCount; i++) {
            Contact con = UTIL_UnitTestData_TEST.getUniqueContact(i);
            contactsToBeInserted.add(con);
        }

        insert contactsToBeInserted;

        for (Contact con : contactsToBeInserted) {
            con.ReportsToId = reportToContact.Id;
        }

        String errorMessageText = CON_PrimaryAffls_TEST.getinvalidContactFieldInAffiliationMappingMessage(
            'ReportsToId'
        );

        Test.startTest();
        Database.SaveResult[] saveResultsList = Database.update(contactsToBeInserted, false);
        Test.stopTest();

        for (Database.SaveResult saveResult : saveResultsList) {
            System.assertEquals(
                errorMessageText,
                saveResult.getErrors()[0].getMessage(),
                'An invalidContactFieldInAffiliationMapping error should be thrown.'
            );
        }
    }

    /****************************************************************************************************************
     * @description Tests to ensure that when a Contact is updated with a primary affiliation field populated, the
     * mapping is to a field that is not of type lookup to Account, Record Type mapping is invalid and validation is
     * enabled, an invalidRecordTypeInAffiliationMapping error is thrown.
     **************************************************************************************************************/
    @isTest
    private static void updateContactWithInvalidRTMappingAndInvalidFieldMappingToAccountLookupValidationOn() {
        UTIL_CustomSettings_API.getSettingsForTests(
            new Hierarchy_Settings__c(Affiliation_Record_Type_Enforced__c = true)
        );

        // insert mappings
        List<Affl_Mappings__c> mappings = new List<Affl_Mappings__c>();
        mappings.add(
            new Affl_Mappings__c(
                Name = 'Business Organization',
                Account_Record_Type__c = 'Business_Organization_Invalid',
                Primary_Affl_Field__c = 'ReportsToId'
            )
        );
        mappings.add(
            new Affl_Mappings__c(
                Name = 'Household Account',
                Account_Record_Type__c = 'HH_Account',
                Primary_Affl_Field__c = UTIL_Namespace.StrTokenNSPrefix('Primary_Household__c')
            )
        );
        insert mappings;

        Contact reportToContact = UTIL_UnitTestData_TEST.getUniqueContact(contactCount + 5);
        insert reportToContact;

        List<Contact> contactsToBeInserted = new List<Contact>();
        for (integer i = 0; i < contactCount; i++) {
            Contact con = UTIL_UnitTestData_TEST.getUniqueContact(i);
            contactsToBeInserted.add(con);
        }

        insert contactsToBeInserted;

        for (Contact con : contactsToBeInserted) {
            con.ReportsToId = reportToContact.Id;
        }

        String errorMessageText = CON_PrimaryAffls_TEST.getInvalidRecordTypeInAffiliationMappingMessage(
            'Business_Organization_Invalid'
        );

        Test.startTest();
        Database.SaveResult[] saveResultsList = Database.update(contactsToBeInserted, false);
        Test.stopTest();

        for (Database.SaveResult saveResult : saveResultsList) {
            System.assertEquals(
                errorMessageText,
                saveResult.getErrors()[0].getMessage(),
                'An invalidRecordTypeInAffiliationMapping error should be thrown.'
            );
        }
    }

    /****************************************************************************************************************
     * @description Tests to ensure that when a Contact is updated with a primary affiliation field populated,  the
     * mapping is to a field that is not of type lookup to Account, Record Type mapping is invalid and validation is
     * disabled, an invalidContactFieldInAffiliationMapping error is thrown.
     **************************************************************************************************************/
    @isTest
    private static void updateContactWithInvalidRTMappingAndInvalidFieldMappingToAccountLookupValidationOff() {
        UTIL_CustomSettings_API.getSettingsForTests(
            new Hierarchy_Settings__c(Affiliation_Record_Type_Enforced__c = false)
        );

        // insert mappings
        List<Affl_Mappings__c> mappings = new List<Affl_Mappings__c>();
        mappings.add(
            new Affl_Mappings__c(
                Name = 'Business Organization',
                Account_Record_Type__c = 'Business_Organization_Invalid',
                Primary_Affl_Field__c = 'ReportsToId'
            )
        );
        mappings.add(
            new Affl_Mappings__c(
                Name = 'Household Account',
                Account_Record_Type__c = 'HH_Account',
                Primary_Affl_Field__c = UTIL_Namespace.StrTokenNSPrefix('Primary_Household__c')
            )
        );
        insert mappings;

        Contact reportToContact = UTIL_UnitTestData_TEST.getUniqueContact(contactCount + 5);
        insert reportToContact;

        List<Contact> contactsToBeInserted = new List<Contact>();
        for (integer i = 0; i < contactCount; i++) {
            Contact con = UTIL_UnitTestData_TEST.getUniqueContact(i);
            contactsToBeInserted.add(con);
        }

        insert contactsToBeInserted;

        for (Contact con : contactsToBeInserted) {
            con.ReportsToId = reportToContact.Id;
        }

        String errorMessageText = CON_PrimaryAffls_TEST.getinvalidContactFieldInAffiliationMappingMessage(
            'ReportsToId'
        );

        Test.startTest();
        Database.SaveResult[] saveResultsList = Database.update(contactsToBeInserted, false);
        Test.stopTest();

        for (Database.SaveResult saveResult : saveResultsList) {
            System.assertEquals(
                errorMessageText,
                saveResult.getErrors()[0].getMessage(),
                'An invalidContactFieldInAffiliationMapping error should be thrown.'
            );
        }
    }

    /****************************************************************************************************************
     * @description Tests to ensure that when a Contact is updated without a primary affiliation field populated,  the
     * mapping is to a field that is not of type lookup to Account, Record Type mapping is invalid and validation is
     * disabled, no error is thrown and the update completes as expected.
     **************************************************************************************************************/
    @isTest
    private static void updateContactWithNoPrimaryAfflFieldPopulated() {
        UTIL_CustomSettings_API.getSettingsForTests(
            new Hierarchy_Settings__c(Affiliation_Record_Type_Enforced__c = false)
        );

        // insert mappings
        List<Affl_Mappings__c> mappings = new List<Affl_Mappings__c>();
        mappings.add(
            new Affl_Mappings__c(
                Name = 'Business Organization',
                Account_Record_Type__c = 'Business_Organization_Invalid',
                Primary_Affl_Field__c = UTIL_Namespace.StrTokenNSPrefix('ReportsToId')
            )
        );
        mappings.add(
            new Affl_Mappings__c(
                Name = 'Household Account',
                Account_Record_Type__c = 'HH_Account',
                Primary_Affl_Field__c = UTIL_Namespace.StrTokenNSPrefix('Primary_Household__c')
            )
        );
        insert mappings;

        Contact reportToContact = UTIL_UnitTestData_TEST.getUniqueContact(contactCount + 5);
        insert reportToContact;

        List<Contact> contactsToBeInserted = new List<Contact>();
        for (integer i = 0; i < contactCount; i++) {
            Contact con = UTIL_UnitTestData_TEST.getUniqueContact(i);
            contactsToBeInserted.add(con);
        }

        insert contactsToBeInserted;

        for (Contact con : contactsToBeInserted) {
            con.Gender__c = 'Decline to State';
        }

        String errorMessageText = CON_PrimaryAffls_TEST.getinvalidContactFieldInAffiliationMappingMessage(
            'ReportsToId'
        );

        Test.startTest();
        update contactsToBeInserted;
        Test.stopTest();

        List<Contact> contactResultsList = [SELECT Id, Gender__c FROM Contact WHERE Id IN :contactsToBeInserted];

        for (Contact con : contactResultsList) {
            System.assertEquals(
                'Decline to State',
                con.Gender__c,
                'Gender__c field should be updated to \'Decline to State\'.'
            );
        }
    }

    /*************************************************************************************************************************
     * @description Test to ensure Contacts are not created created when mappings have incorrect values and validation is off
     *************************************************************************************************************************/
    @isTest
    private static void createAffiliationsOnBulkContactInsertWithWrongMappingsWithValidationOff() {
        // insert mappings
        List<Affl_Mappings__c> mappings = new List<Affl_Mappings__c>();
        mappings.add(
            new Affl_Mappings__c(
                Name = 'Business Organization',
                Account_Record_Type__c = 'Business_Organization',
                Primary_Affl_Field__c = UTIL_Namespace.StrTokenNSPrefix('Primary_Organization__c' + 'test')
            )
        );
        mappings.add(
            new Affl_Mappings__c(
                Name = 'Household Account',
                Account_Record_Type__c = 'HH_Account',
                Primary_Affl_Field__c = UTIL_Namespace.StrTokenNSPrefix('Primary_Household__c')
            )
        );
        insert mappings;

        // insert business account
        Account businessAccount1 = UTIL_UnitTestData_TEST.getMultipleTestAccounts(
            1,
            UTIL_Describe_API.getBizAccRecTypeID()
        )[0];
        insert businessAccount1;

        List<Contact> contactsToBeInserted = new List<Contact>();
        for (integer i = 0; i < contactCount; i++) {
            Contact contactWithPrimaryBusinessOrg = UTIL_UnitTestData_TEST.getUniqueContact(i);
            contactWithPrimaryBusinessOrg.Primary_Organization__c = businessAccount1.Id;
            contactsToBeInserted.add(contactWithPrimaryBusinessOrg);
        }

        Test.startTest();
        insert contactsToBeInserted;
        Test.stopTest();

        List<Contact> conList = [SELECT Id FROM Contact];
        List<Affiliation__c> afflList = [SELECT Id FROM Affiliation__c];

        System.assertEquals(100, conList.size());
        System.assertEquals(true, afflList.isEmpty());
    }

    /********************************************************************************************************************************
     * @description Test to ensure new Primary affiliations are created and old ones become non-primary when Primary affiliation field
     * is updated in a Contact record.
     ********************************************************************************************************************************/
    @isTest
    private static void createAffiliationsOnBulkContactupdates() {
        // insert mappings
        List<Affl_Mappings__c> mappings = new List<Affl_Mappings__c>();
        mappings.add(
            new Affl_Mappings__c(
                Name = 'Business Organization',
                Account_Record_Type__c = 'Business_Organization',
                Primary_Affl_Field__c = UTIL_Namespace.StrTokenNSPrefix('Primary_Organization__c')
            )
        );
        mappings.add(
            new Affl_Mappings__c(
                Name = 'Household Account',
                Account_Record_Type__c = 'HH_Account',
                Primary_Affl_Field__c = UTIL_Namespace.StrTokenNSPrefix('Primary_Household__c')
            )
        );
        insert mappings;

        // insert business account
        List<Account> businessAccountList = UTIL_UnitTestData_TEST.getMultipleTestAccounts(
            2,
            UTIL_Describe_API.getBizAccRecTypeID()
        );
        insert businessAccountList;

        List<Contact> contactsToBeInserted = new List<Contact>();
        for (integer i = 0; i < contactCount; i++) {
            Contact contactWithPrimaryBusinessOrg = UTIL_UnitTestData_TEST.getUniqueContact(i);
            contactWithPrimaryBusinessOrg.Primary_Organization__c = businessAccountList[0].Id;
            contactsToBeInserted.add(contactWithPrimaryBusinessOrg);
        }

        insert contactsToBeInserted;

        List<Affiliation__c> afflList = [
            SELECT Id
            FROM Affiliation__c
            WHERE Account__c = :businessAccountList[0].Id AND Primary__c = TRUE
        ];
        System.assertEquals(100, afflList.size());

        List<Contact> contactToBeUpdatedList = new List<Contact>();

        for (Contact contactToBeUpdated : contactsToBeInserted) {
            contactToBeUpdated.Primary_Organization__c = businessAccountList[1].Id;
            contactToBeUpdatedList.add(contactToBeUpdated);
        }

        Test.startTest();
        update contactToBeUpdatedList;
        Test.stopTest();
        Map<Id, Contact> ContactsById = new Map<Id, Contact>(contactToBeUpdatedList);

        List<Affiliation__c> afflListWithBizOrg1AsPrimary = [
            SELECT Id
            FROM Affiliation__c
            WHERE Account__c = :businessAccountList[0].Id AND Primary__c = TRUE
        ];
        System.assertEquals(0, afflListWithBizOrg1AsPrimary.size());

        List<Affiliation__c> afflListWithBizOrg2AsPrimary = [
            SELECT Id
            FROM Affiliation__c
            WHERE Account__c = :businessAccountList[1].Id AND Primary__c = TRUE
        ];
        System.assertEquals(100, afflListWithBizOrg2AsPrimary.size());
    }

    /*************************************************************************************************************
     * @description Test to ensure Primary Affiliations are made non-primary when Primary field is cleared on
     * update of a Contact record.
     **************************************************************************************************************/
    @isTest
    private static void makeAffiliationNonPrimaryByClearingField() {
        // insert mappings
        List<Affl_Mappings__c> mappings = new List<Affl_Mappings__c>();
        mappings.add(
            new Affl_Mappings__c(
                Name = 'Business Organization',
                Account_Record_Type__c = 'Business_Organization',
                Primary_Affl_Field__c = UTIL_Namespace.StrTokenNSPrefix('Primary_Organization__c')
            )
        );
        mappings.add(
            new Affl_Mappings__c(
                Name = 'Household Account',
                Account_Record_Type__c = 'HH_Account',
                Primary_Affl_Field__c = UTIL_Namespace.StrTokenNSPrefix('Primary_Household__c')
            )
        );
        insert mappings;

        // insert business account
        List<Account> businessAccountList = UTIL_UnitTestData_TEST.getMultipleTestAccounts(
            2,
            UTIL_Describe_API.getBizAccRecTypeID()
        );
        insert businessAccountList;

        List<Contact> contactsToBeInserted = new List<Contact>();
        for (integer i = 0; i < 5; i++) {
            Contact contactWithPrimaryBusinessOrg = UTIL_UnitTestData_TEST.getUniqueContact(i);
            contactWithPrimaryBusinessOrg.Primary_Organization__c = businessAccountList[0].Id;
            contactsToBeInserted.add(contactWithPrimaryBusinessOrg);
        }

        insert contactsToBeInserted;

        List<Affiliation__c> afflList = [
            SELECT Id
            FROM Affiliation__c
            WHERE Account__c = :businessAccountList[0].Id AND Primary__c = TRUE
        ];
        System.assertEquals(5, afflList.size());

        List<Contact> contactToBeUpdatedList = new List<Contact>();

        for (Contact contactToBeUpdated : contactsToBeInserted) {
            contactToBeUpdated.Primary_Organization__c = null;
            contactToBeUpdatedList.add(contactToBeUpdated);
        }

        Test.startTest();
        update contactToBeUpdatedList;
        Test.stopTest();
        Map<Id, Contact> ContactsById = new Map<Id, Contact>(contactToBeUpdatedList);

        List<Affiliation__c> afflListWithBizOrg1AsPrimary = [SELECT Id FROM Affiliation__c WHERE Primary__c = TRUE];
        System.assertEquals(0, afflListWithBizOrg1AsPrimary.size());
    }

    /**************************************************************************************************************
     * @description Helper method to generate invalidRecordTypeInAffiliationMapping with appropriate
     * substitutions.
     * @param  invalidRTName Name of invalid Record Type in affiliation mapping
     * @return A string containing invalidRecordTypeInAffiliationMapping message text with appropriate
     * substitutions.
     **************************************************************************************************************/
    private static String getInvalidRecordTypeInAffiliationMappingMessage(String invalidRTName) {
        List<String> params = new List<String>{ Label.stgColAccountRecordType, invalidRTName };

        return StringHandlingService.getInstance()
            .formatStringWithApostrophesAndParameters(label.invalidRecordTypeInAffiliationMapping, params);
    }

    /**************************************************************************************************************
     * @description Helper method to generate invalidContactFieldInAffiliationMapping with appropriate
     * substitutions.
     * @param  invalidRTName Name of invalid Contact field in affiliation mapping
     * @return A string containing invalidContactFieldInAffiliationMapping message text with appropriate
     * substitutions.
     **************************************************************************************************************/
    private static String getinvalidContactFieldInAffiliationMappingMessage(String invalidContactFieldName) {
        List<String> params = new List<String>{ Label.stgColContactPrimaryAfflField, invalidContactFieldName };

        return StringHandlingService.getInstance()
            .formatStringWithApostrophesAndParameters(label.invalidContactFieldInAffiliationMapping, params);
    }
}
/*
    Copyright (c) 2019, Salesforce.org
    All rights reserved.
    Redistribution and use in source and binary forms, with or without
    modification, are permitted provided that the following conditions are met:
    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
    * Neither the name of Salesforce.org nor the names of
      its contributors may be used to endorse or promote products derived
      from this software without specific prior written permission.
    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
    "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
    LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
    FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
    COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
    INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
    BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
    LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
    CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
    LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
    ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
    POSSIBILITY OF SUCH DAMAGE.
*/
/**
* @author Salesforce.org
* @date 2019
* @group Languages
* @group-content ../../ApexDocContent/Languages.htm
* @description Tests to verify the logic associated with the CON_PrimaryLanguage_TDTM class when Contact records are
* inserted or updated with changes to the Primary Language field.  Validates that a new Contact Language record is
* created only when an existing record corresponding to the Contact and Language is not found.
*/
@isTest
private class CON_PrimaryLanguage_TEST {

    /**************************************************************************************************************************
    ****************************************************** FUNCTIONAL TESTS ***************************************************
    **************************************************************************************************************************/

    /*******************************************************************************************************
    * @description Test method to verify that insertion of a new Contact with a Primary Language specified
    * results in the creation of a Primary Contact Language corresponding to the specified language
    * and related to the Contact.
    ********************************************************************************************************/
    @isTest
    private static void insertContactWithPrimaryLanguage() {
        Language__c englishLanguage = UTIL_UnitTestData_TEST.createLanguage('English');

        List<Contact> testContactsList = UTIL_UnitTestData_TEST.getMultipleTestContacts(5);
        
        for (Contact con : testContactsList){
            con.Primary_Language__c = englishLanguage.Id;
        }

        Test.startTest();
        insert testContactsList;
        Test.stopTest();

        List<Contact_Language__c> conLangAfterInsertList = [SELECT Id, 
                                                                   Primary_Language__c, 
                                                                   Fluency__c,
                                                                   Contact__c,
                                                                   Language__c
                                                            FROM Contact_Language__c
                                                            WHERE Contact__c IN :testContactsList];

        Map<Id, List<Contact_Language__c>> contactLanguagesListByContactId = CON_PrimaryLanguage_TEST.mapContactLanguagesToContact(conLangAfterInsertList);

        for (Contact con : testContactsList){
            System.assertEquals(true, contactLanguagesListByContactId.containsKey(con.Id), 'Contact should be associated with Contact Language records.');
            System.assertEquals(1, contactLanguagesListByContactId.get(con.Id).size(), 'Contact should be associated with one Contact Language record.');            
            System.assertEquals(englishLanguage.Id, contactLanguagesListByContactId.get(con.Id)[0].Language__c, 'Contact Language record associated with Contact should be for the English Language.');
            System.assertEquals(englishLanguage.Id, con.Primary_Language__c, 'Contact\'s primary language should be English.');            
            System.assertEquals(con.Primary_Language__c, contactLanguagesListByContactId.get(con.Id)[0].Language__c, 'Primary language on Contact should match the language specified on Contact Language record.');
            System.assertEquals(true, contactLanguagesListByContactId.get(con.Id)[0].Primary_Language__c, 'English Contact Language record should be set as primary.');
            System.assertEquals(UTIL_CustomSettingsFacade.getSettings().Default_Contact_Language_Fluency__c, contactLanguagesListByContactId.get(con.Id)[0].Fluency__c, 'English Contact Language record fluency should match the default value.');
        }
    }

    /*******************************************************************************************************
    * @description Test method to verify that updating of a Contact to specify a Primary Language 
    * results in the creation of a Primary Contact Language corresponding to the language when one
    * does not already exist.
    ********************************************************************************************************/
    @isTest
    private static void updateContactToAddNewPrimaryLanguage() {
        Language__c englishLanguage = UTIL_UnitTestData_TEST.createLanguage('English');
        List<Contact> testContactsList = UTIL_UnitTestData_TEST.getMultipleTestContacts(5);
        insert testContactsList;
        
        for (Contact con : testContactsList){
            con.Primary_Language__c = englishLanguage.Id;
        }

        Test.startTest();
        update testContactsList;
        Test.stopTest();

        List<Contact_Language__c> conLangAfterInsertList = [SELECT Id, 
                                                                   Primary_Language__c, 
                                                                   Fluency__c,
                                                                   Contact__c,
                                                                   Language__c
                                                            FROM Contact_Language__c
                                                            WHERE Contact__c IN :testContactsList];

        Map<Id, List<Contact_Language__c>> contactLanguagesListByContactId = CON_PrimaryLanguage_TEST.mapContactLanguagesToContact(conLangAfterInsertList);

        for (Contact con : testContactsList){
            System.assertEquals(true, contactLanguagesListByContactId.containsKey(con.Id), 'Contact should be associated with Contact Language records.');
            System.assertEquals(1, contactLanguagesListByContactId.get(con.Id).size(), 'Contact should be associated with one Contact Language record.');            
            System.assertEquals(englishLanguage.Id, contactLanguagesListByContactId.get(con.Id)[0].Language__c, 'Contact Language record associated with Contact should be for the English Language.');
            System.assertEquals(englishLanguage.Id, con.Primary_Language__c, 'Contact\'s primary language should be English.');            
            System.assertEquals(con.Primary_Language__c, contactLanguagesListByContactId.get(con.Id)[0].Language__c, 'Primary language on Contact should match the language specified on Contact Language record.');
            System.assertEquals(true, contactLanguagesListByContactId.get(con.Id)[0].Primary_Language__c, 'English Contact Language record should be set as primary.');
            System.assertEquals(UTIL_CustomSettingsFacade.getSettings().Default_Contact_Language_Fluency__c, contactLanguagesListByContactId.get(con.Id)[0].Fluency__c, 'English Contact Language record fluency should match the default value.');
        }
    }

    /*******************************************************************************************************
    * @description Test method to verify that updating of a Contact to change the specified Primary Language 
    * results in the creation of a new Primary Contact Language corresponding to the new language when one
    * does not already exist and removes the primary setting from the former contact languge record.
    ********************************************************************************************************/
    @isTest
    private static void updateContactToChangeToNewPrimaryLanguage() {
        Language__c englishLanguage = UTIL_UnitTestData_TEST.createLanguage('English');
        Language__c frenchLanguage = UTIL_UnitTestData_TEST.createLanguage('French');

        List<Contact> testContactsList = UTIL_UnitTestData_TEST.getMultipleTestContacts(5);
        
        for (Contact con : testContactsList){
            con.Primary_Language__c = englishLanguage.Id;
        }

        insert testContactsList;
        
        for (Contact con : testContactsList){
            con.Primary_Language__c = frenchLanguage.Id;
        }

        Test.startTest();
        update testContactsList;
        Test.stopTest();

        List<Contact_Language__c> conLangAfterInsertList = [SELECT Id, 
                                                                   Primary_Language__c, 
                                                                   Fluency__c,
                                                                   Contact__c,
                                                                   Language__c
                                                            FROM Contact_Language__c
                                                            WHERE Contact__c IN :testContactsList];

        Map<Id, List<Contact_Language__c>> contactLanguagesListByContactId = CON_PrimaryLanguage_TEST.mapContactLanguagesToContact(conLangAfterInsertList);

        for (Contact con : testContactsList){
            System.assertEquals(true, contactLanguagesListByContactId.containsKey(con.Id), 'Contact should be associated with Contact Language records.');
            System.assertEquals(2, contactLanguagesListByContactId.get(con.Id).size(), 'Contact should be associated with two Contact Language records.');            
            System.assertEquals(frenchLanguage.Id, con.Primary_Language__c, 'Contact\'s primary language should be French.');            

            for (Contact_Language__c conLang : contactLanguagesListByContactId.get(con.Id)){
                if (conLang.Language__c == frenchLanguage.Id){
                    System.assertEquals(true, conLang.Primary_Language__c, 'French Contact Language record should be set as primary.');
                    System.assertEquals(UTIL_CustomSettingsFacade.getSettings().Default_Contact_Language_Fluency__c, conLang.Fluency__c, 'French Contact Language record fluency should match the default value.');
                } else {
                    System.assertEquals(englishLanguage.Id, conLang.Language__c, 'Second contact language record should correspond to the English Language.');
                    System.assertEquals(false, conLang.Primary_Language__c, 'English Contact Language record should not be set as primary.');
                }
            }
        }
    }

    /*******************************************************************************************************
    * @description Test method to verify that updating of a Contact to specify a new Primary Language 
    * does not result in the creation of a new Primary Contact Language corresponding to the new language 
    * when one already exists, and sets the existing record as primary.  Additionally, the primary status on 
    * the former contact is cleard.
    ********************************************************************************************************/
    @isTest
    private static void updateContactToIncludeExistingPrimaryLanguage(){
        Language__c englishLanguage = UTIL_UnitTestData_TEST.createLanguage('English');
        Language__c frenchLanguage = UTIL_UnitTestData_TEST.createLanguage('French');

        List<Contact> testContactsList = UTIL_UnitTestData_TEST.getMultipleTestContacts(5);
        List<Contact_Language__c> testExistingConLangs = new List<Contact_Language__c>();

        for (Contact con : testContactsList){
            con.Primary_Language__c = englishLanguage.Id;
        }

        insert testContactsList;

        for (Contact con : testContactsList){
            Contact_Language__c existingConLang = UTIL_UnitTestData_TEST.getContactLanguage(frenchLanguage, con, UTIL_CustomSettingsFacade.getSettings().Default_Contact_Language_Fluency__c);
            testExistingConLangs.add(existingConLang);
        }

        insert testExistingConLangs;

        for (Contact con : testContactsList){
            con.Primary_Language__c = frenchLanguage.Id;
        }

        Test.startTest();
        update testContactsList;
        Test.stopTest();

        List<Contact_Language__c> conLangAfterInsertList = [SELECT Id, 
                                                                   Primary_Language__c, 
                                                                   Fluency__c,
                                                                   Contact__c,
                                                                   Language__c
                                                            FROM Contact_Language__c
                                                            WHERE Contact__c IN :testContactsList];

        Map<Id, List<Contact_Language__c>> contactLanguagesListByContactId = CON_PrimaryLanguage_TEST.mapContactLanguagesToContact(conLangAfterInsertList);

        for (Contact con : testContactsList){
            System.assertEquals(true, contactLanguagesListByContactId.containsKey(con.Id), 'Contact should be associated with Contact Language records.');
            System.assertEquals(2, contactLanguagesListByContactId.get(con.Id).size(), 'Contact should be associated with two Contact Language records.');            
            System.assertEquals(frenchLanguage.Id, con.Primary_Language__c, 'Contact\'s primary language should be French.');            
            
            for (Contact_Language__c conLang : contactLanguagesListByContactId.get(con.Id)){
                if (conLang.Language__c == frenchLanguage.Id){
                    System.assertEquals(true, conLang.Primary_Language__c, 'French Contact Language record should be set as primary.');
                    System.assertEquals(con.Primary_Language__c, conLang.Language__c, 'Primary language on Contact should match the language specified on Contact Language record.');
                } else {
                    System.assertEquals(englishLanguage.Id, conLang.Language__c, 'Second contact language record should correspond to the English Language.');
                    System.assertEquals(false, conLang.Primary_Language__c, 'English Contact Language record should not be set as primary.');
                }
            }
        }
    }

    /*******************************************************************************************************
    * @description Test method to ensure that new contact language records are creaded with a fluency level
    * specified by the default Fluency value in EDA settings when available.
    ********************************************************************************************************/
    @isTest
    private static void setPrimaryLanguageWithDifferentFluencyValue() {
        String fluencyValue = 'Intermediate';
        UTIL_CustomSettings_API.getSettingsForTests(new Hierarchy_Settings__c(
                                                        Default_Contact_Language_Fluency__c = fluencyValue));
        
        Language__c englishLanguage = UTIL_UnitTestData_TEST.createLanguage('English');
        List<Contact> testContactsList = UTIL_UnitTestData_TEST.getMultipleTestContacts(5);

        for (Contact con : testContactsList){
            con.Primary_Language__c = englishLanguage.Id;
        }

        Test.startTest();
        insert testContactsList;
        Test.stopTest();

        List<Contact_Language__c> conLangAfterInsertList = [SELECT Id, 
                                                                   Primary_Language__c, 
                                                                   Fluency__c,
                                                                   Contact__c,
                                                                   Language__c
                                                            FROM Contact_Language__c
                                                            WHERE Contact__c IN :testContactsList];

        Map<Id, List<Contact_Language__c>> contactLanguagesListByContactId = CON_PrimaryLanguage_TEST.mapContactLanguagesToContact(conLangAfterInsertList);

        for (Contact con : testContactsList){
            System.assertEquals(true, contactLanguagesListByContactId.containsKey(con.Id), 'Contact should be associated with Contact Language records.');
            System.assertEquals(1, contactLanguagesListByContactId.get(con.Id).size(), 'Contact should be associated with two Contact Language records.');            
            System.assertEquals(englishLanguage.Id, contactLanguagesListByContactId.get(con.Id)[0].Language__c, 'Contact Language record should be associated with the English language.');
            System.assertEquals(fluencyValue, contactLanguagesListByContactId.get(con.Id)[0].Fluency__c, 'Contact Language fluency level for English should be Intermediate.');
            System.assertEquals(englishLanguage.Id, con.Primary_Language__c, 'Contact\'s primary language should be English.');            
        }
    }

    /*******************************************************************************************************
    * @description Test method to ensure that when the Primary Language is removed from a Contact, the
    * the primary setting on the corresponding contact language record is cleared. 
    ********************************************************************************************************/
    @isTest
    private static void updateContactToRemovePrimaryLanguage() {
        Language__c englishLanguage = UTIL_UnitTestData_TEST.createLanguage('English');
        List<Contact> testContactsList = UTIL_UnitTestData_TEST.getMultipleTestContacts(5);
        
        for (Contact con : testContactsList){
            con.Primary_Language__c = englishLanguage.Id;
        }

        insert testContactsList;

        for (Contact con : testContactsList){
            con.Primary_Language__c = null;
        }

        Test.startTest();
        update testContactsList;
        Test.stopTest();

        List<Contact_Language__c> conLangAfterInsertList = [SELECT Id, 
                                                                   Primary_Language__c, 
                                                                   Fluency__c,
                                                                   Contact__c,
                                                                   Language__c
                                                            FROM Contact_Language__c
                                                            WHERE Contact__c IN :testContactsList];

        Map<Id, List<Contact_Language__c>> contactLanguagesListByContactId = CON_PrimaryLanguage_TEST.mapContactLanguagesToContact(conLangAfterInsertList);

        for (Contact con : testContactsList){
            System.assertEquals(true, contactLanguagesListByContactId.containsKey(con.Id), 'Contact should be associated with Contact Language records.');
            System.assertEquals(1, contactLanguagesListByContactId.get(con.Id).size(), 'Contact should be associated with one Contact Language record.');            
            System.assertEquals(englishLanguage.Id, contactLanguagesListByContactId.get(con.Id)[0].Language__c, 'Contact Language record associated with Contact should be for the English Language.');
            System.assertEquals(null, con.Primary_Language__c, 'Contact\'s primary language should be blank.');            
            System.assertEquals(false, contactLanguagesListByContactId.get(con.Id)[0].Primary_Language__c, 'English Contact Language record should not be set as primary.');
            System.assertEquals(UTIL_CustomSettingsFacade.getSettings().Default_Contact_Language_Fluency__c, contactLanguagesListByContactId.get(con.Id)[0].Fluency__c, 'English Contact Language record fluency should match the default value.');
        }
    }

    /**************************************************************************************************************************
    ****************************************************** UNIT TESTS *********************************************************
    **************************************************************************************************************************/

    /************************************************************************************************************
    * @description Test method to verify that isUpdateRecursion returns true when only the recursion flag for
    * CON_PrimaryLanguage_TDTM is set.
    *************************************************************************************************************/ 
    @isTest 
    private static void isConPrimaryLanguageUpdateRecursionTrue(){
        TDTM_ProcessControl.setRecursionFlag(TDTM_ProcessControl.registeredTrigger.CON_PrimaryLanguage_TDTM, true);
        TDTM_ProcessControl.setRecursionFlag(TDTM_ProcessControl.registeredTrigger.CLAN_PrimaryLanguage_TDTM, false);

        CON_PrimaryLanguage_TDTM conPriLangTdtm = new CON_PrimaryLanguage_TDTM();

        Test.startTest();
        System.assertEquals(true, conPriLangTdtm.isUpdateRecursion(), 'Update recursion status should be true.');
        Test.stopTest();
    }

    /************************************************************************************************************
    * @description Test method to verify that isUpdateRecursion returns true when only the recursion flag
    * for CLAN_PrimaryLanguage_TDTM is set.
    *************************************************************************************************************/ 
    @isTest 
    private static void isCLANPrimaryLanguageUpdateRecursionTrue(){
        TDTM_ProcessControl.setRecursionFlag(TDTM_ProcessControl.registeredTrigger.CON_PrimaryLanguage_TDTM, false);
        TDTM_ProcessControl.setRecursionFlag(TDTM_ProcessControl.registeredTrigger.CLAN_PrimaryLanguage_TDTM, true);

        CON_PrimaryLanguage_TDTM conPriLangTdtm = new CON_PrimaryLanguage_TDTM();

        Test.startTest();
        System.assertEquals(true, conPriLangTdtm.isUpdateRecursion(), 'Update recursion status should be true.');
        Test.stopTest();
    }

    /************************************************************************************************************
    * @description Test method to verify that isUpdateRecursion returns true when recursion flags for both
    * CON_PrimaryLanguage_TDTM and CLAN_PrimaryLanguage_TDTM set.
    *************************************************************************************************************/ 
    @isTest 
    private static void isUpdateRecursionTrue(){
        TDTM_ProcessControl.setRecursionFlag(TDTM_ProcessControl.registeredTrigger.CON_PrimaryLanguage_TDTM, true);
        TDTM_ProcessControl.setRecursionFlag(TDTM_ProcessControl.registeredTrigger.CLAN_PrimaryLanguage_TDTM, true);

        CON_PrimaryLanguage_TDTM conPriLangTdtm = new CON_PrimaryLanguage_TDTM();

        Test.startTest();
        System.assertEquals(true, conPriLangTdtm.isUpdateRecursion(), 'Update recursion status should be true.');
        Test.stopTest();
    }

    /************************************************************************************************************
    * @description Test method to verify that isUpdateRecursion returns false when recursion flags for both
    * CON_PrimaryLanguage_TDTM and CLAN_PrimaryLanguage_TDTM are unset.
    *************************************************************************************************************/ 
    @isTest 
    private static void isUpdateRecursionFalse(){
        TDTM_ProcessControl.setRecursionFlag(TDTM_ProcessControl.registeredTrigger.CON_PrimaryLanguage_TDTM, false);
        TDTM_ProcessControl.setRecursionFlag(TDTM_ProcessControl.registeredTrigger.CLAN_PrimaryLanguage_TDTM, false);

        CON_PrimaryLanguage_TDTM conPriLangTdtm = new CON_PrimaryLanguage_TDTM();

        Test.startTest();
        System.assertEquals(false, conPriLangTdtm.isUpdateRecursion(), 'Update recursion status should be false.');
        Test.stopTest();
    }

    /************************************************************************************************************
    * @description Test method to verify that unsetUpdateRecursion properly updates the status for the 
    * CON_PrimaryLanguage_After_Update recursion flag to false.
    *************************************************************************************************************/ 
    @isTest 
    private static void unsetUpdateRecursionTrue(){
        TDTM_ProcessControl.setRecursionFlag(TDTM_ProcessControl.registeredTrigger.CON_PrimaryLanguage_TDTM, true);

        CON_PrimaryLanguage_TDTM conPriLangTdtm = new CON_PrimaryLanguage_TDTM();

        Test.startTest();
        conPriLangTdtm.unsetUpdateRecursion();
        Test.stopTest();

        System.assertEquals(false, TDTM_ProcessControl.getRecursionFlag(TDTM_ProcessControl.registeredTrigger.CON_PrimaryLanguage_TDTM), 'Update recursion flag should be cleared.');
    }

    /************************************************************************************************************
    * @description Test method to verify that unsetUpdateRecursion properly updates the status for the 
    * CON_PrimaryLanguage_After_Update recursion flag to true.
    *************************************************************************************************************/ 
    @isTest 
    private static void setUpdateRecursionTrue(){
        TDTM_ProcessControl.setRecursionFlag(TDTM_ProcessControl.registeredTrigger.CON_PrimaryLanguage_TDTM, false);

        CON_PrimaryLanguage_TDTM conPriLangTdtm = new CON_PrimaryLanguage_TDTM();

        Test.startTest();
        conPriLangTdtm.setUpdateRecursion();
        Test.stopTest();

        System.assertEquals(true, TDTM_ProcessControl.getRecursionFlag(TDTM_ProcessControl.registeredTrigger.CON_PrimaryLanguage_TDTM), 'Update recursion flag should be set.');
    }

    /************************************************************************************************************
    * @description Test method to verify that isInsertRecursion returns true when only the recursion flag for
    * CON_PrimaryLanguage_TDTM is set.
    *************************************************************************************************************/ 
    @isTest 
    private static void isCONPrimaryLanguageInsertRecursionTrue(){
        TDTM_ProcessControl.setRecursionFlag(TDTM_ProcessControl.registeredTrigger.CON_PrimaryLanguage_TDTM, true);
        TDTM_ProcessControl.setRecursionFlag(TDTM_ProcessControl.registeredTrigger.CLAN_PrimaryLanguage_TDTM, false);

        CON_PrimaryLanguage_TDTM conPriLangTdtm = new CON_PrimaryLanguage_TDTM();

        Test.startTest();
        System.assertEquals(true, conPriLangTdtm.isInsertRecursion(), 'Insert recursion status should be true.');
        Test.stopTest();
    }

    /************************************************************************************************************
    * @description Test method to verify that isInsertRecursion returns true when only the recursion flag for
    * CLAN_PrimaryLanguage_TDTM is set.
    *************************************************************************************************************/ 
    @isTest 
    private static void isCLANPrimaryLanguageInsertRecursionTrue(){
        TDTM_ProcessControl.setRecursionFlag(TDTM_ProcessControl.registeredTrigger.CON_PrimaryLanguage_TDTM, false);
        TDTM_ProcessControl.setRecursionFlag(TDTM_ProcessControl.registeredTrigger.CLAN_PrimaryLanguage_TDTM, true);

        CON_PrimaryLanguage_TDTM conPriLangTdtm = new CON_PrimaryLanguage_TDTM();

        Test.startTest();
        System.assertEquals(true, conPriLangTdtm.isInsertRecursion(), 'Insert recursion status should be true.');
        Test.stopTest();
    }

    /************************************************************************************************************
    * @description Test method to verify that isInsertRecursion returns true when recursion flags for both
    * CON_PrimaryLanguage_TDTM and CLAN_PrimaryLanguage_TDTM are set.
    *************************************************************************************************************/ 
    @isTest 
    private static void isInsertRecursionTrue(){
        TDTM_ProcessControl.setRecursionFlag(TDTM_ProcessControl.registeredTrigger.CON_PrimaryLanguage_TDTM, true);
        TDTM_ProcessControl.setRecursionFlag(TDTM_ProcessControl.registeredTrigger.CLAN_PrimaryLanguage_TDTM, true);

        CON_PrimaryLanguage_TDTM conPriLangTdtm = new CON_PrimaryLanguage_TDTM();

        Test.startTest();
        System.assertEquals(true, conPriLangTdtm.isInsertRecursion(), 'Insert recursion status should be true.');
        Test.stopTest();
    }

    /************************************************************************************************************
    * @description Test method to verify that isInsertRecursion returns false recursion flags for both
    * CON_PrimaryLanguage_TDTM and CLAN_PrimaryLanguage_TDTM are unset.
    *************************************************************************************************************/ 
    @isTest 
    private static void isInsertRecursionFalse(){
        TDTM_ProcessControl.setRecursionFlag(TDTM_ProcessControl.registeredTrigger.CON_PrimaryLanguage_TDTM, false);
        TDTM_ProcessControl.setRecursionFlag(TDTM_ProcessControl.registeredTrigger.CLAN_PrimaryLanguage_TDTM, false);

        CON_PrimaryLanguage_TDTM conPriLangTdtm = new CON_PrimaryLanguage_TDTM();

        Test.startTest();
        System.assertEquals(false, conPriLangTdtm.isInsertRecursion(), 'Insert recursion status should be false.');
        Test.stopTest();
    }

    /************************************************************************************************************
    * @description Test method to verify that unsetInsertRecursion correctly updates the status of the 
    * CON_PrimaryLanguage_TDTM recursion flag to false.
    *************************************************************************************************************/ 
    @isTest 
    private static void unsetInsertRecursionTrue(){
        TDTM_ProcessControl.setRecursionFlag(TDTM_ProcessControl.registeredTrigger.CON_PrimaryLanguage_TDTM, true);

        CON_PrimaryLanguage_TDTM conPriLangTdtm = new CON_PrimaryLanguage_TDTM();

        Test.startTest();
        conPriLangTdtm.unsetInsertRecursion();
        Test.stopTest();

        System.assertEquals(false, TDTM_ProcessControl.getRecursionFlag(TDTM_ProcessControl.registeredTrigger.CON_PrimaryLanguage_TDTM), 'Insert recursion flag should be cleared.');
    }

    /************************************************************************************************************
    * @description Test method to verify that setInsertRecursion correctly updates the status of the 
    * CON_PrimaryLanguage_TDTM recursion flag to true.
    *************************************************************************************************************/ 
    @isTest 
    private static void setInsertRecursionTrue(){
        TDTM_ProcessControl.setRecursionFlag(TDTM_ProcessControl.registeredTrigger.CON_PrimaryLanguage_TDTM, false);

        CON_PrimaryLanguage_TDTM conPriLangTdtm = new CON_PrimaryLanguage_TDTM();

        Test.startTest();
        conPriLangTdtm.setInsertRecursion();
        Test.stopTest();

        System.assertEquals(true, TDTM_ProcessControl.getRecursionFlag(TDTM_ProcessControl.registeredTrigger.CON_PrimaryLanguage_TDTM), 'Insert recursion flag should be set.');
    }

    /************************************************************************************************************
    * @description Test method to verify that the locateContactPrimaryLanguageService returns an instance of the
    * SRVC_ContactPrimaryLanguage service class.
    *************************************************************************************************************/ 
    @isTest 
    private static void getInstanceOfContactPrimaryLanguageService(){
        Test.startTest();
        CON_PrimaryLanguage_TDTM conPriLangTdtm = new CON_PrimaryLanguage_TDTM();
        SRVC_ContactPrimaryLanguage srvcConPrimaryLangInstance = conPriLangTdtm.locateContactPrimaryLanguageService();
        Test.stopTest();
        
        System.assertEquals(true, srvcConPrimaryLangInstance != null, 'Instance of service class should be retrieved.');
    }

    /************************************************************************************************************
    * @description Test method to verify that handleAfterUpdate creates new contact language records for contacts
    * updated with primary languages never previously associated.  
    *************************************************************************************************************/ 
    @isTest 
    private static void handleAfterUpdateInsertsOnly(){
        TDTM_ProcessControl.setRecursionFlag(TDTM_ProcessControl.registeredTrigger.CON_PrimaryLanguage_TDTM, false);

        List<Contact> newTestContactsList = UTIL_UnitTestData_TEST.getMultipleTestContacts(5);
        List<Contact> oldTestContactsList = new List<Contact>();
      
        Language__c englishLanguage = UTIL_UnitTestData_TEST.createLanguage('English');
        Language__c frenchLanguage = UTIL_UnitTestData_TEST.createLanguage('French');

        insert newTestContactsList;

        for (Contact con : newTestContactsList){
            con.Primary_Language__c = englishLanguage.Id;

            Contact oldContact = con.Clone(false);
            oldContact.Id = con.Id;
            oldContact.Primary_Language__c = frenchLanguage.Id;
            oldTestContactsList.add(oldContact);
        }
        
        Test.startTest();
        CON_PrimaryLanguage_TDTM conPrimaryLangTDTM = new CON_PrimaryLanguage_TDTM();
        conPrimaryLangTDTM.handleAfterUpdate((List<SObject>)newTestContactsList, (List<SObject>)oldTestContactsList);
        Test.stopTest();

        List<Contact_Language__c> conLangResultsList = [SELECT Id, 
                                                               Primary_Language__c, 
                                                               Fluency__c,
                                                               Contact__c,
                                                               Language__c
                                                        FROM Contact_Language__c
                                                        WHERE Contact__c IN :newTestContactsList
                                                        AND Language__c = :englishLanguage.Id];

        System.assertEquals(false, TDTM_ProcessControl.getRecursionFlag(TDTM_ProcessControl.registeredTrigger.CON_PrimaryLanguage_TDTM), 'Recursion flag should remain unset.');
        System.assertEquals(5, conLangResultsList.size(), 'There should be 5 new English Contact Language records created.');

        for (Contact_Language__c conLang : conLangResultsList){
            System.assertEquals(true, conLang.Primary_Language__c, 'Each new Contact Language record should be marked as primary.');
            System.assertEquals(UTIL_CustomSettingsFacade.getSettings().Default_Contact_Language_Fluency__c, conLang.Fluency__c, 'Each new contact language record should be associated with the default fluency value.');
        }        
    }

    /************************************************************************************************************
    * @description Test method to verify that handleAfterUpdate does not create new contact language records for 
    * contacts updated with primary languages previously associated and updates existing contact language record
    * to primary.  Instead, the previous contact language record is unset as primary and the existing contact 
    * language record is updated to primary.
    *************************************************************************************************************/ 
    @isTest 
    private static void handleAfterUpdateUpdatesOnly(){
        TDTM_ProcessControl.setRecursionFlag(TDTM_ProcessControl.registeredTrigger.CON_PrimaryLanguage_TDTM, false);
        
        List<Contact> newTestContactsList = UTIL_UnitTestData_TEST.getMultipleTestContacts(5);
        List<Contact> oldTestContactsList = new List<Contact>();
        List<Contact_Language__c> contactLanguagesList = new List<Contact_Language__c>();

        Language__c englishLanguage = UTIL_UnitTestData_TEST.createLanguage('English');
        Language__c frenchLanguage = UTIL_UnitTestData_TEST.createLanguage('French');

        insert newTestContactsList;

        for (Contact con : newTestContactsList){
            Contact_Language__c englishConLang = UTIL_UnitTestData_TEST.getContactLanguage(englishLanguage, con, UTIL_CustomSettingsFacade.getSettings().Default_Contact_Language_Fluency__c);
            Contact_Language__c frenchConLang = UTIL_UnitTestData_TEST.getContactLanguage(frenchLanguage, con, UTIL_CustomSettingsFacade.getSettings().Default_Contact_Language_Fluency__c);
            frenchConLang.Primary_Language__c = true;

            contactLanguagesList.add(englishConLang);
            contactLanguagesList.add(frenchConLang);

            con.Primary_Language__c = englishLanguage.Id;

            Contact oldContact = con.Clone(false);
            oldContact.Id = con.Id;
            oldContact.Primary_Language__c = frenchLanguage.Id;
            oldTestContactsList.add(oldContact);
        }
        
        insert contactLanguagesList;

        Test.startTest();
        CON_PrimaryLanguage_TDTM conPrimaryLangTDTM = new CON_PrimaryLanguage_TDTM();
        conPrimaryLangTDTM.handleAfterUpdate((List<SObject>)newTestContactsList, (List<SObject>)oldTestContactsList);
        Test.stopTest();

        List<Contact_Language__c> conLangResultsList = [SELECT Id, 
                                                               Primary_Language__c, 
                                                               Fluency__c,
                                                               Contact__c,
                                                               Language__c
                                                        FROM Contact_Language__c
                                                        WHERE Contact__c IN :newTestContactsList];

        Map<Id, List<Contact_Language__c>> contactLanguagesListByContactId = CON_PrimaryLanguage_TEST.mapContactLanguagesToContact(conLangResultsList);

        System.assertEquals(false, TDTM_ProcessControl.getRecursionFlag(TDTM_ProcessControl.registeredTrigger.CON_PrimaryLanguage_TDTM), 'Recursion flag should remain unset.');

        for (Contact con : newTestContactsList){
            List<Contact_Language__c> conLangsList = contactLanguagesListByContactId.get(con.Id);
            System.assertEquals(2, conLangsList.size(), 'There should be 2 contact languages associated with each contact (French and English).');

            for (Contact_Language__c conLang : conLangsList){
                if (conLang.Language__c == englishLanguage.Id){
                    System.assertEquals(true, conLang.Primary_Language__c, 'Existing English Contact Language record should be marked as primary.');
                } else {
                    System.assertEquals(true, (conLang.Language__c == frenchLanguage.Id && conLang.Primary_Language__c == false), 'French Contact Language record should not be marked as primary.');
                }
            } 
        }
    }

    /************************************************************************************************************
    * @description Test method to verify that handleAfterUpdate creates new contact language records for contacts
    * updated with new primary languages and updates to primary existing contact language record for contacts 
    * with matching existing contact language records.
    *************************************************************************************************************/ 
    @isTest 
    private static void handleAfterUpdateInsertsAndUpdates(){
        TDTM_ProcessControl.setRecursionFlag(TDTM_ProcessControl.registeredTrigger.CON_PrimaryLanguage_TDTM, false);

        List<Contact> newTestContactsList = UTIL_UnitTestData_TEST.getMultipleTestContacts(5);
        List<Contact> oldTestContactsList = new List<Contact>();
        List<Contact_Language__c> contactLanguagesList = new List<Contact_Language__c>();

        Language__c englishLanguage = UTIL_UnitTestData_TEST.createLanguage('English');

        insert newTestContactsList;

        for (Integer i = 0; i < 5; i++){
            if (Math.mod(i,2) == 0){
                Contact_Language__c englishConLang = UTIL_UnitTestData_TEST.getContactLanguage(englishLanguage, newTestContactsList[i], UTIL_CustomSettingsFacade.getSettings().Default_Contact_Language_Fluency__c);
                contactLanguagesList.add(englishConLang);
            }
            
            newTestContactsList[i].Primary_Language__c = englishLanguage.Id;

            Contact oldContact = newTestContactsList[i].Clone(false);
            oldContact.Id = newTestContactsList[i].Id;
            oldContact.Primary_Language__c = null;
            oldTestContactsList.add(oldContact);
        }

        insert contactLanguagesList;

        Test.startTest();
        CON_PrimaryLanguage_TDTM conPrimaryLangTDTM = new CON_PrimaryLanguage_TDTM();
        conPrimaryLangTDTM.handleAfterUpdate((List<SObject>)newTestContactsList, (List<SObject>)oldTestContactsList);
        Test.stopTest();

        List<Contact_Language__c> conLangResultsList = [SELECT Id, 
                                                               Primary_Language__c, 
                                                               Fluency__c,
                                                               Contact__c,
                                                               Language__c
                                                        FROM Contact_Language__c
                                                        WHERE Contact__c IN :newTestContactsList
                                                        AND Language__c = :englishLanguage.Id];

        System.assertEquals(false, TDTM_ProcessControl.getRecursionFlag(TDTM_ProcessControl.registeredTrigger.CON_PrimaryLanguage_TDTM), 'Recursion flag should remain unset.');
        System.assertEquals(5, conLangResultsList.size(), 'There should only be 5 English contact language records.');

        for (Contact_Language__c conLang : conLangResultsList){
            System.assertEquals(true, conLang.Primary_Language__c, 'Each English contact language record should not be marked as primary.');
        }
    }

    /************************************************************************************************************
    * @description Test method to verify that handleAfterUpdate does not create new contact language records for 
    * contacts updated with primary languages removed and ensures that the previous contact language record is
    * unset as primary.
    *************************************************************************************************************/ 
    @isTest 
    private static void handleAfterUpdateLanguageRemoved(){
        TDTM_ProcessControl.setRecursionFlag(TDTM_ProcessControl.registeredTrigger.CON_PrimaryLanguage_TDTM, false);

        List<Contact> newTestContactsList = UTIL_UnitTestData_TEST.getMultipleTestContacts(5);
        List<Contact> oldTestContactsList = new List<Contact>();
        List<Contact_Language__c> contactLanguagesList = new List<Contact_Language__c>();

        Language__c englishLanguage = UTIL_UnitTestData_TEST.createLanguage('English');

        insert newTestContactsList;

        for (Contact con : newTestContactsList){
            Contact_Language__c englishConLang = UTIL_UnitTestData_TEST.getContactLanguage(englishLanguage, con, UTIL_CustomSettingsFacade.getSettings().Default_Contact_Language_Fluency__c);
            englishConLang.Primary_Language__c = true;

            contactLanguagesList.add(englishConLang);

            con.Primary_Language__c = null;

            Contact oldContact = con.Clone(false);
            oldContact.Id = con.Id;
            oldContact.Primary_Language__c = englishLanguage.Id;
            oldTestContactsList.add(oldContact);
        }

        insert contactLanguagesList;

        Test.startTest();
        CON_PrimaryLanguage_TDTM conPrimaryLangTDTM = new CON_PrimaryLanguage_TDTM();
        conPrimaryLangTDTM.handleAfterUpdate((List<SObject>)newTestContactsList, (List<SObject>)oldTestContactsList);
        Test.stopTest();

        List<Contact_Language__c> conLangResultsList = [SELECT Id, 
                                                               Primary_Language__c, 
                                                               Fluency__c,
                                                               Contact__c,
                                                               Language__c
                                                        FROM Contact_Language__c
                                                        WHERE Contact__c IN :newTestContactsList
                                                        AND Language__c = :englishLanguage.Id];

        System.assertEquals(false, TDTM_ProcessControl.getRecursionFlag(TDTM_ProcessControl.registeredTrigger.CON_PrimaryLanguage_TDTM), 'Recursion flag should remain unset.');
        System.assertEquals(5, conLangResultsList.size(), 'There should only be 5 English contact language records.');

        for (Contact_Language__c conLang : conLangResultsList){
            System.assertEquals(false, conLang.Primary_Language__c, 'Each English contact language records should not be marked as primary.');
        }
    }

    /************************************************************************************************************
    * @description Test method to verify that handleAfterUpdate updates existing contact language records when
    * a contact is updated with a corresponding primary language.
    *************************************************************************************************************/ 
    @isTest 
    private static void runAfterUpdatePositive(){
        List<Contact> newTestContactsList = UTIL_UnitTestData_TEST.getMultipleTestContacts(5);
        List<Contact> oldTestContactsList = new List<Contact>();
        List<Contact_Language__c> contactLanguagesList = new List<Contact_Language__c>();

        Language__c englishLanguage = UTIL_UnitTestData_TEST.createLanguage('English');

        TDTM_Runnable.Action triggerAction = TDTM_Runnable.Action.AfterUpdate;
        Schema.DescribeSObjectResult objResult = Schema.SObjectType.Contact;

        insert newTestContactsList;

        for (Contact con : newTestContactsList){
            Contact_Language__c englishConLang = UTIL_UnitTestData_TEST.getContactLanguage(englishLanguage, con, UTIL_CustomSettingsFacade.getSettings().Default_Contact_Language_Fluency__c);
            contactLanguagesList.add(englishConLang);

            con.Primary_Language__c = englishLanguage.Id;

            Contact oldContact = con.Clone(false);
            oldContact.Id = con.Id;
            oldContact.Primary_Language__c = null;
            oldTestContactsList.add(oldContact);
        }

        insert contactLanguagesList;

        Test.startTest();
        CON_PrimaryLanguage_TDTM conPrimaryLangTDTM = new CON_PrimaryLanguage_TDTM();
        conPrimaryLangTDTM.run((List<SObject>)newTestContactsList, (List<SObject>)oldTestContactsList, triggerAction, objResult);
        Test.stopTest();

        List<Contact_Language__c> conLangResultsList = [SELECT Id, 
                                                               Primary_Language__c, 
                                                               Fluency__c,
                                                               Contact__c,
                                                               Language__c
                                                        FROM Contact_Language__c
                                                        WHERE Contact__c IN :newTestContactsList
                                                        AND Language__c = :englishLanguage.Id];

        System.assertEquals(5, conLangResultsList.size(), 'There should only be 5 English contact language records.');

        for (Contact_Language__c conLang : conLangResultsList){
            System.assertEquals(true, conLang.Primary_Language__c, 'Each English contact language records should be marked as primary.');
        }
    }

    /************************************************************************************************************
    * @description Test method to verify that handleAfterUpdate does not create or update any contact language 
    * when executed from a recursion context.
    *************************************************************************************************************/ 
    @isTest 
    private static void handleAfterUpdateRecursion(){
        TDTM_ProcessControl.setRecursionFlag(TDTM_ProcessControl.registeredTrigger.CON_PrimaryLanguage_TDTM, true);

        Test.startTest();
        CON_PrimaryLanguage_TDTM conPrimaryLangTDTM = new CON_PrimaryLanguage_TDTM();
        conPrimaryLangTDTM.handleAfterUpdate(new List<SObject>(), new List<SObject>());
        Test.stopTest();

        System.assertEquals(true, TDTM_ProcessControl.getRecursionFlag(TDTM_ProcessControl.registeredTrigger.CON_PrimaryLanguage_TDTM), 'Recursion flag should remain set.');
    }

    /************************************************************************************************************
    * @description Test method to verify that handleAfterInsert creates contact language records for newly 
    * inserted contact records with associated primary languages.   
    *************************************************************************************************************/ 
    @isTest 
    private static void handleAfterInsertWithPrimaryLanguage(){
        List<Contact> testContactsList = UTIL_UnitTestData_TEST.getMultipleTestContacts(5);      
        Language__c englishLanguage = UTIL_UnitTestData_TEST.createLanguage('English');

        TDTM_ProcessControl.setRecursionFlag(TDTM_ProcessControl.registeredTrigger.CON_PrimaryLanguage_TDTM, false);

        for (Contact con : testContactsList){
            con.Primary_Language__c = englishLanguage.Id;
        }

        insert testContactsList; // increases expected count for conLangResultsList by 5

        Test.startTest();
        CON_PrimaryLanguage_TDTM conPrimaryLangTDTM = new CON_PrimaryLanguage_TDTM();
        conPrimaryLangTDTM.handleAfterInsert((List<SObject>)testContactsList);
        Test.stopTest();
        
        List<Contact_Language__c> conLangResultsList = [SELECT Id,
                                                               Contact__c,
                                                               Language__c,
                                                               Primary_Language__c,
                                                               Fluency__c
                                                        FROM Contact_Language__c
                                                        WHERE Contact__c IN :testContactsList];

        System.assertEquals(5, conLangResultsList.size() - 5, 'Each contact record should be associated with 1 new contact language records.');
        System.assertEquals(false, TDTM_ProcessControl.getRecursionFlag(TDTM_ProcessControl.registeredTrigger.CON_PrimaryLanguage_TDTM), 'Recursion flag should be unset.');

        for (Contact_Language__c conLang : conLangResultsList){
            System.assertEquals(englishLanguage.Id, conLang.Language__c, 'Each new contact language record should be associated with the English language.');
            System.assertEquals(true, conLang.Primary_Language__c, 'Each new contact language record should be marked as primary.');
            System.assertEquals(UTIL_CustomSettingsFacade.getSettings().Default_Contact_Language_Fluency__c, conLang.Fluency__c, 'Each new contact language record should be associated with the default fluency value.');
        }
    }

    /************************************************************************************************************
    * @description Test method to verify that handleAfterInsert does not create contact language records for newly 
    * inserted contact records when no primary language is specified.   
    *************************************************************************************************************/ 
    @isTest 
    private static void handleAfterInsertWithoutPrimaryLanguage(){
        SRVC_ContactPrimarylanguage.instance = new STUB_HasNoContactLanguagesToCreate();

        List<Contact> testContactsList = UTIL_UnitTestData_TEST.getMultipleTestContacts(5);  
        TDTM_ProcessControl.setRecursionFlag(TDTM_ProcessControl.registeredTrigger.CON_PrimaryLanguage_TDTM, false);

        for (Contact con : testContactsList){
            con.Id = UTIL_UnitTestData_TEST.getFakeId(Contact.SObjectType);
            con.Primary_Language__c = null;
        }

        Test.startTest();
        CON_PrimaryLanguage_TDTM conPrimaryLangTDTM = new CON_PrimaryLanguage_TDTM();
        conPrimaryLangTDTM.handleAfterInsert((List<SObject>)testContactsList);
        Test.stopTest();
        
        List<Contact_Language__c> conLangResultsList = [SELECT Id,
                                                               Contact__c,
                                                               Language__c,
                                                               Primary_Language__c,
                                                               Fluency__c
                                                        FROM Contact_Language__c
                                                        WHERE Contact__c IN :testContactsList];

        System.assertEquals(true, conLangResultsList.isEmpty(), 'There should be no contact language records created for contacts inserted without a primary language.');
        System.assertEquals(false, TDTM_ProcessControl.getRecursionFlag(TDTM_ProcessControl.registeredTrigger.CON_PrimaryLanguage_TDTM), 'Recursion flag should be remain unset.');
    }

    /************************************************************************************************************
    * @description Test method to verify that handleAfterInsert does not create contact language records for newly 
    * inserted contact records when executed in a recursion context.   
    *************************************************************************************************************/ 
    @isTest 
    private static void handleAfterInsertRecursion(){
        SRVC_ContactPrimaryLanguage.instance = new STUB_HasNoContactLanguagesToCreate();

        List<Contact> testContactsList = UTIL_UnitTestData_TEST.getMultipleTestContacts(5);   
        TDTM_ProcessControl.setRecursionFlag(TDTM_ProcessControl.registeredTrigger.CON_PrimaryLanguage_TDTM, true);

        for (Contact con : testContactsList){
            con.Id = UTIL_UnitTestData_TEST.getFakeId(Contact.SObjectType);
            con.Primary_Language__c = null;
        }

        Test.startTest();
        CON_PrimaryLanguage_TDTM conPrimaryLangTDTM = new CON_PrimaryLanguage_TDTM();
        conPrimaryLangTDTM.handleAfterInsert((List<SObject>)testContactsList);
        Test.stopTest();
        
        List<Contact_Language__c> conLangResultsList = [SELECT Id,
                                                               Contact__c,
                                                               Language__c,
                                                               Primary_Language__c,
                                                               Fluency__c
                                                        FROM Contact_Language__c
                                                        WHERE Contact__c IN :testContactsList];

        System.assertEquals(true, conLangResultsList.isEmpty(), 'There should be no contact language records created for contacts inserted without a primary language.');
        System.assertEquals(true, TDTM_ProcessControl.getRecursionFlag(TDTM_ProcessControl.registeredTrigger.CON_PrimaryLanguage_TDTM), 'Recursion flag should remain set.');
    }

    /************************************************************************************************************
    * @description Test method to verify that the run method creates Contact Language records for newly inserted
    * Contacts with associated Primary Languages.
    *************************************************************************************************************/ 
    @isTest 
    private static void runAfterInsertPositive(){
        
        List<Contact> newContactsList = UTIL_UnitTestData_TEST.getMultipleTestContacts(5);
        List<SObject> oldList = new List<SObject>();

        Language__c englishLanguage = UTIL_UnitTestData_TEST.createLanguage('English');
        TDTM_Runnable.Action triggerAction = TDTM_Runnable.Action.AfterInsert;
        Schema.DescribeSObjectResult objResult = Schema.SObjectType.Contact;
        
        for (Contact con : newContactsList){
            con.Primary_Language__c = englishLanguage.Id;
        }
        
        insert newContactsList;

        Test.startTest();
        CON_PrimaryLanguage_TDTM conPrimaryLangTDTM = new CON_PrimaryLanguage_TDTM();
        conPrimaryLangTDTM.run((List<SObject>)newContactsList, oldList, triggerAction, objResult);
        Test.stopTest();

        List<Contact_Language__c> conLanguageResultsList = [SELECT Id,
                                                                   Contact__c,
                                                                   Language__c,
                                                                   Primary_Language__c,
                                                                   Fluency__c
                                                            FROM Contact_Language__c
                                                            WHERE Contact__c IN :newContactsList];

        System.assertEquals(5, conLanguageResultsList.size() - 5, 'There should 1 new contact language record created for each new contact.');

        for (Contact_Language__c conLang : conLanguageResultsList){
            System.assertEquals(englishLanguage.Id, conLang.Language__c, 'Each contact language record should be associated with the English language.');
            System.assertEquals(true, conLang.Primary_Language__c, 'Each new contact language record should be marked as primary.');
            System.assertEquals(UTIL_CustomSettingsFacade.getSettings().Default_Contact_Language_Fluency__c, conLang.Fluency__c, 'Each new contact language record should be associated with the default fluency value.');
        }
    }

    /************************************************************************************************************
    * @description Test method to verify that the run method does not create Contact Language records when no 
    * new contacts are inserted.
    *************************************************************************************************************/ 
    @isTest 
    private static void runAfterInsertNegative(){
        SRVC_ContactPrimaryLanguage.instance = new STUB_HasNoContactLanguagesToCreate();

        List<Contact> newContactsList = new List<Contact>();
        List<SObject> oldList = new List<SObject>();

        TDTM_Runnable.Action triggerAction = TDTM_Runnable.Action.AfterInsert;
        Schema.DescribeSObjectResult objResult = Schema.SObjectType.Contact;

        Test.startTest();
        CON_PrimaryLanguage_TDTM conPrimaryLangTDTM = new CON_PrimaryLanguage_TDTM();
        conPrimaryLangTDTM.run((List<SObject>)newContactsList, oldList, triggerAction, objResult);
        Test.stopTest();

        List<Contact_Language__c> conLanguageResultsList = [SELECT Id,
                                                                   Contact__c,
                                                                   Language__c,
                                                                   Primary_Language__c,
                                                                   Fluency__c
                                                            FROM Contact_Language__c
                                                            WHERE Contact__c IN :newContactsList];

        System.assertEquals(true, conLanguageResultsList.isEmpty(), 'There should no contact language records created.');
    }

    /**************************************************************************************************************************
    *************************************************** HELPER METHODS ********************************************************
    **************************************************************************************************************************/

    /************************************************************************************************************
    * @description Generates a map of containing a list of Contact Language records, sorted by their associated Contact Id.
    * @param  contactLanguagesList A List of Contact Language records to be mapped.
    * @return A Map containing a list of Contact Languages by Contact Id.
    ************************************************************************************************************/
    private static Map<Id, List<Contact_Language__c>> mapContactLanguagesToContact(List<Contact_Language__c> contactLanguagesList){
        Map<Id, List<Contact_Language__c>> contactLanguagesListByContactId = new Map<Id, List<Contact_Language__c>>();
        List<Contact_Language__c> associatedContactLanguagesList;

        for (Contact_Language__c conLang : contactLanguagesList){
            if (contactLanguagesListByContactId.containsKey(conLang.Contact__c)){
                associatedContactLanguagesList = contactLanguagesListByContactId.get(conLang.Contact__c);
            } else {
                associatedContactLanguagesList = new List<Contact_Language__c>();
            }

            associatedContactLanguagesList.add(conLang);
            contactLanguagesListByContactId.put(conLang.Contact__c, associatedContactLanguagesList);
        }
        return contactLanguagesListByContactId;
    }

    /**************************************************************************************************************************
    ****************************************************** STUBS **************************************************************
    **************************************************************************************************************************/
    
    /************************************************************************************************************
    * @description Stub class to simulate the response from SRVC_ContactPrimaryLanguage with no contact language 
    * records to be inserted.
    *************************************************************************************************************/ 
    private class STUB_HasNoContactLanguagesToCreate extends SRVC_ContactPrimaryLanguage {
        @TestVisible 
        public override List<Contact_Language__c> getContactLanguagesToCreate(List<Contact> contactsList){            
            return new List<Contact_Language__c>();
        }
    }
    
}
/*
    Copyright (c) 2015, Salesforce.org
    All rights reserved.

    Redistribution and use in source and binary forms, with or without
    modification, are permitted provided that the following conditions are met:

    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
    * Neither the name of Salesforce.org nor the names of
      its contributors may be used to endorse or promote products derived
      from this software without specific prior written permission.

    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
    "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
    LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
    FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
    COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
    INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
    BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
    LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
    CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
    LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
    ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
    POSSIBILITY OF SUCH DAMAGE.
*/
/**
 * @author Salesforce.org
 * @date 2015
 * @group Affiliations
 * @group-content ../../ApexDocContent/Affiliations.htm
 * @description Tests specific to Affiliation Management.
 */
@isTest
public with sharing class AFFL_MultiRecordType_TEST {
    private static Integer numberOfTestRecords = 5;
    //Trigger-specific recursion flags
    static final TDTM_ProcessControl.registeredTrigger BEFORE_INSERT_RECURSION = TDTM_ProcessControl.registeredTrigger.AFFL_MultiRecordType_TDTM_Before_Insert;
    static final TDTM_ProcessControl.registeredTrigger AFTER_INSERT_RECURSION = TDTM_ProcessControl.registeredTrigger.AFFL_MultiRecordType_TDTM_After_Insert;
    static final TDTM_ProcessControl.registeredTrigger AFTER_UPDATE_RECURSION = TDTM_ProcessControl.registeredTrigger.AFFL_MultiRecordType_TDTM_After_Update;

    //Special recursion flags
    static final TDTM_ProcessControl.registeredTrigger AFFILIATION_MADE_PRIMARY_RECURSION = TDTM_ProcessControl.registeredTrigger.AFFL_MultiRecordType_TDTM_afflMadePrimary;

    //Cross-trigger recursion flags. Potential antipattern.
    //NOTE: Evaluate if we can improve this
    static final TDTM_ProcessControl.registeredTrigger CONTACT_PRIMARY_AFFILIATION_UPDATED_RECURSION = TDTM_ProcessControl.registeredTrigger.CON_PrimaryAffls_TDTM_keyAfflLookupUpdated;

    /**************************************************************************
     * INTEGRATION TESTS
     **************************************************************************/
    private static void createPrimaryAffl() {
        List<AffiliationTestSetupFactory_TEST.AffiliationMappingWrapper> affiliationMappingWrapperList = AffiliationTestSetupFactory_TEST.setupMappingsByNameAndLabel(
            false
        );
        String bizOrgAcctName = affiliationMappingWrapperList[1].getAccountRecordTypeName();

        Contact contact = new Contact(FirstName = 'Test', LastName = 'Testerson');
        insert contact;

        //Verify default household account has been created for the contact
        contact = [SELECT Account.ID, Primary_Household__c FROM Contact WHERE ID = :Contact.ID];
        System.assertNotEquals(null, contact.Account.ID);
        System.assertEquals(null, contact.Primary_Household__c);
        //Manually create an Affiliation to the household, since we are not automatically doing so any more
        AFFL_ContactAccChange_TEST.resetAfflFlags();
        insert new Affiliation__c(Contact__c = contact.ID, Account__c = contact.Account.ID, Primary__c = true);

        //Verify the primary household field was populated
        contact = [SELECT Account.ID, Primary_Household__c FROM Contact WHERE ID = :Contact.ID];
        System.assertNotEquals(null, contact.Primary_Household__c);

        //Create account of Business Organization record type
        Account bizOrg1 = new Account(Name = 'Acme', RecordTypeId = UTIL_Describe.getBizAccRecTypeID());
        insert bizOrg1;

        //Create another key affiliation, this time to a biz org
        Affiliation__c bizAffl1 = new Affiliation__c(
            Contact__c = contact.ID,
            Account__c = bizOrg1.ID,
            Primary__c = true
        );
        AFFL_ContactAccChange_TEST.resetAfflFlags();
        Test.startTest();
        insert bizAffl1;
        Test.stopTest();

        //The business organization lookup should point to the account that is part of the affiliation we created
        bizAffl1 = [SELECT Affiliation_Type__c FROM Affiliation__c WHERE Account__c = :bizOrg1.ID];
        System.assertEquals(bizOrgAcctName, bizAffl1.Affiliation_Type__c);

        contact = [SELECT Primary_Organization__c FROM Contact WHERE ID = :contact.ID];
        System.assertEquals(bizOrg1.ID, Contact.Primary_Organization__c);

        //Create second account of the same record type
        Account bizOrg2 = new Account(Name = 'Toys Inc', RecordTypeId = UTIL_Describe.getBizAccRecTypeID());
        insert bizOrg2;

        //Create second primary affiliation
        Affiliation__c bizAffl2 = new Affiliation__c(
            Contact__c = contact.ID,
            Account__c = bizOrg2.ID,
            Primary__c = true
        );
        AFFL_ContactAccChange_TEST.resetAfflFlags();
        insert bizAffl2;

        //The previous affiliation should not be the primary any more
        bizAffl1 = [SELECT Primary__c FROM Affiliation__c WHERE ID = :bizAffl1.ID];
        System.assertEquals(false, bizAffl1.Primary__c);

        //The business organization lookup should point to the account that is part of the second affiliation we created
        contact = [SELECT Primary_Organization__c FROM Contact WHERE ID = :contact.ID];
        System.assertEquals(bizOrg2.ID, Contact.Primary_Organization__c);

        //  Test addition of a new affiliation with the same Account doesn't erase the Primary field on Contact

        // Insert another primary Affiliaiton on the Contact with same Account
        Affiliation__c bizAffl3 = new Affiliation__c(
            Contact__c = contact.Id,
            Account__c = bizOrg2.ID,
            Primary__c = true
        );
        insert bizAffl3;

        // Verify Primary Buisness Organization on the Contact is not erased
        Contact updatedContact = [SELECT Id, Primary_Organization__c FROM Contact WHERE Id = :contact.Id];
        System.assertEquals(bizOrg2.ID, updatedContact.Primary_Organization__c);
    }

    @isTest
    private static void noDuplicateAffl() {
        AffiliationTestSetupFactory_TEST.setupMappingsByNameAndLabel(false);

        Contact contact = new Contact(FirstName = 'Test', LastName = 'Testerson');
        insert contact;

        //Create account of Business Organization record type
        Account bizOrg1 = new Account(Name = 'Acme', RecordTypeId = UTIL_Describe.getBizAccRecTypeID());
        insert bizOrg1;

        //Create primary affiliation
        Affiliation__c bizAffl1 = new Affiliation__c(
            Contact__c = contact.ID,
            Account__c = bizOrg1.ID,
            Primary__c = true
        );
        Test.startTest();
        AFFL_ContactAccChange_TEST.resetAfflFlags();
        insert bizAffl1;
        Test.stopTest();

        //Verify only one Affiliation record to the business account exists. Github #159.
        List<Affiliation__c> affls = [
            SELECT ID
            FROM Affiliation__c
            WHERE Contact__c = :contact.ID AND Account__c = :bizOrg1.ID
        ];
        System.assertEquals(1, affls.size());
    }

    @isTest
    private static void deletePrimaryAffl() {
        AffiliationTestSetupFactory_TEST.setupMappingsByNameAndLabel(false);

        Contact contact = new Contact(FirstName = 'Test', LastName = 'Testerson');
        insert contact;

        //Verify default household account has been created for the contact
        contact = [SELECT Account.ID, Primary_Household__c FROM Contact WHERE ID = :Contact.ID];
        System.assertNotEquals(null, contact.Account.ID);
        System.assertEquals(null, contact.Primary_Household__c);

        //Manually create an Affiliation to the household, since we are not automatically doing so any more.
        insert new Affiliation__c(Contact__c = contact.ID, Account__c = contact.Account.ID, Primary__c = true);

        //Verify the primary household field was populated
        contact = [SELECT Account.ID, Primary_Household__c FROM Contact WHERE ID = :Contact.ID];
        System.assertNotEquals(null, contact.Primary_Household__c);

        //Craete account of Business Organization record type
        Account acc1 = new Account(Name = 'Acme', RecordTypeId = UTIL_Describe.getBizAccRecTypeID());
        insert acc1;

        //Create primary Business affiliation
        Affiliation__c affl1 = new Affiliation__c(Contact__c = contact.ID, Account__c = acc1.ID, Primary__c = true);
        Test.startTest();
        AFFL_ContactAccChange_TEST.resetAfflFlags();
        insert affl1;
        Test.stopTest();

        //Verify Primary Organization lookup field points to the account we just created
        contact = [SELECT Primary_Organization__c FROM Contact WHERE ID = :contact.ID];
        System.assertEquals(acc1.ID, Contact.Primary_Organization__c);

        //Delete Business affiliation
        AFFL_ContactAccChange_TEST.resetAfflFlags();
        delete affl1;

        //Verify Primary Organization lookup field has been cleared
        contact = [SELECT Primary_Organization__c FROM Contact WHERE ID = :contact.ID];
        System.assertEquals(null, Contact.Primary_Organization__c);
    }

    @isTest
    private static void makePrimaryAfflNonPrimary() {
        AffiliationTestSetupFactory_TEST.setupMappingsByNameAndLabel(false);

        Contact contact = new Contact(FirstName = 'Test', LastName = 'Testerson');
        insert contact;

        //Verify default household account has been created for the contact
        contact = [SELECT Account.ID, Primary_Household__c FROM Contact WHERE ID = :Contact.ID];
        System.assertNotEquals(null, contact.Account.ID);
        ID parentAccountId = contact.Account.ID;
        System.assertEquals(null, contact.Primary_Household__c);

        //Manually create an Affiliation to the household, since we are not automatically doing so any more.
        Affiliation__c affl = new Affiliation__c(
            Contact__c = contact.ID,
            Account__c = contact.Account.ID,
            Primary__c = true
        );
        AFFL_ContactAccChange_TEST.resetAfflFlags();
        insert affl;

        //Verify the primary household field was populated
        contact = [SELECT Account.ID, Primary_Household__c FROM Contact WHERE ID = :Contact.ID];
        System.assertNotEquals(null, contact.Primary_Household__c);

        //Make the affiliation not primary
        affl.Primary__c = false;
        Test.startTest();
        AFFL_ContactAccChange_TEST.resetAfflFlags();
        update affl;
        Test.stopTest();

        //Verify Primary_Household__c field has been cleared
        contact = [SELECT Account.ID, Primary_Household__c FROM Contact WHERE ID = :Contact.ID];
        System.assertEquals(null, contact.Primary_Household__c);

        //Verify the contact is still the child of the same account
        System.assertEquals(parentAccountId, contact.Account.ID);
    }

    @isTest
    private static void updatePrimaryAffiliationRecordType_FieldNames() {
        AffiliationTestSetupFactory_TEST.setupMappingsByNameAndLabel(false);
        Test.startTest();
        updatePrimaryAfflAccountRecordType();
        Test.stopTest();
    }

    /*
     * Ensure account record type changes are appropriated reflected upon contact fields/affiliations.
     * Test Scenario: T-3938997
     */
    private static void updatePrimaryAfflAccountRecordType() {
        Contact contact = new Contact(FirstName = 'Test', LastName = 'Testerson');
        insert contact;

        Account affiliatedBizAcct = new Account(Name = 'Acme', RecordTypeId = UTIL_Describe.getBizAccRecTypeID());
        Account affiliatedHHAcct = new Account(Name = 'Acme', RecordTypeId = UTIL_Describe.getHhAccRecTypeID());
        insert new List<Account>{ affiliatedBizAcct, affiliatedHHAcct };

        contact.Primary_Organization__c = affiliatedBizAcct.Id;
        contact.Primary_Household__c = affiliatedHHAcct.Id;
        update contact;

        affiliatedHHAcct.RecordTypeId = UTIL_Describe.getBizAccRecTypeID();
        update affiliatedHHAcct;

        contact = [SELECT Id, Primary_Household__c, Primary_Organization__c FROM Contact WHERE Id = :contact.Id];
        System.assertEquals(affiliatedHHAcct.Id, contact.Primary_Organization__c);
        System.assertEquals(null, contact.Primary_Household__c);

        Affiliation__c initialBizAffl = [
            SELECT Id, Primary__c, Affiliation_Type__c
            FROM Affiliation__c
            WHERE Contact__c = :contact.Id AND Account__c = :affiliatedBizAcct.Id
        ];

        Affiliation__c finalBizAffl = [
            SELECT Id, Primary__c, Affiliation_Type__c
            FROM Affiliation__c
            WHERE Contact__c = :contact.Id AND Account__c = :affiliatedHHAcct.Id
        ];

        System.assertEquals('Business Organization', initialBizAffl.Affiliation_Type__c);
        System.assertEquals('Business Organization', finalBizAffl.Affiliation_Type__c);
        System.assertEquals(false, initialBizAffl.Primary__c);
        System.assertEquals(true, finalBizAffl.Primary__c);
    }

    @isTest
    private static void makeNonPrimaryAfflPrimary() {
        AffiliationTestSetupFactory_TEST.setupMappingsByNameAndLabel(false);

        Contact contact = new Contact(FirstName = 'Test', LastName = 'Testerson');
        insert contact;

        //Create account of Business Organization record type
        Account acc1 = new Account(Name = 'Acme', RecordTypeId = UTIL_Describe.getBizAccRecTypeID());
        insert acc1;

        //Create non-primary Business affiliation
        Affiliation__c affl1 = new Affiliation__c(Contact__c = contact.ID, Account__c = acc1.ID, Primary__c = false);
        AFFL_ContactAccChange_TEST.resetAfflFlags();
        insert affl1;

        //Verify Primary Organization lookup field is blank
        contact = [SELECT Primary_Organization__c FROM Contact WHERE ID = :contact.ID];
        System.assertEquals(null, Contact.Primary_Organization__c);

        //Make the business affiliation primary
        affl1.Primary__c = true;
        AFFL_ContactAccChange_TEST.resetAfflFlags();
        Test.startTest();
        update affl1;
        Test.stopTest();

        //Verify key affl field has been populated
        contact = [SELECT Primary_Organization__c FROM Contact WHERE ID = :contact.ID];
        System.assertEquals(acc1.ID, Contact.Primary_Organization__c);

        //No other affiliation should have been created (bug W-008631)
        List<Affiliation__c> affls = [SELECT ID FROM Affiliation__c WHERE Contact__c = :contact.ID];
        System.assertEquals(1, affls.size());
    }

    @isTest
    private static void makeNonPrimaryAfflPrimaryWhenAnotherPrimaryExists() {
        AffiliationTestSetupFactory_TEST.setupMappingsByNameAndLabel(false);

        Contact contact = new Contact(FirstName = 'Test', LastName = 'Testerson');
        insert contact;

        //Create 2 accounts of Business Organization record type
        Account acc1 = new Account(Name = 'Acme1', RecordTypeId = UTIL_Describe.getBizAccRecTypeID());
        Account acc2 = new Account(Name = 'Acme2', RecordTypeId = UTIL_Describe.getBizAccRecTypeID());
        insert new List<Account>{ acc1, acc2 };

        //Create primary Business affiliation
        Affiliation__c affl1 = new Affiliation__c(Contact__c = contact.ID, Account__c = acc1.ID, Primary__c = true);
        AFFL_ContactAccChange_TEST.resetAfflFlags();
        insert affl1;

        //Verify key affl field has been populated
        contact = [SELECT Primary_Organization__c FROM Contact WHERE ID = :contact.ID];
        System.assertEquals(acc1.ID, Contact.Primary_Organization__c);

        //Create non-primary Business affiliation
        Affiliation__c affl2 = new Affiliation__c(Contact__c = contact.ID, Account__c = acc2.ID, Primary__c = false);
        AFFL_ContactAccChange_TEST.resetAfflFlags();
        insert affl2;

        //Made the second business affiliation primary
        affl2.Primary__c = true;
        AFFL_ContactAccChange_TEST.resetAfflFlags();
        Test.startTest();
        update affl2;
        Test.stopTest();

        //The second affiliation should be the only primary so order by Primary ASC
        //to ensure we recieve the Primary = True as the second record. Verify
        //its affiliiation with acc2.
        List<Affiliation__c> affls = [
            SELECT Account__c, Primary__c
            FROM Affiliation__c
            WHERE Contact__c = :contact.ID
            ORDER BY Primary__c ASC
        ];
        System.assertEquals(affls[0].Account__c, acc1.ID);
        System.assertEquals(affls[0].Primary__c, false);
        System.assertEquals(affls[1].Account__c, acc2.ID);
        System.assertEquals(affls[1].Primary__c, true);

        //Verify key affl field has been updated
        contact = [SELECT Primary_Organization__c FROM Contact WHERE ID = :contact.ID];
        System.assertEquals(acc2.ID, Contact.Primary_Organization__c);
    }

    /* Ensure additional affiliations created render previous affiliations as non-primary.
     *  Test Scenario: T-3938989
     */
    @isTest
    private static void createPrimaryAfflWhenAnotherPrimaryExists() {
        AffiliationTestSetupFactory_TEST.setupMappingsByNameAndLabel(false);

        Contact contact = new Contact(FirstName = 'Test', LastName = 'Testerson');
        insert contact;

        //Create 2 accounts of Business Organization record type
        Account primaryAcct = new Account(Name = 'Acme1', RecordTypeId = UTIL_Describe.getBizAccRecTypeID());
        Account secondaryAcct = new Account(Name = 'Acme2', RecordTypeId = UTIL_Describe.getBizAccRecTypeID());
        insert new List<Account>{ primaryAcct, secondaryAcct };

        //Create primary Business affiliation
        Affiliation__c primaryAffiliation = new Affiliation__c(
            Contact__c = contact.ID,
            Account__c = primaryAcct.ID,
            Primary__c = true
        );
        AFFL_ContactAccChange_TEST.resetAfflFlags();
        insert primaryAffiliation;

        primaryAffiliation = [SELECT Id, Account__c, Primary__c FROM Affiliation__c WHERE Id = :primaryAffiliation.Id];
        System.assertEquals(true, primaryAffiliation.Primary__c);

        //Create second primary Business affiliation
        Affiliation__c secondaryAffiliation = new Affiliation__c(
            Contact__c = contact.ID,
            Account__c = secondaryAcct.ID,
            Primary__c = true
        );
        AFFL_ContactAccChange_TEST.resetAfflFlags();
        Test.startTest();
        insert secondaryAffiliation;
        Test.stopTest();

        Map<ID, Affiliation__c> allAffiliations = new Map<ID, Affiliation__c>(
            [SELECT Id, Account__c, Primary__c FROM Affiliation__c]
        );

        System.assertNotEquals(null, allAffiliations.get(primaryAffiliation.Id));
        System.assertEquals(false, allAffiliations.get(primaryAffiliation.Id).Primary__c);
        System.assertNotEquals(null, allAffiliations.get(secondaryAffiliation.Id));
        System.assertEquals(true, allAffiliations.get(secondaryAffiliation.Id).Primary__c);
    }

    @isTest
    private static void autoCreateProgramEnrollment() {
        List<AffiliationTestSetupFactory_TEST.AffiliationMappingWrapper> affiliationMappingWrapperList = AffiliationTestSetupFactory_TEST.setupMappingsByNameAndLabel(
            false
        );

        AffiliationTestSetupFactory_TEST.AffiliationMappingWrapper bizOrgMappingWrapper = affiliationMappingWrapperList[1];
        String bizOrgRecordTypeName = bizOrgMappingWrapper.getAccountRecordTypeName();

        //Turn on Academic Record auto-creation for Business Organization mapping, which we are using as an arbitrary record type for testing.
        Affl_Mappings__c bizOrgMapping = bizOrgMappingWrapper.getAffiliationMapping();
        bizOrgMapping.Auto_Program_Enrollment__c = true;
        bizOrgMapping.Auto_Program_Enrollment_Role__c = AffiliationTestSetupFactory_TEST.PROG_ENROLL_ROLE_STUDENT;
        bizOrgMapping.Auto_Program_Enrollment_Status__c = AffiliationTestSetupFactory_TEST.PROG_ENROLL_STATUS_CURRENT;
        update bizOrgMapping;

        Contact contact = new Contact(FirstName = 'Test', LastName = 'Testerson');
        insert contact;

        //Craete account of Business Organization record type
        Account acc = new Account(Name = 'Acme', RecordTypeId = UTIL_Describe.getBizAccRecTypeID());
        insert acc;

        //Create Business affiliation
        Affiliation__c affl = new Affiliation__c(
            Contact__c = contact.ID,
            Account__c = acc.ID,
            Role__c = AffiliationTestSetupFactory_TEST.PROG_ENROLL_ROLE_STUDENT,
            Status__c = AffiliationTestSetupFactory_TEST.PROG_ENROLL_STATUS_CURRENT
        );

        Test.startTest();
        AFFL_ContactAccChange_TEST.resetAfflFlags();
        insert affl;
        Test.stopTest();
        //Verify Progran Enrollment record has been created
        List<Program_Enrollment__c> programEnrollments = [
            SELECT ID, Contact__c
            FROM Program_Enrollment__c
            WHERE Affiliation__c = :affl.ID
        ];
        System.assertEquals(1, programEnrollments.size());
        System.assertEquals(contact.ID, programEnrollments[0].Contact__c);
    }

    @isTest
    private static void autoCreateProgramEnrollmentDifferentRole() {
        List<AffiliationTestSetupFactory_TEST.AffiliationMappingWrapper> affiliationMappingWrapperList = AffiliationTestSetupFactory_TEST.setupMappingsByNameAndLabel(
            false
        );

        AffiliationTestSetupFactory_TEST.AffiliationMappingWrapper bizOrgMappingWrapper = affiliationMappingWrapperList[1];
        String bizOrgRecordTypeName = bizOrgMappingWrapper.getAccountRecordTypeName();

        //Turn on Academic Record auto-creation for Business Organization mapping, which we are using as an arbitrary record type for testing.
        Affl_Mappings__c bizOrgMapping = bizOrgMappingWrapper.getAffiliationMapping();
        bizOrgMapping.Auto_Program_Enrollment__c = true;
        bizOrgMapping.Auto_Program_Enrollment_Role__c = AffiliationTestSetupFactory_TEST.PROG_ENROLL_ROLE_STUDENT;
        bizOrgMapping.Auto_Program_Enrollment_Status__c = AffiliationTestSetupFactory_TEST.PROG_ENROLL_STATUS_CURRENT;
        update bizOrgMapping;

        Contact contact = new Contact(FirstName = 'Test', LastName = 'Testerson');
        insert contact;

        //Craete account of Business Organization record type
        Account acc = new Account(Name = 'Acme', RecordTypeId = UTIL_Describe.getBizAccRecTypeID());
        insert acc;

        //Create Business affiliation
        Affiliation__c affl = new Affiliation__c(
            Contact__c = contact.ID,
            Account__c = acc.ID,
            Role__c = 'Teacher',
            Status__c = AffiliationTestSetupFactory_TEST.PROG_ENROLL_STATUS_CURRENT
        );

        Test.startTest();
        AFFL_ContactAccChange_TEST.resetAfflFlags();
        insert affl;
        Test.stopTest();

        //Verify Program Enrollment record has not been created
        List<Program_Enrollment__c> programEnrollments = [
            SELECT ID, Contact__c
            FROM Program_Enrollment__c
            WHERE Affiliation__c = :affl.ID
        ];
        System.assertEquals(0, programEnrollments.size());
    }

    /*********************************************************************************************************
     * @description
     * This method ensures there is no NPE when a primay affiliation
     * with no contact is deleted
     */
    @isTest
    private static void affiliationDeleteNPECheck() {
        AffiliationTestSetupFactory_TEST.setupMappingsByNameAndLabel(false);

        // Insert a business account
        Account bizAcc = UTIL_UnitTestData_API.getMultipleTestAccounts(1, UTIL_Describe.getBizAccRecTypeID())[0];
        insert bizAcc;

        // Insert a contact
        Contact contact = UTIL_UnitTestData_API.getContact();
        insert contact;

        //Insert a primary affiliation
        Affiliation__c affl = new Affiliation__c(Contact__c = contact.Id, Account__c = bizAcc.Id, Primary__c = true);
        insert affl;

        //Verify 1 affiliation is created
        List<Affiliation__c> affiliationList = [
            SELECT Id, Name, Contact__c, Primary__c
            FROM Affiliation__c
            WHERE Contact__c = :contact.Id AND Account__c = :bizAcc.Id
        ];

        System.assertEquals(1, affiliationList.size());
        System.assertEquals(true, affiliationList[0].Primary__c);

        // Clear the value of contact on affiliation
        affiliationList[0].Contact__c = null;
        update affiliationList;

        // delete affiliation
        Test.startTest();

        delete affiliationList;

        Test.stopTest();

        //Verify affiliation is deleted and no NPE
        List<Affiliation__c> allAffiliationList = [
            SELECT Id, Name, Primary__c
            FROM Affiliation__c
            WHERE Contact__c = :contact.Id AND Account__c = :bizAcc.Id
        ];

        System.assertEquals(0, allAffiliationList.size());
    }

    /*********************************************************************************************************
     * @description
     * This method ensures concurrent updates to multiple affiliation records as Primary populates correct
     * Primary fields on related Contact
     */
    @isTest
    private static void multipleAffiliationUpdates() {
        AffiliationTestSetupFactory_TEST.setupMappingsByNameAndLabel(false);

        // Insert Accounts
        Account bizAcc1 = UTIL_UnitTestData_API.getMultipleTestAccounts(1, UTIL_Describe.getBizAccRecTypeID())[0];
        Account bizAcc2 = UTIL_UnitTestData_API.getMultipleTestAccounts(1, UTIL_Describe.getBizAccRecTypeID())[0];
        Account hhAcc1 = UTIL_UnitTestData_API.getMultipleTestAccounts(1, UTIL_Describe.getCustomHHAccRecTypeID())[0];
        Account hhAcc2 = UTIL_UnitTestData_API.getMultipleTestAccounts(1, UTIL_Describe.getCustomHHAccRecTypeID())[0];

        insert new List<Account>{ bizAcc1, bizAcc2, hhAcc1, hhAcc2 };

        // Insert a Contact
        Contact contact1 = UTIL_UnitTestData_API.getContact();
        Contact contact2 = UTIL_UnitTestData_API.getContact();
        insert new List<Contact>{ contact1, contact2 };

        //Insert primary and non-primary Affiliations
        Affiliation__c affl1 = UTIL_UnitTestData_TEST.getAffiliation(contact1.Id, bizAcc1.Id, true);
        Affiliation__c affl2 = UTIL_UnitTestData_TEST.getAffiliation(contact1.Id, bizAcc2.Id, false);
        Affiliation__c affl3 = UTIL_UnitTestData_TEST.getAffiliation(contact1.Id, hhAcc1.Id, true);
        Affiliation__c affl4 = UTIL_UnitTestData_TEST.getAffiliation(contact1.Id, hhAcc2.Id, false);

        Affiliation__c affl5 = UTIL_UnitTestData_TEST.getAffiliation(contact2.Id, bizAcc1.Id, true);
        Affiliation__c affl6 = UTIL_UnitTestData_TEST.getAffiliation(contact2.Id, bizAcc2.Id, false);
        Affiliation__c affl7 = UTIL_UnitTestData_TEST.getAffiliation(contact2.Id, hhAcc1.Id, true);
        Affiliation__c affl8 = UTIL_UnitTestData_TEST.getAffiliation(contact2.Id, hhAcc2.Id, false);

        insert new List<Affiliation__c>{ affl1, affl2, affl3, affl4, affl5, affl6, affl7, affl8 };

        for (Contact eachCon : [SELECT Id, Primary_Organization__c, Primary_Household__c FROM Contact]) {
            // Ensure Primary fields on Contact are populated
            System.assertEquals(eachCon.Primary_Organization__c, bizAcc1.Id);
            System.assertEquals(eachCon.Primary_Household__c, hhAcc1.Id);
        }

        // Make non-primary Affliations as primary
        List<Affiliation__c> afflList = new List<Affiliation__c>();
        for (Affiliation__c eachAffl : [SELECT Id, Primary__c FROM Affiliation__c WHERE Primary__c = FALSE]) {
            eachAffl.Primary__c = true;
            afflList.add(eachAffl);
        }

        Test.startTest();
        if (afflList.size() > 0) {
            update afflList;
        }
        Test.stopTest();

        for (contact conAfterUpdate : [SELECT Id, Primary_Organization__c, Primary_Household__c FROM Contact]) {
            // Ensure Primary fields on Contact are populated with new Accounts
            System.assertEquals(conAfterUpdate.Primary_Organization__c, bizAcc2.Id);
            System.assertEquals(conAfterUpdate.Primary_Household__c, hhAcc2.Id);
        }
        // Ensure old Affliations are made non-primary
        for (Affiliation__c eachAffl : [
            SELECT Id, Primary__c
            FROM Affiliation__c
            WHERE
                (Contact__c = :contact1.Id
                OR Contact__c = :contact2.Id)
                AND (Account__c = :bizAcc1.Id
                OR Account__c = :hhAcc1.Id)
        ]) {
            System.assertEquals(eachAffl.Primary__c, false);
        }
    }

    /*********************************************************************************************************
     * @description
     * This bulk test method ensures Multiple affiliations to the same Business Organization don't
     * prevent Primary fields on Contacts from updating
     */
    @isTest
    private static void bulkAffiliationUpdates() {
        AffiliationTestSetupFactory_TEST.setupMappingsByNameAndLabel(false);

        List<Account> accList = new List<Account>();

        // Insert a Business Account
        Account bizAcc = UTIL_UnitTestData_API.getMultipleTestAccounts(1, UTIL_Describe.getBizAccRecTypeID())[0];
        accList.add(bizAcc);

        // Insert a Household Account
        Account hhAcc = UTIL_UnitTestData_API.getMultipleTestAccounts(1, UTIL_Describe.getCustomHHAccRecTypeID())[0];
        accList.add(hhAcc);

        // Insert multiple contacts
        List<Contact> conList = UTIL_UnitTestData_Test.getMultipleTestContacts(3);
        insert conList;

        // Insert 3 Primay Business Affiliations
        List<Affiliation__c> afflList = new List<Affiliation__c>();
        for (Contact each : conList) {
            Affiliation__c affl = UTIL_UnitTestData_TEST.getAffiliation(each.Id, bizAcc.Id, true);
            afflList.add(affl);
        }
        insert afflList;

        // Verify Primary Buisness Organization is populated on the Contact
        for (Contact eachContact : [SELECT Id, Primary_Organization__c FROM Contact]) {
            System.assertEquals(bizAcc.Id, eachContact.Primary_Organization__c);
        }

        // Insert a contact
        Contact contact2 = UTIL_UnitTestData_API.getContact();
        insert contact2;

        // Insert 1 non-primary business affiliation and 1 primary household affiliation
        List<Affiliation__c> newAfflList = new List<Affiliation__c>();
        Affiliation__c afflBizAcc = UTIL_UnitTestData_TEST.getAffiliation(contact2.Id, bizAcc.Id, false);
        Affiliation__c afflAcad = UTIL_UnitTestData_TEST.getAffiliation(contact2.Id, hhAcc.Id, true);
        newAfflList.add(afflBizAcc);
        newAfflList.add(afflAcad);
        insert newAfflList;

        // Ensure Primary Organization is NULL and household affiliation is populated
        Contact con = [SELECT Id, Primary_Organization__c, Primary_Household__c FROM Contact WHERE Id = :contact2.Id];
        System.assertEquals(null, con.Primary_Organization__c);
        System.assertEquals(hhAcc.Id, con.Primary_Household__c);

        // Insert Affiliations on the Contacts with the same Account as the Primary Organization
        // Change the Primary Academic Affiliation to non-primary
        List<Affiliation__c> afflListNew = new List<Affiliation__c>();
        for (Contact each : conList) {
            Affiliation__c affl1 = UTIL_UnitTestData_TEST.getAffiliation(each.Id, bizAcc.Id, true);
            afflListNew.add(affl1);
        }
        Affiliation__c afflBiz = UTIL_UnitTestData_TEST.getAffiliation(contact2.Id, bizAcc.Id, true);
        Affiliation__c hhAffl1 = UTIL_UnitTestData_TEST.getAffiliation(contact2.Id, hhAcc.Id, true);
        Affiliation__c hhAffl2 = UTIL_UnitTestData_TEST.getAffiliation(contact2.Id, hhAcc.Id, false);
        afflListNew.add(hhAffl1);
        afflListNew.add(hhAffl2);
        afflListNew.add(afflBiz);

        test.startTest();
        upsert afflListNew;
        test.stopTest();

        // Verify Primary Buisness Organization on Contacts are not erased
        for (Contact eachContact : [SELECT Id, Primary_Organization__c FROM Contact]) {
            System.assertEquals(bizAcc.Id, eachContact.Primary_Organization__c);
        }

        // Ensure Primary Household are populated
        Contact conAfterUpdate = [SELECT Id, Primary_Household__c FROM Contact WHERE Id = :contact2.Id];
        System.assertEquals(hhAcc.Id, conAfterUpdate.Primary_Household__c);
    }

    // Test the usage of custom API field name for affiliation mapping for multi-language support
    @isTest
    private static void customFieldAPIInMappings() {
        AffiliationTestSetupFactory_TEST.setupMappingsByNameAndApiName(false);

        // Insert a business account
        Account bizAcc = UTIL_UnitTestData_API.getMultipleTestAccounts(1, UTIL_Describe.getBizAccRecTypeID())[0];
        insert bizAcc;

        // Insert a contact with business account as Primary business organization
        Contact contact = UTIL_UnitTestData_API.getContact();
        insert contact;

        Affiliation__c affl = new Affiliation__c(Contact__c = contact.Id, Account__c = bizAcc.Id, Primary__c = true);
        test.startTest();
        //Insert an affiliation
        insert affl;
        test.stopTest();

        //Verify Primary Organization is populated
        Contact updatedContact = [SELECT Id, Primary_Organization__c FROM Contact WHERE Id = :contact.Id];

        System.assertEquals(bizAcc.Id, updatedContact.Primary_Organization__c);
    }

    /* Test deletion of an Affiliation clears the Primary Affiliation field on its Contact when Affiliation Mappings
     have Label for Account Record Types and APIs for Primary Affiliation fields. */

    @isTest
    private static void testAfflDeletionWithLabelForRecTypeAndAPINameForPrimaryAfflFields() {
        AffiliationTestSetupFactory_TEST.setupMappingsByNameAndApiName(false);

        // Insert a business account
        Account bizAcc = UTIL_UnitTestData_API.getMultipleTestAccounts(1, UTIL_Describe.getBizAccRecTypeID())[0];
        insert bizAcc;

        // Insert a contact with business account as Primary business organization
        Contact contact = UTIL_UnitTestData_API.getContact();
        insert contact;

        // Insert an affiliation
        Affiliation__c affiliation = new Affiliation__c(
            Contact__c = contact.Id,
            Account__c = bizAcc.Id,
            Primary__c = true
        );
        insert affiliation;

        // Verify Primary Organization lookup field points to the account we just created
        contact = [SELECT Primary_Organization__c FROM Contact WHERE Id = :contact.Id];
        System.assertEquals(bizAcc.ID, Contact.Primary_Organization__c);

        Test.startTest();
        delete affiliation;
        Test.stopTest();

        // Verify Primary Organization lookup field has been cleared
        contact = [SELECT Primary_Organization__c FROM Contact WHERE Id = :contact.Id];
        System.assertEquals(null, Contact.Primary_Organization__c);
    }

    /* Test deletion of an Affiliation clears the Primary Affiliation field on its Contact when Affiliation Mappings
     have API names for Account Record Types and Labels for Primary Affiliation fields. */

    @isTest
    private static void testAfflDeletionWithAPIForRecTypeAndLabelForPrimaryAfflFields() {
        AffiliationTestSetupFactory_TEST.setupMappingsByDevNameAndLabel(false);

        // Insert a business account
        Account bizAcc = UTIL_UnitTestData_API.getMultipleTestAccounts(1, UTIL_Describe.getBizAccRecTypeID())[0];
        insert bizAcc;

        // Insert a contact with business account as Primary business organization
        Contact contact = UTIL_UnitTestData_API.getContact();
        insert contact;

        // Insert an affiliation
        Affiliation__c affiliation = new Affiliation__c(
            Contact__c = contact.Id,
            Account__c = bizAcc.Id,
            Primary__c = true
        );
        insert affiliation;

        // Verify Primary Organization lookup field points to the account we just created
        contact = [SELECT Primary_Organization__c FROM Contact WHERE Id = :contact.Id];
        System.assertEquals(bizAcc.ID, Contact.Primary_Organization__c);

        Test.startTest();
        delete affiliation;
        Test.stopTest();

        // Verify Primary Organization lookup field has been cleared
        contact = [SELECT Primary_Organization__c FROM Contact WHERE Id = :contact.Id];
        System.assertEquals(null, Contact.Primary_Organization__c);
    }

    /* Test deletion of an Affiliation clears the Primary Affiliation field on its Contact when Affiliation Mappings
     have API names for Account Record Types and API for Primary Affiliation fields. */

    @isTest
    private static void testAfflDeletionWithAPIForRecTypeAndAPIForPrimaryAfflFields() {
        AffiliationTestSetupFactory_TEST.setupMappingsByDevNameAndApiName(false);

        // Insert a business account
        Account bizAcc = UTIL_UnitTestData_API.getMultipleTestAccounts(1, UTIL_Describe.getBizAccRecTypeID())[0];
        insert bizAcc;

        // Insert a contact with business account as Primary business organization
        Contact contact = UTIL_UnitTestData_API.getContact();
        insert contact;

        // Insert an affiliation
        Affiliation__c affiliation = new Affiliation__c(
            Contact__c = contact.Id,
            Account__c = bizAcc.Id,
            Primary__c = true
        );
        insert affiliation;

        // Verify Primary Organization lookup field points to the account we just created
        contact = [SELECT Primary_Organization__c FROM Contact WHERE Id = :contact.Id];
        System.assertEquals(bizAcc.ID, Contact.Primary_Organization__c);

        Test.startTest();
        delete affiliation;
        Test.stopTest();

        // Verify Primary Organization lookup field has been cleared
        contact = [SELECT Primary_Organization__c FROM Contact WHERE Id = :contact.Id];
        System.assertEquals(null, Contact.Primary_Organization__c);
    }

    /* Test to ensure users can create Contacts and Affiliations when Affiliation Record Type Enforced is enabled in EDA Settings
     and Affilation Mappings have Record Type Names for Account Record Type */
    @isTest
    private static void affiliationRecordTypeEnforceWAPINamesForAccRecType() {
        AffiliationTestSetupFactory_TEST.setupMappingsByDevNameAndLabel(false);
        AffiliationTestSetupFactory_TEST.enableAffiliationRecordTypeEnforcement();

        List<Account> testAccounts = UTIL_UnitTestData_TEST.getMultipleTestAccounts(
            1,
            UTIL_Describe.getBizAccRecTypeID()
        );
        insert testAccounts;

        // Ensure Accounts are inserted
        List<Account> accountsInserted = [SELECT Id FROM Account];
        System.assert(accountsInserted.size() == 1);

        // Insert 4 Contacts
        List<Contact> contactsToBeInserted = UTIL_UnitTestData_TEST.getMultipleTestContacts(3);
        Contact testContact = UTIL_UnitTestData_TEST.getUniqueContact(1);
        testContact.Primary_Organization__c = testAccounts[0].Id;
        contactsToBeInserted.add(testContact);
        insert contactsToBeInserted;

        // Ensure 4 Contacts are inserted
        List<Contact> contactsInserted = [SELECT Id FROM Contact];
        System.assertEquals(contactsInserted.size(), 4);

        // Ensure only 1 affiliation is created for testContact
        List<Affiliation__c> affiliationsBeforeInserted = [SELECT Id, Contact__c FROM Affiliation__c];
        System.assertEquals(1, affiliationsBeforeInserted.size());
        System.assertEquals(testContact.Id, affiliationsBeforeInserted[0].Contact__c);

        // Create 1 affiliaton each for a Contact
        List<Affiliation__c> affiliationsToBeInserted = new List<Affiliation__c>();
        for (Contact each : contactsInserted) {
            Affiliation__c affl = UTIL_UnitTestData_TEST.getAffiliation(each.Id, accountsInserted[0].Id, false);
            affiliationsToBeInserted.add(affl);
        }

        Test.startTest();
        insert affiliationsToBeInserted;
        Test.stopTest();

        // Ensure 4 new Affiliations are inserted
        List<Affiliation__c> affiliationsInserted = [SELECT Id FROM Affiliation__c];
        System.assertEquals(5, affiliationsInserted.size());
    }

    /* Test to ensure users can create Contacts and Affiliations when Affiliation Record Type Enforced is enabled in EDA Settings
     and Affiliation Mappings have Record Type Labels for Account Record Type */

    @isTest
    private static void affiliationRecordTypeEnforceWLabelsForAccRecType() {
        AffiliationTestSetupFactory_TEST.setupMappingsByNameAndLabel(false);
        AffiliationTestSetupFactory_TEST.enableAffiliationRecordTypeEnforcement();

        List<Account> testAccounts = UTIL_UnitTestData_TEST.getMultipleTestAccounts(
            1,
            UTIL_Describe.getBizAccRecTypeID()
        );
        insert testAccounts;

        // Ensure Accounts are inserted
        List<Account> accountsInserted = [SELECT Id FROM Account];
        System.assert(accountsInserted.size() == 1);

        // Insert 4 Contacts
        List<Contact> contactsToBeInserted = UTIL_UnitTestData_TEST.getMultipleTestContacts(3);
        Contact testContact = UTIL_UnitTestData_TEST.getUniqueContact(1);
        testContact.Primary_Organization__c = testAccounts[0].Id;
        contactsToBeInserted.add(testContact);
        insert contactsToBeInserted;

        // Ensure 4 Contacts are inserted
        List<Contact> contactsInserted = [SELECT Id FROM Contact];
        System.assertEquals(contactsInserted.size(), 4);

        // Ensure only 1 affiliation is created for testContact
        List<Affiliation__c> affiliationsBeforeInserted = [SELECT Id, Contact__c FROM Affiliation__c];
        System.assertEquals(1, affiliationsBeforeInserted.size());
        System.assertEquals(testContact.Id, affiliationsBeforeInserted[0].Contact__c);

        // Create 1 affiliation each for a Contact
        List<Affiliation__c> affiliationsToBeInserted = new List<Affiliation__c>();

        for (Contact each : contactsInserted) {
            Affiliation__c affl = UTIL_UnitTestData_TEST.getAffiliation(each.Id, accountsInserted[0].Id, false);
            affiliationsToBeInserted.add(affl);
        }

        Test.startTest();
        insert affiliationsToBeInserted;
        Test.stopTest();

        // Ensure 4 new Affiliations are inserted
        List<Affiliation__c> affiliationsInserted = [SELECT Id FROM Affiliation__c];
        System.assertEquals(5, affiliationsInserted.size());
    }

    /* Test to ensure users can create Contacts and Affiliations when Affiliation Record Type Enforced is enabled in EDA Settings
     and Affiliation Mappings have API names for Account Record Type and primary Affiliaiton Fields */

    @isTest
    private static void affiliationRecordTypeEnforceWAPINamesForAccRecTypeAndPrimaryAffl() {
        AffiliationTestSetupFactory_TEST.setupMappingsByDevNameAndApiName(false);
        AffiliationTestSetupFactory_TEST.enableAffiliationRecordTypeEnforcement();

        List<Account> testAccounts = UTIL_UnitTestData_TEST.getMultipleTestAccounts(
            1,
            UTIL_Describe.getBizAccRecTypeID()
        );
        insert testAccounts;

        // Ensure Accounts are inserted
        List<Account> accountsInserted = [SELECT Id FROM Account];
        System.assert(accountsInserted.size() == 1);

        // Insert 4 Contacts
        List<Contact> contactsToBeInserted = UTIL_UnitTestData_TEST.getMultipleTestContacts(3);
        Contact testContact = UTIL_UnitTestData_TEST.getUniqueContact(1);
        testContact.Primary_Organization__c = testAccounts[0].Id;
        contactsToBeInserted.add(testContact);
        insert contactsToBeInserted;

        // Ensure 4 Contacts are inserted
        List<Contact> contactsInserted = [SELECT Id FROM Contact];
        System.assertEquals(contactsInserted.size(), 4);

        // Ensure only 1 affiliation is created for testContact
        List<Affiliation__c> affiliationsBeforeInserted = [SELECT Id, Contact__c FROM Affiliation__c];
        System.assertEquals(1, affiliationsBeforeInserted.size());
        System.assertEquals(testContact.Id, affiliationsBeforeInserted[0].Contact__c);

        // Create 1 affiliation each for a Contact
        List<Affiliation__c> affiliationsToBeInserted = new List<Affiliation__c>();
        for (Contact each : contactsInserted) {
            Affiliation__c affl = UTIL_UnitTestData_TEST.getAffiliation(each.Id, accountsInserted[0].Id, false);
            affiliationsToBeInserted.add(affl);
        }

        Test.startTest();
        insert affiliationsToBeInserted;
        Test.stopTest();

        // Ensure 4 new Affiliations are inserted
        List<Affiliation__c> affiliationsInserted = [SELECT Id FROM Affiliation__c];
        System.assertEquals(5, affiliationsInserted.size());
    }

    /* Test to ensure users can create Contacts and Affiliations when Affiliation Record Type Enforced is enabled in EDA Settings
     and Affiliation Mappings have Labels for Account Record Type and APIs for Primary Affiliaiton Fields */
    @isTest
    private static void affiliationRecordTypeEnforceWLabelsForAccRecTypeAndAPIForPrimaryAffl() {
        AffiliationTestSetupFactory_TEST.setupMappingsByNameAndApiName(false);
        AffiliationTestSetupFactory_TEST.enableAffiliationRecordTypeEnforcement();

        List<Account> testAccounts = UTIL_UnitTestData_TEST.getMultipleTestAccounts(
            1,
            UTIL_Describe.getBizAccRecTypeID()
        );
        insert testAccounts;

        // Ensure Accounts are inserted
        List<Account> accountsInserted = [SELECT Id FROM Account];
        System.assert(accountsInserted.size() == 1);

        // Insert 4 Contacts
        List<Contact> contactsToBeInserted = UTIL_UnitTestData_TEST.getMultipleTestContacts(3);
        Contact testContact = UTIL_UnitTestData_TEST.getUniqueContact(1);
        testContact.Primary_Organization__c = testAccounts[0].Id;
        contactsToBeInserted.add(testContact);
        insert contactsToBeInserted;

        // Ensure 4 Contacts are inserted
        List<Contact> contactsInserted = [SELECT Id FROM Contact];
        System.assertEquals(contactsInserted.size(), 4);

        // Ensure only 1 affiliation is created for testContact
        List<Affiliation__c> affiliationsBeforeInserted = [SELECT Id, Contact__c FROM Affiliation__c];
        System.assertEquals(1, affiliationsBeforeInserted.size());
        System.assertEquals(testContact.Id, affiliationsBeforeInserted[0].Contact__c);

        // Create 1 affiliation each for a Contact
        List<Affiliation__c> affiliationsToBeInserted = new List<Affiliation__c>();
        for (Contact each : contactsInserted) {
            Affiliation__c affl = UTIL_UnitTestData_TEST.getAffiliation(each.Id, accountsInserted[0].Id, false);
            affiliationsToBeInserted.add(affl);
        }

        Test.startTest();
        insert affiliationsToBeInserted;
        Test.stopTest();

        // Ensure 4 new Affiliations are inserted
        List<Affiliation__c> affiliationsInserted = [SELECT Id FROM Affiliation__c];
        System.assertEquals(5, affiliationsInserted.size());
    }

    /**************************************************************************
     * Unit TESTS
     *************************************************************************/

    /****************************************
     * handleAfterInsert
     ****************************************/

    /**
     * @description helper class for initialization of tests for handleAfterInsert
     */
    private class HandleAfterInsertValidData {
        public AFFL_MultiRecordType_TDTM tdtmClass;
        public TDTM_Runnable.DmlWrapper dmlWrapper;
        public Account accountToTest;
        public Contact contactToTest;
        public Affiliation__c affiliation;

        public HandleAfterInsertValidData() {
            this.tdtmClass = new AFFL_MultiRecordType_TDTM();
            this.dmlWrapper = new TDTM_Runnable.DmlWrapper();
            this.contactToTest = UTIL_UnitTestData_TEST.getUniqueContact(1);
            insert contactToTest;

            Id businessOrganizationRecordTypeId = UTIL_Describe.getBizAccRecTypeID();
            this.accountToTest = UTIL_UnitTestData_TEST.getMultipleTestAccounts(1, businessOrganizationRecordTypeId)[0];
            insert this.accountToTest;

            this.affiliation = new Affiliation__c(
                Id = UTIL_UnitTestData_TEST.getFakeId(Affiliation__c.SObjectType),
                Account__c = this.accountToTest.Id,
                Contact__c = this.contactToTest.Id,
                Primary__c = true
            );
        }
    }

    /**
     * @description Tests handleAfterInsert appropriately calls createProgramEnrollmentIfNecessary
     */
    private static void handleAfterInsertValid() {
        HandleAfterInsertValidData testData = new HandleAfterInsertValidData();
        AFFL_MultiRecordType_TDTM.afflMapper = new AFFL_MultiRecordTypeMapper_STUB(true);
        Formula.recalculateFormulas(new List<Affiliation__c>{ testData.affiliation });

        List<SObject> newList = new List<SObject>();
        newList.add(testData.affiliation);

        Test.startTest();
        TDTM_Runnable.DMLWrapper dmlWrapperReturned = testData.tdtmClass.handleAfterInsert(
            newList,
            testData.dmlWrapper
        );
        Test.stopTest();

        System.assertEquals(
            true,
            testData.tdtmClass.isAfterInsertRecursion(),
            'After insert recursion for should be active for AFFL_MultiRecordType_TDTM.'
        );

        System.assertEquals(
            1,
            dmlWrapperReturned.objectsToInsert.size(),
            'The DMLWrapper should contain a single program enrollment to insert.'
        );

        for (SObject sObjectRetrieved : dmlWrapperReturned.objectsToInsert) {
            Program_Enrollment__c programEnrollment = (Program_Enrollment__c) sObjectRetrieved;

            System.assertEquals(
                testData.affiliation.Account__c,
                programEnrollment.Account__c,
                'The Account of the created Program Enrollment should match the provided Affiliation\'s.'
            );
            System.assertEquals(
                testData.affiliation.Contact__c,
                programEnrollment.Contact__c,
                'The Contact of the created Program Enrollment should match the provided Affiliation\'s.'
            );
            System.assertEquals(
                testData.affiliation.Id,
                programEnrollment.Affiliation__c,
                'The Affiliation of the created Program Enrollment should be the provided Affiliation\'s.'
            );
        }
    }

    /**
     * @description Tests handleAfterInsert appropriately calls createProgramEnrollmentIfNecessary and does not create a Program Enrollment
     */
    private static void handleAfterInsertInvalid() {
        HandleAfterInsertValidData testData = new HandleAfterInsertValidData();
        AFFL_MultiRecordType_TDTM.afflMapper = new AFFL_MultiRecordTypeMapper_STUB(false);
        Formula.recalculateFormulas(new List<Affiliation__c>{ testData.affiliation });

        List<SObject> newList = new List<SObject>();
        newList.add(testData.affiliation);

        Test.startTest();
        TDTM_Runnable.DMLWrapper dmlWrapperReturned = testData.tdtmClass.handleAfterInsert(
            newList,
            testData.dmlWrapper
        );
        Test.stopTest();

        System.assertEquals(
            true,
            testData.tdtmClass.isAfterInsertRecursion(),
            'After insert recursion for should be active for AFFL_MultiRecordType_TDTM.'
        );

        System.assertEquals(true, dmlWrapperReturned.objectsToInsert.isEmpty(), 'The DMLWrapper should be empty.');
    }

    /**
     * @description Tests handleAfterInsert only sets after insert recursion on an empty new list
     */
    private static void handleAfterInsertNewListEmpty() {
        AFFL_MultiRecordType_TDTM tdtmClass = new AFFL_MultiRecordType_TDTM();
        TDTM_Runnable.DmlWrapper dmlWrapper = new TDTM_Runnable.DmlWrapper();

        List<SObject> newList = new List<SObject>();

        Test.startTest();
        TDTM_Runnable.DMLWrapper dmlWrapperReturned = tdtmClass.handleAfterInsert(newList, dmlWrapper);
        Test.stopTest();

        System.assertEquals(
            true,
            tdtmClass.isAfterInsertRecursion(),
            'After insert recursion for should be active for AFFL_MultiRecordType_TDTM.'
        );

        System.assertEquals(true, dmlWrapperReturned.objectsToInsert.isEmpty(), 'The DMLWrapper should be empty.');
    }

    /**
     * @description Tests handleAfterInsert only sets after insert recursion on a null new list
     */
    private static void handleAfterInsertNewListNull() {
        AFFL_MultiRecordType_TDTM tdtmClass = new AFFL_MultiRecordType_TDTM();
        TDTM_Runnable.DmlWrapper dmlWrapper = new TDTM_Runnable.DmlWrapper();

        List<SObject> newList = null;
        tdtmClass.setAfterInsertRecursion();

        Test.startTest();
        TDTM_Runnable.DMLWrapper dmlWrapperReturned = tdtmClass.handleAfterInsert(newList, dmlWrapper);
        Test.stopTest();

        System.assertEquals(true, dmlWrapperReturned.objectsToInsert.isEmpty(), 'The DMLWrapper should be empty.');
    }

    /**
     * @description Tests handleAfterInsert does nothing on an after insert recursion
     */
    private static void handleAfterInsertNewListAfterInsertRecursion() {
        AFFL_MultiRecordType_TDTM tdtmClass = new AFFL_MultiRecordType_TDTM();
        TDTM_Runnable.DmlWrapper dmlWrapper = new TDTM_Runnable.DmlWrapper();

        List<SObject> newList = null;

        Test.startTest();
        TDTM_Runnable.DMLWrapper dmlWrapperReturned = tdtmClass.handleAfterInsert(newList, dmlWrapper);
        Test.stopTest();

        System.assertEquals(
            false,
            tdtmClass.isAfterInsertRecursion(),
            'After insert recursion for should be inactive for AFFL_MultiRecordType_TDTM.'
        );

        System.assertEquals(true, dmlWrapperReturned.objectsToInsert.isEmpty(), 'The DMLWrapper should be empty.');
    }

    /****************************************
     * processAfflDeletedValid
     ****************************************/

    /**
     * @description helper class for initialization of tests for processAfflDeleted
     */
    private class ProcessAfflDeletedValidData {
        public AFFL_MultiRecordType_TDTM tdtmClass;
        public TDTM_Runnable.DmlWrapper dmlWrapper;
        public Id fakeAccountId;
        public String primaryAffiliationFieldAPIName;
        public Contact testContact;
        public Affiliation__c affiliation;

        public ProcessAfflDeletedValidData() {
            this.tdtmClass = new AFFL_MultiRecordType_TDTM();
            this.dmlWrapper = new TDTM_Runnable.DmlWrapper();
            this.primaryAffiliationFieldAPIName = AffiliationTestSetupFactory_TEST.getBusinessOrganizationFieldApiName();
            this.fakeAccountId = UTIL_UnitTestData_TEST.getFakeId(Account.SObjectType);

            Id fakeContactId = UTIL_UnitTestData_TEST.getFakeId(Contact.SObjectType);
            this.testContact = new Contact(Id = fakeContactId, FirstName = 'Test');
            testContact.put(this.primaryAffiliationFieldAPIName, fakeAccountId);

            this.affiliation = new Affiliation__c(
                Account__c = fakeAccountId,
                Contact__c = fakeContactId,
                Primary__c = true
            );
        }
    }

    /**
     * @description Tests processAfflDeleted appropriately clears the primary affiliation field
     */
    private static void processAfflDeletedValid() {
        ProcessAfflDeletedValidData testData = new ProcessAfflDeletedValidData();

        Test.startTest();
        Contact contactReturned = testData.tdtmClass.processAfflDeleted(
            testData.affiliation,
            testData.testContact,
            testData.primaryAffiliationFieldAPIName,
            testData.dmlWrapper
        );
        Test.stopTest();

        System.assertEquals(
            null,
            contactReturned.get(testData.primaryAffiliationFieldAPIName),
            'Contact Primary Affiliation Field api name should be set to null on deletion.'
        );
        System.assertEquals(
            true,
            testData.dmlWrapper.objectsToUpdate.contains(contactReturned),
            'The Contact should be added to the DMLWrapper.'
        );
    }

    /**
     * @description Tests processAfflDeleted does not run on recursion
     */
    private static void processAfflDeletedRecursion() {
        ProcessAfflDeletedValidData testData = new ProcessAfflDeletedValidData();

        TDTM_ProcessControl.setRecursionFlag(
            TDTM_ProcessControl.registeredTrigger.CON_PrimaryAffls_TDTM_keyAfflLookupUpdated,
            true
        );

        Test.startTest();
        Contact contactReturned = testData.tdtmClass.processAfflDeleted(
            testData.affiliation,
            testData.testContact,
            testData.primaryAffiliationFieldAPIName,
            testData.dmlWrapper
        );
        Test.stopTest();

        System.assertEquals(null, contactReturned, 'Method should make no changes to the Contact on recursion.');
        System.assertEquals(
            false,
            testData.dmlWrapper.objectsToUpdate.contains(contactReturned),
            'Method should make no changes to the DMLWrapper on recursion.'
        );
    }

    /**
     * @description Tests processAfflDeleted does not run for non-primary affiliations
     */
    private static void processAfflDeletedNonPrimaryAffiliation() {
        ProcessAfflDeletedValidData testData = new ProcessAfflDeletedValidData();
        testData.affiliation.Primary__c = false;

        Test.startTest();
        Contact contactReturned = testData.tdtmClass.processAfflDeleted(
            testData.affiliation,
            testData.testContact,
            testData.primaryAffiliationFieldAPIName,
            testData.dmlWrapper
        );
        Test.stopTest();

        System.assertEquals(
            null,
            contactReturned,
            'Method should make no changes to the Contact on non-primary affiliations.'
        );
        System.assertEquals(
            false,
            testData.dmlWrapper.objectsToUpdate.contains(contactReturned),
            'Method should make no changes to the DMLWrapper on non-primary affiliations.'
        );
    }

    /**
     * @description Tests processAfflDeleted does not run for contacts when a primary affiliation field is not supplied
     */
    private static void processAfflDeletedNullAffiliationField() {
        ProcessAfflDeletedValidData testData = new ProcessAfflDeletedValidData();
        testData.primaryAffiliationFieldAPIName = null;

        Test.startTest();
        Contact contactReturned = testData.tdtmClass.processAfflDeleted(
            testData.affiliation,
            testData.testContact,
            testData.primaryAffiliationFieldAPIName,
            testData.dmlWrapper
        );
        Test.stopTest();

        System.assertEquals(
            null,
            contactReturned,
            'Method should make no changes to the Contact on a null primary affiliation field.'
        );
        System.assertEquals(
            false,
            testData.dmlWrapper.objectsToUpdate.contains(contactReturned),
            'Method should make no changes to the DMLWrapper on a null primary affiliation field.'
        );
    }

    /**
     * @description Tests processAfflDeleted does not run for contacts when the contact is null
     */
    private static void processAfflDeletedNullContact() {
        ProcessAfflDeletedValidData testData = new ProcessAfflDeletedValidData();

        Test.startTest();
        Contact contactReturned = testData.tdtmClass.processAfflDeleted(
            testData.affiliation,
            null,
            testData.primaryAffiliationFieldAPIName,
            testData.dmlWrapper
        );
        Test.stopTest();

        System.assertEquals(null, contactReturned, 'Method should make no changes to the Contact on a null contact.');
        System.assertEquals(
            false,
            testData.dmlWrapper.objectsToUpdate.contains(contactReturned),
            'Method should make no changes to the DMLWrapper on a null contact.'
        );
    }

    /**
     * @description Tests processAfflDeleted does not run for contacts when the affiliation account does not match the contact account
     */
    private static void processAfflDeletedDifferentContactPrimaryAffiliationAccount() {
        ProcessAfflDeletedValidData testData = new ProcessAfflDeletedValidData();
        Id differentFakeAccountId = UTIL_UnitTestData_TEST.getFakeId(Account.SObjectType);
        testData.affiliation = new Affiliation__c(
            Account__c = differentFakeAccountId,
            Contact__c = testData.testContact.Id,
            Primary__c = true
        );

        Test.startTest();
        Contact contactReturned = testData.tdtmClass.processAfflDeleted(
            testData.affiliation,
            testData.testContact,
            testData.primaryAffiliationFieldAPIName,
            testData.dmlWrapper
        );
        Test.stopTest();

        System.assertEquals(
            null,
            contactReturned,
            'Method should make no changes to the Contact on an unmatched account.'
        );
        System.assertEquals(
            false,
            testData.dmlWrapper.objectsToUpdate.contains(contactReturned),
            'Method should make no changes to the DMLWrapper on an unmatched account.'
        );
    }

    /****************************************
     * queryAfflLookupFields
     ****************************************/

    /**
     * @description Tests queryAfflLookupFields for multiple affiliations
     */
    private static void queryAfflLookupFields() {
        AFFL_MultiRecordType_TDTM tdtmClass = new AFFL_MultiRecordType_TDTM();

        //Setup Accounts
        Id businessOrganizationRecordTypeId = UTIL_Describe.getBizAccRecTypeID();
        Id householdAccountId = UTIL_Describe.getCustomHHAccRecTypeID();

        List<Account> businessOrganizationAccounts = UTIL_UnitTestData_TEST.getMultipleTestAccounts(
            AFFL_MultiRecordType_TEST.numberOfTestRecords,
            businessOrganizationRecordTypeId
        );
        List<Account> householdAccounts = UTIL_UnitTestData_TEST.getMultipleTestAccounts(
            AFFL_MultiRecordType_TEST.numberOfTestRecords,
            householdAccountId
        );

        List<Account> accountsToInsert = new List<Account>();
        accountsToInsert.addAll(businessOrganizationAccounts);
        accountsToInsert.addAll(householdAccounts);
        //Saving time on the dml operation adds up
        insert accountsToInsert;

        //Setup Contacts
        List<Contact> contactList = UTIL_UnitTestData_TEST.getMultipleTestContacts(
            AFFL_MultiRecordType_TEST.numberOfTestRecords
        );

        for (Integer i = 0; i < AFFL_MultiRecordType_TEST.numberOfTestRecords; i++) {
            Contact contactToInsert = contactList[i];
            contactToInsert.Primary_Household__c = householdAccounts[i].Id;
            contactToInsert.Primary_Organization__c = businessOrganizationAccounts[i].Id;
        }

        insert contactList;
        Map<Id, Contact> insertedContactsByIds = new Map<Id, Contact>(contactList);

        //Mock Affiliations
        List<Affiliation__c> affiliationList = new List<Affiliation__c>();

        for (Integer i = 0; i < AFFL_MultiRecordType_TEST.numberOfTestRecords; i++) {
            Affiliation__c businessAffiliation = new Affiliation__c(
                Contact__c = contactList[i].Id,
                Account__c = businessOrganizationAccounts[i].Id,
                Primary__c = true
            );
            affiliationList.add(businessAffiliation);

            Affiliation__c householdAffiliation = new Affiliation__c(
                Contact__c = contactList[i].Id,
                Account__c = householdAccounts[i].Id,
                Primary__c = true
            );
            affiliationList.add(householdAffiliation);
        }

        List<SObject> affiliationAsSObjectList = affiliationList;

        //Set up affiliation mappings on household and business organization
        //This is done later to cause it not to interfere with our data setup so the unit test detects unexpected behavior better.
        AffiliationTestSetupFactory_TEST.setupMappingsByDevNameAndApiName(false);

        Test.startTest();
        Map<Id, Contact> returnedContactsByIds = tdtmClass.queryAfflLookupFields(affiliationAsSObjectList);
        Test.stopTest();

        System.assertEquals(
            insertedContactsByIds.size(),
            returnedContactsByIds.size(),
            'Number of returned contacts should match the number inserted.'
        );

        for (Contact returnedContact : returnedContactsByIds.values()) {
            Contact insertedContact = insertedContactsByIds.get(returnedContact.Id);

            System.assertNotEquals(null, insertedContact, 'A contact should be returned for each inserted contact.');
            System.assertEquals(
                returnedContact.Primary_Household__c,
                insertedContact.Primary_Household__c,
                'The Primary Household field should be queried and match that of the inserted Contact.'
            );
            System.assertEquals(
                returnedContact.Primary_Organization__c,
                insertedContact.Primary_Organization__c,
                'The Primary Organization field should be queried and match that of the inserted Contact.'
            );
        }
    }

    /****************************************
     * populateKeyAffls
     ****************************************/

    /**
     * @description helper class for initialization of tests for populateKeyAffls
     */
    private class PopulateKeyAfflsValidData {
        public AFFL_MultiRecordType_TDTM tdtmClass;
        public TDTM_Runnable.DmlWrapper dmlWrapper;
        public Id fakeAccountId;
        public String primaryAffiliationFieldAPIName;
        public Contact testContact;
        public Affiliation__c affiliation;

        public PopulateKeyAfflsValidData() {
            this.tdtmClass = new AFFL_MultiRecordType_TDTM();
            this.dmlWrapper = new TDTM_Runnable.DmlWrapper();
            this.primaryAffiliationFieldAPIName = AffiliationTestSetupFactory_TEST.getBusinessOrganizationFieldApiName();
            this.fakeAccountId = UTIL_UnitTestData_TEST.getFakeId(Account.SObjectType);

            Id fakeContactId = UTIL_UnitTestData_TEST.getFakeId(Contact.SObjectType);
            this.testContact = new Contact(Id = fakeContactId, FirstName = 'Test');
            testContact.put(this.primaryAffiliationFieldAPIName, fakeAccountId);

            this.affiliation = new Affiliation__c(
                Account__c = fakeAccountId,
                Contact__c = fakeContactId,
                Primary__c = true
            );
        }
    }

    /**
     * @description Tests populateKeyAffls appropriately sets the primary affiliation field
     */
    private static void populateKeyAfflsValid() {
        PopulateKeyAfflsValidData testData = new PopulateKeyAfflsValidData();

        Test.startTest();
        Contact contactReturned = testData.tdtmClass.populateKeyAffls(
            testData.affiliation,
            testData.primaryAffiliationFieldAPIName,
            testData.testContact,
            testData.dmlWrapper
        );
        Test.stopTest();

        System.assertEquals(
            testData.affiliation.Account__c,
            (Id) contactReturned.get(testData.primaryAffiliationFieldAPIName),
            'Contact Primary Affiliation Field api name should be set to the Affiliation\'s Account.'
        );
        System.assertEquals(
            true,
            testData.dmlWrapper.objectsToUpdate.contains(contactReturned),
            'The Contact should be added to the DMLWrapper.'
        );
    }

    /**
     * @description Tests populateKeyAffls does not run on recursion
     */
    private static void populateKeyAfflsRecursion() {
        PopulateKeyAfflsValidData testData = new PopulateKeyAfflsValidData();

        TDTM_ProcessControl.setRecursionFlag(
            TDTM_ProcessControl.registeredTrigger.CON_PrimaryAffls_TDTM_keyAfflLookupUpdated,
            true
        );

        Test.startTest();
        Contact contactReturned = testData.tdtmClass.populateKeyAffls(
            testData.affiliation,
            testData.primaryAffiliationFieldAPIName,
            testData.testContact,
            testData.dmlWrapper
        );
        Test.stopTest();

        System.assertEquals(null, contactReturned, 'Method should make no changes to the Contact on recursion.');
        System.assertEquals(
            false,
            testData.dmlWrapper.objectsToUpdate.contains(contactReturned),
            'Method should make no changes to the DMLWrapper on recursion.'
        );
    }

    /**
     * @description Tests populateKeyAffls does not run for contacts when a primary affiliation field is not supplied
     */
    private static void populateKeyAfflsNullAffiliationField() {
        PopulateKeyAfflsValidData testData = new PopulateKeyAfflsValidData();
        testData.primaryAffiliationFieldAPIName = null;

        Test.startTest();
        Contact contactReturned = testData.tdtmClass.populateKeyAffls(
            testData.affiliation,
            testData.primaryAffiliationFieldAPIName,
            testData.testContact,
            testData.dmlWrapper
        );
        Test.stopTest();

        System.assertEquals(
            null,
            contactReturned,
            'Method should make no changes to the Contact on a null primary affiliation field.'
        );
        System.assertEquals(
            false,
            testData.dmlWrapper.objectsToUpdate.contains(contactReturned),
            'Method should make no changes to the DMLWrapper on a null primary affiliation field.'
        );
    }

    /****************************************
     * uncheckOtherPrimariesSameType
     ****************************************/

    /**
     * @description Tests uncheckOtherPrimariesSameType for multiple affiliations
     */
    private static void uncheckOtherPrimariesSameType() {
        AFFL_MultiRecordType_TDTM tdtmClass = new AFFL_MultiRecordType_TDTM();
        TDTM_Runnable.DmlWrapper dmlWrapper = new TDTM_Runnable.DmlWrapper();

        //Setup Accounts
        Id businessOrganizationRecordTypeId = UTIL_Describe.getBizAccRecTypeID();
        Id householdAccountId = UTIL_Describe.getCustomHHAccRecTypeID();

        List<Account> businessOrganizationAccounts = UTIL_UnitTestData_TEST.getMultipleTestAccounts(
            AFFL_MultiRecordType_TEST.numberOfTestRecords,
            businessOrganizationRecordTypeId
        );
        List<Account> householdAccounts = UTIL_UnitTestData_TEST.getMultipleTestAccounts(
            AFFL_MultiRecordType_TEST.numberOfTestRecords,
            householdAccountId
        );

        List<Account> accountsToInsert = new List<Account>();
        accountsToInsert.addAll(businessOrganizationAccounts);
        accountsToInsert.addAll(householdAccounts);
        //Saving time on the dml operation adds up
        insert accountsToInsert;

        //Setup Contacts
        List<Contact> contactList = UTIL_UnitTestData_TEST.getMultipleTestContacts(
            AFFL_MultiRecordType_TEST.numberOfTestRecords
        );

        for (Integer i = 0; i < AFFL_MultiRecordType_TEST.numberOfTestRecords; i++) {
            Contact contactToInsert = contactList[i];
            contactToInsert.Primary_Household__c = householdAccounts[i].Id;
            contactToInsert.Primary_Organization__c = businessOrganizationAccounts[i].Id;
        }

        insert contactList;
        Map<Id, Contact> insertedContactsByIds = new Map<Id, Contact>(contactList);

        //Setup Initial Primary Affiliations
        List<Affiliation__c> oldPrimaryAffiliationList = new List<Affiliation__c>();

        for (Integer i = 0; i < AFFL_MultiRecordType_TEST.numberOfTestRecords; i++) {
            Affiliation__c businessAffiliation = new Affiliation__c(
                Contact__c = contactList[i].Id,
                Account__c = businessOrganizationAccounts[i].Id,
                Primary__c = true
            );
            oldPrimaryAffiliationList.add(businessAffiliation);

            Affiliation__c householdAffiliation = new Affiliation__c(
                Contact__c = contactList[i].Id,
                Account__c = householdAccounts[i].Id,
                Primary__c = true
            );
            oldPrimaryAffiliationList.add(householdAffiliation);
        }
        insert oldPrimaryAffiliationList;
        Map<Id, Affiliation__c> oldPrimaryAffiliationsById = new Map<Id, Affiliation__c>(oldPrimaryAffiliationList);

        //Setup new primary affiliations
        List<Affiliation__c> newPrimaryAffiliationList = new List<Affiliation__c>();

        for (Integer i = 0; i < AFFL_MultiRecordType_TEST.numberOfTestRecords; i++) {
            Integer nextSafeInteger = math.mod(i, 5);
            Affiliation__c businessAffiliation = new Affiliation__c(
                Contact__c = contactList[i].Id,
                Account__c = businessOrganizationAccounts[nextSafeInteger].Id,
                Primary__c = true
            );
            newPrimaryAffiliationList.add(businessAffiliation);

            Affiliation__c householdAffiliation = new Affiliation__c(
                Contact__c = contactList[i].Id,
                Account__c = householdAccounts[nextSafeInteger].Id,
                Primary__c = true
            );
            newPrimaryAffiliationList.add(householdAffiliation);
        }
        //Recalculate formulas in memory!
        Formula.recalculateFormulas(newPrimaryAffiliationList);

        Test.startTest();
        List<Affiliation__c> uncheckedAffiliations = tdtmClass.uncheckOtherPrimariesSameType(
            newPrimaryAffiliationList,
            dmlWrapper
        );
        Test.stopTest();

        System.assertEquals(
            oldPrimaryAffiliationList.size(),
            uncheckedAffiliations.size(),
            'Number of returned affiliations should match the number unchecked.'
        );

        for (Affiliation__c uncheckedAffiliation : uncheckedAffiliations) {
            Affiliation__c originalAffiliation = oldPrimaryAffiliationsById.get(uncheckedAffiliation.Id);
            System.assertNotEquals(null, originalAffiliation, 'Each old primary affiliation should be modified.');
            System.assertEquals(
                false,
                originalAffiliation.Primary__c,
                'Each old primary affiliation should have its Primary field set to false.'
            );
        }
    }

    /****************************************
     * createProgramEnrollmentIfNecessary
     ****************************************/

    /**
     * @description helper class for initialization of tests for createProgramEnrollmentIfNecessary
     */
    private class CreateProgramEnrollmentValidData {
        public AFFL_MultiRecordType_TDTM tdtmClass;
        public TDTM_Runnable.DmlWrapper dmlWrapper;
        public Account accountToTest;
        public Contact contactToTest;
        public Affiliation__c affiliation;

        public CreateProgramEnrollmentValidData() {
            this.tdtmClass = new AFFL_MultiRecordType_TDTM();
            this.dmlWrapper = new TDTM_Runnable.DmlWrapper();
            this.contactToTest = UTIL_UnitTestData_TEST.getUniqueContact(1);
            insert contactToTest;

            Id businessOrganizationRecordTypeId = UTIL_Describe.getBizAccRecTypeID();
            this.accountToTest = UTIL_UnitTestData_TEST.getMultipleTestAccounts(1, businessOrganizationRecordTypeId)[0];
            insert this.accountToTest;

            this.affiliation = new Affiliation__c(
                Id = UTIL_UnitTestData_TEST.getFakeId(Affiliation__c.SObjectType),
                Account__c = this.accountToTest.Id,
                Contact__c = this.contactToTest.Id,
                Primary__c = true
            );
        }
    }

    /**
     * @description Tests createProgramEnrollmentIfNecessary for valid data requiring a program enrollment be created
     */
    private static void createProgramEnrollmentIfNecessaryValidData() {
        CreateProgramEnrollmentValidData testData = new CreateProgramEnrollmentValidData();
        AFFL_MultiRecordType_TDTM.afflMapper = new AFFL_MultiRecordTypeMapper_STUB(true);
        Formula.recalculateFormulas(new List<Affiliation__c>{ testData.affiliation });

        Test.startTest();
        Program_Enrollment__c programEnrollmentCreated = testData.tdtmClass.createProgramEnrollmentIfNecessary(
            testData.affiliation,
            testData.dmlWrapper
        );
        Test.stopTest();

        System.assertNotEquals(
            null,
            programEnrollmentCreated,
            'A Program Enrollment should be created for the associated Affiliation.'
        );
        System.assertEquals(
            testData.affiliation.Id,
            programEnrollmentCreated.Affiliation__c,
            'The Program Enrollment\'s Affiliation should match the provided Affiliation\'s.'
        );
        System.assertEquals(
            testData.affiliation.Account__c,
            programEnrollmentCreated.Account__c,
            'The Program Enrollment\'s Account should match the Affiliation\'s.'
        );
        System.assertEquals(
            testData.affiliation.Contact__c,
            programEnrollmentCreated.Contact__c,
            'The Program Enrollment\'s Contact should match the Affiliation\'s.'
        );
    }

    /**
     * @description Tests createProgramEnrollmentIfNecessary for when a Program Enrollment is not needed
     */
    private static void createProgramEnrollmentIfNecessaryNotNeeded() {
        CreateProgramEnrollmentValidData testData = new CreateProgramEnrollmentValidData();
        AFFL_MultiRecordType_TDTM.afflMapper = new AFFL_MultiRecordTypeMapper_STUB(false);
        Formula.recalculateFormulas(new List<Affiliation__c>{ testData.affiliation });

        Test.startTest();
        Program_Enrollment__c programEnrollmentCreated = testData.tdtmClass.createProgramEnrollmentIfNecessary(
            testData.affiliation,
            testData.dmlWrapper
        );
        Test.stopTest();

        System.assertEquals(
            null,
            programEnrollmentCreated,
            'A Program Enrollment should not be created when the mapper specifies it should not.'
        );
    }

    /**
     * @description Tests createProgramEnrollmentIfNecessary for when the affiliation type is null
     */
    private static void createProgramEnrollmentIfNecessaryNoAffiliationType() {
        CreateProgramEnrollmentValidData testData = new CreateProgramEnrollmentValidData();
        AFFL_MultiRecordType_TDTM.afflMapper = new AFFL_MultiRecordTypeMapper_STUB(true);

        Test.startTest();
        Program_Enrollment__c programEnrollmentCreated = testData.tdtmClass.createProgramEnrollmentIfNecessary(
            testData.affiliation,
            testData.dmlWrapper
        );
        Test.stopTest();

        System.assertEquals(
            null,
            programEnrollmentCreated,
            'A Program Enrollment should not be created when the affiliation type is null.'
        );
    }

    /**
     * @description Tests createProgramEnrollmentIfNecessary for when the affiliation is null
     */
    private static void createProgramEnrollmentIfNecessaryNullAffiliation() {
        CreateProgramEnrollmentValidData testData = new CreateProgramEnrollmentValidData();
        AFFL_MultiRecordType_TDTM.afflMapper = new AFFL_MultiRecordTypeMapper_STUB(true);

        Test.startTest();
        Program_Enrollment__c programEnrollmentCreated = testData.tdtmClass.createProgramEnrollmentIfNecessary(
            null,
            testData.dmlWrapper
        );
        Test.stopTest();

        System.assertEquals(
            null,
            programEnrollmentCreated,
            'A Program Enrollment should not be created when the affiliation type is null.'
        );
    }

    /****************************************
     * RECURSION TESTS
     ****************************************/

    /**
     * @description Tests setBeforeInsertRecursion
     */
    @isTest
    static void setBeforeInsertRecursion() {
        AFFL_MultiRecordType_TDTM tdtmClass = new AFFL_MultiRecordType_TDTM();

        Test.startTest();
        tdtmClass.setBeforeInsertRecursion();
        Test.stopTest();

        Boolean beforeInsert = TDTM_ProcessControl.getRecursionFlag(BEFORE_INSERT_RECURSION);

        System.assertEquals(
            true,
            beforeInsert,
            'Before Insert recursion flag should be active for AFFL_MultiRecordType_TDTM.'
        );
    }

    /**
     * @description Tests isBeforeInsertRecursion
     */
    @isTest
    static void isBeforeInsertRecursion() {
        AFFL_MultiRecordType_TDTM tdtmClass = new AFFL_MultiRecordType_TDTM();
        tdtmClass.setBeforeInsertRecursion();

        Test.startTest();
        Boolean beforeInsert = tdtmClass.isBeforeInsertRecursion();
        Test.stopTest();

        System.assertEquals(
            true,
            beforeInsert,
            'Before Insert recursion flag should be active for AFFL_MultiRecordType_TDTM.'
        );
    }

    /**
     * @description Tests unsetBeforeInsertRecursion
     */
    @isTest
    static void unsetBeforeInsertRecursion() {
        AFFL_MultiRecordType_TDTM tdtmClass = new AFFL_MultiRecordType_TDTM();

        tdtmClass.setBeforeInsertRecursion();

        Test.startTest();
        tdtmClass.unsetBeforeInsertRecursion();
        Test.stopTest();

        Boolean beforeInsert = tdtmClass.isBeforeInsertRecursion();

        System.assertEquals(
            false,
            beforeInsert,
            'Before Insert recursion flag should be inactive for AFFL_MultiRecordType_TDTM.'
        );
    }

    /**
     * @description Tests setAfterInsertRecursion
     */
    @isTest
    static void setAfterInsertRecursion() {
        AFFL_MultiRecordType_TDTM tdtmClass = new AFFL_MultiRecordType_TDTM();

        Test.startTest();
        tdtmClass.setAfterInsertRecursion();
        Test.stopTest();

        Boolean afterInsert = TDTM_ProcessControl.getRecursionFlag(AFTER_INSERT_RECURSION);

        System.assertEquals(
            true,
            afterInsert,
            'After Insert recursion flag should be active for AFFL_MultiRecordType_TDTM.'
        );
    }

    /**
     * @description Tests isAfterInsertRecursion
     */
    @isTest
    static void isAfterInsertRecursion() {
        AFFL_MultiRecordType_TDTM tdtmClass = new AFFL_MultiRecordType_TDTM();
        tdtmClass.setAfterInsertRecursion();

        Test.startTest();
        Boolean afterInsert = tdtmClass.isAfterInsertRecursion();
        Test.stopTest();

        System.assertEquals(
            true,
            afterInsert,
            'After Insert recursion flag should be active for AFFL_MultiRecordType_TDTM.'
        );
    }

    /**
     * @description Tests unsetAfterInsertRecursion
     */
    @isTest
    static void unsetAfterInsertRecursion() {
        AFFL_MultiRecordType_TDTM tdtmClass = new AFFL_MultiRecordType_TDTM();

        tdtmClass.setAfterInsertRecursion();

        Test.startTest();
        tdtmClass.unsetAfterInsertRecursion();
        Test.stopTest();

        Boolean afterInsert = tdtmClass.isAfterInsertRecursion();

        System.assertEquals(
            false,
            afterInsert,
            'After Insert recursion flag should be inactive for AFFL_MultiRecordType_TDTM.'
        );
    }

    /**
     * @description Tests setAfterUpdateRecursion
     */
    @isTest
    static void setAfterUpdateRecursion() {
        AFFL_MultiRecordType_TDTM tdtmClass = new AFFL_MultiRecordType_TDTM();

        Test.startTest();
        tdtmClass.setAfterUpdateRecursion();
        Test.stopTest();

        Boolean afterUpdate = TDTM_ProcessControl.getRecursionFlag(AFTER_UPDATE_RECURSION);

        System.assertEquals(
            true,
            afterUpdate,
            'After Update recursion flag should be active for AFFL_MultiRecordType_TDTM.'
        );
    }

    /**
     * @description Tests isAfterUpdateRecursion
     */
    @isTest
    static void isAfterUpdateRecursion() {
        AFFL_MultiRecordType_TDTM tdtmClass = new AFFL_MultiRecordType_TDTM();
        tdtmClass.setAfterUpdateRecursion();

        Test.startTest();
        Boolean afterUpdate = tdtmClass.isAfterUpdateRecursion();
        Test.stopTest();

        System.assertEquals(
            true,
            afterUpdate,
            'After Update recursion flag should be active for AFFL_MultiRecordType_TDTM.'
        );
    }

    /**
     * @description Tests unsetAfterUpdateRecursion
     */
    @isTest
    static void unsetAfterUpdateRecursion() {
        AFFL_MultiRecordType_TDTM tdtmClass = new AFFL_MultiRecordType_TDTM();

        tdtmClass.setAfterUpdateRecursion();

        Test.startTest();
        tdtmClass.unsetAfterUpdateRecursion();
        Test.stopTest();

        Boolean afterUpdate = tdtmClass.isAfterUpdateRecursion();

        System.assertEquals(
            false,
            afterUpdate,
            'After Update recursion flag should be inactive for AFFL_MultiRecordType_TDTM.'
        );
    }

    /**
     * @description Tests setAffiliationMadePrimaryRecursion
     */
    @isTest
    static void setAffiliationMadePrimaryRecursion() {
        AFFL_MultiRecordType_TDTM tdtmClass = new AFFL_MultiRecordType_TDTM();

        Test.startTest();
        tdtmClass.setAffiliationMadePrimaryRecursion();
        Test.stopTest();

        Boolean affiliationMadePrimary = TDTM_ProcessControl.getRecursionFlag(AFFILIATION_MADE_PRIMARY_RECURSION);

        System.assertEquals(
            true,
            affiliationMadePrimary,
            'Affiliation Made Primary recursion flag should be active for AFFL_MultiRecordType_TDTM.'
        );
    }

    /**
     * @description Tests isAffiliationMadePrimaryRecursion
     */
    @isTest
    static void isAffiliationMadePrimaryRecursion() {
        AFFL_MultiRecordType_TDTM tdtmClass = new AFFL_MultiRecordType_TDTM();
        tdtmClass.setAffiliationMadePrimaryRecursion();

        Test.startTest();
        Boolean affiliationMadePrimary = tdtmClass.isAffiliationMadePrimaryRecursion();
        Test.stopTest();

        System.assertEquals(
            true,
            affiliationMadePrimary,
            'Affiliation Made Primary recursion flag should be active for AFFL_MultiRecordType_TDTM.'
        );
    }

    /**
     * @description Tests resetAffiliationMadePrimaryRecursion
     */
    @isTest
    static void resetAffiliationMadePrimaryRecursion() {
        AFFL_MultiRecordType_TDTM tdtmClass = new AFFL_MultiRecordType_TDTM();

        tdtmClass.setAffiliationMadePrimaryRecursion();

        Test.startTest();
        tdtmClass.resetAffiliationMadePrimaryRecursion();
        Test.stopTest();

        Boolean affiliationMadePrimary = tdtmClass.isAffiliationMadePrimaryRecursion();

        System.assertEquals(
            false,
            affiliationMadePrimary,
            'Affiliation Made Primary recursion flag should be inactive for AFFL_MultiRecordType_TDTM.'
        );
    }

    /**
     * @description Tests isContactPrimaryAffiliationUpdatedRecursion
     */
    @isTest
    static void isContactPrimaryAffiliationUpdatedRecursion() {
        AFFL_MultiRecordType_TDTM tdtmClass = new AFFL_MultiRecordType_TDTM();
        TDTM_ProcessControl.setRecursionFlag(CONTACT_PRIMARY_AFFILIATION_UPDATED_RECURSION, true);

        Test.startTest();
        Boolean contactPrimaryAffiliationUpdatedRecursion = tdtmClass.isContactPrimaryAffiliationUpdatedRecursion();
        Test.stopTest();

        System.assertEquals(
            true,
            contactPrimaryAffiliationUpdatedRecursion,
            'Contact Primary Affiliation Updated recursion flag should be active for AFFL_MultiRecordType_TDTM.'
        );
    }

    /**************************************************************************
     * STUBS
     **************************************************************************/

    /**
     * @description Stubs the AFFL_MultiRecordTypeMapper to mock behavior of needsProgramEnrollment
     */
    public class AFFL_MultiRecordTypeMapper_STUB extends AFFL_MultiRecordTypeMapper {
        Boolean programEnrollmentNeeded;

        public AFFL_MultiRecordTypeMapper_STUB(Boolean programEnrollmentNeeded) {
            this.programEnrollmentNeeded = programEnrollmentNeeded;
        }

        public override Boolean needsProgramEnrollment(Affiliation__c affl) {
            return programEnrollmentNeeded;
        }
    }
}
/*
    Copyright (c) 2021, Salesforce.org
    All rights reserved.
    Redistribution and use in source and binary forms, with or without
    modification, are permitted provided that the following conditions are met:
    * Redistributions of source code must retain the above copyright
      notice, this List of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this List of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
    * Neither the name of Salesforce.org nor the names of
      its contributors may be used to endorse or promote products derived
      from this software without specific prior written permission.
    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
    "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
    LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
    FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
    COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
    INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
    BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
    LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
    CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
    LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
    ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
    POSSIBILITY OF SUCH DAMAGE.
*/
/**
* @author Salesforce.org
* @date 2021
* @group
* @group-content ../../ApexDocContent/Tests.htm
* @description Test class for AccountModelHealthCheckVMapper.
*/
@isTest
public with sharing class AccountModelHealthCheckVMapper_TEST {
    /**************************************************************************************************************************
    * @description Test method to verify that the getInstance method returns a new instance of the 
    * AccountModelHealthCheckVMapper class when one does not already exist.
    ***************************************************************************************************************************/
    @isTest
    private static void getInstanceNew() {

        Test.startTest();
            AccountModelHealthCheckVMapper accountModelHealthCheckVMapperInstance = AccountModelHealthCheckVMapper.getInstance();
        Test.stopTest();

        System.assertEquals(AccountModelHealthCheckVMapper.instance, accountModelHealthCheckVMapperInstance, 'Instance of mapper class returned should match static instance variable.');
        System.assertEquals(true, accountModelHealthCheckVMapperInstance != null, 'Instance of mapper class should not be null.');
    }

    /**************************************************************************************************************************
    * @description Test method to verify that the getInstance method returns the existing instance of the 
    * AccountModelHealthCheckVMapper class when one already exists.
    ***************************************************************************************************************************/
    @isTest
    private static void getInstanceExisting() {

        Test.startTest();
            AccountModelHealthCheckVMapper accountModelHealthCheckVMapperInstance1 = AccountModelHealthCheckVMapper.getInstance();
            AccountModelHealthCheckVMapper accountModelHealthCheckVMapperInstance2 = AccountModelHealthCheckVMapper.getInstance();
        Test.stopTest();

        System.assertEquals(AccountModelHealthCheckVMapper.instance, accountModelHealthCheckVMapperInstance1, 'Instance of mapper class returned should match static instance variable.');
        System.assertEquals(accountModelHealthCheckVMapperInstance1, accountModelHealthCheckVMapperInstance2, 'Subsequent retrievals of mapper class instance should return existing instance.');
        System.assertEquals(true, accountModelHealthCheckVMapperInstance1 != null, 'Instance of mapper class should not be null.');
    }

    /**************************************************************************************************************************
    * @description Test to verify locateRecordTypeService() returns an instance of the RecordTypeService class.
    **************************************************************************************************************************/ 
    @isTest
    private static void locateRecordTypeServiceValid(){
        Test.startTest();
        RecordTypeService rtServiceInstance = AccountModelHealthCheckVMapper.getInstance().locateRecordTypeService();
        Test.stopTest();

        System.assertEquals(RecordTypeService.getInstance(), rtServiceInstance, 'Should return instance of RecordTypeService class.');
        System.assertEquals(true, rtServiceInstance != null, 'Instance of RecordTypeService class should not be null.');
    }

    /**************************************************************************************************************************
    * @description Test to verify locateAccountModelSettingsService() returns an instance of the AccountModelSettingsService class.
    **************************************************************************************************************************/ 
    @isTest
    private static void locateAccountModelSettingsServiceValid(){
        Test.startTest();
        AccountModelSettingsService accModSettingsServiceInstance = AccountModelHealthCheckVMapper.getInstance().locateAccountModelSettingsService();
        Test.stopTest();

        System.assertEquals(AccountModelSettingsService.getInstance(), accModSettingsServiceInstance, 'Should return instance of AccountModelSettingsService class.');
        System.assertEquals(true, accModSettingsServiceInstance != null, 'Instance of AccountModelSettingsService class should not be null.');
    }

    /**************************************************************************************************************************
    * @description Test to verify locateStringHandlingService() returns an instance of the StringHandlingService class.
    **************************************************************************************************************************/ 
    @isTest
    private static void locateStringHandlingServiceValid(){
        Test.startTest();
        StringHandlingService stringHandlingServiceInstance = AccountModelHealthCheckVMapper.getInstance().locateStringHandlingService();
        Test.stopTest();

        System.assertEquals(StringHandlingService.getInstance(), stringHandlingServiceInstance, 'Should return instance of StringHandlingService class.');
        System.assertEquals(true, stringHandlingServiceInstance != null, 'Instance of StringHandlingService class should not be null.');
    }

    /**************************************************************************************************************************
    * @description Test to verify combineAccountHealthCheckGroupViewModels() returns a combined HealthCheckGroupVModel comprised of
    * the combined properties of the group view models passed as arguments.
    **************************************************************************************************************************/ 
    @isTest 
    private static void combineAccountHealthCheckGroupViewModelsValid(){

        List<HealthCheckGroupVModel> testHealthCheckGroupModelsList = new List<HealthCheckGroupVModel>();
        List<HealthCheckItemVModel> group1HealthCheckItemList = new List<HealthCheckItemVModel>();

        group1HealthCheckItemList.add(new HealthCheckItemVModel('Key1',
                                                            'Setting-X',
                                                            'Pass',
                                                            'PassedLabel',
                                                            'Description',
                                                            'RecommendedFix',
                                                            new List<HealthCheckItemVModel>()));
                                                            
        group1HealthCheckItemList.add(new HealthCheckItemVModel('Key2',
                                                            'Setting-B',
                                                            'Pass',
                                                            'PassedLabel',
                                                            'Description',
                                                            'RecommendedFix',
                                                            new List<HealthCheckItemVModel>()));

        group1HealthCheckItemList.add(new HealthCheckItemVModel('Key3',
                                                            'Setting-Y',
                                                            'Fail',
                                                            'FailedLabel',
                                                            'Description',
                                                            'RecommendedFix',
                                                            new List<HealthCheckItemVModel>()));


        testHealthCheckGroupModelsList.add(new HealthCheckGroupVModel('SubGroup1',
                                                                 'Fail',
                                                                 2,
                                                                 3,
                                                                 new List<String>(),
                                                                 group1HealthCheckItemList));

        testHealthCheckGroupModelsList.add(new HealthCheckGroupVModel('SubGroup2',
                                                                 'Pass',
                                                                 1,
                                                                 1,
                                                                 new List<String>(),
                                                                 new List<HealthCheckItemVModel>()));


        Test.startTest();
        HealthCheckGroupVModel healthCheckGroupVModel = AccountModelHealthCheckVMapper.getInstance().combineAccountHealthCheckGroupViewModels(testHealthCheckGroupModelsList);
        Test.stopTest();

        System.assertEquals(Label.stgHealthCheckAccountModel, healthCheckGroupVModel.label, 'Group label should be \'' + Label.stgHealthCheckAccountModel + '\'');
        System.assertEquals(Label.stgHealthCheckStatusFailed, healthCheckGroupVModel.status, 'Group status should be \'' + Label.stgHealthCheckStatusFailed + '\'');
        System.assertEquals(3, healthCheckGroupVModel.passedChecks, 'Group passed checks should be \'' + healthCheckGroupVModel.passedChecks + '\'');
        System.assertEquals(4, healthCheckGroupVModel.totalChecks, 'Group total checks should be \'' + healthCheckGroupVModel.totalChecks + '\'');
        System.assertEquals(3, healthCheckGroupVModel.healthCheckItemList.size(), 'Group HealthCheckItems list should have \'' + healthCheckGroupVModel.healthCheckItemList.size() + '\' items');

        System.assertEquals('Setting-Y', healthCheckGroupVModel.healthCheckItemList[0].setting, 'HealthCheckItemList should be sorted alphabetically by Setting, with Failed items prioritized.');
        System.assertEquals('Setting-B', healthCheckGroupVModel.healthCheckItemList[1].setting, 'HealthCheckItemList should be sorted alphabetically by Setting, with Failed items prioritized.');
        System.assertEquals('Setting-X', healthCheckGroupVModel.healthCheckItemList[2].setting, 'HealthCheckItemList should be sorted alphabetically by Setting, with Failed items prioritized.');
    }

    /**************************************************************************************************************************
    * @description Test to verify getDefaultAccountModelHealthCheckItems() returns a HealthCheckGroupVModel with a status of
    * pass when the ID provided as the defaultAccountModel Id in AccountSettingsModel is valid and matches to a RT for Default 
    * Account Modelthat is valid and active.
    **************************************************************************************************************************/ 
    @isTest
    private static void getDefaultAccountModelHealthCheckItemsIdMatchFoundToRTValidAndActive(){
        RecordTypeService.instance = new STUB_RecordTypeServiceValidAndActiveDefaultModel();

        AccountModelSettingsModel accountModelSettingsModel = new AccountModelSettingsModel('000000000000000001',
                                                                                '000000000000000002',
                                                                                '000000000000000003');

        RecordTypeModel recordTypeModel = new RecordTypeModel('000000000000000001',
                                                              'Test Record Name',
                                                              'testRecordDevName',
                                                              true);
                          
        Map<Id, RecordTypeModel> recordTypeModelsById = new Map<Id, RecordTypeModel>{recordTypeModel.id => recordTypeModel};

        Test.startTest();
        HealthCheckGroupVModel healthCheckGroupVModel = 
            AccountModelHealthCheckVMapper.getInstance().getDefaultAccountModelHealthCheckItems(accountModelSettingsModel, recordTypeModelsById);
        Test.stopTest();

        AccountModelHealthCheckVMapper_TEST.verifyHealthCheckGroupVModelAssertions(Label.stgHealthCheckAccountModel,
                                                                                   Label.stgHealthCheckStatusPassed,
                                                                                   1,
                                                                                   1,
                                                                                   0,
                                                                                   1,
                                                                                   healthCheckGroupVModel);

        String expectedDescription = StringHandlingService.getInstance().formatStringWithApostrophesAndParameters(
            Label.stgHCRecordTypeValid, 
            new List<Object>{'Test Record Name', 'testRecordDevName'}
        );
        String expectedFix = Label.stgHealthCheckFixNotApplicable;

        AccountModelHealthCheckVMapper_TEST.verifyHealthCheckItemListAssertions(Label.stgAccModelTitle, 
                                                                                'Pass', 
                                                                                Label.stgHealthCheckStatusPassed, 
                                                                                expectedDescription, 
                                                                                expectedFix, 
                                                                                healthCheckGroupVModel.healthCheckItemList);
    }

    /**************************************************************************************************************************
    * @description Test to verify getDefaultAccountModelHealthCheckItems() returns a HealthCheckGroupVModel with a status of
    * fail when the ID provided as the defaultAccountModel Id in AccountSettingsModel is valid and matches to a RT for Default 
    * Account Modelthat is valid, but inactive.
    **************************************************************************************************************************/ 
    @isTest
    private static void getDefaultAccountModelHealthCheckItemsIdMatchFoundToRTValidAndInactive(){
        RecordTypeService.instance = new STUB_RecordTypeServiceValidAndInactiveDefaultModel();

        AccountModelSettingsModel accountModelSettingsModel = new AccountModelSettingsModel('000000000000000001',
                                                                                            '000000000000000002',
                                                                                            '000000000000000003');

        RecordTypeModel recordTypeModel = new RecordTypeModel('000000000000000001',
                                                              'Test Record Name',
                                                              'testRecordDevName',
                                                              false);

        Map<Id, RecordTypeModel> recordTypeModelsById = new Map<Id, RecordTypeModel>{recordTypeModel.id => recordTypeModel};

        Test.startTest();
        HealthCheckGroupVModel healthCheckGroupVModel = 
            AccountModelHealthCheckVMapper.getInstance().getDefaultAccountModelHealthCheckItems(accountModelSettingsModel, recordTypeModelsById);
        Test.stopTest();

        AccountModelHealthCheckVMapper_TEST.verifyHealthCheckGroupVModelAssertions(Label.stgHealthCheckAccountModel,
                                                                                   Label.stgHealthCheckStatusFailed,
                                                                                   0,
                                                                                   1,
                                                                                   0,
                                                                                   1,
                                                                                   healthCheckGroupVModel);

        String expectedDescription = StringHandlingService.getInstance().formatStringWithApostrophesAndParameters(
            Label.stgHCRecordTypeInactive, 
            new List<Object>{'Test Record Name', 'testRecordDevName'}
        );
        String expectedFix = StringHandlingService.getInstance().formatStringWithApostrophesAndParameters(
            Label.stgHCAccountModelDefaultInactiveFix, 
            new List<Object>{'Test Record Name', 'testRecordDevName'}
        );

        AccountModelHealthCheckVMapper_TEST.verifyHealthCheckItemListAssertions(Label.stgAccModelTitle, 
                                                                                'Fail', 
                                                                                Label.stgHealthCheckStatusFailed, 
                                                                                expectedDescription, 
                                                                                expectedFix, 
                                                                                healthCheckGroupVModel.healthCheckItemList);
    }

    /**************************************************************************************************************************
    * @description Test to verify getDefaultAccountModelHealthCheckItems() returns a HealthCheckGroupVModel with a status of
    * fail when an the ID provided as the defaultAccountModel Id in AccountSettingsModel is not an ID.
    **************************************************************************************************************************/ 
    @isTest
    private static void getDefaultAccountModelHealthCheckItemsInvalidDefaultId(){
        RecordTypeService.instance = new STUB_RecordTypeServiceNullModel();

        AccountModelSettingsModel accountModelSettingsModel = new AccountModelSettingsModel('Not an ID default acct',
                                                                                            'Not an ID admin acct',
                                                                                            'Not an Id HH acct');

        RecordTypeModel recordTypeModel = new RecordTypeModel('000000000000000111',
                                                              'Account Name',
                                                              'accountDevName',
                                                              true);

        Map<Id, RecordTypeModel> recordTypeModelsById = new Map<Id, RecordTypeModel>{recordTypeModel.id => recordTypeModel};

        Test.startTest();
        HealthCheckGroupVModel healthCheckGroupVModel = 
            AccountModelHealthCheckVMapper.getInstance().getDefaultAccountModelHealthCheckItems(accountModelSettingsModel, recordTypeModelsById);
        Test.stopTest();

        AccountModelHealthCheckVMapper_TEST.verifyHealthCheckGroupVModelAssertions(Label.stgHealthCheckAccountModel,
                                                                                   Label.stgHealthCheckStatusFailed,
                                                                                   0,
                                                                                   1,
                                                                                   0,
                                                                                   1,
                                                                                   healthCheckGroupVModel);

        String expectedDescription = StringHandlingService.getInstance().formatStringWithApostrophesAndParameters(
            Label.stgHCRecordTypeNotFound, 
            new List<Object>{'Not an ID default acct'}
        );
        String expectedFix = StringHandlingService.getInstance().formatStringWithApostrophesAndParameters(
            Label.stgHCAccountModelDefaultNotFoundFix, 
            new List<Object>{'Not an ID default acct'}
        );

        AccountModelHealthCheckVMapper_TEST.verifyHealthCheckItemListAssertions(Label.stgAccModelTitle, 
                                                                                'Fail', 
                                                                                Label.stgHealthCheckStatusFailed, 
                                                                                expectedDescription, 
                                                                                expectedFix, 
                                                                                healthCheckGroupVModel.healthCheckItemList);
    }

    /**************************************************************************************************************************
    * @description Test to verify getDefaultAccountModelHealthCheckItems() returns a HealthCheckGroupVModel with a status of
    * fail when an invalid RT is specified for Default Account Model and the defaultAccountModel Id in AccountSettingsModel is a
    * valid ID, but does not match any Ids in the RecordType map.
    **************************************************************************************************************************/ 
    @isTest
    private static void getDefaultAccountModelHealthCheckItemsValidIdNoMatchingRT(){
        RecordTypeService.instance = new STUB_RecordTypeServiceNullModel();

        AccountModelSettingsModel accountModelSettingsModel = new AccountModelSettingsModel('000000000000000000',
                                                                                            '000000000000000000',
                                                                                            '000000000000000000');

        RecordTypeModel recordTypeModel = new RecordTypeModel('000000000000000123',
                                                              'Different Account Name',
                                                              'differentAccountDevName',
                                                              true);

        Map<Id, RecordTypeModel> recordTypeModelsById = new Map<Id, RecordTypeModel>{recordTypeModel.id => recordTypeModel};

        Test.startTest();
        HealthCheckGroupVModel healthCheckGroupVModel = 
            AccountModelHealthCheckVMapper.getInstance().getDefaultAccountModelHealthCheckItems(accountModelSettingsModel, recordTypeModelsById);
        Test.stopTest();

        AccountModelHealthCheckVMapper_TEST.verifyHealthCheckGroupVModelAssertions(Label.stgHealthCheckAccountModel,
                                                                                   Label.stgHealthCheckStatusFailed,
                                                                                   0,
                                                                                   1,
                                                                                   0,
                                                                                   1,
                                                                                   healthCheckGroupVModel);

        String expectedDescription = StringHandlingService.getInstance().formatStringWithApostrophesAndParameters(
            Label.stgHCRecordTypeNotFound, 
            new List<Object>{'000000000000000000'}
        );
        String expectedFix = StringHandlingService.getInstance().formatStringWithApostrophesAndParameters(
            Label.stgHCAccountModelDefaultNotFoundFix, 
            new List<Object>{'000000000000000000'}
        );

        AccountModelHealthCheckVMapper_TEST.verifyHealthCheckItemListAssertions(Label.stgAccModelTitle, 
                                                                                'Fail', 
                                                                                Label.stgHealthCheckStatusFailed, 
                                                                                expectedDescription, 
                                                                                expectedFix, 
                                                                                healthCheckGroupVModel.healthCheckItemList);
    }

    /**************************************************************************************************************************
    * @description Test to verify getAdministrativeAccountModelHealthCheckItems() returns a HealthCheckGroupVModel with a status of
    * pass when the ID provided as the administrative AccountModel Id in AccountSettingsModel is valid and matches to a RT for Admin 
    * Account Modelthat is valid and active.
    **************************************************************************************************************************/ 
    @isTest
    private static void getAdministrativeAccountModelHealthCheckItemsIdMatchFoundToRTValidAndActive(){
        RecordTypeService.instance = new STUB_RecordTypeServiceValidAndActiveDefaultModel();

        AccountModelSettingsModel accountModelSettingsModel = new AccountModelSettingsModel('000000000000000001',
                                                                                            '000000000000000002',
                                                                                            '000000000000000003');

        RecordTypeModel recordTypeModel = new RecordTypeModel('000000000000000002',
                                                              'Test Record Name',
                                                              'testRecordDevName',
                                                              true);
                          
        Map<Id, RecordTypeModel> recordTypeModelsById = new Map<Id, RecordTypeModel>{recordTypeModel.id => recordTypeModel};

        Test.startTest();
        HealthCheckGroupVModel healthCheckGroupVModel = 
            AccountModelHealthCheckVMapper.getInstance().getAdministrativeAccountModelHealthCheckItems(accountModelSettingsModel, recordTypeModelsById);
        Test.stopTest();

        AccountModelHealthCheckVMapper_TEST.verifyHealthCheckGroupVModelAssertions(Label.stgHealthCheckAccountModel,
                                                                                   Label.stgHealthCheckStatusPassed,
                                                                                   1,
                                                                                   1,
                                                                                   0,
                                                                                   1,
                                                                                   healthCheckGroupVModel);

        String expectedDescription = StringHandlingService.getInstance().formatStringWithApostrophesAndParameters(
            Label.stgHCRecordTypeValid, 
            new List<Object>{'Test Record Name', 'testRecordDevName'}
        );
        String expectedFix = Label.stgHealthCheckFixNotApplicable;
        
        AccountModelHealthCheckVMapper_TEST.verifyHealthCheckItemListAssertions(Label.stgAdminAccountRecordType, 
                                                                                'Pass', 
                                                                                Label.stgHealthCheckStatusPassed, 
                                                                                expectedDescription, 
                                                                                expectedFix, 
                                                                                healthCheckGroupVModel.healthCheckItemList);
    }

    /**************************************************************************************************************************
    * @description Test to verify getAdministrativeAccountModelHealthCheckItems() returns a HealthCheckGroupVModel with a status of
    * fail when the ID provided as the administrativeAccountModel Id in AccountSettingsModel is valid and matches to a RT for Admin 
    * Account Modelthat is valid, but inactive.
    **************************************************************************************************************************/ 
    @isTest
    private static void getAdministrativeAccountModelHealthCheckItemsIdMatchFoundToRTValidAndInactive(){
        RecordTypeService.instance = new STUB_RecordTypeServiceValidAndInactiveDefaultModel();

        AccountModelSettingsModel accountModelSettingsModel = new AccountModelSettingsModel('000000000000000001',
                                                                                            '000000000000000002',
                                                                                            '000000000000000003');

        RecordTypeModel recordTypeModel = new RecordTypeModel('000000000000000002',
                                                              'Test Record Name',
                                                              'testRecordDevName',
                                                              false);

        Map<Id, RecordTypeModel> recordTypeModelsById = new Map<Id, RecordTypeModel>{recordTypeModel.id => recordTypeModel};

        Test.startTest();
        HealthCheckGroupVModel healthCheckGroupVModel = 
            AccountModelHealthCheckVMapper.getInstance().getAdministrativeAccountModelHealthCheckItems(accountModelSettingsModel, recordTypeModelsById);
        Test.stopTest();

        AccountModelHealthCheckVMapper_TEST.verifyHealthCheckGroupVModelAssertions(Label.stgHealthCheckAccountModel,
                                                                                   Label.stgHealthCheckStatusFailed,
                                                                                   0,
                                                                                   1,
                                                                                   0,
                                                                                   1,
                                                                                   healthCheckGroupVModel);

        String expectedDescription = StringHandlingService.getInstance().formatStringWithApostrophesAndParameters(
            Label.stgHCRecordTypeInactive, 
            new List<Object>{'Test Record Name', 'testRecordDevName'}
        );
        String expectedFix = StringHandlingService.getInstance().formatStringWithApostrophesAndParameters(
            Label.stgHCAccountModelAdminInactiveFix, 
            new List<Object>{'Test Record Name', 'testRecordDevName'}
        );
        
        AccountModelHealthCheckVMapper_TEST.verifyHealthCheckItemListAssertions(Label.stgAdminAccountRecordType, 
                                                                                'Fail', 
                                                                                Label.stgHealthCheckStatusFailed, 
                                                                                expectedDescription, 
                                                                                expectedFix, 
                                                                                healthCheckGroupVModel.healthCheckItemList);
    }

    /**************************************************************************************************************************
    * @description Test to verify getAdministrativeAccountModelHealthCheckItems() returns a HealthCheckGroupVModel with a status of
    * fail when an the ID provided as the administrativeAccountModel Id in AccountSettingsModel is not an ID.
    **************************************************************************************************************************/ 
    @isTest
    private static void getAdministrativeAccountModelHealthCheckItemsInvalidDefaultId(){
        RecordTypeService.instance = new STUB_RecordTypeServiceNullModel();

        AccountModelSettingsModel accountModelSettingsModel = new AccountModelSettingsModel('Not an ID default acct',
                                                                                            'Not an ID admin acct',
                                                                                            'Not an Id HH acct');

        RecordTypeModel recordTypeModel = new RecordTypeModel('000000000000000111',
                                                              'Account Name',
                                                              'accountDevName',
                                                              true);

        Map<Id, RecordTypeModel> recordTypeModelsById = new Map<Id, RecordTypeModel>{recordTypeModel.id => recordTypeModel};

        Test.startTest();
        HealthCheckGroupVModel healthCheckGroupVModel = 
            AccountModelHealthCheckVMapper.getInstance().getAdministrativeAccountModelHealthCheckItems(accountModelSettingsModel, recordTypeModelsById);
        Test.stopTest();

        AccountModelHealthCheckVMapper_TEST.verifyHealthCheckGroupVModelAssertions(Label.stgHealthCheckAccountModel,
                                                                                   Label.stgHealthCheckStatusFailed,
                                                                                   0,
                                                                                   1,
                                                                                   0,
                                                                                   1,
                                                                                   healthCheckGroupVModel);

        String expectedDescription = StringHandlingService.getInstance().formatStringWithApostrophesAndParameters(
            Label.stgHCRecordTypeNotFound, 
            new List<Object>{'Not an ID admin acct'}
        );
        String expectedFix = StringHandlingService.getInstance().formatStringWithApostrophesAndParameters(
            Label.stgHCAccountModelAdminNotFoundFix, 
            new List<Object>{'Not an ID admin acct'}
        );
        
        AccountModelHealthCheckVMapper_TEST.verifyHealthCheckItemListAssertions(Label.stgAdminAccountRecordType, 
                                                                                'Fail', 
                                                                                Label.stgHealthCheckStatusFailed, 
                                                                                expectedDescription, 
                                                                                expectedFix, 
                                                                                healthCheckGroupVModel.healthCheckItemList);
    }

    /**************************************************************************************************************************
    * @description Test to verify getAdministrativeAccountModelHealthCheckItems() returns a HealthCheckGroupVModel with a status of
    * fail when an invalid RT is specified for Administrative Account Model and the adminAccountModel Id in AccountSettingsModel is a
    * valid ID, but does not match any Ids in the RecordType map.
    **************************************************************************************************************************/ 
    @isTest
    private static void getAdministrativeAccountModelHealthCheckItemsValidIdNoMatchingRT(){
        RecordTypeService.instance = new STUB_RecordTypeServiceNullModel();

        AccountModelSettingsModel accountModelSettingsModel = new AccountModelSettingsModel('000000000000000000',
                                                                                            '000000000000000000',
                                                                                            '000000000000000000');

        RecordTypeModel recordTypeModel = new RecordTypeModel('000000000000000123',
                                                              'Different Account Name',
                                                              'differentAccountDevName',
                                                              true);

        Map<Id, RecordTypeModel> recordTypeModelsById = new Map<Id, RecordTypeModel>{recordTypeModel.id => recordTypeModel};

        Test.startTest();
        HealthCheckGroupVModel healthCheckGroupVModel = 
            AccountModelHealthCheckVMapper.getInstance().getAdministrativeAccountModelHealthCheckItems(accountModelSettingsModel, recordTypeModelsById);
        Test.stopTest();

        AccountModelHealthCheckVMapper_TEST.verifyHealthCheckGroupVModelAssertions(Label.stgHealthCheckAccountModel,
                                                                                   Label.stgHealthCheckStatusFailed,
                                                                                   0,
                                                                                   1,
                                                                                   0,
                                                                                   1,
                                                                                   healthCheckGroupVModel);

        String expectedDescription = StringHandlingService.getInstance().formatStringWithApostrophesAndParameters(
            Label.stgHCRecordTypeNotFound, 
            new List<Object>{'000000000000000000'}
        );
        String expectedFix = StringHandlingService.getInstance().formatStringWithApostrophesAndParameters(
            Label.stgHCAccountModelAdminNotFoundFix, 
            new List<Object>{'000000000000000000'}
        );
        
        AccountModelHealthCheckVMapper_TEST.verifyHealthCheckItemListAssertions(Label.stgAdminAccountRecordType, 
                                                                                'Fail', 
                                                                                Label.stgHealthCheckStatusFailed, 
                                                                                expectedDescription, 
                                                                                expectedFix, 
                                                                                healthCheckGroupVModel.healthCheckItemList);
    }

    /**************************************************************************************************************************
    * @description Test to verify getHouseholdAccountModelHealthCheckItems() returns a HealthCheckGroupVModel with a status of
    * pass when the ID provided as the household AccountModel Id in AccountSettingsModel is valid and matches to a RT for HH 
    * Account Modelthat is valid and active.
    **************************************************************************************************************************/ 
    @isTest
    private static void getHouseholdAccountModelHealthCheckItemsIdMatchFoundToRTValidAndActive(){
        RecordTypeService.instance = new STUB_RecordTypeServiceValidAndActiveDefaultModel();

        AccountModelSettingsModel accountModelSettingsModel = new AccountModelSettingsModel('000000000000000001',
                                                                                            '000000000000000002',
                                                                                            '000000000000000003');

        RecordTypeModel recordTypeModel = new RecordTypeModel('000000000000000003',
                                                              'Test Record Name',
                                                              'testRecordDevName',
                                                              true);
                          
        Map<Id, RecordTypeModel> recordTypeModelsById = new Map<Id, RecordTypeModel>{recordTypeModel.id => recordTypeModel};

        Test.startTest();
        HealthCheckGroupVModel healthCheckGroupVModel = 
            AccountModelHealthCheckVMapper.getInstance().getHouseholdAccountModelHealthCheckItems(accountModelSettingsModel, recordTypeModelsById);
        Test.stopTest();

        AccountModelHealthCheckVMapper_TEST.verifyHealthCheckGroupVModelAssertions(Label.stgHealthCheckAccountModel,
                                                                                   Label.stgHealthCheckStatusPassed,
                                                                                   1,
                                                                                   1,
                                                                                   0,
                                                                                   1,
                                                                                   healthCheckGroupVModel);

        String expectedDescription = StringHandlingService.getInstance().formatStringWithApostrophesAndParameters(
            Label.stgHCRecordTypeValid, 
            new List<Object>{'Test Record Name', 'testRecordDevName'}
        );
        String expectedFix = Label.stgHealthCheckFixNotApplicable;
        
        AccountModelHealthCheckVMapper_TEST.verifyHealthCheckItemListAssertions(Label.stgAccountRecordTypeSupportsHHAddress, 
                                                                                'Pass', 
                                                                                Label.stgHealthCheckStatusPassed, 
                                                                                expectedDescription, 
                                                                                expectedFix, 
                                                                                healthCheckGroupVModel.healthCheckItemList);
    }

    /**************************************************************************************************************************
    * @description Test to verify getHouseholdAccountModelHealthCheckItems() returns a HealthCheckGroupVModel with a status of
    * fail when the ID provided as the householdAccountModel Id in AccountSettingsModel is valid and matches to a RT for HH 
    * Account Model that is valid, but inactive.
    **************************************************************************************************************************/ 
    @isTest
    private static void getHouseholdAccountModelHealthCheckItemsIdMatchFoundToRTValidAndInactive(){
        RecordTypeService.instance = new STUB_RecordTypeServiceValidAndInactiveDefaultModel();

        AccountModelSettingsModel accountModelSettingsModel = new AccountModelSettingsModel('000000000000000001',
                                                                                            '000000000000000002',
                                                                                            '000000000000000003');

        RecordTypeModel recordTypeModel = new RecordTypeModel('000000000000000003',
                                                              'Test HH Record Name',
                                                              'testHHRecordDevName',
                                                              false);

        Map<Id, RecordTypeModel> recordTypeModelsById = new Map<Id, RecordTypeModel>{recordTypeModel.id => recordTypeModel};

        Test.startTest();
        HealthCheckGroupVModel healthCheckGroupVModel = 
            AccountModelHealthCheckVMapper.getInstance().getHouseholdAccountModelHealthCheckItems(accountModelSettingsModel, recordTypeModelsById);
        Test.stopTest();

        AccountModelHealthCheckVMapper_TEST.verifyHealthCheckGroupVModelAssertions(Label.stgHealthCheckAccountModel,
                                                                                   Label.stgHealthCheckStatusFailed,
                                                                                   0,
                                                                                   1,
                                                                                   0,
                                                                                   1,
                                                                                   healthCheckGroupVModel);

        String expectedDescription = StringHandlingService.getInstance().formatStringWithApostrophesAndParameters(
            Label.stgHCRecordTypeInactive, 
            new List<Object>{'Test Record Name', 'testRecordDevName'}
        );
        String expectedFix = StringHandlingService.getInstance().formatStringWithApostrophesAndParameters(
            Label.stgHCAccountModelHHInactiveFix, 
            new List<Object>{'Test Record Name', 'testRecordDevName'}
        );
        
        AccountModelHealthCheckVMapper_TEST.verifyHealthCheckItemListAssertions(Label.stgAccountRecordTypeSupportsHHAddress, 
                                                                                'Fail', 
                                                                                Label.stgHealthCheckStatusFailed, 
                                                                                expectedDescription, 
                                                                                expectedFix, 
                                                                                healthCheckGroupVModel.healthCheckItemList);
    }

    /**************************************************************************************************************************
    * @description Test to verify getHouseholdAccountModelHealthCheckItems() returns a HealthCheckGroupVModel with a status of
    * fail when an the ID provided as the administrativeAccountModel Id in AccountSettingsModel is not an ID.
    **************************************************************************************************************************/ 
    @isTest
    private static void getHouseholdAccountModelHealthCheckItemsInvalidDefaultId(){
        RecordTypeService.instance = new STUB_RecordTypeServiceNullModel();

        AccountModelSettingsModel accountModelSettingsModel = new AccountModelSettingsModel('Not an ID default acct',
                                                                                            'Not an ID admin acct',
                                                                                            'Not an ID HH acct');

        RecordTypeModel recordTypeModel = new RecordTypeModel('000000000000000111',
                                                              'Account Name',
                                                              'accountDevName',
                                                              true);

        Map<Id, RecordTypeModel> recordTypeModelsById = new Map<Id, RecordTypeModel>{recordTypeModel.id => recordTypeModel};

        Test.startTest();
        HealthCheckGroupVModel healthCheckGroupVModel = 
            AccountModelHealthCheckVMapper.getInstance().getHouseholdAccountModelHealthCheckItems(accountModelSettingsModel, recordTypeModelsById);
        Test.stopTest();

        AccountModelHealthCheckVMapper_TEST.verifyHealthCheckGroupVModelAssertions(Label.stgHealthCheckAccountModel,
                                                                                   Label.stgHealthCheckStatusFailed,
                                                                                   0,
                                                                                   1,
                                                                                   0,
                                                                                   1,
                                                                                   healthCheckGroupVModel);

        String expectedDescription = StringHandlingService.getInstance().formatStringWithApostrophesAndParameters(
            Label.stgHCRecordTypeNotFound, 
            new List<Object>{'Not an ID HH acct'}
        );
        String expectedFix = StringHandlingService.getInstance().formatStringWithApostrophesAndParameters(
            Label.stgHCAccountModelHHNotFoundFix, 
            new List<Object>{'Not an ID HH acct'}
        );
        
        AccountModelHealthCheckVMapper_TEST.verifyHealthCheckItemListAssertions(Label.stgAccountRecordTypeSupportsHHAddress, 
                                                                                'Fail', 
                                                                                Label.stgHealthCheckStatusFailed, 
                                                                                expectedDescription, 
                                                                                expectedFix, 
                                                                                healthCheckGroupVModel.healthCheckItemList);
    }

    /**************************************************************************************************************************
    * @description Test to verify getHouseholdAccountModelHealthCheckItems() returns a HealthCheckGroupVModel with a status of
    * fail when an invalid RT is specified for Administrative Account Model and the adminAccountModel Id in AccountSettingsModel is a
    * valid ID, but does not match any Ids in the RecordType map.
    **************************************************************************************************************************/ 
    @isTest
    private static void getHouseholdAccountModelHealthCheckItemsValidIdNoMatchingRT(){
        RecordTypeService.instance = new STUB_RecordTypeServiceNullModel();

        AccountModelSettingsModel accountModelSettingsModel = new AccountModelSettingsModel('000000000000000000',
                                                                                            '000000000000000000',
                                                                                            '000000000000000000');

        RecordTypeModel recordTypeModel = new RecordTypeModel('000000000000000123',
                                                              'Different Account Name',
                                                              'differentAccountDevName',
                                                              true);

        Map<Id, RecordTypeModel> recordTypeModelsById = new Map<Id, RecordTypeModel>{recordTypeModel.id => recordTypeModel};

        Test.startTest();
        HealthCheckGroupVModel healthCheckGroupVModel = 
            AccountModelHealthCheckVMapper.getInstance().getHouseholdAccountModelHealthCheckItems(accountModelSettingsModel, recordTypeModelsById);
        Test.stopTest();

        AccountModelHealthCheckVMapper_TEST.verifyHealthCheckGroupVModelAssertions(Label.stgHealthCheckAccountModel,
                                                                                   Label.stgHealthCheckStatusFailed,
                                                                                   0,
                                                                                   1,
                                                                                   0,
                                                                                   1,
                                                                                   healthCheckGroupVModel);

        String expectedDescription = StringHandlingService.getInstance().formatStringWithApostrophesAndParameters(
            Label.stgHCRecordTypeNotFound, 
            new List<Object>{'000000000000000000'}
        );
        String expectedFix = StringHandlingService.getInstance().formatStringWithApostrophesAndParameters(
            Label.stgHCAccountModelHHNotFoundFix, 
            new List<Object>{'000000000000000000'}
        );
        
        AccountModelHealthCheckVMapper_TEST.verifyHealthCheckItemListAssertions(Label.stgAccountRecordTypeSupportsHHAddress, 
                                                                                'Fail', 
                                                                                Label.stgHealthCheckStatusFailed, 
                                                                                expectedDescription, 
                                                                                expectedFix, 
                                                                                healthCheckGroupVModel.healthCheckItemList);
    }

    /**************************************************************************************************************************
    * @description Test to verify getHealthCheckGroup() returns a HealthCheckGroupVModel with a status of
    * passed when valid and active record types are specified for Default, Administrative and Household Account Models and the
    * record types specified for HH and Admin accounts are unique.
    **************************************************************************************************************************/ 
    @isTest
    private static void getHealthCheckGroupValidAndActive(){
        AccountModelSettingsService.instance = new STUB_AccountModelSettingsServiceValidDefaultAccountId();
        RecordTypeService.instance = new STUB_RecordTypeServiceForGetHealtCheckGroupValid();

        Test.startTest();
        HealthCheckGroupVModel hlthChkGroupVModel = AccountModelHealthCheckVMapper.getInstance().getHealthCheckGroup();
        Test.stopTest();

        System.assertEquals(
            Label.stgHealthCheckAccountModel, 
            hlthChkGroupVModel.label, 
            'Label should be \'' + Label.stgHealthCheckAccountModel + '\''
        );
        System.assertEquals(
            Label.stgHealthCheckStatusPassed, 
            hlthChkGroupVModel.status, 
            'Status should be \'' + Label.stgHealthCheckStatusPassed + '\''
        );
        System.assertEquals(
            4, 
            hlthChkGroupVModel.healthCheckItemList.size(), 
            'Should contain Health Check Items for Default, Admin and HH Account models and Admin and HH Account Uniqueness.'
        );
    }

    /**************************************************************************************************************************
    * @description Test to verify getHealthCheckGroup() returns a HealthCheckGroupVModel with a status of
    * failed when a valid, but inactive record type is specified for Default Account Model.
    **************************************************************************************************************************/ 
    @isTest
    private static void getHealthCheckGroupValidAndInactive(){
        AccountModelSettingsService.instance = new STUB_AccountModelSettingsServiceValidDefaultAccountId();
        RecordTypeService.instance = new STUB_RecordTypeServiceValidAndInactiveDefaultModel();

        Test.startTest();
        HealthCheckGroupVModel hlthChkGroupVModel = AccountModelHealthCheckVMapper.getInstance().getHealthCheckGroup();
        Test.stopTest();

        System.assertEquals(
            Label.stgHealthCheckAccountModel, 
            hlthChkGroupVModel.label, 
            'Label should be \'' + Label.stgHealthCheckAccountModel + '\''
        );
        System.assertEquals(
            Label.stgHealthCheckStatusFailed, 
            hlthChkGroupVModel.status, 
            'Status should be \'' + Label.stgHealthCheckStatusFailed + '\''
        );
        System.assertEquals(
            4, 
            hlthChkGroupVModel.healthCheckItemList.size(), 
            'Should contain Health Check Items for Default, Admin and HH Account models and Admin and HH Account Uniqueness.'
        );
    }

    /**************************************************************************************************************************
    * @description Test to verify getHealthCheckGroup() returns a HealthCheckGroupVModel with a status of
    * failed when a record type id that is not an ID is specified for Default Account Model.
    **************************************************************************************************************************/ 
    @isTest
    private static void getHealthCheckGroupInvalidIdSpecified(){
        AccountModelSettingsService.instance = new STUB_AccountModelSettingsServiceInvalidDefaultAccountId();
        RecordTypeService.instance = new STUB_RecordTypeServiceForGetHealtCheckGroupInvalid();

        Test.startTest();
        HealthCheckGroupVModel hlthChkGroupVModel = AccountModelHealthCheckVMapper.getInstance().getHealthCheckGroup();
        Test.stopTest();

        System.assertEquals(
            Label.stgHealthCheckAccountModel, 
            hlthChkGroupVModel.label, 
            'Label should be \'' + Label.stgHealthCheckAccountModel + '\''
        );
        System.assertEquals(
            Label.stgHealthCheckStatusFailed, 
            hlthChkGroupVModel.status, 
            'Status should be \'' + Label.stgHealthCheckStatusFailed + '\''
        );
        System.assertEquals(
            4, 
            hlthChkGroupVModel.healthCheckItemList.size(), 
            'Should contain Health Check Items for Default, Admin and HH Account models and Admin and HH Account Uniqueness.'
        );
    }

    /**************************************************************************************************************************
    * @description Test to verify getHealthCheckGroup() returns a HealthCheckGroupVModel with a status of
    * failed when a record type id that is not an ID is specified for Default Account Model.
    **************************************************************************************************************************/ 
    @isTest
    private static void getHealthCheckGroupNotAnIdSpecified(){
        AccountModelSettingsService.instance = new STUB_AccountModelSettingsServiceNotId();
        RecordTypeService.instance = new STUB_RecordTypeServiceForGetHealtCheckGroupValid();

        Test.startTest();
        HealthCheckGroupVModel hlthChkGroupVModel = AccountModelHealthCheckVMapper.getInstance().getHealthCheckGroup();
        Test.stopTest();

        System.assertEquals(
            Label.stgHealthCheckAccountModel, 
            hlthChkGroupVModel.label, 
            'Label should be \'' + Label.stgHealthCheckAccountModel + '\''
        );
        System.assertEquals(
            Label.stgHealthCheckStatusFailed, 
            hlthChkGroupVModel.status, 
            'Status should be \'' + Label.stgHealthCheckStatusFailed + '\''
        );
        System.assertEquals(
            4, 
            hlthChkGroupVModel.healthCheckItemList.size(), 
            'Should contain Health Check Items for Default, Admin and HH Account models and Admin and HH Account Uniqueness.'
        );
    }

    /**************************************************************************************************************************
    * @description Test to verify getHealthCheckGroup() returns a HealthCheckGroupVModel with a status of
    * failed when Admin and HH account record types are the same.
    **************************************************************************************************************************/ 
    @isTest
    private static void getHealthCheckGroupNotUnique(){
        AccountModelSettingsService.instance = new STUB_AccountModelSettingsServiceNotUnique();
        RecordTypeService.instance = new STUB_RecordTypeServiceForGetHealtCheckGroupValid();

        Test.startTest();
        HealthCheckGroupVModel hlthChkGroupVModel = AccountModelHealthCheckVMapper.getInstance().getHealthCheckGroup();
        Test.stopTest();

        System.assertEquals(
            Label.stgHealthCheckAccountModel, 
            hlthChkGroupVModel.label, 
            'Label should be \'' + Label.stgHealthCheckAccountModel + '\''
        );
        System.assertEquals(
            Label.stgHealthCheckStatusFailed, 
            hlthChkGroupVModel.status, 
            'Status should be \'' + Label.stgHealthCheckStatusFailed + '\''
        );
        System.assertEquals(
            4, 
            hlthChkGroupVModel.healthCheckItemList.size(), 
            'Should contain Health Check Items for Default, Admin and HH Account models and Admin and HH Account Uniqueness.'
        );
    }

    /**************************************************************************************************************************
    * @description Test to verify getAccountRecordTypeUniquenessHealthCheckItems() returns a HealthCheckGroupVModel with a status of
    * passed when Admin and HH account record types are not the same.
    **************************************************************************************************************************/ 
    private static void getHouseholdAccountModelHealthCheckItemsUnique(){
        AccountModelSettingsModel accountModelSettingsModel = new AccountModelSettingsModel('000000000000000001',
                                                                                '000000000000000002',
                                                                                '000000000000000003');

        Test.startTest();
        HealthCheckGroupVModel healthCheckGroupVModel = 
            AccountModelHealthCheckVMapper.getInstance().getAccountRecordTypeUniquenessHealthCheckItems(accountModelSettingsModel);
        Test.stopTest();

        AccountModelHealthCheckVMapper_TEST.verifyHealthCheckGroupVModelAssertions(Label.stgHealthCheckAccountModel,
                                                                                   Label.stgHealthCheckStatusPassed,
                                                                                   1,
                                                                                   1,
                                                                                   0,
                                                                                   1,
                                                                                   healthCheckGroupVModel);

        String expectedDescription = Label.stgHCAccountRecordTypesUnique;
        String expectedFix = Label.stgHealthCheckFixNotApplicable;
        
        AccountModelHealthCheckVMapper_TEST.verifyHealthCheckItemListAssertions(Label.stgHCAccountRecordTypeSettingsUnique, 
                                                                                'Pass', 
                                                                                Label.stgHealthCheckStatusPassed, 
                                                                                expectedDescription, 
                                                                                expectedFix, 
                                                                                healthCheckGroupVModel.healthCheckItemList);
    }

    /**************************************************************************************************************************
    * @description Test to verify getAccountRecordTypeUniquenessHealthCheckItems() returns a HealthCheckGroupVModel with a status of
    * failed when Admin and HH account record types are the same.
    **************************************************************************************************************************/ 
    private static void getHouseholdAccountModelHealthCheckItemsNotUnique(){
        AccountModelSettingsModel accountModelSettingsModel = new AccountModelSettingsModel('000000000000000001',
                                                                                            '000000000000000005',
                                                                                            '000000000000000005');

        Test.startTest();
        HealthCheckGroupVModel healthCheckGroupVModel = 
            AccountModelHealthCheckVMapper.getInstance().getAccountRecordTypeUniquenessHealthCheckItems(accountModelSettingsModel);
        Test.stopTest();

        AccountModelHealthCheckVMapper_TEST.verifyHealthCheckGroupVModelAssertions(Label.stgHealthCheckAccountModel,
                                                                                   Label.stgHealthCheckStatusFailed,
                                                                                   0,
                                                                                   1,
                                                                                   0,
                                                                                   1,
                                                                                   healthCheckGroupVModel);

        String expectedDescription = Label.stgHCAccountRecordTypesNotUnique;
        String expectedFix = Label.stgHCAccountRecordTypesNotUniqueFix;
        
        AccountModelHealthCheckVMapper_TEST.verifyHealthCheckItemListAssertions(Label.stgHCAccountRecordTypeSettingsUnique, 
                                                                                'Fail', 
                                                                                Label.stgHealthCheckStatusFailed, 
                                                                                expectedDescription, 
                                                                                expectedFix, 
                                                                                healthCheckGroupVModel.healthCheckItemList);
    }

    /**************************************************************************************************************************
    ****************************************************** STUBS **************************************************************
    **************************************************************************************************************************/
    
    /**************************************************************************************************************************************
    * @description Stub class to simulate the response from RecordTypeService to return a valid and active RecordTypeModel from getRecordTypeModelFromMap.
    **************************************************************************************************************************************/ 
    private class STUB_RecordTypeServiceValidAndActiveDefaultModel extends RecordTypeService {
        @TestVisible 
        public override RecordTypeModel getRecordTypeModelFromMap(String recordTypeId, Map<Id, RecordTypeModel> recordTypeModelById) { 
            return new RecordTypeModel('000000000000000001',
                                       'Test Record Name',
                                       'testRecordDevName',
                                       true);
        }
    }

    /**************************************************************************************************************************************
    * @description Stub class to simulate the response from RecordTypeService to return a valid, but inactive RecordTypeModel from getModelByIdMapForSObjectType.
    **************************************************************************************************************************************/ 
    private class STUB_RecordTypeServiceForGetHealtCheckGroupValid extends RecordTypeService {
        public override  Map<Id, RecordTypeModel> getModelByIdMapForSObjectType(Schema.SObjectType sObjectType) {

            Map<Id, RecordTypeModel> accRTModelsById = new Map<Id, RecordTypeModel>();

            RecordTypeModel defaultAccRTModel = new RecordTypeModel('000000000000000001',
                                                                    'Test Record Name',
                                                                    'testRecordDevName',
                                                                    true);
                                                                    
            RecordTypeModel adminAccRTModel = new RecordTypeModel('000000000000000002',
                                                                  'Test Admin Record Name',
                                                                  'testAdminRecordDevName',
                                                                  true);
                                                                    
            RecordTypeModel hhAccRTModel = new RecordTypeModel('000000000000000003',
                                                               'Test HH Record Name',
                                                               'testHHRecordDevName',
                                                               true);
                                                                    
            accRTModelsById.put(defaultAccRTModel.id, defaultAccRTModel);
            accRTModelsById.put(adminAccRTModel.id, adminAccRTModel);
            accRTModelsById.put(hhAccRTModel.id, hhAccRTModel);
            
            return accRTModelsById;
        }
    }

    /**************************************************************************************************************************************
    * @description Stub class to simulate the response from RecordTypeService to return a valid, but inactive RecordTypeModel from getRecordTypeModelFromMap.
    **************************************************************************************************************************************/ 
    private class STUB_RecordTypeServiceValidAndInactiveDefaultModel extends RecordTypeService {
        @TestVisible 
        public override RecordTypeModel getRecordTypeModelFromMap(String recordTypeId, Map<Id, RecordTypeModel> recordTypeModelById) { 
            return new RecordTypeModel('000000000000000001',
                                       'Test Record Name',
                                       'testRecordDevName',
                                       false);
        }
    }

    /**************************************************************************************************************************************
    * @description Stub class to simulate the response from RecordTypeService to return a valid, but inactive RecordTypeModel from getModelByIdMapForSObjectType.
    **************************************************************************************************************************************/ 
    private class STUB_RecordTypeServiceForGetHealtCheckGroupInvalid extends RecordTypeService {
        public override  Map<Id, RecordTypeModel> getModelByIdMapForSObjectType(Schema.SObjectType sObjectType) {
            RecordTypeModel accRTModel = new RecordTypeModel('000000000000000001',
                                                            'Test Record Name',
                                                            'testRecordDevName',
                                                            false);

            return new Map<Id, RecordTypeModel>{accRTModel.id => accRTModel};
        }
    }

    /**************************************************************************************************************************************
    * @description Stub class to simulate the response from RecordTypeService to return null.
    **************************************************************************************************************************************/ 
    private class STUB_RecordTypeServiceNullModel extends RecordTypeService {
        @TestVisible 
        public override RecordTypeModel getRecordTypeModelFromMap(String recordTypeId, Map<Id, RecordTypeModel> recordTypeModelById) { 
            return null;
        }

        public override  Map<Id, RecordTypeModel> getModelByIdMapForSObjectType(Schema.SObjectType sObjectType) {
            return new Map<Id, RecordTypeModel>();
        }
    }

    /**************************************************************************************************************************************
    * @description Stub class to simulate the response from AccountModelSettingsService to return a valid set of account model settings.
    **************************************************************************************************************************************/ 
    private class STUB_AccountModelSettingsServiceValidDefaultAccountId extends AccountModelSettingsService {
        public override AccountModelSettingsModel getAccountModelSettingsModel() {
            return new AccountModelSettingsModel('000000000000000001',
                                                 '000000000000000002',
                                                 '000000000000000003');
        }
    }

    /**************************************************************************************************************************************
    * @description Stub class to simulate the response from AccountModelSettingsService to return a set of invalid account model settings.
    **************************************************************************************************************************************/ 
    private class STUB_AccountModelSettingsServiceInvalidDefaultAccountId extends AccountModelSettingsService {
        public override AccountModelSettingsModel getAccountModelSettingsModel() {
            return new AccountModelSettingsModel('000aaaaaaaaaaaaaaa',
                                                 '000aaaaaaaaaaaaaab',
                                                 '000aaaaaaaaaaaaaac');
        }
    }

    /**************************************************************************************************************************************
    * @description Stub class to simulate the response from AccountModelSettingsService to return a set of account model settings that are not Ids.
    **************************************************************************************************************************************/ 
    private class STUB_AccountModelSettingsServiceNotId extends AccountModelSettingsService {
        public override AccountModelSettingsModel getAccountModelSettingsModel() {
            return new AccountModelSettingsModel('Not an ID 1',
                                                 'Not an ID 2',
                                                 'Not an ID 3');
        }
    }

    /**************************************************************************************************************************************
    * @description Stub class to simulate the response from AccountModelSettingsService to return a set of account model settings with the
    * same RT set for both Admin and HH accounts.
    **************************************************************************************************************************************/ 
    private class STUB_AccountModelSettingsServiceNotUnique extends AccountModelSettingsService {
        public override AccountModelSettingsModel getAccountModelSettingsModel() {
            return new AccountModelSettingsModel('123000000000000001',
                                                 '123000000000000005',
                                                 '123000000000000005');
        }
    }

    /**************************************************************************************************************************
    ************************************************* HELPER METHODS **********************************************************
    **************************************************************************************************************************/

    /**************************************************************************************************************************
    * @description Helper method to validate assertions for HealthCheckGroupVModel tests.
    **************************************************************************************************************************/
    private static void verifyHealthCheckGroupVModelAssertions(String expectedLabel, 
                                                               String expectedStatus, 
                                                               Integer expectedPassedCheckCount, 
                                                               Integer expectedTotalCheckCount, 
                                                               Integer expectedExpandedRowSize, 
                                                               Integer expectedHealthCheckItemListSize,
                                                               HealthCheckGroupVModel healthCheckGroupResult){

        System.assertEquals(expectedLabel, healthCheckGroupResult.label, 'Should have \'' + expectedLabel + '\' label.');
        System.assertEquals(expectedStatus, healthCheckGroupResult.status, 'Should have status of \'' + expectedStatus + '\'.');
        System.assertEquals(expectedPassedCheckCount, healthCheckGroupResult.passedChecks, 'Should have ' + expectedPassedCheckCount + ' passed checks.');
        System.assertEquals(expectedTotalCheckCount, healthCheckGroupResult.totalChecks, 'Should have ' + expectedTotalCheckCount + ' check.');
        System.assertEquals(expectedExpandedRowSize, healthCheckGroupResult.expandedRowsList.size(), 'Should have ' + expectedExpandedRowSize + ' expanded rows.');
        System.assertEquals(expectedHealthCheckItemListSize, healthCheckGroupResult.healthCheckItemList.size(), 'Should have ' + expectedHealthCheckItemListSize + ' health check item.');
    }

    /**************************************************************************************************************************
    * @description Helper method to validate assertions for HealthCheckGroupVModel HealthCheckItems.
    **************************************************************************************************************************/
    private static void verifyHealthCheckItemListAssertions(String expectedSetting,
                                                            String expectedStatus, 
                                                            String expectedStatusLabel,
                                                            String expectedDescription,
                                                            String expectedFix,
                                                            List<HealthCheckItemVModel> healthCheckItemList){

        for (HealthCheckItemVModel healthCheckItemVModel : healthCheckItemList){
            System.assertEquals(expectedSetting, healthCheckItemVModel.setting, 'Health Check Item setting should be \'' + expectedSetting + '\'.');
            System.assertEquals(expectedStatus, healthCheckItemVModel.status, 'Health Check Item status should be \'' + expectedStatus + '\'.');
            System.assertEquals(expectedStatusLabel, healthCheckItemVModel.statusLabel, 'Health Check Item status label should be \'' + expectedStatusLabel + '\'.');
            System.assertEquals(expectedDescription, healthCheckItemVModel.description, 'Health Check Item description should be correctly set.');
            System.assertEquals(expectedFix, healthCheckItemVModel.recommendedFix, 'Health Check Item recommended fix should be correctly set.');
        }        
    }
}
/*
    Copyright (c) 2021, Salesforce.org
    All rights reserved.
    Redistribution and use in source and binary forms, with or without
    modification, are permitted provided that the following conditions are met:
    * Redistributions of source code must retain the above copyright
      notice, this List of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this List of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
    * Neither the name of Salesforce.org nor the names of
      its contributors may be used to endorse or promote products derived
      from this software without specific prior written permission.
    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
    "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
    LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
    FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
    COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
    INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
    BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
    LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
    CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
    LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
    ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
    POSSIBILITY OF SUCH DAMAGE.
*/
/**
* @author Salesforce.org
* @date 2021
* @group 
* @group-content ../../ApexDocContent/Tests.htm
* @description Test class for AffiliationMappingsHealthCheckVMapper class.
*/
@isTest 
public with sharing class AffiliationMappingsHCVMapper_TEST {
    /**************************************************************************************************************************
    * @description Test method to verify that the getInstance method returns a new instance of the 
    * AffiliationMappingsHealthCheckVMapper class when one does not already exist.
    ***************************************************************************************************************************/
    @isTest
    private static void getInstanceNew() {

        Test.startTest();
        AffiliationMappingsHealthCheckVMapper AffiliationMappingsHealthCheckVMapperInstance = 
            AffiliationMappingsHealthCheckVMapper.getInstance();
        Test.stopTest();

        System.assertEquals(AffiliationMappingsHealthCheckVMapper.instance, AffiliationMappingsHealthCheckVMapperInstance, 'Instance of mapper class returned should match static instance variable.');
        System.assertEquals(true, AffiliationMappingsHealthCheckVMapperInstance != null, 'Instance of mapper class should not be null.');
    }

    /**************************************************************************************************************************
    * @description Test method to verify that the getInstance method returns the existing instance of the 
    * AffiliationMappingsHealthCheckVMapper class when one already exists.
    ***************************************************************************************************************************/
    @isTest
    private static void getInstanceExisting() {

        Test.startTest();
        AffiliationMappingsHealthCheckVMapper AffiliationMappingsHealthCheckVMapperInstance1 = 
            AffiliationMappingsHealthCheckVMapper.getInstance();
        AffiliationMappingsHealthCheckVMapper AffiliationMappingsHealthCheckVMapperInstance2 = 
            AffiliationMappingsHealthCheckVMapper.getInstance();
        Test.stopTest();

        System.assertEquals(AffiliationMappingsHealthCheckVMapper.instance, AffiliationMappingsHealthCheckVMapperInstance1, 'Instance of mapper class returned should match static instance variable.');
        System.assertEquals(AffiliationMappingsHealthCheckVMapperInstance1, AffiliationMappingsHealthCheckVMapperInstance2, 'Subsequent retrievals of mapper class instance should return existing instance.');
        System.assertEquals(true, AffiliationMappingsHealthCheckVMapperInstance1 != null, 'Instance of mapper class should not be null.');
    }

    /**************************************************************************************************************************
    * @description Test to verify locateRecordTypeService() returns an instance of the RecordTypeService class.
    **************************************************************************************************************************/ 
    @isTest
    private static void locateRecordTypeServiceValid() {
        Test.startTest();
        RecordTypeService recordTypeServiceInstance = AccountModelHealthCheckVMapper.getInstance().locateRecordTypeService();
        Test.stopTest();

        System.assertEquals(RecordTypeService.getInstance(), recordTypeServiceInstance, 'Should return instance of RecordTypeService class.');
        System.assertEquals(true, recordTypeServiceInstance != null, 'Instance of RecordTypeService class should not be null.');
    }

    /**************************************************************************************************************************
    * @description Test to verify locateAffiliationMappingsService() returns an instance of the AffiliationMappingsService class.
    **************************************************************************************************************************/ 
    @isTest
    private static void locateAffiliationMappingsServiceValid() {
        Test.startTest();
        AffiliationMappingsService AffiliationMappingsServiceInstance = AffiliationMappingsHealthCheckVMapper.getInstance().locateAffiliationMappingsService();
        Test.stopTest();

        System.assertEquals(AffiliationMappingsService.getInstance(), AffiliationMappingsServiceInstance, 'Should return instance of AffiliationMappingsService class.');
        System.assertEquals(true, AffiliationMappingsServiceInstance != null, 'Instance of AffiliationMappingsService class should not be null.');
    }

    /**************************************************************************************************************************
    * @description Test to verify locateLookupFieldService() returns an instance of the LookupFieldService class.
    **************************************************************************************************************************/ 
    @isTest
    private static void locateLookupFieldServiceValid() {
        Test.startTest();
        LookupFieldService LookupFieldServiceInstance = AffiliationMappingsHealthCheckVMapper.getInstance().locateLookupFieldService();
        Test.stopTest();

        System.assertEquals(LookupFieldService.getInstance(), LookupFieldServiceInstance, 'Should return instance of LookupFieldService class.');
        System.assertEquals(true, LookupFieldServiceInstance != null, 'Instance of LookupFieldService class should not be null.');
    }

    /**************************************************************************************************************************
    * @description Test to verify locatePicklistEntryService() returns an instance of the PicklistEntryService class.
    **************************************************************************************************************************/ 
    @isTest
    private static void locatePicklistEntryServiceValid() {
        Test.startTest();
        PicklistEntryService PicklistEntryServiceInstance = AffiliationMappingsHealthCheckVMapper.getInstance().locatePicklistEntryService();
        Test.stopTest();

        System.assertEquals(PicklistEntryService.getInstance(), PicklistEntryServiceInstance, 'Should return instance of PicklistEntryService class.');
        System.assertEquals(true, PicklistEntryServiceInstance != null, 'Instance of PicklistEntryService class should not be null.');
    }

    /**************************************************************************************************************************
    * @description Test to verify locateStringHandlingService() returns an instance of the StringHandlingService class.
    **************************************************************************************************************************/ 
    @isTest
    private static void locateStringHandlingServiceValid() {
        Test.startTest();
        StringHandlingService StringHandlingServiceInstance = AffiliationMappingsHealthCheckVMapper.getInstance().locateStringHandlingService();
        Test.stopTest();

        System.assertEquals(StringHandlingService.getInstance(), StringHandlingServiceInstance, 'Should return instance of StringHandlingService class.');
        System.assertEquals(true, StringHandlingServiceInstance != null, 'Instance of StringHandlingService class should not be null.');
    }

    /***************************************************************************
    * @description Test method to verify that getHealthCheckGroup handles all
    * passed health checks
    ***************************************************************************/
    @isTest
    private static void getHealthCheckGroupAllPassed() {
        AffiliationMappingsService.instance = new STUB_AffiliationMappingsService();
        RecordTypeService.instance = new STUB_RecordTypeService();
        LookupFieldService.instance = new STUB_LookupFieldService();
        PicklistEntryService.instance = new STUB_PicklistEntryServiceRole();

        STUB_AffiliationMappingsHealthCheckVMapperPass AffiliationMappingsHealthCheckVMapperStub =
            new STUB_AffiliationMappingsHealthCheckVMapperPass();
        AffiliationMappingsHealthCheckVMapper.instance = AffiliationMappingsHealthCheckVMapperStub;  

        AffiliationMappingsHealthCheckVMapper AffiliationMappingsHealthCheckVMapper =
            AffiliationMappingsHealthCheckVMapper.getInstance();

        Integer numberOfHealthChecks = 6; //NOTE: Update when adding new Health Check

        Test.startTest();
            HealthCheckGroupVModel healthCheckGroupVModel =
                AffiliationMappingsHealthCheckVMapperStub.getHealthCheckGroup();
        Test.stopTest();

        System.assertEquals(
            Label.stgHealthCheckAffiliationMappings,
            healthCheckGroupVModel.label,
            'Label of returned health check should match expected custom label.'
        );
        System.assertEquals(
            Label.stgHealthCheckStatusPassed,
            healthCheckGroupVModel.status,
            'Status of returned health check should match expected custom label.'
        );
        System.assertEquals(
            numberOfHealthChecks,
            healthCheckGroupVModel.passedChecks,
            'Number of passed checks of returned health check should match expected custom label.'
        );
        System.assertEquals(
            numberOfHealthChecks,
            healthCheckGroupVModel.totalChecks,
            'Number of total checks of returned health check should match expected custom label.'
        );
        System.assertEquals(
            0,
            healthCheckGroupVModel.expandedRowsList.size(),
            'No health checks should fail, making expanded rows list size 0.'
        );
        System.assertEquals(
            numberOfHealthChecks,
            healthCheckGroupVModel.healthCheckItemList[0].healthCheckItemList.size(),
            'Number of health check items of returned health check should match total number of health checks.'
        );
    }

    /***************************************************************************
    * @description Test method to verify that getHealthCheckGroup handles all
    * failed health checks
    ***************************************************************************/
    @isTest
    private static void getHealthCheckGroupAllFail() {
        AffiliationMappingsService.instance = new STUB_AffiliationMappingsServiceUnfound();
        RecordTypeService.instance = new STUB_RecordTypeServiceNull();

        STUB_AffiliationMappingsHealthCheckVMapperFail AffiliationMappingsHealthCheckVMapperStub =
            new STUB_AffiliationMappingsHealthCheckVMapperFail();

        AffiliationMappingsHealthCheckVMapper.instance = AffiliationMappingsHealthCheckVMapperStub;  

        AffiliationMappingsHealthCheckVMapper AffiliationMappingsHealthCheckVMapper =
            AffiliationMappingsHealthCheckVMapper.getInstance();

        Integer numberOfHealthChecks = 6; //NOTE: Update when adding new health checks

        Test.startTest();
            HealthCheckGroupVModel healthCheckGroupVModel =
                AffiliationMappingsHealthCheckVMapper.getHealthCheckGroup();
        Test.stopTest();

        System.assertEquals(
            Label.stgHealthCheckAffiliationMappings,
            healthCheckGroupVModel.label,
            'Label of returned health check should match expected custom label.'
        );
        System.assertEquals(
            Label.stgHealthCheckStatusFailed,
            healthCheckGroupVModel.status,
            'Status of returned health check should match expected custom label.'
        );
        System.assertEquals(
            0,
            healthCheckGroupVModel.passedChecks,
            'Number of passed checks should be 0.'
        );
        System.assertEquals(
            numberOfHealthChecks,
            healthCheckGroupVModel.totalChecks,
            'Number of total checks of returned health check should match expected custom label.'
        );
        System.assertEquals(
            1,
            healthCheckGroupVModel.expandedRowsList.size(),
            'All health checks should fail, making expanded rows list size 1.'
        );
        System.assertEquals(
            numberOfHealthChecks,
            healthCheckGroupVModel.healthCheckItemList[0].healthCheckItemList.size(),
            'Number of health check items of returned health check should match total number of health checks.'
        );
    }

    /*****************************************************************************************
    * @description Test method to verify getValidRecordTypeHealthCheckGroupVModel returns a 
    * HealthCheckGroupVModel with a Passed status when an affiliation mapping is mapped to
    * an Account record type that is valid and active.
    *****************************************************************************************/
    @isTest 
    private static void getValidRecordTypeHealthCheckGroupVModelValid() {
        RecordTypeService.instance = new STUB_RecordTypeService();
        AffiliationMappingsHealthCheckVMapper afflMappingHealthCheckVMapperInstance = 
            AffiliationMappingsHealthCheckVMapper.getInstance();

        List<AffiliationMappingsModel> affiliationMappingsModelsList = new List<AffiliationMappingsModel> {
            new AffiliationMappingsModel(
                'Test Affiliation Mapping',
                'Active RecordType Label',
                'Test Primary Field',
                true,
                'Test Status',
                'Test Role'
            )
        };

        Test.startTest();
        HealthCheckGroupVModel healthCheckGroupVModelResult = 
            afflMappingHealthCheckVMapperInstance.getValidRecordTypeHealthCheckGroupVModel(
                affiliationMappingsModelsList[0],
                new RecordTypeModel(
                    '000000000000000006',
                    'Active RecordType Label',
                    'activeRTDevName',
                    true
                )
            );
        Test.stopTest();

        AffiliationMappingsHCVMapper_TEST.validateHCGroupAssertions(
            healthCheckGroupVModelResult,
            Label.stgHealthCheckAffiliationMappings,
            Label.stgHealthCheckStatusPassed,
            1,
            1,
            0,
            1
        );

        AffiliationMappingsHCVMapper_TEST.validateHCItemAssertions(
            healthCheckGroupVModelResult,
            Label.stgHCAfflMapAccRecordTypeTitle,
            'Pass',
            Label.stgHealthCheckStatusPassed,
            StringHandlingService.getInstance().formatStringWithApostrophesAndParameters(
                Label.stgHCRecordTypeValid, 
                new List<Object> {'Active RecordType Label', 'activeRTDevName'}
            ),
            Label.stgHealthCheckFixNotApplicable,
            0
        );
    }

    /*****************************************************************************************
    * @description Test method to verify getValidRecordTypeHealthCheckGroupVModel returns a 
    * HealthCheckGroupVModel with a Failed status when an affiliation mapping is mapped to
    * an Account record type that is valid, but inactive.
    *****************************************************************************************/
    @isTest 
    private static void getValidRecordTypeHealthCheckGroupVModelInactiveRT() {
        RecordTypeService.instance = new STUB_RecordTypeServiceInactive();
        AffiliationMappingsHealthCheckVMapper afflMappingHealthCheckVMapperInstance = 
            AffiliationMappingsHealthCheckVMapper.getInstance();

        List<AffiliationMappingsModel> affiliationMappingsModelsList = new List<AffiliationMappingsModel> {
            new AffiliationMappingsModel(
                'Test Affiliation Mapping',
                'inactiveRTDevName',
                'Test Primary Field',
                true,
                'Test Status',
                'Test Role'
            )
        };

        Test.startTest();
        HealthCheckGroupVModel healthCheckGroupVModelResult = 
            afflMappingHealthCheckVMapperInstance.getValidRecordTypeHealthCheckGroupVModel(
                affiliationMappingsModelsList[0],
                new RecordTypeModel(
                    '000000000000000005',
                    'Inactive RecordType Label',
                    'inactiveRTDevName',
                    false
                )
            );
        Test.stopTest();

        AffiliationMappingsHCVMapper_TEST.validateHCGroupAssertions(
            healthCheckGroupVModelResult,
            Label.stgHealthCheckAffiliationMappings,
            Label.stgHealthCheckStatusFailed,
            0,
            1,
            0,
            1
        );

        AffiliationMappingsHCVMapper_TEST.validateHCItemAssertions(
            healthCheckGroupVModelResult,
            Label.stgHCAfflMapAccRecordTypeTitle,
            'Fail',
            Label.stgHealthCheckStatusFailed,
            StringHandlingService.getInstance().formatStringWithApostrophesAndParameters(
                Label.stgHCRecordTypeInactive, 
                new List<Object> {'Inactive RecordType Label', 'inactiveRTDevName'}
            ),
            StringHandlingService.getInstance().formatStringWithApostrophesAndParameters(
                Label.stgHCAfflMapAccRecordTypeInactiveFix, 
                new List<Object> {'Inactive RecordType Label', 'inactiveRTDevName'}
            ),
            0
        );  
    }

    /*****************************************************************************************
    * @description Test method to verify getValidRecordTypeHealthCheckGroupVModel returns a 
    * HealthCheckGroupVModel with a Failed status when an affiliation mapping contains a
    * value that does not match a record type by name or label.
    *****************************************************************************************/
    @isTest 
    private static void getValidRecordTypeHealthCheckGroupVModelNonExistentRT() {
        RecordTypeService.instance = new STUB_RecordTypeServiceNull();
        AffiliationMappingsHealthCheckVMapper afflMappingHealthCheckVMapperInstance = 
            AffiliationMappingsHealthCheckVMapper.getInstance();

        List<AffiliationMappingsModel> affiliationMappingModelsList = new List<AffiliationMappingsModel>{
            new AffiliationMappingsModel(
                'Test Affiliation Mapping',
                'Non Existent Record Type Name', 
                'Test Primary Field',
                true,
                'Test Status',
                'Test Role'
            )
        };

        Test.startTest();
        HealthCheckGroupVModel healthCheckGroupVModelResult = 
            afflMappingHealthCheckVMapperInstance.getValidRecordTypeHealthCheckGroupVModel(
                affiliationMappingModelsList[0],
                null
            );
        Test.stopTest();

        AffiliationMappingsHCVMapper_TEST.validateHCGroupAssertions(
            healthCheckGroupVModelResult,
            Label.stgHealthCheckAffiliationMappings,
            Label.stgHealthCheckStatusFailed,
            0,
            1,
            0,
            1
        );

        AffiliationMappingsHCVMapper_TEST.validateHCItemAssertions(
            healthCheckGroupVModelResult,
            Label.stgHCAfflMapAccRecordTypeTitle,
            'Fail',
            Label.stgHealthCheckStatusFailed,
            StringHandlingService.getInstance().formatStringWithApostrophesAndParameters(
                Label.stgHCRecordTypeNotFound, 
                new List<Object>{affiliationMappingModelsList[0].accountRecordTypeFieldValue} 
            ),
            StringHandlingService.getInstance().formatStringWithApostrophesAndParameters(
                Label.stgHCAfflMapAccRecordTypeNotFoundFix, 
                new List<Object>{affiliationMappingModelsList[0].accountRecordTypeFieldValue}
            ),
            0
        ); 
    }

    /*****************************************************************************************
    * @description Test method to verify getAccountRecordTypeUniquenessHealthCheckGroupVModel returns a 
    * HealthCheckGroupVModel with a Passed status when a valid and active account record type is unique
    * in Affiliation Mappings
    *****************************************************************************************/
    @isTest 
    private static void getAccountRecordTypeUniquenessHealthCheckGroupVModelValid() {
        RecordTypeService.instance = new STUB_RecordTypeService();
        AffiliationMappingsHealthCheckVMapper afflMappingHealthCheckVMapperInstance = 
            AffiliationMappingsHealthCheckVMapper.getInstance();

        List<AffiliationMappingsModel> affiliationMappingsModelsList = new List<AffiliationMappingsModel> {
            new AffiliationMappingsModel(
                'Test Affiliation Mapping',
                'Active RecordType Label',
                'Test Primary Field',
                true,
                'Test Status',
                'Test Role'
            ),
            new AffiliationMappingsModel(
                'Test Affiliation Mapping2',
                'Active RecordType Label2',
                'Test Primary Field2',
                true,
                'Test Status',
                'Test Role'
            )
        };

        Test.startTest();
        HealthCheckGroupVModel healthCheckGroupVModelResult = 
            afflMappingHealthCheckVMapperInstance.getAccountRecordTypeUniquenessHealthCheckGroupVModel(
                affiliationMappingsModelsList[0],
                new RecordTypeModel(
                    '000000000000000006',
                    'Active RecordType Label',
                    'activeRTDevName',
                    true
                ),
                new Set<Id>()
            );
        Test.stopTest();

        AffiliationMappingsHCVMapper_TEST.validateHCGroupAssertions(
            healthCheckGroupVModelResult,
            Label.stgHealthCheckAffiliationMappings,
            Label.stgHealthCheckStatusPassed,
            1,
            1,
            0,
            1
        );

        AffiliationMappingsHCVMapper_TEST.validateHCItemAssertions(
            healthCheckGroupVModelResult,
            Label.stgHCAfflMapAccRecordTypeUniqueTitle,
            'Pass',
            Label.stgHealthCheckStatusPassed,
            StringHandlingService.getInstance().formatStringWithApostrophesAndParameters(
                Label.stgHCAfflMapAccRecordTypeUnique, 
                new List<Object> {'Active RecordType Label', 'activeRTDevName'}
            ),
            Label.stgHealthCheckFixNotApplicable,
            0
        );
    }

    /*****************************************************************************************
    * @description Test method to verify getAccountRecordTypeUniquenessHealthCheckGroupVModel returns a 
    * HealthCheckGroupVModel with a Failed status when the account record type does not exist
    *****************************************************************************************/
    @isTest 
    private static void getAccountRecordTypeUniquenessHealthCheckGroupVModelRTNonExistent() {
        RecordTypeService.instance = new STUB_RecordTypeServiceNull();
        AffiliationMappingsHealthCheckVMapper afflMappingHealthCheckVMapperInstance = 
            AffiliationMappingsHealthCheckVMapper.getInstance();

        List<AffiliationMappingsModel> affiliationMappingsModelsList = new List<AffiliationMappingsModel>{
            new AffiliationMappingsModel(
                'Test Affiliation Mapping',
                'Non Existent Record Type Name', 
                'Test Primary Field',
                true,
                'Test Status',
                'Test Role'
            ),
            new AffiliationMappingsModel(
                'Test Affiliation Mapping2',
                'Active RecordType Label2',
                'Test Primary Field2',
                true,
                'Test Status',
                'Test Role'
            )
        };

        Test.startTest();
        HealthCheckGroupVModel healthCheckGroupVModelResult = 
            afflMappingHealthCheckVMapperInstance.getAccountRecordTypeUniquenessHealthCheckGroupVModel(
                affiliationMappingsModelsList[0],
                null,
                new Set<Id>()
            );
        Test.stopTest();

        AffiliationMappingsHCVMapper_TEST.validateHCGroupAssertions(
            healthCheckGroupVModelResult,
            Label.stgHealthCheckAffiliationMappings,
            Label.stgHealthCheckStatusFailed,
            0,
            1,
            0,
            1
        );

        AffiliationMappingsHCVMapper_TEST.validateHCItemAssertions(
            healthCheckGroupVModelResult,
            Label.stgHCAfflMapAccRecordTypeUniqueTitle,
            'Fail',
            Label.stgHealthCheckStatusFailed,
            StringHandlingService.getInstance().formatStringWithApostrophesAndParameters(
                Label.stgHCRecordTypeNotFound, 
                new List<Object>{affiliationMappingsModelsList[0].accountRecordTypeFieldValue} 
            ),
            StringHandlingService.getInstance().formatStringWithApostrophesAndParameters(
                Label.stgHCAfflMapAccRecordTypeNotFoundFix, 
                new List<Object>{affiliationMappingsModelsList[0].accountRecordTypeFieldValue}
            ),
            0
        ); 
    }

    /*****************************************************************************************
    * @description Test method to verify getAccountRecordTypeUniquenessHealthCheckGroupVModel returns a 
    * HealthCheckGroupVModel with a Failed status when the account record type is inactive
    *****************************************************************************************/
    @isTest 
    private static void getAccountRecordTypeUniquenessHealthCheckGroupVModelRTInactive() {
        RecordTypeService.instance = new STUB_RecordTypeServiceInactive();
        AffiliationMappingsHealthCheckVMapper afflMappingHealthCheckVMapperInstance = 
            AffiliationMappingsHealthCheckVMapper.getInstance();

        List<AffiliationMappingsModel> affiliationMappingsModelsList = new List<AffiliationMappingsModel> {
            new AffiliationMappingsModel(
                'Test Affiliation Mapping',
                'inactiveRTDevName',
                'Test Primary Field',
                true,
                'Test Status',
                'Test Role'
            ),
            new AffiliationMappingsModel(
                'Test Affiliation Mapping2',
                'Active RecordType Label2',
                'Test Primary Field2',
                true,
                'Test Status',
                'Test Role'
            )
        };

        Test.startTest();
        HealthCheckGroupVModel healthCheckGroupVModelResult = 
            afflMappingHealthCheckVMapperInstance.getAccountRecordTypeUniquenessHealthCheckGroupVModel(
                affiliationMappingsModelsList[0],
                new RecordTypeModel(
                    '000000000000000005',
                    'Inactive RecordType Label',
                    'inactiveRTDevName',
                    false
                ),
                new Set<Id>()
            );
        Test.stopTest();

        AffiliationMappingsHCVMapper_TEST.validateHCGroupAssertions(
            healthCheckGroupVModelResult,
            Label.stgHealthCheckAffiliationMappings,
            Label.stgHealthCheckStatusFailed,
            0,
            1,
            0,
            1
        );

        AffiliationMappingsHCVMapper_TEST.validateHCItemAssertions(
            healthCheckGroupVModelResult,
            Label.stgHCAfflMapAccRecordTypeUniqueTitle,
            'Fail',
            Label.stgHealthCheckStatusFailed,
            StringHandlingService.getInstance().formatStringWithApostrophesAndParameters(
                Label.stgHCRecordTypeInactive, 
                new List<Object> {'Inactive RecordType Label', 'inactiveRTDevName'}
            ),
            StringHandlingService.getInstance().formatStringWithApostrophesAndParameters(
                Label.stgHCAfflMapAccRecordTypeInactiveFix, 
                new List<Object> {'Inactive RecordType Label', 'inactiveRTDevName'}
            ),
            0
        );
    }

    /*****************************************************************************************
    * @description Test method to verify getAccountRecordTypeUniquenessHealthCheckGroupVModel returns a 
    * HealthCheckGroupVModel with a Failed status when a valid and active account record type is not unique
    * in Affiliation Mappings
    *****************************************************************************************/
    @isTest 
    private static void getAccountRecordTypeUniquenessHealthCheckGroupVModelValidDuplicate() {
        RecordTypeService.instance = new STUB_RecordTypeService();
        AffiliationMappingsHealthCheckVMapper afflMappingHealthCheckVMapperInstance = 
            AffiliationMappingsHealthCheckVMapper.getInstance();

        List<AffiliationMappingsModel> affiliationMappingsModelsList = new List<AffiliationMappingsModel> {
            new AffiliationMappingsModel(
                'Test Affiliation Mapping',
                'Active RecordType Label',
                'Test Primary Field',
                true,
                'Test Status',
                'Test Role'
            ),
            new AffiliationMappingsModel(
                'Test Affiliation Mapping2',
                'Active RecordType Label',
                'Test Primary Field2',
                true,
                'Test Status',
                'Test Role'
            )
        };

        Test.startTest();
        HealthCheckGroupVModel healthCheckGroupVModelResult = 
            afflMappingHealthCheckVMapperInstance.getAccountRecordTypeUniquenessHealthCheckGroupVModel(
                affiliationMappingsModelsList[0],
                new RecordTypeModel(
                    '000000000000000006',
                    'Active RecordType Label',
                    'activeRTDevName',
                    true
                ),
                new Set<Id>{'000000000000000006'}
            );
        Test.stopTest();

        AffiliationMappingsHCVMapper_TEST.validateHCGroupAssertions(
            healthCheckGroupVModelResult,
            Label.stgHealthCheckAffiliationMappings,
            Label.stgHealthCheckStatusFailed,
            0,
            1,
            0,
            1
        );

        AffiliationMappingsHCVMapper_TEST.validateHCItemAssertions(
            healthCheckGroupVModelResult,
            Label.stgHCAfflMapAccRecordTypeUniqueTitle,
            'Fail',
            Label.stgHealthCheckStatusFailed,
            StringHandlingService.getInstance().formatStringWithApostrophesAndParameters(
                Label.stgHCAfflMapAccRecordTypeNotUnique, 
                new List<Object> {'Active RecordType Label', 'activeRTDevName'}
            ),
            StringHandlingService.getInstance().formatStringWithApostrophesAndParameters(
                Label.stgHCAfflMapAccRecordTypeUniqueFix, 
                new List<Object> {'Active RecordType Label', 'activeRTDevName'}
            ),
            0
        );
    }

    /*****************************************************************************************
    * @description Test method to verify getValidContactPrimaryFieldHealthCheckGroupVModel returns a 
    * HealthCheckGroupVModel with a Passed status when an Primary Affilition field specified
    * in affiliation mappings matches the developer name of a field that corresponds to a  
    * lookup to Account on Contact. 
    *****************************************************************************************/
    @isTest 
    private static void getValidContactPrimaryFieldHealthCheckGroupVModelValidByName() {
        LookupFieldService.instance = new STUB_LookupFieldServiceDevNameMatch();

        AffiliationMappingsHealthCheckVMapper afflMappingHealthCheckVMapperInstance = 
            AffiliationMappingsHealthCheckVMapper.getInstance();

        List<AffiliationMappingsModel> affiliationMappingsModelsList = new List<AffiliationMappingsModel> {
            new AffiliationMappingsModel(
                'Test Affiliation Mapping',
                'Test Record Type Name', 
                'Valid Contact Lookup Field Name',
                true,
                'Test Status',
                'Test Role'
            )
        };

        LookupFieldModel expectedLookupFieldModel = 
            new LookupFieldModel(
                'Valid Contact Lookup Field Name',
                'Valid Contact Lookup Field Label'
            );

        Test.startTest();
        HealthCheckGroupVModel healthCheckGroupVModelResult = 
            afflMappingHealthCheckVMapperInstance.getValidContactPrimaryFieldHealthCheckGroupVModel(
                affiliationMappingsModelsList[0],
                expectedLookupFieldModel
            );
        Test.stopTest();

        AffiliationMappingsHCVMapper_TEST.validateHCGroupAssertions(
            healthCheckGroupVModelResult,
            Label.stgHealthCheckAffiliationMappings,
            Label.stgHealthCheckStatusPassed,
            1,
            1,
            0,
            1
        );

        AffiliationMappingsHCVMapper_TEST.validateHCItemAssertions(
            healthCheckGroupVModelResult,
            Label.stgHCAfflMapContactPrimaryFieldTitle,  
            'Pass',
            Label.stgHealthCheckStatusPassed,
            StringHandlingService.getInstance().formatStringWithApostrophesAndParameters(
                Label.stgHCAfflMapContactPrimaryFieldValid, 
                new List<Object> {
                    affiliationMappingsModelsList[0].primaryAffiliationField, 
                    expectedLookupFieldModel.name
                }
            ),
            Label.stgHealthCheckFixNotApplicable,
            0
        );
    }

    /*****************************************************************************************
    * @description Test method to verify getValidContactPrimaryFieldHealthCheckGroupVModel returns a 
    * HealthCheckGroupVModel with a Passed status when an Primary Affilition field specified
    * in affiliation mappings matches the label name of a field that corresponds to a  
    * lookup to Account on Contact. 
    *****************************************************************************************/
    @isTest 
    private static void getValidContactPrimaryFieldHealthCheckGroupVModelValidByLabel() {
        LookupFieldService.instance = new STUB_LookupFieldServiceLabelMatch();

        AffiliationMappingsHealthCheckVMapper afflMappingHealthCheckVMapperInstance = 
            AffiliationMappingsHealthCheckVMapper.getInstance();

        List<AffiliationMappingsModel> affiliationMappingsModelsList = new List<AffiliationMappingsModel> {
            new AffiliationMappingsModel(
                'Test Affiliation Mapping',
                'Test Record Type Name', 
                'Valid Contact Lookup Field Name',
                true,
                'Test Status',
                'Test Role'
            )
        };

        LookupFieldModel expectedLookupFieldModel = 
            new LookupFieldModel(
                'Valid Contact Lookup Field Name',
                'Valid Contact Lookup Field Label'
            );

        Test.startTest();
        HealthCheckGroupVModel healthCheckGroupVModelResult = 
            afflMappingHealthCheckVMapperInstance.getValidContactPrimaryFieldHealthCheckGroupVModel(
                affiliationMappingsModelsList[0],
                expectedLookupFieldModel
            );
        Test.stopTest();

        AffiliationMappingsHCVMapper_TEST.validateHCGroupAssertions(
            healthCheckGroupVModelResult,
            Label.stgHealthCheckAffiliationMappings,
            Label.stgHealthCheckStatusPassed,
            1,
            1,
            0,
            1
        );

        AffiliationMappingsHCVMapper_TEST.validateHCItemAssertions(
            healthCheckGroupVModelResult,
            Label.stgHCAfflMapContactPrimaryFieldTitle,  
            'Pass',
            Label.stgHealthCheckStatusPassed,
            StringHandlingService.getInstance().formatStringWithApostrophesAndParameters(
                Label.stgHCAfflMapContactPrimaryFieldValid, 
                new List<Object> {
                    affiliationMappingsModelsList[0].primaryAffiliationField, 
                    expectedLookupFieldModel.name}
            ),
            Label.stgHealthCheckFixNotApplicable,
            0
        );
    }

    /*****************************************************************************************
    * @description Test method to verify getValidContactPrimaryFieldHealthCheckGroupVModel returns a 
    * HealthCheckGroupVModel with a Failed status when mapping specifies a 
    * Primary Affl Field that does not match a field on Contact (by dev name or label name).
    *****************************************************************************************/
    @isTest 
    private static void getValidContactPrimaryFieldHealthCheckGroupVModelNoContactFieldMatch() {
        LookupFieldService.instance = new STUB_LookupFieldServiceNull();

        AffiliationMappingsHealthCheckVMapper afflMappingHealthCheckVMapperInstance = 
            AffiliationMappingsHealthCheckVMapper.getInstance();

        List<AffiliationMappingsModel> affiliationMappingsModelsList = new List<AffiliationMappingsModel> {
            new AffiliationMappingsModel(
                'Test Affiliation Mapping',
                'Test Record Type Name', 
                'Test Primary Field',
                true,
                'Test Status',
                'Test Role'
            )
        };

        Test.startTest();
        HealthCheckGroupVModel healthCheckGroupVModelResult = 
            afflMappingHealthCheckVMapperInstance.getValidContactPrimaryFieldHealthCheckGroupVModel(
                affiliationMappingsModelsList[0],
                null
            );
        Test.stopTest();

        AffiliationMappingsHCVMapper_TEST.validateHCGroupAssertions(
            healthCheckGroupVModelResult,
            Label.stgHealthCheckAffiliationMappings,
            Label.stgHealthCheckStatusFailed,
            0,
            1,
            0,
            1
        );

        AffiliationMappingsHCVMapper_TEST.validateHCItemAssertions(
            healthCheckGroupVModelResult,
            Label.stgHCAfflMapContactPrimaryFieldTitle,
            'Fail',
            Label.stgHealthCheckStatusFailed,
            StringHandlingService.getInstance().formatStringWithApostrophesAndParameters(
                Label.stgHCAfflMapContactPrimaryFieldInvalid, 
                new List<Object> {affiliationMappingsModelsList[0].primaryAffiliationField}
            ),
            StringHandlingService.getInstance().formatStringWithApostrophesAndParameters(
                Label.stgHCAfflMapContPrimaryFieldInvalidFix, 
                new List<Object> {affiliationMappingsModelsList[0].primaryAffiliationField}
            ),
            0
        ); 
    }

    /*****************************************************************************************
    * @description Test method to verify getHealthCheckItemVModelForAffiliationMappingsModel 
    * returns a HealthCheckItemVModel with the key set to affiliationMappingsModel.name when
    * there is no Account record type matching the RT specified in the affiliation mapping.
    *****************************************************************************************/
    @isTest
    private static void getHealthCheckItemVModelForAffiliationMappingsModelValidRT() {
        AffiliationMappingsModel affiliationMappingsModel = new AffiliationMappingsModel(
                'Test Affiliation Mapping',
                '000000000000000007',
                'Test Primary Field',
                true,
                'Test Status',
                'Test Role'
            );

            RecordTypeModel recordTypeModel = new RecordTypeModel(
                '000000000000000007',
                'Active RecordType Name',
                'ActiveRTDevName',
                true
            );

        AffiliationMappingsHealthCheckVMapper affiliationMappingsHealthCheckVMapperInstance = 
            AffiliationMappingsHealthCheckVMapper.getInstance();

        Test.startTest();
        HealthCheckItemVModel healthCheckItemVModel = 
            affiliationMappingsHealthCheckVMapperInstance.getHealthCheckItemVModelForAffiliationMappingsModel( 
                affiliationMappingsModel, 
                recordTypeModel
            );
        Test.stopTest();

        List<String> listForSettingsLabel =
            new List<String>{affiliationMappingsModel.accountRecordTypeFieldValue};
        
        String healthCheckItemSetting = StringHandlingService.getInstance().formatStringWithApostrophesAndParameters(
            Label.stgHCAffiliationMappingSettingHeading,
            listForSettingsLabel
        );
        
        System.assertEquals(affiliationMappingsModel.name, healthCheckItemVModel.key, 'Health check item key should be \'' + affiliationMappingsModel.name + '\'.');
        System.assertEquals(healthCheckItemSetting, healthCheckItemVModel.setting, 'Health check item key should be \'' + healthCheckItemSetting + '\'.');
        System.assertEquals('Pass', healthCheckItemVModel.status, 'Health check item key should be \'Pass\'.');
        System.assertEquals(Label.stgHealthCheckStatusPassed, healthCheckItemVModel.statusLabel, 'Health check item key should be \'' + Label.stgHealthCheckStatusPassed + '\'.');
        System.assertEquals('', healthCheckItemVModel.description, 'Health check item description should be blank.');
        System.assertEquals('', healthCheckItemVModel.recommendedFix, 'Health check item recommended fix should be blank.');
        System.assertEquals(0, healthCheckItemVModel.healthCheckItemList.size(), 'Health check item should not have any child health check items.');
    }
 
    /*****************************************************************************************
    * @description Test method to verify getValidContactPrimaryFieldHealthCheckGroupVModel returns a 
    * HealthCheckGroupVModel with a Failed status when mapping specifies a 
    * Primary Affl Field is empty.
    *****************************************************************************************/
    @isTest 
    private static void getValidContactPrimaryFieldHealthCheckGroupVModelNullField() {
        LookupFieldService.instance = new STUB_LookupFieldServiceNull();

        AffiliationMappingsHealthCheckVMapper afflMappingHealthCheckVMapperInstance = 
            AffiliationMappingsHealthCheckVMapper.getInstance();

        List<AffiliationMappingsModel> affiliationMappingsModelsList = new List<AffiliationMappingsModel> {
            new AffiliationMappingsModel(
                'Test Affiliation Mapping',
                'Test Record Type Name', 
                '',
                true,
                'Test Status',
                'Test Role'
            )
        };

        Test.startTest();
        HealthCheckGroupVModel healthCheckGroupVModelResult = 
            afflMappingHealthCheckVMapperInstance.getValidContactPrimaryFieldHealthCheckGroupVModel(
                affiliationMappingsModelsList[0],
                null
            );
        Test.stopTest();

        AffiliationMappingsHCVMapper_TEST.validateHCGroupAssertions(
            healthCheckGroupVModelResult,
            Label.stgHealthCheckAffiliationMappings,
            Label.stgHealthCheckStatusFailed,
            0,
            1,
            0,
            1
        );

        AffiliationMappingsHCVMapper_TEST.validateHCItemAssertions(
            healthCheckGroupVModelResult,
            Label.stgHCAfflMapContactPrimaryFieldTitle,
            'Fail',
            Label.stgHealthCheckStatusFailed,
            StringHandlingService.getInstance().formatStringWithApostrophesAndParameters(
                Label.stgHCAfflMapContactPrimaryFieldInvalid, 
                new List<Object> {affiliationMappingsModelsList[0].primaryAffiliationField}
            ),
            StringHandlingService.getInstance().formatStringWithApostrophesAndParameters(
                Label.stgHCAfflMapContPrimaryFieldInvalidFix, 
                new List<Object> {affiliationMappingsModelsList[0].primaryAffiliationField}
            ),
            0
        );
    }

    /*****************************************************************************************
    * @description Test method to verify getHealthCheckItemVModelForAffiliationMappingsModel 
    * returns a HealthCheckItemVModel with the key set to affiliationMappingsModel.name when
    * there is no Account record type matching the RT specified in the affiliation mapping.
    *****************************************************************************************/
    @isTest
    private static void getHealthCheckItemVModelForAffiliationMappingsModelNullRT() {
        AffiliationMappingsModel affiliationMappingsModel = new AffiliationMappingsModel(
                'Test Affiliation Mapping',
                '000000000000000007',
                'Test Primary Field',
                true,
                'Test Status',
                'Test Role'
            );

        AffiliationMappingsHealthCheckVMapper affiliationMappingsHealthCheckVMapperInstance = 
            AffiliationMappingsHealthCheckVMapper.getInstance();

        Test.startTest();
        HealthCheckItemVModel healthCheckItemVModel = 
            affiliationMappingsHealthCheckVMapperInstance.getHealthCheckItemVModelForAffiliationMappingsModel( 
                affiliationMappingsModel, 
                null
            );
        Test.stopTest();

        List<String> listForSettingsLabel =
            new List<String>{affiliationMappingsModel.accountRecordTypeFieldValue};
        
        String healthCheckItemSetting = StringHandlingService.getInstance().formatStringWithApostrophesAndParameters(
            Label.stgHCAffiliationMappingSettingHeading,
            listForSettingsLabel
        );
        
        System.assertEquals(affiliationMappingsModel.name, healthCheckItemVModel.key);
        System.assertEquals(healthCheckItemSetting, healthCheckItemVModel.setting);
        System.assertEquals('Pass', healthCheckItemVModel.status);
        System.assertEquals(Label.stgHealthCheckStatusPassed, healthCheckItemVModel.statusLabel);
        System.assertEquals('', healthCheckItemVModel.description);
        System.assertEquals('', healthCheckItemVModel.recommendedFix);
        System.assertEquals(0, healthCheckItemVModel.healthCheckItemList.size());
    }

    /*****************************************************************************************
    * @description Test method to verify getContactPrimaryFieldUniquenessHealthCheckGroupVModel returns a 
    * HealthCheckGroupVModel with a Passed status when a unique Primary Affilition field specified
    * in affiliation mappings matches the developer name of a field that corresponds to a  
    * lookup to Account on Contact. 
    *****************************************************************************************/
    @isTest 
    private static void getContactPrimaryFieldUniquenessHealthCheckGroupVModelValid() {
        LookupFieldService.instance = new STUB_LookupFieldServiceDevNameMatch();

        AffiliationMappingsHealthCheckVMapper afflMappingHealthCheckVMapperInstance = 
            AffiliationMappingsHealthCheckVMapper.getInstance();

        List<AffiliationMappingsModel> affiliationMappingsModelsList = new List<AffiliationMappingsModel> {
            new AffiliationMappingsModel(
                'Test Affiliation Mapping',
                'Test Record Type Name', 
                'Valid Contact Lookup Field Name',
                true,
                'Test Status',
                'Test Role'
            )
        };

        Test.startTest();
        HealthCheckGroupVModel healthCheckGroupVModelResult = 
            afflMappingHealthCheckVMapperInstance.getContactPrimaryFieldUniquenessHealthCheckGroupVModel(
                affiliationMappingsModelsList[0],
                new LookupFieldModel(
                    'Valid Contact Lookup Field Name',
                    'Valid Contact Lookup Field Label'
                ),
                new Set<String>()
            );
        Test.stopTest();

        AffiliationMappingsHCVMapper_TEST.validateHCGroupAssertions(
            healthCheckGroupVModelResult,
            Label.stgHealthCheckAffiliationMappings,
            Label.stgHealthCheckStatusPassed,
            1,
            1,
            0,
            1
        );

        AffiliationMappingsHCVMapper_TEST.validateHCItemAssertions(
            healthCheckGroupVModelResult,
            Label.stgHCAfflMapContPrimaryFieldUniqueTitle,  
            'Pass',
            Label.stgHealthCheckStatusPassed,
            StringHandlingService.getInstance().formatStringWithApostrophesAndParameters(
                Label.stgHCAfflMapContactPrimaryFieldUnique, 
                new List<Object> {
                    'Valid Contact Lookup Field Label', 
                    'Valid Contact Lookup Field Name'}
            ),
            Label.stgHealthCheckFixNotApplicable,
            0
        );
    }

    /*****************************************************************************************
    * @description Test method to verify getContactPrimaryFieldUniquenessHealthCheckGroupVModel returns a 
    * HealthCheckGroupVModel with a Failed status when the primary contact field is not valid
    *****************************************************************************************/
    @isTest 
    private static void getContactPrimaryFieldUniquenessHealthCheckGroupVModelFieldNotExist() {
        LookupFieldService.instance = new STUB_LookupFieldServiceDevNameMatch();

        AffiliationMappingsHealthCheckVMapper afflMappingHealthCheckVMapperInstance = 
            AffiliationMappingsHealthCheckVMapper.getInstance();

        List<AffiliationMappingsModel> affiliationMappingsModelsList = new List<AffiliationMappingsModel> {
            new AffiliationMappingsModel(
                'Test Affiliation Mapping',
                'Test Record Type Name', 
                'Valid Contact Lookup Field Name',
                true,
                'Test Status',
                'Test Role'
            )
        };

        Test.startTest();
        HealthCheckGroupVModel healthCheckGroupVModelResult = 
            afflMappingHealthCheckVMapperInstance.getContactPrimaryFieldUniquenessHealthCheckGroupVModel(
                affiliationMappingsModelsList[0],
                null,
                new Set<String>()
            );
        Test.stopTest();

        AffiliationMappingsHCVMapper_TEST.validateHCGroupAssertions(
            healthCheckGroupVModelResult,
            Label.stgHealthCheckAffiliationMappings,
            Label.stgHealthCheckStatusFailed,
            0,
            1,
            0,
            1
        );

        AffiliationMappingsHCVMapper_TEST.validateHCItemAssertions(
            healthCheckGroupVModelResult,
            Label.stgHCAfflMapContPrimaryFieldUniqueTitle,  
            'Fail',
            Label.stgHealthCheckStatusFailed,
            StringHandlingService.getInstance().formatStringWithApostrophesAndParameters(
                Label.stgHCAfflMapContactPrimaryFieldInvalid, 
                new List<Object> {'Valid Contact Lookup Field Name'}
            ),
            StringHandlingService.getInstance().formatStringWithApostrophesAndParameters(
                Label.stgHCAfflMapContPrimaryFieldInvalidFix, 
                new List<Object> {'Valid Contact Lookup Field Name'}
            ),
            0
        );
    }

    /*****************************************************************************************
    * @description Test method to verify getContactPrimaryFieldUniquenessHealthCheckGroupVModel returns a 
    * HealthCheckGroupVModel with a Failed status when an account record type matched to multiple
    * Primary Affilition fields specified in affiliation mappings matches the developer name
    * of a field that corresponds to a lookup to Account on Contact. 
    *****************************************************************************************/
    @isTest 
    private static void getContactPrimaryFieldUniquenessHealthCheckGroupVModelFieldDuplicate() {
        LookupFieldService.instance = new STUB_LookupFieldServiceDevNameMatch();

        AffiliationMappingsHealthCheckVMapper afflMappingHealthCheckVMapperInstance = 
            AffiliationMappingsHealthCheckVMapper.getInstance();

        List<AffiliationMappingsModel> affiliationMappingsModelsList = new List<AffiliationMappingsModel> {
            new AffiliationMappingsModel(
                'Test Affiliation Mapping',
                'Test Record Type Name', 
                'Valid Contact Lookup Field Name',
                true,
                'Test Status',
                'Test Role'
            )
        };

        Test.startTest();
        HealthCheckGroupVModel healthCheckGroupVModelResult = 
            afflMappingHealthCheckVMapperInstance.getContactPrimaryFieldUniquenessHealthCheckGroupVModel(
                affiliationMappingsModelsList[0],
                new LookupFieldModel(
                    'Valid Contact Lookup Field Name',
                    'Valid Contact Lookup Field Label'
                ),
                new Set<String>{'Valid Contact Lookup Field Name'}
            );
        Test.stopTest();

        AffiliationMappingsHCVMapper_TEST.validateHCGroupAssertions(
            healthCheckGroupVModelResult,
            Label.stgHealthCheckAffiliationMappings,
            Label.stgHealthCheckStatusFailed,
            0,
            1,
            0,
            1
        );

        AffiliationMappingsHCVMapper_TEST.validateHCItemAssertions(
            healthCheckGroupVModelResult,
            Label.stgHCAfflMapContPrimaryFieldUniqueTitle,  
            'Fail',
            Label.stgHealthCheckStatusFailed,
            StringHandlingService.getInstance().formatStringWithApostrophesAndParameters(
                Label.stgHCAfflMapContactPrimaryFieldNotUnique, 
                new List<Object> {
                    'Valid Contact Lookup Field Label', 
                    'Valid Contact Lookup Field Name'}
            ),
            StringHandlingService.getInstance().formatStringWithApostrophesAndParameters(
                Label.stgHCAfflMapContactPrimaryFieldUniqueFix, 
                new List<Object> {
                    'Valid Contact Lookup Field Label', 
                    'Valid Contact Lookup Field Name'}
            ),
            0
        );
    }

    /***************************************************************************
    * @description Test method to verify that
    * getAffiliationMappingsHealthCheckResults returns the expected passing health
    * check
    ***************************************************************************/
    @isTest
    private static void getAffiliationMappingsHealthCheckResultsPass() {
        STUB_AffiliationMappingsService affiliationMappingsServiceStub = 
            new STUB_AffiliationMappingsService();

        STUB_RecordTypeService recordTypeServiceStub = 
            new STUB_RecordTypeService();

        AffiliationMappingsHealthCheckVMapper.instance = 
            new STUB_AffiliationMappingsHealthCheckVMapperSub();
        
        AffiliationMappingsHealthCheckVMapper AffiliationMappingsHealthCheckVMapperInstance =
            AffiliationMappingsHealthCheckVMapper.getInstance();
        
        AffiliationMappingsModel affiliationMappingsModel =
            affiliationMappingsServiceStub.getAffiliationMappingsModels()[0];

        Integer numberOfHealthChecks = 6; // NOTE: Increment when adding health checks

        Test.startTest();
        HealthCheckGroupVModel healthCheckGroupVModelResult = 
            affiliationMappingsHealthCheckVMapperInstance.getAffiliationMappingsHealthCheckResults(
                affiliationMappingsModel,
                new RecordTypeModel(
                    '000000000000001234', 
                    'Test Account Record Type',
                    'Test_Account_Record_Type', 
                    true
                ),
                new LookupFieldModel(
                    'Test_Lookup_Field', 
                    'Test Lookup Field'
                ),
                new Map<String, PicklistEntryModel>(),
                new Map<String, PicklistEntryModel>(),
                new Set<Id>(),
                new Set<String>()
            );
        Test.stopTest();

        System.assertEquals(
            '',
            healthCheckGroupVModelResult.label,
            'Label should equal expected value of blank'
        );
        System.assertEquals(
            Label.stgHealthCheckStatusPassed,
            healthCheckGroupVModelResult.status,
            'Status should default to passed'
        );
        System.assertEquals(
            numberOfHealthChecks,
            healthCheckGroupVModelResult.passedChecks,
            'Passed checks should equal expected value of ' + numberOfHealthChecks
        );
        System.assertEquals(
            numberOfHealthChecks,
            healthCheckGroupVModelResult.totalChecks,
            'Total checks should equal expected value of ' + numberOfHealthChecks
        );
        System.assertEquals(
            0,
            healthCheckGroupVModelResult.expandedRowsList.size(),
            'Expanded rows list should have a size of 0'
        );
        System.assertEquals(
            1,
            healthCheckGroupVModelResult.healthCheckItemList.size(),
            'Health Check Item list should have a size of 1'
        );
    }

    /***************************************************************************
    * @description Test method to verify that
    * getAffiliationMappingsHealthCheckResults returns the expected failed health
    * check
    ***************************************************************************/
    @isTest
    private static void getAffiliationMappingsHealthCheckResultsFail() {
        List<Affl_Mappings__c> affiliationMappingsList = new List<Affl_Mappings__c>();
        affiliationMappingsList.add(
            new Affl_Mappings__c(
                Name = 'Test Account', 
                Account_Record_Type__c = 'Test Record Type', 
                Primary_Affl_Field__c = UTIL_Namespace.StrTokenNSPrefix('Test_Organization__c')
            )
        );
        insert affiliationMappingsList;

        STUB_AffiliationMappingsService affiliationMappingsServiceStub = 
            new STUB_AffiliationMappingsService();

        STUB_RecordTypeService recordTypeServiceStub = 
            new STUB_RecordTypeService();

        AffiliationMappingsHealthCheckVMapper.instance = 
            new STUB_AffiliationMappingsHealthCheckVMapperSubFail();
        
        AffiliationMappingsHealthCheckVMapper affiliationMappingsHealthCheckVMapperInstance =
            AffiliationMappingsHealthCheckVMapper.getInstance();
        
        AffiliationMappingsModel affiliationMappingsModel = 
            affiliationMappingsHealthCheckVMapperInstance.locateAffiliationMappingsService().getAffiliationMappingsModels()[0];
        
        Integer numberOfHealthChecks = 6; // NOTE: Increment when adding health checks

        Test.startTest();
        HealthCheckGroupVModel healthCheckGroupVModelResult = 
            affiliationMappingsHealthCheckVMapperInstance.getAffiliationMappingsHealthCheckResults(
                affiliationMappingsModel,
                new RecordTypeModel(
                    '000000000000001234', 
                    'Test Account Record Type',
                    'Test_Account_Record_Type', 
                    true
                ),
                new LookupFieldModel(
                    'Test_Lookup_Field', 
                    'Test Lookup Field'
                ),
                new Map<String, PicklistEntryModel>(),
                new Map<String, PicklistEntryModel>(),
                new Set<Id>(),
                new Set<String>()
            );
        Test.stopTest();

        System.assertEquals(
            '',
            healthCheckGroupVModelResult.label,
            'Label should equal expected value of blank'
        );
        System.assertEquals(
            Label.stgHealthCheckStatusFailed,
            healthCheckGroupVModelResult.status,
            'Status should equal failed'
        );
        System.assertEquals(
            0,
            healthCheckGroupVModelResult.passedChecks,
            'Passed checks should equal expected value of 0.'
        );
        System.assertEquals(
            numberOfHealthChecks,
            healthCheckGroupVModelResult.totalChecks,
            'Total checks should equal expected value of ' + numberOfHealthChecks
        );
        System.assertEquals(
            1,
            healthCheckGroupVModelResult.expandedRowsList.size(),
            'Expanded rows list should have a size of 1.'
        );
        System.assertEquals(
            1,
            healthCheckGroupVModelResult.healthCheckItemList.size(),
            'Health Check Item list should have a size of 1'
        );
    }

    /*****************************************************************************************
    * @description Test method to verify getActiveExistingRoleHealthCheckGroupVModel returns a 
    * HealthCheckGroupVModel with a Passed status when the Auto Enrollment Role is populated and
    * corresponds to a value in the Role picklist field on Affiliation__c that is active.
    *****************************************************************************************/
    @isTest 
    private static void getActiveExistingRoleHealthCheckGroupVModelValidAndActivePicklistField() {
        PicklistEntryService.instance = new STUB_PicklistEntryServiceValid();

        AffiliationMappingsHealthCheckVMapper afflMappingHealthCheckVMapperInstance = 
            AffiliationMappingsHealthCheckVMapper.getInstance();

        List<AffiliationMappingsModel> affiliationMappingsModelsList = new List<AffiliationMappingsModel> {
            new AffiliationMappingsModel(
                'Test Affiliation Mapping',
                'Test Record Type Name', 
                '',
                true,
                'Test Status',
                'Test Auto Enrollment'
            )
        };

        Map<String, PicklistEntryModel> affiliationRolePicklistEntryModelByName = new Map<String, PicklistEntryModel> {
            'Test Auto Enrollment' => new PicklistEntryModel(
                'Test Auto Enrollment',
                'Auto Enrollment Label',
                true
            ),

            'Auto Enrollment Role Name 2' => new PicklistEntryModel(
                'Auto Enrollment Role Name 2',
                'Auto Enrollment Role Label 2',
                true
            )
        };

        Test.startTest();
        HealthCheckGroupVModel healthCheckGroupVModelResult = 
            afflMappingHealthCheckVMapperInstance.getActiveExistingRoleHealthCheckGroupVModel(
                affiliationMappingsModelsList[0],
                affiliationRolePicklistEntryModelByName
            );
        Test.stopTest();

        AffiliationMappingsHCVMapper_TEST.validateHCGroupAssertions(
            healthCheckGroupVModelResult,
            Label.stgHealthCheckAffiliationMappings,
            Label.stgHealthCheckStatusPassed,
            1,
            1,
            0,
            1
        );

        AffiliationMappingsHCVMapper_TEST.validateHCItemAssertions(
            healthCheckGroupVModelResult,
            Label.stgHCAfflMapAutoEnrollRoleTitle,
            'Pass',
            Label.stgHealthCheckStatusPassed,
            StringHandlingService.getInstance().formatStringWithApostrophesAndParameters(
                Label.stgHCAfflMapAutoEnrollRoleValid, 
                new List<Object> {
                    affiliationRolePicklistEntryModelByName.get(affiliationMappingsModelsList[0].autoProgramEnrollmentRole).label, 
                    affiliationRolePicklistEntryModelByName.get(affiliationMappingsModelsList[0].autoProgramEnrollmentRole).name
                }
            ),
            Label.stgHealthCheckFixNotApplicable,
            0
        ); 
    }
    
    /*****************************************************************************************
    * @description Test method to verify getActiveExistingRoleHealthCheckGroupVModel returns a 
    * HealthCheckGroupVModel with a Failed status when the Auto Enrollment Role is populated and
    * corresponds to a value in the Role picklist field on Affiliation__c that is inactive.
    *****************************************************************************************/
    @isTest 
    private static void getActiveExistingRoleHealthCheckGroupVModelValidAndInActivePicklistField() {
        PicklistEntryService.instance = new STUB_PicklistEntryServiceInactive();

        AffiliationMappingsHealthCheckVMapper afflMappingHealthCheckVMapperInstance = 
            AffiliationMappingsHealthCheckVMapper.getInstance();

        List<AffiliationMappingsModel> affiliationMappingsModelsList = new List<AffiliationMappingsModel> {
            new AffiliationMappingsModel(
                'Test Affiliation Mapping',
                'Test Record Type Name', 
                '',
                true,
                'Test Status',
                'Test Auto Enrollment'
            )
        };

        Map<String, PicklistEntryModel> affiliationRolePicklistEntryModelByName = new Map<String, PicklistEntryModel> {
            'Test Auto Enrollment' => new PicklistEntryModel(
                'Test Auto Enrollment',
                'Auto Enrollment Label',
                false
            ),

            'Auto Enrollment Role Name 2' => new PicklistEntryModel(
                'Auto Enrollment Role Name 2',
                'Auto Enrollment Role Label 2',
                true
            )
        };

        Test.startTest();
        HealthCheckGroupVModel healthCheckGroupVModelResult = 
            afflMappingHealthCheckVMapperInstance.getActiveExistingRoleHealthCheckGroupVModel(
                affiliationMappingsModelsList[0],
                affiliationRolePicklistEntryModelByName
            );
        Test.stopTest();

        AffiliationMappingsHCVMapper_TEST.validateHCGroupAssertions(
            healthCheckGroupVModelResult,
            Label.stgHealthCheckAffiliationMappings,
            Label.stgHealthCheckStatusFailed,
            0,
            1,
            0,
            1
        );

        AffiliationMappingsHCVMapper_TEST.validateHCItemAssertions(
            healthCheckGroupVModelResult,
            Label.stgHCAfflMapAutoEnrollRoleTitle,
            'Fail',
            Label.stgHealthCheckStatusFailed,
            StringHandlingService.getInstance().formatStringWithApostrophesAndParameters(
                Label.stgHCAfflMapAutoEnrollRoleInactive, 
                new List<Object> {
                    affiliationMappingsModelsList[0].autoProgramEnrollmentRole, 
                    affiliationRolePicklistEntryModelByName.get(affiliationMappingsModelsList[0].autoProgramEnrollmentRole).name
                }
            ),
            StringHandlingService.getInstance().formatStringWithApostrophesAndParameters(
                Label.stgHCAfflMapAutoEnrollRoleInactiveFix, 
                new List<Object> {
                    affiliationMappingsModelsList[0].autoProgramEnrollmentRole, 
                    affiliationRolePicklistEntryModelByName.get(affiliationMappingsModelsList[0].autoProgramEnrollmentRole).name
                }
            ),
            0
        ); 
    }

    /*****************************************************************************************
    * @description Test method to verify getActiveExistingRoleHealthCheckGroupVModel returns a 
    * HealthCheckGroupVModel with a Failed status when the Auto Enrollment Role is populated and
    * does not correspond to a value in the Role picklist field on Affiliation__c.
    *****************************************************************************************/
    @isTest 
    private static void getActiveExistingRoleHealthCheckGroupVModelInvalidPicklistField() {
        PicklistEntryService.instance = new STUB_PicklistEntryServiceNull();

        AffiliationMappingsHealthCheckVMapper afflMappingHealthCheckVMapperInstance = 
            AffiliationMappingsHealthCheckVMapper.getInstance();

        List<AffiliationMappingsModel> affiliationMappingsModelsList = new List<AffiliationMappingsModel> {
            new AffiliationMappingsModel(
                'Test Affiliation Mapping',
                'Test Record Type Name', 
                '',
                true,
                'Test Status',
                'Invalid Auto Enrollment Role'
            )
        };

        Map<String, PicklistEntryModel> affiliationRolePicklistEntryModelByName = new Map<String, PicklistEntryModel> {
            'Test Auto Enrollment' => new PicklistEntryModel(
                'Test Auto Enrollment',
                'Auto Enrollment Label',
                true
            ),

            'Auto Enrollment Role Name 2' => new PicklistEntryModel(
                'Auto Enrollment Role Name 2',
                'Auto Enrollment Role Label 2',
                true
            )
        };

        Test.startTest();
        HealthCheckGroupVModel healthCheckGroupVModelResult = 
            afflMappingHealthCheckVMapperInstance.getActiveExistingRoleHealthCheckGroupVModel(
                affiliationMappingsModelsList[0],
                affiliationRolePicklistEntryModelByName
            );
        Test.stopTest();

        AffiliationMappingsHCVMapper_TEST.validateHCGroupAssertions(
            healthCheckGroupVModelResult,
            Label.stgHealthCheckAffiliationMappings,
            Label.stgHealthCheckStatusFailed,
            0,
            1,
            0,
            1
        );

        AffiliationMappingsHCVMapper_TEST.validateHCItemAssertions(
            healthCheckGroupVModelResult,
            Label.stgHCAfflMapAutoEnrollRoleTitle,
            'Fail',
            Label.stgHealthCheckStatusFailed,
            StringHandlingService.getInstance().formatStringWithApostrophesAndParameters(
                Label.stgHCAfflMapAutoEnrollRoleNotFound, 
                new List<Object> {affiliationMappingsModelsList[0].autoProgramEnrollmentRole}
            ),
            Label.stgHCAfflMapAutoEnrollRoleNotFoundFix,
            0
        ); 
    }

    /*****************************************************************************************
    * @description Test method to verify getActiveExistingRoleHealthCheckGroupVModel returns an
    * empty HealthCheckGroupVModel with a Failed status when the Auto Enrollment Role is not 
    * populated for an affiliation mapping.
    *****************************************************************************************/
    @isTest 
    private static void getActiveExistingRoleHealthCheckGroupVModelBlankRole() {
        PicklistEntryService.instance = new STUB_PicklistEntryServiceNull();

        AffiliationMappingsHealthCheckVMapper afflMappingHealthCheckVMapperInstance = 
            AffiliationMappingsHealthCheckVMapper.getInstance();

        List<AffiliationMappingsModel> affiliationMappingsModelsList = new List<AffiliationMappingsModel> {
            new AffiliationMappingsModel(
                'Test Affiliation Mapping',
                'Test Record Type Name', 
                '',
                true,
                'Test Status',
                ''
            )
        };

        Map<String, PicklistEntryModel> affiliationRolePicklistEntryModelByName = new Map<String, PicklistEntryModel> {
            'Test Auto Enrollment' => new PicklistEntryModel(
                'Test Auto Enrollment',
                'Auto Enrollment Label',
                true
            ),

            'Auto Enrollment Role Name 2' => new PicklistEntryModel(
                'Auto Enrollment Role Name 2',
                'Auto Enrollment Role Label 2',
                true
            )
        };

        Test.startTest();
        HealthCheckGroupVModel healthCheckGroupVModelResult = 
            afflMappingHealthCheckVMapperInstance.getActiveExistingRoleHealthCheckGroupVModel(
                affiliationMappingsModelsList[0],
                affiliationRolePicklistEntryModelByName
            );
        Test.stopTest();

        AffiliationMappingsHCVMapper_TEST.validateHCGroupAssertions(
            healthCheckGroupVModelResult,
            Label.stgHealthCheckAffiliationMappings,
            Label.stgHealthCheckStatusFailed,
            0,
            1,
            0,
            1
        );

        AffiliationMappingsHCVMapper_TEST.validateHCItemAssertions(
            healthCheckGroupVModelResult,
            Label.stgHCAfflMapAutoEnrollRoleTitle,
            'Fail',
            Label.stgHealthCheckStatusFailed,
            StringHandlingService.getInstance().formatStringWithApostrophesAndParameters(
                Label.stgHCAfflMapAutoEnrollRoleNotFound, 
                new List<Object> {affiliationMappingsModelsList[0].autoProgramEnrollmentRole}
            ),
            Label.stgHCAfflMapAutoEnrollRoleNotFoundFix,
            0
        ); 
    }

    /*****************************************************************************************
    * @description Test method to verify getActiveExistingRoleHealthCheckGroupVModel returns an
    * empty HealthCheckGroupVModel with a Passed status when the Auto Enrollment feature is not
    * enabled.
    *****************************************************************************************/
    @isTest 
    private static void getActiveExistingRoleHealthCheckGroupVModelAutoEnrollDisabled() {
        AffiliationMappingsHealthCheckVMapper afflMappingHealthCheckVMapperInstance = 
            AffiliationMappingsHealthCheckVMapper.getInstance();

        List<AffiliationMappingsModel> affiliationMappingsModelsList = new List<AffiliationMappingsModel> {
            new AffiliationMappingsModel(
                'Test Affiliation Mapping',
                'Test Record Type Name', 
                '',
                false,
                '',
                'Test Role'
            )
        };

        Test.startTest();
        HealthCheckGroupVModel healthCheckGroupVModelResult = 
            afflMappingHealthCheckVMapperInstance.getActiveExistingRoleHealthCheckGroupVModel(
                affiliationMappingsModelsList[0],
                new Map<String, PicklistEntryModel>()
            );
        Test.stopTest();

        AffiliationMappingsHCVMapper_TEST.validateHCGroupAssertions(
            healthCheckGroupVModelResult,
            Label.stgHealthCheckAffiliationMappings,
            Label.stgHealthCheckStatusPassed,
            0,
            0,
            0,
            0
        );
    }

    /*****************************************************************************************
    * @description Test method to verify getActiveExistingStatusHealthCheckGroupVModel returns a 
    * HealthCheckGroupVModel with a Passed status when the Auto Enrollment Status is populated and
    * corresponds to a value in the Status picklist field on Affiliation__c that is active.
    *****************************************************************************************/
    @isTest 
    private static void getActiveExistingStatusHealthCheckGroupVModelValidAndActivePicklistField() {
        PicklistEntryService.instance = new STUB_PicklistEntryServiceValid();

        AffiliationMappingsHealthCheckVMapper afflMappingHealthCheckVMapperInstance = 
            AffiliationMappingsHealthCheckVMapper.getInstance();

        List<AffiliationMappingsModel> affiliationMappingsModelsList = new List<AffiliationMappingsModel> {
            new AffiliationMappingsModel(
                'Test Affiliation Mapping',
                'Test Record Type Name', 
                '',
                true,
                'Test Auto Enrollment',
                'Test Role'
            )
        };

        Map<String, PicklistEntryModel> affiliationStatusPicklistEntryModelByName = new Map<String, PicklistEntryModel> {
            'Test Auto Enrollment' => new PicklistEntryModel(
                'Test Auto Enrollment',
                'Auto Enrollment Label',
                true
            ),

            'Auto Enrollment Status Name 2' => new PicklistEntryModel(
                'Auto Enrollment Status Name 2',
                'Auto Enrollment Status Label 2',
                true
            )
        };

        Test.startTest();
        HealthCheckGroupVModel healthCheckGroupVModelResult = 
            afflMappingHealthCheckVMapperInstance.getActiveExistingStatusHealthCheckGroupVModel(
                affiliationMappingsModelsList[0],
                affiliationStatusPicklistEntryModelByName
            );
        Test.stopTest();

        AffiliationMappingsHCVMapper_TEST.validateHCGroupAssertions(
            healthCheckGroupVModelResult,
            Label.stgHealthCheckAffiliationMappings,
            Label.stgHealthCheckStatusPassed,
            1,
            1,
            0,
            1
        );

        AffiliationMappingsHCVMapper_TEST.validateHCItemAssertions(
            healthCheckGroupVModelResult,
            Label.stgHCAfflMapAutoEnrollStatusTitle,
            'Pass',
            Label.stgHealthCheckStatusPassed,
            StringHandlingService.getInstance().formatStringWithApostrophesAndParameters(
                Label.stgHCAfflMapAutoEnrollStatusValid, 
                new List<Object> {
                affiliationStatusPicklistEntryModelByName.get(affiliationMappingsModelsList[0].autoProgramEnrollmentStatus).label, 
                affiliationStatusPicklistEntryModelByName.get(affiliationMappingsModelsList[0].autoProgramEnrollmentStatus).name
                }
            ),
            Label.stgHealthCheckFixNotApplicable,
            0
        ); 
    }
    
    /*****************************************************************************************
    * @description Test method to verify getActiveExistingStatusHealthCheckGroupVModel returns a 
    * HealthCheckGroupVModel with a Failed status when the Auto Enrollment Status is populated and
    * corresponds to a value in the Status picklist field on Affiliation__c that is inactive.
    *****************************************************************************************/
    @isTest 
    private static void getActiveExistingStatusHealthCheckGroupVModelValidAndInActivePicklistField() {
        PicklistEntryService.instance = new STUB_PicklistEntryServiceInactive();

        AffiliationMappingsHealthCheckVMapper afflMappingHealthCheckVMapperInstance = 
            AffiliationMappingsHealthCheckVMapper.getInstance();

        List<AffiliationMappingsModel> affiliationMappingsModelsList = new List<AffiliationMappingsModel> {
            new AffiliationMappingsModel(
                'Test Affiliation Mapping',
                'Test Record Type Name', 
                '',
                true,
                'Test Auto Enrollment',
                'Test Role'
            )
        };

        Map<String, PicklistEntryModel> affiliationStatusPicklistEntryModelByName = new Map<String, PicklistEntryModel> {
            'Test Auto Enrollment' => new PicklistEntryModel(
                'Test Auto Enrollment',
                'Auto Enrollment Label',
                false
            ),

            'Auto Enrollment Status Name 2' => new PicklistEntryModel(
                'Auto Enrollment Status Name 2',
                'Auto Enrollment Status Label 2',
                true
            )
        };

        Test.startTest();
        HealthCheckGroupVModel healthCheckGroupVModelResult = 
            afflMappingHealthCheckVMapperInstance.getActiveExistingStatusHealthCheckGroupVModel(
                affiliationMappingsModelsList[0],
                affiliationStatusPicklistEntryModelByName
            );
        Test.stopTest();

        AffiliationMappingsHCVMapper_TEST.validateHCGroupAssertions(
            healthCheckGroupVModelResult,
            Label.stgHealthCheckAffiliationMappings,
            Label.stgHealthCheckStatusFailed,
            0,
            1,
            0,
            1
        );

        AffiliationMappingsHCVMapper_TEST.validateHCItemAssertions(
            healthCheckGroupVModelResult,
            Label.stgHCAfflMapAutoEnrollStatusTitle,
            'Fail',
            Label.stgHealthCheckStatusFailed,
            StringHandlingService.getInstance().formatStringWithApostrophesAndParameters(
                Label.stgHCAfflMapAutoEnrollStatusInactive, 
                new List<Object> {
                    affiliationMappingsModelsList[0].autoProgramEnrollmentStatus, 
                    affiliationStatusPicklistEntryModelByName.get(affiliationMappingsModelsList[0].autoProgramEnrollmentStatus).name
                }
            ),
            StringHandlingService.getInstance().formatStringWithApostrophesAndParameters(
                Label.stgHCAfflMapAutoEnrollStatusInactiveFix, 
                new List<Object> {
                    affiliationMappingsModelsList[0].autoProgramEnrollmentStatus, 
                    affiliationStatusPicklistEntryModelByName.get(affiliationMappingsModelsList[0].autoProgramEnrollmentStatus).name
                }
            ),
            0
        ); 
    }

    /*****************************************************************************************
    * @description Test method to verify getActiveExistingStatusHealthCheckGroupVModel returns a 
    * HealthCheckGroupVModel with a Failed status when the Auto Enrollment Status is populated and
    * does not correspond to a value in the Status picklist field on Affiliation__c.
    *****************************************************************************************/
    @isTest 
    private static void getActiveExistingStatusHealthCheckGroupVModelInvalidPicklistField() {
        PicklistEntryService.instance = new STUB_PicklistEntryServiceNull();

        AffiliationMappingsHealthCheckVMapper afflMappingHealthCheckVMapperInstance = 
            AffiliationMappingsHealthCheckVMapper.getInstance();

        List<AffiliationMappingsModel> affiliationMappingsModelsList = new List<AffiliationMappingsModel> {
            new AffiliationMappingsModel(
                'Test Affiliation Mapping',
                'Test Record Type Name', 
                '',
                true,
                'Invalid Auto Enrollment Status',
                'Test Enrollment Role'
            )
        };

        Map<String, PicklistEntryModel> affiliationStatusPicklistEntryModelByName = new Map<String, PicklistEntryModel> {
            'Test Auto Enrollment' => new PicklistEntryModel(
                'Test Auto Enrollment',
                'Auto Enrollment Label',
                true
            ),

            'Auto Enrollment Status Name 2' => new PicklistEntryModel(
                'Auto Enrollment Status Name 2',
                'Auto Enrollment Status Label 2',
                true
            )
        };

        Test.startTest();
        HealthCheckGroupVModel healthCheckGroupVModelResult = 
            afflMappingHealthCheckVMapperInstance.getActiveExistingStatusHealthCheckGroupVModel(
                affiliationMappingsModelsList[0],
                affiliationStatusPicklistEntryModelByName
            );
        Test.stopTest();

        AffiliationMappingsHCVMapper_TEST.validateHCGroupAssertions(
            healthCheckGroupVModelResult,
            Label.stgHealthCheckAffiliationMappings,
            Label.stgHealthCheckStatusFailed,
            0,
            1,
            0,
            1
        );

        AffiliationMappingsHCVMapper_TEST.validateHCItemAssertions(
            healthCheckGroupVModelResult,
            Label.stgHCAfflMapAutoEnrollStatusTitle,
            'Fail',
            Label.stgHealthCheckStatusFailed,
            StringHandlingService.getInstance().formatStringWithApostrophesAndParameters(
                Label.stgHCAfflMapAutoEnrollStatusNotFound, 
                new List<Object> {affiliationMappingsModelsList[0].autoProgramEnrollmentStatus}
            ),
            Label.stgHCAfflMapAutoEnrollStatusNotFoundFix,
            0
        ); 
    }

    /*****************************************************************************************
    * @description Test method to verify getActiveExistingStatusHealthCheckGroupVModel returns an
    * empty HealthCheckGroupVModel with a Failed status when the Auto Enrollment Status is not 
    * populated for an affiliation mapping.
    *****************************************************************************************/
    @isTest 
    private static void getActiveExistingStatusHealthCheckGroupVModelBlankStatus() {
        PicklistEntryService.instance = new STUB_PicklistEntryServiceNull();

        AffiliationMappingsHealthCheckVMapper afflMappingHealthCheckVMapperInstance = 
            AffiliationMappingsHealthCheckVMapper.getInstance();

        List<AffiliationMappingsModel> affiliationMappingsModelsList = new List<AffiliationMappingsModel> {
            new AffiliationMappingsModel(
                'Test Affiliation Mapping',
                'Test Record Type Name', 
                '',
                true,
                '',
                'Test Role'
            )
        };

        Map<String, PicklistEntryModel> affiliationStatusPicklistEntryModelByName = new Map<String, PicklistEntryModel> {
            'Test Auto Enrollment' => new PicklistEntryModel(
                'Test Auto Enrollment',
                'Auto Enrollment Label',
                true
            ),

            'Auto Enrollment Status Name 2' => new PicklistEntryModel(
                'Auto Enrollment Status Name 2',
                'Auto Enrollment Status Label 2',
                true
            )
        };

        Test.startTest();
        HealthCheckGroupVModel healthCheckGroupVModelResult = 
            afflMappingHealthCheckVMapperInstance.getActiveExistingStatusHealthCheckGroupVModel(
                affiliationMappingsModelsList[0],
                affiliationStatusPicklistEntryModelByName
            );
        Test.stopTest();

        AffiliationMappingsHCVMapper_TEST.validateHCGroupAssertions(
            healthCheckGroupVModelResult,
            Label.stgHealthCheckAffiliationMappings,
            Label.stgHealthCheckStatusFailed,
            0,
            1,
            0,
            1
        );

        AffiliationMappingsHCVMapper_TEST.validateHCItemAssertions(
            healthCheckGroupVModelResult,
            Label.stgHCAfflMapAutoEnrollStatusTitle,
            'Fail',
            Label.stgHealthCheckStatusFailed,
            StringHandlingService.getInstance().formatStringWithApostrophesAndParameters(
                Label.stgHCAfflMapAutoEnrollStatusNotFound, 
                new List<Object> {affiliationMappingsModelsList[0].autoProgramEnrollmentStatus}
            ),
            Label.stgHCAfflMapAutoEnrollStatusNotFoundFix,
            0
        ); 
    }

    /*****************************************************************************************
    * @description Test method to verify getActiveExistingStatusHealthCheckGroupVModel returns an
    * empty HealthCheckGroupVModel with a Passed status when the Auto Enrollment feature is not
    * enabled.
    *****************************************************************************************/
    @isTest 
    private static void getActiveExistingStatusHealthCheckGroupVModelAutoEnrollDisabled() {
        AffiliationMappingsHealthCheckVMapper afflMappingHealthCheckVMapperInstance = 
            AffiliationMappingsHealthCheckVMapper.getInstance();

        List<AffiliationMappingsModel> affiliationMappingsModelsList = new List<AffiliationMappingsModel> {
            new AffiliationMappingsModel(
                'Test Affiliation Mapping',
                'Test Record Type Name', 
                '',
                false,
                '',
                'Test Role'
            )
        };

        Test.startTest();
        HealthCheckGroupVModel healthCheckGroupVModelResult = 
            afflMappingHealthCheckVMapperInstance.getActiveExistingStatusHealthCheckGroupVModel(
                affiliationMappingsModelsList[0],
                new Map<String, PicklistEntryModel>()
            );
        Test.stopTest();

        AffiliationMappingsHCVMapper_TEST.validateHCGroupAssertions(
            healthCheckGroupVModelResult,
            Label.stgHealthCheckAffiliationMappings,
            Label.stgHealthCheckStatusPassed,
            0,
            0,
            0,
            0
        );
    }

    /*****************************************************************************************
    * @description Test method to verify getDuplicateAccountRecordTypeIds returns an
    * empty set when there is no duplicate record type model in Affiliation Mappings
    *****************************************************************************************/
    @isTest 
    private static void getDuplicateAccountRecordTypeIdsNoDuplicate() {
        AffiliationMappingsHealthCheckVMapper afflMappingHealthCheckVMapperInstance = 
            AffiliationMappingsHealthCheckVMapper.getInstance();

        List<AffiliationMappingsModel> affiliationMappingsModelsList = new List<AffiliationMappingsModel> {
            new AffiliationMappingsModel(
                'Test Affiliation Mapping',
                'Test Account Record Type', 
                '',
                false,
                '',
                'Test Role'
            ),
            new AffiliationMappingsModel(
                'Test Affiliation Mapping 2',
                'Test Account Record Type 2', 
                '',
                false,
                '',
                'Test Role'
            )
        };
        RecordTypeModel accountRecordTypeModel = 
            new RecordTypeModel(
                '000000000000001234', 
                'Test Account Record Type',
                'Test_Account_Record_Type', 
                true
        );
        RecordTypeModel accountRecordTypeModel2= 
            new RecordTypeModel(
                '000000000000005678', 
                'Test Account Record Type 2',
                'Test_Account_Record_Type2', 
                true
        );
        Map<String, RecordTypeModel> accountRecordTypeModelsByName = new Map<String, RecordTypeModel> {
            'Test_Account_Record_Type' => accountRecordTypeModel,
            'Test_Account_Record_Type2' => accountRecordTypeModel2
        };
        Map<String, RecordTypeModel> accountRecordTypeModelsByLabel = new Map<String, RecordTypeModel> {
            'Test Account Record Type' => accountRecordTypeModel,
            'Test Account Record Type2' => accountRecordTypeModel2
        };


        Test.startTest();
            Set<Id> duplicateAccountRecordTypeIds = afflMappingHealthCheckVMapperInstance.getDuplicateAccountRecordTypeIds(
                affiliationMappingsModelsList, 
                accountRecordTypeModelsByName,
                accountRecordTypeModelsByLabel  
            );
        Test.stopTest();

        System.assertEquals(
            true, 
            duplicateAccountRecordTypeIds.isEmpty(), 
            'The set of duplicate account record type ids should be empty.'
        );
    }

    /*****************************************************************************************
    * @description Test method to verify getDuplicateAccountRecordTypeIds returns a
    * set when there is duplicate record type model in Affiliation Mappings with the same Record Type Value
    *****************************************************************************************/
    @isTest 
    private static void getDuplicateAccountRecordTypeIdsRecordTypeValueSameDuplicate() {
        AffiliationMappingsHealthCheckVMapper afflMappingHealthCheckVMapperInstance = 
            AffiliationMappingsHealthCheckVMapper.getInstance();

        List<AffiliationMappingsModel> affiliationMappingsModelsList = new List<AffiliationMappingsModel> {
            new AffiliationMappingsModel(
                'Test Affiliation Mapping',
                'Test Account Record Type', 
                '',
                false,
                '',
                'Test Role'
            ),
            new AffiliationMappingsModel(
                'Test Affiliation Mapping 2',
                'Test Account Record Type', 
                '',
                false,
                '',
                'Test Role'
            )
        };
        RecordTypeModel accountRecordTypeModel = 
            new RecordTypeModel(
                '000000000000001234', 
                'Test Account Record Type',
                'Test_Account_Record_Type', 
                true
        );
        RecordTypeModel accountRecordTypeModel2= 
            new RecordTypeModel(
                '000000000000005678', 
                'Test Account Record Type 2',
                'Test_Account_Record_Type2', 
                true
        );
        Map<String, RecordTypeModel> accountRecordTypeModelsByName = new Map<String, RecordTypeModel> {
            'Test_Account_Record_Type' => accountRecordTypeModel,
            'Test_Account_Record_Type2' => accountRecordTypeModel2
        };
        Map<String, RecordTypeModel> accountRecordTypeModelsByLabel = new Map<String, RecordTypeModel> {
            'Test Account Record Type' => accountRecordTypeModel,
            'Test Account Record Type2' => accountRecordTypeModel2
        };


        Test.startTest();
            Set<Id> duplicateAccountRecordTypeIds = afflMappingHealthCheckVMapperInstance.getDuplicateAccountRecordTypeIds(
                affiliationMappingsModelsList, 
                accountRecordTypeModelsByName,
                accountRecordTypeModelsByLabel  
            );
        Test.stopTest();

        System.assertEquals(
            false, 
            duplicateAccountRecordTypeIds.isEmpty(), 
            'The set of duplicate account record type ids should not be empty.'
        );

        System.assertEquals(
            true, 
            duplicateAccountRecordTypeIds.contains('000000000000001234'), 
            'The set of duplicate account record type ids contains 000000000000001234.'
        );
    }

    /*****************************************************************************************
    * @description Test method to verify getDuplicateAccountRecordTypeIds returns a
    * set when there is duplicate record type model in Affiliation Mappings with the mix Record Type Values
    *****************************************************************************************/
    @isTest 
    private static void getDuplicateAccountRecordTypeIdsRecordTypeValueMixDuplicate() {
        AffiliationMappingsHealthCheckVMapper afflMappingHealthCheckVMapperInstance = 
            AffiliationMappingsHealthCheckVMapper.getInstance();

        List<AffiliationMappingsModel> affiliationMappingsModelsList = new List<AffiliationMappingsModel> {
            new AffiliationMappingsModel(
                'Test Affiliation Mapping',
                'Test Account Record Type', 
                '',
                false,
                '',
                'Test Role'
            ),
            new AffiliationMappingsModel(
                'Test Affiliation Mapping 2',
                'Test_Account_Record_Type', 
                '',
                false,
                '',
                'Test Role'
            )
        };
        RecordTypeModel accountRecordTypeModel = 
            new RecordTypeModel(
                '000000000000001234', 
                'Test Account Record Type',
                'Test_Account_Record_Type', 
                true
        );
        RecordTypeModel accountRecordTypeModel2= 
            new RecordTypeModel(
                '000000000000005678', 
                'Test Account Record Type 2',
                'Test_Account_Record_Type2', 
                true
        );
        Map<String, RecordTypeModel> accountRecordTypeModelsByName = new Map<String, RecordTypeModel> {
            'Test_Account_Record_Type' => accountRecordTypeModel,
            'Test_Account_Record_Type2' => accountRecordTypeModel2
        };
        Map<String, RecordTypeModel> accountRecordTypeModelsByLabel = new Map<String, RecordTypeModel> {
            'Test Account Record Type' => accountRecordTypeModel,
            'Test Account Record Type2' => accountRecordTypeModel2
        };


        Test.startTest();
            Set<Id> duplicateAccountRecordTypeIds = afflMappingHealthCheckVMapperInstance.getDuplicateAccountRecordTypeIds(
                affiliationMappingsModelsList, 
                accountRecordTypeModelsByName,
                accountRecordTypeModelsByLabel  
            );
        Test.stopTest();

        System.assertEquals(
            false, 
            duplicateAccountRecordTypeIds.isEmpty(), 
            'The set of duplicate account record type ids should not be empty.'
        );

        System.assertEquals(
            true, 
            duplicateAccountRecordTypeIds.contains('000000000000001234'), 
            'The set of duplicate account record type ids contains 000000000000001234.'
        );
    }

    /*****************************************************************************************
    * @description Test method to verify getDuplicateLookupFieldModelNames returns an
    * empty set when there is no duplicate Lookup Field Model in Affiliation Mappings
    *****************************************************************************************/
    @isTest 
    private static void getDuplicateLookupFieldModelNamesNoDuplicate() {
        AffiliationMappingsHealthCheckVMapper afflMappingHealthCheckVMapperInstance = 
            AffiliationMappingsHealthCheckVMapper.getInstance();

        List<AffiliationMappingsModel> affiliationMappingsModelsList = new List<AffiliationMappingsModel> {
            new AffiliationMappingsModel(
                'Test Affiliation Mapping',
                'Test Account Record Type', 
                'Test Contact Primary Field',
                false,
                '',
                'Test Role'
            ),
            new AffiliationMappingsModel(
                'Test Affiliation Mapping 2',
                'Test Account Record Type 2', 
                'Test Contact Primary Field 2',
                false,
                '',
                'Test Role'
            )
        };
        LookupFieldModel lookupFieldModel = 
            new LookupFieldModel( 
                'Test_Contact_Primary_Field',
                'Test Contact Primary Field'
        );
        LookupFieldModel lookupFieldModel2 = 
            new LookupFieldModel( 
                'Test_Contact_Primary_Field2',
                'Test Contact Primary Field 2'
        );
        Map<String, LookupFieldModel> accountLookupsOnContactFieldModelsByName = new Map<String, LookupFieldModel> {
            'Test_Contact_Primary_Field' => lookupFieldModel,
            'Test_Contact_Primary_Field2' => lookupFieldModel2
        };
        Map<String, LookupFieldModel> accountLookupsOnContactFieldModelsByLabel = new Map<String, LookupFieldModel> {
            'Test Contact Primary Field' => lookupFieldModel,
            'Test Contact Primary Field 2' => lookupFieldModel2
        };


        Test.startTest();
            Set<String> duplicateLookupFieldModelNames = afflMappingHealthCheckVMapperInstance.getDuplicateLookupFieldModelNames(
                affiliationMappingsModelsList, 
                accountLookupsOnContactFieldModelsByName,
                accountLookupsOnContactFieldModelsByLabel  
            );
        Test.stopTest();

        System.assertEquals(
            true, 
            duplicateLookupFieldModelNames.isEmpty(), 
            'The set of duplicate lookup field model names should be empty.'
        );
    }

    /*****************************************************************************************
    * @description Test method to verify getDuplicateLookupFieldModelNames returns an
    * set when there is duplicate Lookup Field Model in Affiliation Mappings with the same primary contact field value
    *****************************************************************************************/
    @isTest 
    private static void getDuplicateLookupFieldModelNamesSameDuplicate() {
        AffiliationMappingsHealthCheckVMapper afflMappingHealthCheckVMapperInstance = 
            AffiliationMappingsHealthCheckVMapper.getInstance();

        List<AffiliationMappingsModel> affiliationMappingsModelsList = new List<AffiliationMappingsModel> {
            new AffiliationMappingsModel(
                'Test Affiliation Mapping',
                'Test Account Record Type', 
                'Test Contact Primary Field',
                false,
                '',
                'Test Role'
            ),
            new AffiliationMappingsModel(
                'Test Affiliation Mapping 2',
                'Test Account Record Type 2', 
                'Test Contact Primary Field',
                false,
                '',
                'Test Role'
            )
        };
        LookupFieldModel lookupFieldModel = 
            new LookupFieldModel( 
                'Test_Contact_Primary_Field',
                'Test Contact Primary Field'
        );
        LookupFieldModel lookupFieldModel2 = 
            new LookupFieldModel( 
                'Test_Contact_Primary_Field2',
                'Test Contact Primary Field 2'
        );
        Map<String, LookupFieldModel> accountLookupsOnContactFieldModelsByName = new Map<String, LookupFieldModel> {
            'Test_Contact_Primary_Field' => lookupFieldModel,
            'Test_Contact_Primary_Field2' => lookupFieldModel2
        };
        Map<String, LookupFieldModel> accountLookupsOnContactFieldModelsByLabel = new Map<String, LookupFieldModel> {
            'Test Contact Primary Field' => lookupFieldModel,
            'Test Contact Primary Field 2' => lookupFieldModel2
        };


        Test.startTest();
            Set<String> duplicateLookupFieldModelNames = afflMappingHealthCheckVMapperInstance.getDuplicateLookupFieldModelNames(
                affiliationMappingsModelsList, 
                accountLookupsOnContactFieldModelsByName,
                accountLookupsOnContactFieldModelsByLabel  
            );
        Test.stopTest();

        System.assertEquals(
            false, 
            duplicateLookupFieldModelNames.isEmpty(), 
            'The set of duplicate lookup field model names should not be empty.'
        );

        System.assertEquals(
            true, 
            duplicateLookupFieldModelNames.contains('Test_Contact_Primary_Field'), 
            'The set of duplicate lookup field model names should contain Test_Contact_Primary_FieldTest Contact Primary Field.'
        );
    }

    /*****************************************************************************************
    * @description Test method to verify getDuplicateLookupFieldModelNames returns an
    * set when there is duplicate Lookup Field Model in Affiliation Mappings with the mix primary contact field value
    *****************************************************************************************/
    @isTest 
    private static void getDuplicateLookupFieldModelNamesMixDuplicate() {
        AffiliationMappingsHealthCheckVMapper afflMappingHealthCheckVMapperInstance = 
            AffiliationMappingsHealthCheckVMapper.getInstance();

        List<AffiliationMappingsModel> affiliationMappingsModelsList = new List<AffiliationMappingsModel> {
            new AffiliationMappingsModel(
                'Test Affiliation Mapping',
                'Test Account Record Type', 
                'Test Contact Primary Field',
                false,
                '',
                'Test Role'
            ),
            new AffiliationMappingsModel(
                'Test Affiliation Mapping 2',
                'Test Account Record Type 2', 
                'Test_Contact_Primary_Field',
                false,
                '',
                'Test Role'
            )
        };
        LookupFieldModel lookupFieldModel = 
            new LookupFieldModel( 
                'Test_Contact_Primary_Field',
                'Test Contact Primary Field'
        );
        LookupFieldModel lookupFieldModel2 = 
            new LookupFieldModel( 
                'Test_Contact_Primary_Field2',
                'Test Contact Primary Field 2'
        );
        Map<String, LookupFieldModel> accountLookupsOnContactFieldModelsByName = new Map<String, LookupFieldModel> {
            'Test_Contact_Primary_Field' => lookupFieldModel,
            'Test_Contact_Primary_Field2' => lookupFieldModel2
        };
        Map<String, LookupFieldModel> accountLookupsOnContactFieldModelsByLabel = new Map<String, LookupFieldModel> {
            'Test Contact Primary Field' => lookupFieldModel,
            'Test Contact Primary Field 2' => lookupFieldModel2
        };


        Test.startTest();
            Set<String> duplicateLookupFieldModelNames = afflMappingHealthCheckVMapperInstance.getDuplicateLookupFieldModelNames(
                affiliationMappingsModelsList, 
                accountLookupsOnContactFieldModelsByName,
                accountLookupsOnContactFieldModelsByLabel  
            );
        Test.stopTest();

        System.assertEquals(
            false, 
            duplicateLookupFieldModelNames.isEmpty(), 
            'The set of duplicate lookup field model names should not be empty.'
        );

        System.assertEquals(
            true, 
            duplicateLookupFieldModelNames.contains('Test_Contact_Primary_Field'), 
            'The set of duplicate lookup field model names should contain Test_Contact_Primary_FieldTest Contact Primary Field.'
        );
    }

    /**************************************************************************************
    ********************************* HELPER METHODS **************************************
    **************************************************************************************/

    /**************************************************************************************
    * @description Helper method to validate test assertions for HealthCheckGroup
    **************************************************************************************/ 
    private static void validateHCGroupAssertions(
        HealthCheckGroupVModel healthCheckGroupVModelResult,
        String expectedHealthCheckGroupLabel,
        String expectedHealthCheckGroupStatus,
        Integer expectedPassedChecksCount,
        Integer expectedTotalChecksCount,
        Integer expectedExpandedListSize,
        Integer expectedHealthCheckItemsListSize
    ) {
        System.assertEquals(
            expectedHealthCheckGroupLabel, 
            healthCheckGroupVModelResult.label, 
            'Label should be \'' + expectedHealthCheckGroupLabel + '\'.'
        );

        System.assertEquals(
            expectedHealthCheckGroupStatus, 
            healthCheckGroupVModelResult.status, 
            'Status should be \'' + expectedHealthCheckGroupStatus + '\'.'
        );

        System.assertEquals(
            expectedPassedChecksCount, 
            healthCheckGroupVModelResult.passedChecks, 
            'Passed checks count should be ' + expectedPassedChecksCount + '.'
        );

        System.assertEquals(
            expectedTotalChecksCount, 
            healthCheckGroupVModelResult.totalChecks, 
            'Total checks count should be ' + expectedTotalChecksCount + '.'
        );

        System.assertEquals(
            expectedExpandedListSize, 
            healthCheckGroupVModelResult.expandedRowsList.size(), 
            'ExpandedRows list should have ' + expectedExpandedListSize + ' elements.'
        );

        System.assertEquals(
            expectedHealthCheckItemsListSize, 
            healthCheckGroupVModelResult.healthCheckItemList.size(), 
            'HealthCheckItems list should have ' + expectedHealthCheckItemsListSize + ' elements.'
        );
    }

    /**************************************************************************************
    * @description Helper method to validate test assertions for HealthCheckItem
    **************************************************************************************/ 
    private static void validateHCItemAssertions(
        HealthCheckGroupVModel healthCheckGroupVModelResult,
        String expectedHealthCheckItemSetting,
        String expectedHealthCheckItemStatus,
        String expectedHealthCheckItemStatusLabel,
        String expectedHealthCheckItemDescription,
        String expectedHealthCheckItemFix,
        Integer expectedHealtCheckItemSublistSize
    ) {
        System.assertEquals(
            expectedHealthCheckItemSetting, 
            healthCheckGroupVModelResult.healthCheckItemList[0].setting, 
            'HealthCheckItem setting should be \'' + expectedHealthCheckItemSetting + '\'.'
        );  
        
        System.assertEquals(
            expectedHealthCheckItemStatus, 
            healthCheckGroupVModelResult.healthCheckItemList[0].status, 
            'HealthCheckItem status should be \'' + expectedHealthCheckItemStatus + '\'.'
        ); 

        System.assertEquals(
            expectedHealthCheckItemStatusLabel, 
            healthCheckGroupVModelResult.healthCheckItemList[0].statusLabel, 
            'HealthCheckItem statusLabel should be \'' + expectedHealthCheckItemStatusLabel + '\'.'
        ); 
        
        System.assertEquals(
            expectedHealthCheckItemDescription, 
            healthCheckGroupVModelResult.healthCheckItemList[0].description, 
            'HealthCheckItem statusLabel should be \'' + expectedHealthCheckItemDescription + '\'.'
        ); 

        System.assertEquals(
            expectedHealthCheckItemFix, 
            healthCheckGroupVModelResult.healthCheckItemList[0].recommendedFix, 
            'HealthCheckItem statusLabel should be \'' + expectedHealthCheckItemFix + '\'.'
        ); 

        System.assertEquals(
            expectedHealtCheckItemSublistSize, 
            healthCheckGroupVModelResult.healthCheckItemList[0].healthCheckItemList.size(), 
            'HealthCheckItem statusLabel should be \'' + expectedHealtCheckItemSublistSize + '\'.'
        ); 
    }

    /***************************************************************************
    *********************************STUBS**************************************
    ***************************************************************************/

    /***************************************************************************
    * @description Stub class to simulate the response from
    * AffiliationMappingsHealthCheckVMapper to return a passing result for
    * getAffiliationMappingsHealthCheckResults
    ***************************************************************************/
    private class STUB_AffiliationMappingsHealthCheckVMapperPass extends AffiliationMappingsHealthCheckVMapper {
        private override HealthCheckGroupVModel getValidRecordTypeHealthCheckGroupVModel(
            AffiliationMappingsModel affiliationMappingsModel, 
            RecordTypeModel accountRecordTypeModel
        ) {
            return new HealthCheckGroupVModel(
                'Account RT Health Check', 
                'Pass', 
                1, 
                1, 
                new List<String>(), 
                new List<HealthCheckItemVModel>{
                    new HealthCheckItemVModel(
                        'test key 1', 
                        'test setting', 
                        'Pass', 
                        Label.stgHealthCheckStatusPassed,
                        'test description', 
                        'test fix',
                        new List<HealthCheckItemVModel>()
                    ) 
                }
            );
        }

        private override HealthCheckGroupVModel getAccountRecordTypeUniquenessHealthCheckGroupVModel(
            AffiliationMappingsModel affiliationMappingsModel, 
            RecordTypeModel accountRecordTypeModel,
            Set<Id> duplicateAccountRecordTypeIds
        ) {
            return new HealthCheckGroupVModel(
                'Account RT Uniqueness Health Check', 
                'Pass', 
                1, 
                1, 
                new List<String>(), 
                new List<HealthCheckItemVModel>{
                    new HealthCheckItemVModel(
                        'test key 2', 
                        'test setting', 
                        'Pass', 
                        Label.stgHealthCheckStatusPassed,
                        'test description', 
                        'test fix',
                        new List<HealthCheckItemVModel>()
                    ) 
                }
            );
        }

        private override HealthCheckGroupVModel getValidContactPrimaryFieldHealthCheckGroupVModel(
            AffiliationMappingsModel affiliationMappingsModel,
            LookupFieldModel accountlookupFieldOnContactFieldModelFromName
        ) {
            return new HealthCheckGroupVModel(
                'Contact Primary Field Health Check', 
                'Pass', 
                1, 
                1, 
                new List<String>(), 
                new List<HealthCheckItemVModel>{
                    new HealthCheckItemVModel(
                        'test key 3', 
                        'test setting', 
                        'Pass', 
                        Label.stgHealthCheckStatusPassed,
                        'test description', 
                        'test fix',
                        new List<HealthCheckItemVModel>()
                    ) 
                }
            );
        }

        private override HealthCheckGroupVModel getContactPrimaryFieldUniquenessHealthCheckGroupVModel(
            AffiliationMappingsModel affiliationMappingsModel, 
            LookupFieldModel accountlookupFieldOnContactFieldModel,
            Set<String> duplicateLookupFieldModelNames
        ) {
            return new HealthCheckGroupVModel(
                'Contact Primary Field Uniqueness Health Check', 
                'Pass', 
                1, 
                1, 
                new List<String>(), 
                new List<HealthCheckItemVModel>{
                    new HealthCheckItemVModel(
                        'test key 4', 
                        'test setting', 
                        'Pass', 
                        Label.stgHealthCheckStatusPassed,
                        'test description', 
                        'test fix',
                        new List<HealthCheckItemVModel>()
                    ) 
                }
            );
        }

        private override HealthCheckGroupVModel getActiveExistingRoleHealthCheckGroupVModel(
            AffiliationMappingsModel affiliationMappingsModel,
            Map<String, PicklistEntryModel> picklistEntryModelByName
        ) {
            return new HealthCheckGroupVModel(
                'Contact Primary Field Health Check', 
                'Pass', 
                1, 
                1, 
                new List<String>(), 
                new List<HealthCheckItemVModel>{
                    new HealthCheckItemVModel(
                        'test key 5', 
                        'test setting', 
                        'Pass', 
                        Label.stgHealthCheckStatusPassed,
                        'test description', 
                        'test fix',
                        new List<HealthCheckItemVModel>()
                    ) 
                }
            );
        }

        private override HealthCheckGroupVModel getActiveExistingStatusHealthCheckGroupVModel(
            AffiliationMappingsModel affiliationMappingsModel,
            Map<String, PicklistEntryModel> picklistEntryModelByName
        ) {
            return new HealthCheckGroupVModel(
                'Contact Primary Field Health Check', 
                'Pass', 
                1, 
                1, 
                new List<String>(), 
                new List<HealthCheckItemVModel>{
                    new HealthCheckItemVModel(
                        'test key 6', 
                        'test setting', 
                        'Pass', 
                        Label.stgHealthCheckStatusPassed,
                        'test description', 
                        'test fix',
                        new List<HealthCheckItemVModel>()
                    ) 
                }
            );
        }
    }

    /***************************************************************************
    * @description Stub class to simulate the response from
    * AffiliationMappingsHealthCheckVMapper to return a failing result for
    * getAffiliationMappingsHealthCheckResults
    ***************************************************************************/
    private class STUB_AffiliationMappingsHealthCheckVMapperFail extends AffiliationMappingsHealthCheckVMapper {
        private override HealthCheckGroupVModel getValidRecordTypeHealthCheckGroupVModel(
            AffiliationMappingsModel affiliationMappingsModel, 
            RecordTypeModel accountRecordTypeModel
        ) {
            return new HealthCheckGroupVModel(
                'Account RT Health Check', 
                'Fail', 
                0, 
                1, 
                new List<String>(), 
                new List<HealthCheckItemVModel>{
                    new HealthCheckItemVModel(
                        'test key 1', 
                        'test setting', 
                        'Fail', 
                        Label.stgHealthCheckStatusFailed,
                        'test description', 
                        'test fix',
                        new List<HealthCheckItemVModel>()
                    ) 
                }
            );
        }

        private override HealthCheckGroupVModel getAccountRecordTypeUniquenessHealthCheckGroupVModel(
            AffiliationMappingsModel affiliationMappingsModel, 
            RecordTypeModel accountRecordTypeModel,
            Set<Id> duplicateAccountRecordTypeIds
        ) {
            return new HealthCheckGroupVModel(
                'Account RT Uniqueness Health Check', 
                'Fail', 
                0, 
                1, 
                new List<String>(), 
                new List<HealthCheckItemVModel>{
                    new HealthCheckItemVModel(
                        'test key 2', 
                        'test setting', 
                        'Fail', 
                        Label.stgHealthCheckStatusFailed,
                        'test description', 
                        'test fix',
                        new List<HealthCheckItemVModel>()
                    ) 
                }
            );
        }

        private override HealthCheckGroupVModel getValidContactPrimaryFieldHealthCheckGroupVModel(
            AffiliationMappingsModel affiliationMappingsModel,
            LookupFieldModel accountlookupFieldOnContactFieldModelFromName
        ) {
            return new HealthCheckGroupVModel(
                'Contact Primary Field Health Check', 
                'Fail', 
                0, 
                1, 
                new List<String>(), 
                new List<HealthCheckItemVModel>{
                    new HealthCheckItemVModel(
                        'test key 3', 
                        'test setting', 
                        'Fail', 
                        Label.stgHealthCheckStatusFailed,
                        'test description', 
                        'test fix',
                        new List<HealthCheckItemVModel>()
                    ) 
                }
            );
        }

        private override HealthCheckGroupVModel getContactPrimaryFieldUniquenessHealthCheckGroupVModel(
            AffiliationMappingsModel affiliationMappingsModel, 
            LookupFieldModel accountlookupFieldOnContactFieldModel,
            Set<String> duplicateLookupFieldModelNames
        ) {
            return new HealthCheckGroupVModel(
                'Contact Primary Field Uniqueness Health Check', 
                'Fail', 
                0, 
                1, 
                new List<String>(), 
                new List<HealthCheckItemVModel>{
                    new HealthCheckItemVModel(
                        'test key 4', 
                        'test setting', 
                        'Fail', 
                        Label.stgHealthCheckStatusFailed,
                        'test description', 
                        'test fix',
                        new List<HealthCheckItemVModel>()
                    ) 
                }
            );
        }

        private override HealthCheckGroupVModel getActiveExistingRoleHealthCheckGroupVModel(
            AffiliationMappingsModel affiliationMappingsModel,
            Map<String, PicklistEntryModel> picklistEntryModelByName
        ) {
            return new HealthCheckGroupVModel(
                'Auto Enrollment Role Health Check', 
                'Fail', 
                0, 
                1, 
                new List<String>(), 
                new List<HealthCheckItemVModel>{
                    new HealthCheckItemVModel(
                        'test key 5', 
                        'test setting', 
                        'Fail', 
                        Label.stgHealthCheckStatusFailed,
                        'test description', 
                        'test fix',
                        new List<HealthCheckItemVModel>()
                    ) 
                }
            );
        }

        private override HealthCheckGroupVModel getActiveExistingStatusHealthCheckGroupVModel(
            AffiliationMappingsModel affiliationMappingsModel,
            Map<String, PicklistEntryModel> picklistEntryModelByName
        ) {
            return new HealthCheckGroupVModel(
                'Auto Enrollment Status Health Check', 
                'Fail', 
                0, 
                1, 
                new List<String>(), 
                new List<HealthCheckItemVModel>{
                    new HealthCheckItemVModel(
                        'test key 6', 
                        'test setting', 
                        'Fail', 
                        Label.stgHealthCheckStatusFailed,
                        'test description', 
                        'test fix',
                        new List<HealthCheckItemVModel>()
                    ) 
                }
            );
        }
    }

    /***************************************************************************
    * @description Stub class to simulate the response from
    * AffiliationMappingsHealthCheckVMapper to control individual health check methods
    * for failure
    ***************************************************************************/
    private class STUB_AffiliationMappingsHealthCheckVMapperSubFail extends AffiliationMappingsHealthCheckVMapper {
        private override HealthCheckGroupVModel getValidRecordTypeHealthCheckGroupVModel(
            AffiliationMappingsModel affiliationMappingModel, 
            RecordTypeModel accountRecordTypeModel
        ) {
            return new HealthCheckGroupVModel(
                'Failed Health Check 1', 
                Label.stgHealthCheckStatusFailed, 
                0, 
                1, 
                new List<String>(), 
                new List<HealthCheckItemVModel>()
            );
        }

        private override HealthCheckGroupVModel getAccountRecordTypeUniquenessHealthCheckGroupVModel(
            AffiliationMappingsModel affiliationMappingModel, 
            RecordTypeModel accountRecordTypeModel,
            Set<Id> duplicateAccountRecordTypeIds
        ) {
            return new HealthCheckGroupVModel(
                'Failed Health Check 2', 
                Label.stgHealthCheckStatusFailed, 
                0, 
                1, 
                new List<String>(), 
                new List<HealthCheckItemVModel>()
            );
        }

        private override HealthCheckGroupVModel getValidContactPrimaryFieldHealthCheckGroupVModel(
            AffiliationMappingsModel affiliationMappingsModel,
            LookupFieldModel accountlookupFieldOnContactFieldModelFromName
        ) {
            return new HealthCheckGroupVModel(
                'Failed Health Check 3', 
                Label.stgHealthCheckStatusFailed, 
                0, 
                1, 
                new List<String>(), 
                new List<HealthCheckItemVModel>()
            );
        }

        private override HealthCheckGroupVModel getContactPrimaryFieldUniquenessHealthCheckGroupVModel(
            AffiliationMappingsModel affiliationMappingModel, 
            LookupFieldModel accountlookupFieldOnContactFieldModel,
            Set<String> duplicateLookupFieldModelNames
        ) {
            return new HealthCheckGroupVModel(
                'Failed Health Check 4', 
                Label.stgHealthCheckStatusFailed, 
                0, 
                1, 
                new List<String>(), 
                new List<HealthCheckItemVModel>()
            );
        }

        private override HealthCheckGroupVModel getActiveExistingRoleHealthCheckGroupVModel(
            AffiliationMappingsModel affiliationMappingsModel,
            Map<String, PicklistEntryModel> picklistEntryModelByName
        ) {
            return new HealthCheckGroupVModel(
                'Failed Health Check 5', 
                Label.stgHealthCheckStatusFailed, 
                0, 
                1, 
                new List<String>(), 
                new List<HealthCheckItemVModel>()
            );
        }

        private override HealthCheckGroupVModel getActiveExistingStatusHealthCheckGroupVModel(
            AffiliationMappingsModel affiliationMappingsModel,
            Map<String, PicklistEntryModel> picklistEntryModelByName
        ) {
            return new HealthCheckGroupVModel(
                'Failed Health Check 6', 
                Label.stgHealthCheckStatusFailed, 
                0, 
                1, 
                new List<String>(), 
                new List<HealthCheckItemVModel>()
            );
        }
    }

    /***************************************************************************
    * @description Stub class to simulate the response from
    * AffiliationMappingsHealthCheckVMapper to control individual health check methods
    * for success
    ***************************************************************************/
    private class STUB_AffiliationMappingsHealthCheckVMapperSub extends AffiliationMappingsHealthCheckVMapper {
        private override HealthCheckGroupVModel getValidRecordTypeHealthCheckGroupVModel(
            AffiliationMappingsModel affiliationMappingsModel, 
            RecordTypeModel accountRecordTypeModel
        ) {
            return this.mockCheck(affiliationMappingsModel);
        }

        private override HealthCheckGroupVModel getValidContactPrimaryFieldHealthCheckGroupVModel(
            AffiliationMappingsModel affiliationMappingsModel, 
            LookupFieldModel accountlookupFieldOnContactFieldModelFromName
        ) {
            return this.mockCheck(affiliationMappingsModel);
        }

        private override HealthCheckGroupVModel getActiveExistingRoleHealthCheckGroupVModel(
            AffiliationMappingsModel affiliationMappingsModel,
            Map<String, PicklistEntryModel> picklistEntryModelByName
        ) {
            return this.mockCheck(affiliationMappingsModel);
        }

        private override HealthCheckGroupVModel getActiveExistingStatusHealthCheckGroupVModel(
            AffiliationMappingsModel affiliationMappingsModel,
            Map<String, PicklistEntryModel> picklistEntryModelByName
        ) {
            return this.mockCheck(affiliationMappingsModel);
        }
        
        private HealthCheckGroupVModel mockCheck(AffiliationMappingsModel affiliationMappingModel) {
            HealthCheckGroupVModel healthCheckGroupVModel = new HealthCheckGroupVModel(
                '',
                '',
                0,
                0,
                new List<String>(),
                new List<HealthCheckItemVModel>()
            );
    
            HealthCheckItemVModel healthCheckItemVModel =
                new healthCheckItemVModel(
                    'Mock',
                    'MockSetting',
                    'Pass',
                    'MockStatusLabel',
                    'MockDescription',
                    'MockRecommendedFix',
                    new List<HealthCheckItemVModel>()
                );

            healthCheckGroupVModel.totalChecks += 1;

            if(affiliationMappingModel != null) {
                healthCheckGroupVModel.passedChecks += 1;
            }

            if(healthCheckGroupVModel.passedChecks < healthCheckGroupVModel.totalChecks) {
                healthCheckItemVModel.status = 'Fail';
                healthCheckItemVModel.statusLabel = Label.stgHealthCheckStatusFailed;
            }
    
            healthCheckGroupVModel.healthCheckItemList.add(healthCheckItemVModel);
            return healthCheckGroupVModel;
        }
    }

    private class STUB_LookupFieldService extends LookupFieldService {
        public override Map<String, LookupFieldModel> getModelByNameMapForSObjectType(
            SObjectType sObjectType, 
            SObjectType lookupToSObjectType
        ) {
            return new Map<String, LookupFieldModel>{
                'Test_Field__c' => new LookupFieldModel(
                    'Test_Field__c',
                    'Test Field'
                )
            };
        }
    }

    private class STUB_PicklistEntryServiceRole extends PickListEntryService {
        public override Map<String,PicklistEntryModel> getModelsByNameForSObjectField(
            SObjectType sObjectTypeName,
            SObjectField SObjectFieldName
        ) {
            return new Map<String, PicklistEntryModel>{
                'Test_Role' => new PicklistEntryModel(
                    'Test_Role',
                    'Test Role', 
                    true)
            };
        }
    }

    /***************************************************************************
    * @description Stub class to simulate the response from
    * AffiliationMappingsService to return a predetermined set of models.
    ***************************************************************************/
    private class STUB_AffiliationMappingsService extends AffiliationMappingsService {
        public override List<AffiliationMappingsModel> getAffiliationMappingsModels() {
            List<AffiliationMappingsModel> AffiliationMappingsModelList =
                new List<AffiliationMappingsModel>();
            
            AffiliationMappingsModel AffiliationMappingsModel = 
                new AffiliationMappingsModel(
                    'testName',
                    'test account record type name',
                    'testPrimaryAfflField',
                    true,
                    'testStatus',
                    'testRole'
                );

            AffiliationMappingsModelList.add(AffiliationMappingsModel);

            return AffiliationMappingsModelList;
        }
    }

    /***************************************************************************
    * @description Stub class to simulate the response from
    * AffiliationMappingsService to return a predetermined set of unfound
    * models.
    ***************************************************************************/
    private class STUB_AffiliationMappingsServiceUnfound extends AffiliationMappingsService {
        public override List<AffiliationMappingsModel> getAffiliationMappingsModels() {
            List<AffiliationMappingsModel> affiliationMappingsModelsList = new List<AffiliationMappingsModel>();

            affiliationMappingsModelsList.add(
                new AffiliationMappingsModel(
                    'unfound name',
                    'unfound accountRecordTypeFieldValue',
                    'unfound primaryAffiliationField',
                    true,
                    'unfound autoProgramEnrollmentStatus',
                    'unfound autoProgramEnrollmentRole'
                )
            );

            return affiliationMappingsModelsList;
        }
    }

    /***************************************************************************
    * @description Stub class to simulate the response from
    * RecordTypeService to return a predetermined set of active models.
    ***************************************************************************/
    private class STUB_RecordTypeService extends RecordTypeService {
        public override Map<Id, RecordTypeModel> getModelByIdMapForSObjectType(Schema.SObjectType sObjectType) {
            Map<Id, RecordTypeModel> recordTypeModelById =
                new Map<Id, RecordTypeModel>();
            
            recordTypeModelById.put('000000000000000001', new RecordTypeModel(
                '000000000000000001',
                'Active RecordType Test Name1',
                'activeRTTestDeveloperName1',
                true
            ));         
                 
            recordTypeModelById.put('000000000000000002', new RecordTypeModel(
                '000000000000000002',
                'Active RecordType Test Name2',
                'activeRTTestDeveloperName2',
                true
            ));         

            recordTypeModelById.put('000000000000000003', new RecordTypeModel(
                '000000000000000003',
                'Active RecordType Test Name3',
                'activeRTTestDeveloperName3',
                true
            ));         
            
            return recordTypeModelById;
        }

        public override RecordTypeModel getRecordTypeModelFromMap(String recordTypeId, Map<Id, RecordTypeModel> recordTypeModelById) { 
            return new RecordTypeModel(
                '000000000000000006',
                'Active RecordType Name',
                'activeRTDevName',
                true
            );
        }
    }

    /***************************************************************************
    * @description Stub class to simulate the response from
    * RecordTypeService to return a predetermined set of inactive models.
    ***************************************************************************/
    private class STUB_RecordTypeServiceInactive extends RecordTypeService {
        public override Map<Id, RecordTypeModel> getModelByIdMapForSObjectType(Schema.SObjectType sObjectType) {
            Map<Id, RecordTypeModel> recordTypeModelById =
                new Map<Id, RecordTypeModel>();
            
            recordTypeModelById.put('000000000000000001', new RecordTypeModel(
                '000000000000000001',
                'Inactive RecordType Test Name1',
                'InactiveRTTestDeveloperName1',
                false
            ));         
                 
            recordTypeModelById.put('000000000000000002', new RecordTypeModel(
                '000000000000000002',
                'Inactive RecordType Test Name2',
                'InactiveRTTestDeveloperName2',
                false
            ));         

            recordTypeModelById.put('000000000000000003', new RecordTypeModel(
                '000000000000000003',
                'Inactive RecordType Test Name3',
                'InactiveRTTestDeveloperName3',
                false
            ));         
            
            return recordTypeModelById;
        }

        public override RecordTypeModel getRecordTypeModelFromMap(String recordTypeId, Map<Id, RecordTypeModel> recordTypeModelById) { 
            return new RecordTypeModel(
                '000000000000000005',
                'Inactive RecordType Name',
                'inactiveRTDevName',
                false
            );
        }
    }

    /***************************************************************************
    * @description Stub class to simulate the response from
    * RecordTypeService to return a null value.
    ***************************************************************************/
    private class STUB_RecordTypeServiceNull extends RecordTypeService {
        public override RecordTypeModel getRecordTypeModelFromMap(String recordTypeId, Map<Id, RecordTypeModel> recordTypeModelById) { 
            return null;
        }

        public override Map<Id, RecordTypeModel> getModelByIdMapForSObjectType(Schema.SObjectType sObjectType) {
            return new Map<Id, RecordTypeModel>{
               '000000000000000009' => new RecordTypeModel(
                                            '000000000000000009',
                                            'random test acct record type',
                                            'randomAcctRT',
                                            true
                                       )
            };
        }
    }

    /***************************************************************************
    * @description Stub class to simulate the response from
    * LookupFieldService to return a valid lookup field model for a Contact
    * field that is a lookup to Account matching my field dev name.
    ***************************************************************************/
    private class STUB_LookupFieldServiceDevNameMatch extends LookupFieldService {
        public override LookupFieldModel getLookupFieldModelFromNameMap(
            String fieldName, 
            Map<String, LookupFieldModel> lookupFieldModelByName
        ){
            return new LookupFieldModel(
                'Valid Contact Lookup Field Name',
                'Valid Contact Lookup Field Label'
            );
        }
    }

    /***************************************************************************
    * @description Stub class to simulate the response from
    * LookupFieldService to return a valid lookup field model for a Contact
    * field that is a lookup to Account matching my field label name.
    ***************************************************************************/
    private class STUB_LookupFieldServiceLabelMatch extends LookupFieldService {
        public override LookupFieldModel getLookupFieldModelFromNameMap(
            String fieldName, 
            Map<String, LookupFieldModel> lookupFieldModelByName 
        ){
            return null;
        }
        
        public override LookupFieldModel getLookupFieldModelFromLabelMap(
            String fieldLabel, 
            Map<String, LookupFieldModel> lookupFieldModelByLabel) 
        {
            return new LookupFieldModel(
                'Valid Contact Lookup Field Name',
                'Valid Contact Lookup Field Label'
            );
        }
    }

    /***************************************************************************
    * @description Stub class to simulate the response from
    * LookupFieldService to return a null value.
    ***************************************************************************/
    private class STUB_LookupFieldServiceNull extends LookupFieldService {
        public override LookupFieldModel getLookupFieldModelFromNameMap(
            String fieldName, 
            Map<String, LookupFieldModel> lookupFieldModelByName) 
        {
            return null;
        }

        public override LookupFieldModel getLookupFieldModelFromLabelMap(
            String fieldLabel, 
            Map<String, LookupFieldModel> lookupFieldModelByLabel) 
        {
            return null;
        }
    }

    /***************************************************************************
    * @description Stub class to simulate the response from PicklistEntryService
    * to return a PicklistEntryModel for a valid and active picklist value.
    ***************************************************************************/
    private class STUB_PicklistEntryServiceValid extends PicklistEntryService {
        public override Map<String,PicklistEntryModel> getModelsByNameForSObjectField(
            SObjectType sObjectTypeName,
            SObjectField SObjectFieldName
        ) {
            return new Map<String,PicklistEntryModel>{
                'Test Auto Enrollment Name' => new PicklistEntryModel(
                'Test Auto Enrollment Name',
                'Auto Enrollment Label',
                true)
            };
        }
    }

    /***************************************************************************
    * @description Stub class to simulate the response from PicklistEntryService
    * to return a PicklistEntryModel for a valid, but inactive picklist value.
    ***************************************************************************/
    private class STUB_PicklistEntryServiceInactive extends PicklistEntryService {
        public override Map<String,PicklistEntryModel> getModelsByNameForSObjectField(
            SObjectType sObjectTypeName,
            SObjectField SObjectFieldName
        ) {
            return new Map<String,PicklistEntryModel>{
                'Test Auto Enrollment Name' => new PicklistEntryModel(
                'Test Auto Enrollment Name',
                'Auto Enrollment Label',
                false)
            };
        }
    }

    /***************************************************************************
    * @description Stub class to simulate the response from PicklistEntryService 
    * to return a null value.
    ***************************************************************************/
    private class STUB_PicklistEntryServiceNull extends PicklistEntryService {
        public override Map<String,PicklistEntryModel> getModelsByNameForSObjectField(
            SObjectType sObjectTypeName,
            SObjectField SObjectFieldName
        ) {
            return null;
        }
    }
}
